<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sguotao.com/"/>
  <updated>2017-08-09T09:54:13.000Z</updated>
  <id>http://www.sguotao.com/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分析Android中的异步消息处理机制</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2017-06-17-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html"/>
    <id>http://www.sguotao.com/Android进阶-2017-06-17-分析Android中的异步消息处理机制.html</id>
    <published>2017-06-17T02:27:04.000Z</published>
    <updated>2017-08-09T09:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><h2 id="什么是Handler"><a href="#什么是Handler" class="headerlink" title="什么是Handler"></a>什么是Handler</h2><p>Handler通过发送和处理Message和Runnable对象来关联相对应线程的MessageQueue。<br>1.可以让对应的Message和Runnable在未来的某个时间点进行相应处理；<br>2.自己想要处理的耗时操作放在子线程，让更新UI的操作放在主线程。</p>
<h2 id="Handler的使用方法"><a href="#Handler的使用方法" class="headerlink" title="Handler的使用方法"></a>Handler的使用方法</h2><p>1.post(Runnable)<br>    创建Handler对象<br>    调用Handler的post（Runnable）方法；<br>2.sendMessage(message）</p>
<h2 id="Handler的机制原理"><a href="#Handler的机制原理" class="headerlink" title="Handler的机制原理"></a>Handler的机制原理</h2><p>类图，流程图</p>
<h2 id="Handler引起的内存泄露以及解决办法"><a href="#Handler引起的内存泄露以及解决办法" class="headerlink" title="Handler引起的内存泄露以及解决办法"></a>Handler引起的内存泄露以及解决办法</h2><p>原因:静态内部类持有外部类的匿名引用，导致外部activity无法释放；<br>解决办法:handler内部持有外部Activity的弱引用;并把handler改为静态内部类;mHandler.removeCallback()</p>
<h1 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h1><h2 id="什么是AsyncTask"><a href="#什么是AsyncTask" class="headerlink" title="什么是AsyncTask"></a>什么是AsyncTask</h2><p>它本质上据说一个封装了线程池和handler的异步框架。</p>
<h2 id="AsyncTask的使用方法"><a href="#AsyncTask的使用方法" class="headerlink" title="AsyncTask的使用方法"></a>AsyncTask的使用方法</h2><p>三个参数<br>五个方法</p>
<h2 id="AsyncTask的机制原理"><a href="#AsyncTask的机制原理" class="headerlink" title="AsyncTask的机制原理"></a>AsyncTask的机制原理</h2><ol>
<li>AsyncTask的本质上是一个静态的线程池，AsyncTask派生的子类可以实现不同的异步任务，这些任务都是提交到静态的线程池中执行。</li>
<li>线程池中的工作线程执行doInBackground(mParams)方法执行异步任务</li>
<li>当任务状态改变之后，工作线程会向UI线程发送消息，AsyncTask内部的InternalHandler响应这些消息，并调用相关的回调函数。</li>
</ol>
<h2 id="AsyncTask的注意事项"><a href="#AsyncTask的注意事项" class="headerlink" title="AsyncTask的注意事项"></a>AsyncTask的注意事项</h2><ol>
<li>内存泄露</li>
<li>生命周期(AsyncTask并不会随着Activity的销毁而销毁)，在Activity退出时cancel</li>
<li>结果丢失</li>
<li>并行or串行</li>
</ol>
<h1 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h1><h2 id="HandlerThread产生背景"><a href="#HandlerThread产生背景" class="headerlink" title="HandlerThread产生背景"></a>HandlerThread产生背景</h2><p>开启Thread子线程进行耗时操作，多次创建和销毁线程是很耗资源的。</p>
<h2 id="handlerThread是什么"><a href="#handlerThread是什么" class="headerlink" title="handlerThread是什么"></a>handlerThread是什么</h2><p>handler+thread+looper<br>是一个thread内部有looper；</p>
<h2 id="HandlerThread的特点"><a href="#HandlerThread的特点" class="headerlink" title="HandlerThread的特点"></a>HandlerThread的特点</h2><ol>
<li>HandlerThread本质上是一个线程类，它集成了Thread；</li>
<li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li>
<li>通过获取HandlerThread的Looper对象传递给Handler对象，可以在HandleMessage方法中执行异步任务。</li>
<li>优点是不会有堵塞，减少了对性能的消耗，缺点是不能同时进行多任务的处理，需要等待进行处理，处理效率较低；</li>
<li>与线程池注重并发不同，HandlerThread是一个串行队列，HandlerThread背后只有一个线程。</li>
</ol>
<h2 id="HandlerThread源码解析"><a href="#HandlerThread源码解析" class="headerlink" title="HandlerThread源码解析"></a>HandlerThread源码解析</h2><h1 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h1><h2 id="IntentService是什么"><a href="#IntentService是什么" class="headerlink" title="IntentService是什么"></a>IntentService是什么</h2><p>IntentService是继承并处理异步请求的一个类，在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方法和启动传统Service一样，同时，当任务执行完成后，IntentService会自动停止，而不需要我们手动去控制或stopSelf()。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个。</p>
<p>1.它本质是一种特殊的Service，继承自Service并且本身就是一个抽象类；<br>2.它内部通过HandlerThread和Handler实现异步操作。</p>
<h2 id="IntentService的使用方法"><a href="#IntentService的使用方法" class="headerlink" title="IntentService的使用方法"></a>IntentService的使用方法</h2><p>创建IntentService时，只需实现onHandleIntent和构造方法，onHandleIntent为异步方法，可以执行耗时操作。</p>
<h2 id="IntentService源码解析"><a href="#IntentService源码解析" class="headerlink" title="IntentService源码解析"></a>IntentService源码解析</h2><p>它本质是就是封装了HandlerThread和Handler异步框架</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2017-06-17-分析Android中的异步消息处理机制.html">http://www.sguotao.com/Android进阶-2017-06-17-分析Android中的异步消息处理机制.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; class=&quot;headerlink&quot; title=&quot;Handler&quot;&gt;&lt;/a&gt;Handler&lt;/h1&gt;&lt;h2 id=&quot;什么是Handler&quot;&gt;&lt;a href=&quot;#什么是Handler&quot; class=&quot;head
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Handler" scheme="http://www.sguotao.com/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>【Kotlin笔记】Kotlin的前世今生</title>
    <link href="http://www.sguotao.com/Kotlin-2017-06-09-Kotlin-note1.html"/>
    <id>http://www.sguotao.com/Kotlin-2017-06-09-Kotlin-note1.html</id>
    <published>2017-06-09T02:30:37.000Z</published>
    <updated>2017-06-23T11:06:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>三周前的Google IO大会上，官方宣布将Kotlin作为除Java、C++外的官方编程语言，在最新一期的TIOBE排行榜中，Kotlin就首次挤进编程语言TOP50。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/201706091496976207210.jpg" alt="201706091496976207210.jpg"><br>Kotlin是怎样的编程语言？Google为何将Kotlin作为官方的编程语言？Kotlin与其它语言(尤其是Java)相比，有哪些特点呢？带着这些问题，来了解Kotlin。</p>
<h2 id="Kotlin是什么？"><a href="#Kotlin是什么？" class="headerlink" title="Kotlin是什么？"></a>Kotlin是什么？</h2><blockquote>
<p>Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可以被编译成为JavaScript源代码。它主要是由俄罗斯圣彼得堡的JetBrains开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。[2]2012年1月，著名期刊《Dr. Dobb’s Journal》中Kotlin被认定为该月的最佳语言。[3]虽然与Java语法并不兼容，但Kotlin被设计成可以和Java代码相互运作，并可以重复使用如Java集合框架等的现有Java类库。</p>
</blockquote>
<p>这是wikipedia给出的解释，总结一下:</p>
<ol>
<li>起源自有背书的JetBrains开发团队；</li>
<li>一种基于JVM的静态类型编程语言。</li>
</ol>
<h2 id="为什么是Kotlin"><a href="#为什么是Kotlin" class="headerlink" title="为什么是Kotlin?"></a>为什么是Kotlin?</h2><p>为什么Google选择了Kotlin，除了一些与Oracle众所周知的原因外，更多的是Kotlin本身的一些特点：</p>
<ol>
<li>开源，Apache许可证版本2.0下发布；</li>
<li>简洁，与Java相比，节约了大概40%的代码；</li>
<li>容易，如果会Java，很容易上手Kotlin；</li>
<li>安全，避免了空引用；</li>
<li>工具友好，由JetBrains开发，一家创造开发工具而闻名的公司；</li>
<li>互操作，与Java和Android 100%互操作；</li>
</ol>
<h2 id="与Java相比优势是什么？"><a href="#与Java相比优势是什么？" class="headerlink" title="与Java相比优势是什么？"></a>与Java相比优势是什么？</h2><p>由于Android 应用使用了JVM，这意味着可以使用任何语言去编写app，只要能够编译成被JVM识别的字节码文件就可以了，同样编译字节码Kotlin与Java相比的优势：</p>
<ol>
<li><p>更加易表现，这个重要的特点意味着可以少些很多代码，比如定义一个数据类，只需要进行如下定义，Kotlin会自动生成所有属性和他们的访问器，以及一些常用的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data class Person(</div><div class="line">        var id: Long,</div><div class="line">        var name: String,</div><div class="line">        var gender: Int,</div><div class="line">        var address: String</div><div class="line">        )</div></pre></td></tr></table></figure>
</li>
<li><p>更加安全，Kotlin是空安全的，即在编译期间处理了各种null的场景，避免了运行时异常。在Java开发中，需要通过判断是否为null来避免NullPointerException,在Kotlin中通过一个安全调用操作符(?)来明确地指定一个对象是否为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person:Person ?=null //person可以是null</div><div class="line">person.speak() //编译不过,person可能是null</div><div class="line">person?.speak() //person不为null,调用speak()</div></pre></td></tr></table></figure>
</li>
<li><p>函数式，Kotlin是基于面向对象语言，使用了很多函数式编程的概念，主要是Lambda，Java8中也支持Lambda表达式。</p>
</li>
<li><p>可以扩展函数，可以扩展类的更多特性，甚至是一些没有权限访问类的代码；如给fragment添加一个显示toast的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun Fragment.toast(message: CharSequence, duration:Int = Toast.LENGTH_LONG)&#123;</div><div class="line">    Toast.makeText(getActivity(),message,duration).show()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>高度互操作，可以使用所有用Java写的代码和第三方库，因为Kotlin和Java之间的相互操作是完美的，甚至可以在项目中进行混合编程。</p>
</li>
</ol>
<h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><p>Android程序员和其它程序员相比，甚至是其它职业相比，<strong>竞争力在本质上还是体现在解决问题的能力上</strong>。想要提升这种能力，核心还是建立在扎实的基础和对问题技术的准确认识程度上。编程语言本质上只是一种工具，一个顺手的工具能带来更高的效率，但是如何用好这个工具，将效率和质量提升到最高，还是依赖于开发者的能力。选用一个趁手的工具，夯实基础，加强对事物本质透彻的分析和认识，才是真正回归到提升竞争力的本质上来。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="external">TIOBE 编程语言社区</a><br><a href="https://kotlinlang.org/docs/tutorials/koans.html" target="_blank" rel="external">kotlin-koans</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Kotlin-2017-06-09-Kotlin-note1.html">http://www.sguotao.com/Kotlin-2017-06-09-Kotlin-note1.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三周前的Google IO大会上，官方宣布将Kotlin作为除Java、C++外的官方编程语言，在最新一期的TIOBE排行榜中，Kotlin就首次挤进编程语言TOP50。&lt;br&gt;&lt;img src=&quot;http://7u2np3.com1.z0.glb.clouddn.com/
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.sguotao.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://www.sguotao.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>【Kotlin笔记】Hello Kotlin</title>
    <link href="http://www.sguotao.com/Kotlin-2017-06-10-Kotlin-note2.html"/>
    <id>http://www.sguotao.com/Kotlin-2017-06-10-Kotlin-note2.html</id>
    <published>2017-06-09T02:30:37.000Z</published>
    <updated>2017-06-23T11:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇 <em><a href="/Kotlin-2017-06-09-Kotlin-note1.html">Kotlin的前世今生</a></em> 中介绍了Kotlin的一些特点，下面记录一下Kotlin开发环境的配置，并且完成“Hello Kotlin”的打印输出。</p>
<h2 id="AndroidStudio"><a href="#AndroidStudio" class="headerlink" title="AndroidStudio"></a>AndroidStudio</h2><p>由于AndroidStudio是基于Intllij Idead的插件实现，Intellij Idea也是JetBrains开发的，所有AndroidStudio就与Kotlin天生有一层紧密的联系，在AndroidStudio的预览版中已经将Kotlin作为了一个基础插件进行了集成，官方最新的2.3版本还暂时没有集成Kotlin插件，需要手动进行安装，安装的过程也非常的简单，具体路径Preferences–&gt;Plugin,选择Kotlin，安装，重启编译器。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170622149812368551731.png" alt="20170622149812368551731.png"><br>Eclipse编译器同样需要手动安装插件，从Intellij 15开始，Kotlin也默认是安装的。</p>
<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>使用gradle构建Kotlin项目时，需要添加kotlin的依赖，对不同的项目，gradle文件也有所不同。</p>
<h3 id="Java项目"><a href="#Java项目" class="headerlink" title="Java项目"></a>Java项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    ext.kotlin_version = &apos;1.1.2&apos;</div><div class="line"></div><div class="line">    repositories &#123;</div><div class="line">        mavenCentral()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: &apos;java&apos;</div><div class="line">apply plugin: &apos;kotlin&apos;</div><div class="line"></div><div class="line">sourceCompatibility = 1.7</div><div class="line"></div><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot;</div><div class="line">    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="JavaScript项目"><a href="#JavaScript项目" class="headerlink" title="JavaScript项目"></a>JavaScript项目</h3><p>JavaScript使用不同的插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &quot;kotlin2js&quot;</div></pre></td></tr></table></figure></p>
<h3 id="Android项目"><a href="#Android项目" class="headerlink" title="Android项目"></a>Android项目</h3><p>如果通过编译器新建Kotlin项目工程，Gradle文件是默认生成的，如果要手动修改，需要手动添加Kotlin的引用包。在工程的gradle文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    ext.kotlin_version = &apos;1.1.0&apos; //使用的kotlin版本</div><div class="line"></div><div class="line">    repositories &#123;</div><div class="line">        mavenCentral()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dependencies &#123;</div><div class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建一个变量来保存当前使用的kotlin的版本号，在每个module的gradle文件中，都会用到这个变量，当使用高版本的kotlin时，直接修改这个变量即可。</p>
<h2 id="Hello-Kotlin"><a href="#Hello-Kotlin" class="headerlink" title="Hello Kotlin"></a>Hello Kotlin</h2><p>打开IntelliJ，新建project，选中Kotlin。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170622149812594181308.png" alt="20170622149812594181308.png"><br>输入GroupID（项目组织唯一的标识符，建议对应JAVA的包的结构）和 ArtifactID（项目的唯一的标识符，建议对应项目的名称），一路Next。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170622149812620532141.png" alt="20170622149812620532141.png"><br>新建的工程中，是没有src文件的，需要手动添加，新建directory，名称src/main/kotlin。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170622149812643655117.png" alt="20170622149812643655117.png"><br>新建一个package，创建HelloKotlin.kt。<br> <img src="http://7u2np3.com1.z0.glb.clouddn.com/2017062214981267486665.png" alt="2017062214981267486665.png"><br>添加一个main方法，输出“Hello Kotlin”。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170622149812693961350.png" alt="20170622149812693961350.png"><br>至此，完成了“Hello Kotlin”的输出。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Kotlin-2017-06-10-Kotlin-note2.html">http://www.sguotao.com/Kotlin-2017-06-10-Kotlin-note2.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇 &lt;em&gt;&lt;a href=&quot;/Kotlin-2017-06-09-Kotlin-note1.html&quot;&gt;Kotlin的前世今生&lt;/a&gt;&lt;/em&gt; 中介绍了Kotlin的一些特点，下面记录一下Kotlin开发环境的配置，并且完成“Hello Kotlin”的打印输出。
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.sguotao.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://www.sguotao.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>分析HTTPS协议</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2017-06-04-%E5%88%86%E6%9E%90HTTPS%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://www.sguotao.com/Android进阶-2017-06-04-分析HTTPS协议.html</id>
    <published>2017-06-04T02:27:04.000Z</published>
    <updated>2017-08-09T03:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><blockquote>
<p>是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
</blockquote>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170809150224326682630.png" alt="20170809150224326682630.png"><br>Https并不是一个单独的协议，而是对工作在一加密连接（SSL/TLS）上的常规Http协议。通过在TCP和HTTP之间加入TLS（Transport Layer Security）来加密。Https实际就是在TCP层与Http层之间加入了SSL/TLS来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</p>
<h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>HTTPS和HTTP的区别主要为以下几点：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li>
<li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。由于HTTPS要进行加密处理，所有传输速度比HTTP慢。</li>
</ol>
<h2 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h2><p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p>
<h3 id="SSL协议的作用"><a href="#SSL协议的作用" class="headerlink" title="SSL协议的作用"></a>SSL协议的作用</h3><ol>
<li>认证用户和服务器，确保数据发送到正确的客户机和服务器;</li>
<li>加密数据以防止数据中途被窃取;</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。</li>
</ol>
<h3 id="SSL协议的工作过程"><a href="#SSL协议的工作过程" class="headerlink" title="SSL协议的工作过程"></a>SSL协议的工作过程</h3><p><strong>服务器认证阶段:</strong></p>
<ol>
<li>客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；</li>
<li>服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；</li>
<li>客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</li>
<li>服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</li>
</ol>
<p><strong>用户认证阶段:</strong><br>在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p>
<h2 id="TLS-SSL握手"><a href="#TLS-SSL握手" class="headerlink" title="TLS/SSL握手"></a>TLS/SSL握手</h2><p>SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170809150224484346357.png" alt="20170809150224484346357.png"></p>
<p>1.客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>
<p>2.服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p>
<p>3.客户利用服务器传过来的信息验证服务器的合法性，<strong>服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。</strong>如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行下一步。</p>
<p>用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤2中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p>
<p>如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。</p>
<p>如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，<strong>具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。</strong>检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p>
<p>服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p>
<p>客户端向服务器端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p>
<p>4.服务器向客户端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p>
<p>5.SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p>
<h2 id="Https加密算法相关"><a href="#Https加密算法相关" class="headerlink" title="Https加密算法相关"></a>Https加密算法相关</h2><h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>密钥是一种参数，它是在使用密码算法过程中输入的参数，同一个明文在相同的密码算法和不同的密钥计算下会产生不同的密文。</p>
<h3 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h3><p>又称共享密钥加密，对称密钥在加密和解密的过程中使用的密钥是相同的，常见的对称加密算法有DES、3DES、AES、RC5、RC6.</p>
<p>优点是计算速度快，缺点是密钥需要在通讯的两端共享。</p>
<h3 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h3><p>又称为公开密钥加密。服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公钥可以自由发布，供任何人使用。</p>
<p>与对称密钥加密相比，非对称加密无需在客户端和服务端之间共享密钥，只要私钥不发给任何用户，即使公钥在网上被截获，也无法被解密，仅有被窃取的公钥是没有任何用处的。</p>
<h3 id="RSA加密过程"><a href="#RSA加密过程" class="headerlink" title="RSA加密过程"></a>RSA加密过程</h3><p>RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。</p>
<p>RSA加密过程:</p>
<ol>
<li>服务端生成配对的公钥和私钥；</li>
<li>私钥保存在服务端，公钥发送给客户端；</li>
<li>客户端使用公钥加密明文传输给服务端；</li>
<li>服务端使用私钥解密密文得到明文；</li>
</ol>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>就是互联网通讯中标志通讯各方身份信息的一串数字。数字证书解决的问题，就是保证现在使用的公钥就是真实服务器发送给我们的。</p>
<p>数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的。</p>
<h2 id="数字签名和CA"><a href="#数字签名和CA" class="headerlink" title="数字签名和CA"></a>数字签名和CA</h2><p>数据在浏览器和服务器之间传输时，如何保证数据传输是真实服务器发送的而不是被掉包的？同时，如何保证传输的数据没有被人篡改？</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名就是用于验证传输的内容是不是真实服务器发送的数据，发送的数据有没有被篡改过，是非对称加密的一种应用场景，不过他是反过来用私钥加密，通过与之配对的公钥来解密。</p>
<p>数字签名的过程:</p>
<ol>
<li>服务端把报文经过Hash处理后生成摘要信息Digest，摘要信息使用私钥private-key加密之后就生成签名，服务器把签名连同报文一起发送给客户端。</li>
<li>客户端接收到数据后，把签名提取出来用公钥public-key解密，如果能正常的解密出来Digest2，那么就能确认是对方发送的。</li>
<li>客户端把报文Text提取出来做同样的Hash处理，得到的摘要信息Digest1，再与之前解密出来的Digest2对比。如果一致，则文本内容没有被修改过。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">超文本传输安全协议</a><br><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" target="_blank" rel="external">数字证书</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2017-06-04-分析HTTPS协议.html">http://www.sguotao.com/Android进阶-2017-06-04-分析HTTPS协议.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Https&quot;&gt;&lt;a href=&quot;#Https&quot; class=&quot;headerlink&quot; title=&quot;Https&quot;&gt;&lt;/a&gt;Https&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Http" scheme="http://www.sguotao.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>分析HTTP协议</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2017-06-03-%E5%88%86%E6%9E%90HTTP%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://www.sguotao.com/Android进阶-2017-06-03-分析HTTP协议.html</id>
    <published>2017-06-03T02:27:04.000Z</published>
    <updated>2017-08-08T03:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>所谓协议，是指指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。<br>Http协议，超文本传输协议(Http)是一种通信协议，它允许将超文本标记语言（HTML）文档从web服务器传送到客户端的浏览器。</p>
</blockquote>
<p>HTTP协议的最显著的两个特点:</p>
<ul>
<li>HTTP是构建于TCP/IP协议之上的协议，默认端口号是80。</li>
<li>HTTP是无连接无状态的协议。</li>
</ul>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170808150215936342753.png" alt="20170808150215936342753.png"></p>
<h3 id="请求行（Request-Line）"><a href="#请求行（Request-Line）" class="headerlink" title="请求行（Request Line）"></a>请求行（Request Line）</h3><p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。其中比较常用的请求方法是GET和POST。</p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送。以用google搜索domety为例，Request格式如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  </div><div class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </div><div class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </div><div class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn/"</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </div><div class="line">Accept-Language: zh-cn  </div><div class="line">Accept-Encoding: gzip, deflate  </div><div class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </div><div class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn"</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </div><div class="line">Connection: Keep-Alive  </div><div class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </div><div class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</div><div class="line">FxlRugatx63JLv7CWMD6UB_O_r</div></pre></td></tr></table></figure>
<p>可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&amp;”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</p>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面的搜索domety为例，如果使用POST方式的话，格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">POST /search HTTP/1.1  </div><div class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </div><div class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </div><div class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn/"</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </div><div class="line">Accept-Language: zh-cn  </div><div class="line">Accept-Encoding: gzip, deflate  </div><div class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </div><div class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn"</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </div><div class="line">Connection: Keep-Alive  </div><div class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </div><div class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</div><div class="line">FxlRugatx63JLv7CWMD6UB_O_r  </div><div class="line"></div><div class="line">hl=zh-CN&amp;source=hp&amp;q=domety</div></pre></td></tr></table></figure>
<p>可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。POST方式大多用于页面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用GET还是使用POST。</p>
<h4 id="GET-POST方法的区别"><a href="#GET-POST方法的区别" class="headerlink" title="GET/POST方法的区别"></a>GET/POST方法的区别</h4><ol>
<li>提交的数据，get提交的数据会在url链接中，以”?”的形式进行分割，post提交数据都放在http请求的body中。</li>
<li>提交的数据大小是否有限制，get有限制，post没有限制。</li>
<li>取得变量的值Request.QueryString &amp; Request.Form</li>
<li>安全问题，get提交方式有安全隐患。</li>
</ol>
<h3 id="请求头（Header）"><a href="#请求头（Header）" class="headerlink" title="请求头（Header）"></a>请求头（Header）</h3><p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p>
<p><strong>User-Agent</strong>：产生请求的浏览器类型。<br><strong>Accept</strong>：客户端可识别的内容类型列表。<br><strong>Host</strong>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p>
<h3 id="空行（Blank-Line）"><a href="#空行（Blank-Line）" class="headerlink" title="空行（Blank Line）"></a>空行（Blank Line）</h3><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<h3 id="请求数据（Request-Body）"><a href="#请求数据（Request-Body）" class="headerlink" title="请求数据（Request-Body）"></a>请求数据（Request-Body）</h3><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><p>HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：状态行、响应头(Response Header)和响应正文。<br>状态行由协议版本、数字形式的状态码、及相应的状态描述，各元素之间以空格分隔。</p>
<p>常见的状态码有如下几种：</p>
<ul>
<li>200 OK 客户端请求成功</li>
<li>301 Moved Permanently 请求永久重定向</li>
<li>302 Moved Temporarily 请求临时重定向</li>
<li>304 Not Modified 文件未修改，可以直接使用缓存的文件。</li>
<li>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</li>
<li>401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li>
<li>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</li>
<li>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li>
</ul>
<h2 id="Http协议中容易混淆的知识点"><a href="#Http协议中容易混淆的知识点" class="headerlink" title="Http协议中容易混淆的知识点"></a>Http协议中容易混淆的知识点</h2><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>URI：Uniform Resource Identifier,统一资源标识符，用来唯一的标识一个资源。</p>
<p>URI的三个组成部分:</p>
<ol>
<li>访问资源的命名机制；</li>
<li>存放资源的主机名；</li>
<li>资源自身的名称，由路径表示，着重强调资源。</li>
</ol>
<p>URL:Uniform Resource Locator，统一资源定位器，它是一种具体的URI，即URL可以标识一个资源，而且还指明了如何locate这个资源。</p>
<p>URL的三个组成部分：</p>
<ol>
<li>协议</li>
<li>存有该资源的主机IP地址</li>
<li>主机资源的具体地址；</li>
</ol>
<h3 id="http1-1-http1-0的区别"><a href="#http1-1-http1-0的区别" class="headerlink" title="http1.1/http1.0的区别"></a>http1.1/http1.0的区别</h3><ol>
<li><p>http1.0产生的背景<br>超文本传输协议（HyperText Transfer Protocol）伴随着计算机网络和浏览器的诞生，Http1.0也随之而来，处于计算机网络中的应用层。</p>
</li>
<li><p>http1.0所做的优化<br>带宽:现阶段已经解决<br>延迟：<br> 1.浏览器阻塞：浏览器对于同一个域名，同时只能有4个连接；<br> 2.DNS查询：浏览器需要知道目标服务器的IP才能建立连接<br> 3.建立连接: 3次握手</p>
</li>
<li><p>http1.1/http1.0的具体区别<br> a. 缓存处理，Http1.1引入了更多的缓存策略；<br> b. 带宽优化及网络连接的使用，Http1.1在请求头中添加了range，可以请求资源的某个部分。<br> c. Host头处理，Http1.1请求消息和响应消息都支持Host的改进，在请求中如果没有Host域会报400错误。<br> d. 长连接，Http1.1支持长连接，减少每次请求都需要建立和关闭连接的消耗。</p>
</li>
<li><p>http1.1和http1.0存在的问题<br> a. Http1.0在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间；<br> b. Http1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份；<br> c. Http1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本；<br> d. 虽然Http1.1支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务器带来大量的性能压力。</p>
</li>
</ol>
<h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><p>Cookie技术是客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。</p>
<p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。</p>
<p>Session的工作原理：</p>
<ol>
<li>创建Session</li>
<li>在创建了Session的同时，服务器会为该Session生成唯一的Session id；</li>
<li>在Session被创建后，就可以调用Session相关的方法在Session中增加内容；</li>
<li>当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session </li>
</ol>
<p>Session和Cookie的区别：</p>
<ol>
<li>存放位置不同；Session保存在服务端，Cookie保存在客户端；</li>
<li>存取方式不同；Session能存取任意类型的数据，Cookie只能保存字符串；</li>
<li>安全性（隐私策略）不同</li>
<li>有效期上的不同</li>
<li>对服务器造成的压力不同</li>
</ol>
<h2 id="附录1-HTTP请求报文请求头Header字段说明"><a href="#附录1-HTTP请求报文请求头Header字段说明" class="headerlink" title="附录1 HTTP请求报文请求头Header字段说明"></a>附录1 HTTP请求报文请求头Header字段说明</h2><table>
<thead>
<tr>
<th style="text-align:center">Header字段</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">指定客户端能够接收的内容类型</td>
<td style="text-align:center">Accept: text/plain, text/html</td>
</tr>
<tr>
<td style="text-align:center">Accept-Charset</td>
<td style="text-align:center">浏览器可以接受的字符编码集。</td>
<td style="text-align:center">Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td style="text-align:center">Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">浏览器可接受的语言</td>
<td style="text-align:center">Accept-Language: en,zh</td>
</tr>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">可以请求网页实体的一个或者多个子范围字段</td>
<td style="text-align:center">Accept-Ranges: bytes</td>
</tr>
<tr>
<td style="text-align:center">Authorization</td>
<td style="text-align:center">HTTP授权的授权证书</td>
<td style="text-align:center">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">指定请求和响应遵循的缓存机制</td>
<td style="text-align:center">Cache-Control: no-cache</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td style="text-align:center">Connection: close</td>
</tr>
<tr>
<td style="text-align:center">Cookie</td>
<td style="text-align:center">HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td style="text-align:center">Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">请求的内容长度</td>
<td style="text-align:center">Content-Length: 348</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">请求的与实体对应的MIME信息</td>
<td style="text-align:center">Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">请求发送的日期和时间</td>
<td style="text-align:center">Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td style="text-align:center">Expect</td>
<td style="text-align:center">请求的特定的服务器行为</td>
<td style="text-align:center">Expect: 100-continue</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">发出请求的用户的Email</td>
<td style="text-align:center">From: user@email.com</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">指定请求的服务器的域名和端口号</td>
<td style="text-align:center">Host: www.zcmhi.com</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center">只有请求内容与实体相匹配才有效</td>
<td style="text-align:center">If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td style="text-align:center">If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center">如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td style="text-align:center">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:center">If-Range</td>
<td style="text-align:center">如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td style="text-align:center">If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center">只在实体在指定时间之后未被修改才请求成功</td>
<td style="text-align:center">If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td style="text-align:center">Max-Forwards</td>
<td style="text-align:center">限制信息通过代理和网关传送的时间</td>
<td style="text-align:center">Max-Forwards: 10</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">用来包含实现特定的指令</td>
<td style="text-align:center">Pragma: no-cache</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authorization</td>
<td style="text-align:center">连接到代理的授权证书</td>
<td style="text-align:center">Proxy-Authorization: BasicQWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center">只请求实体的一部分，指定范围</td>
<td style="text-align:center">Range: bytes=500-999</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">先前网页的地址，当前请求网页紧随其后,即来路</td>
<td style="text-align:center">Referer: <a href="http://www.zcmhi.com/archives/71.html" target="_blank" rel="external">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td style="text-align:center">TE</td>
<td style="text-align:center">客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td style="text-align:center">TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td style="text-align:center">Upgrade</td>
<td style="text-align:center">向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td style="text-align:center">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">User-Agent的内容包含发出请求的用户信息</td>
<td style="text-align:center">User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">通知中间网关或代理服务器地址，通信协议</td>
<td style="text-align:center">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">关于消息实体的警告信息</td>
<td style="text-align:center">Warn: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
<h2 id="附录2-HTTP响应报文响应头ResponseHeader字段说明"><a href="#附录2-HTTP响应报文响应头ResponseHeader字段说明" class="headerlink" title="附录2 HTTP响应报文响应头ResponseHeader字段说明"></a>附录2 HTTP响应报文响应头ResponseHeader字段说明</h2><table>
<thead>
<tr>
<th style="text-align:center">Header字段</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td style="text-align:center">Accept-Ranges: bytes</td>
</tr>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td style="text-align:center">Age: 12</td>
</tr>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">对某网络资源的有效的请求行为，不允许则返回405</td>
<td style="text-align:center">Allow: GET, HEAD</td>
</tr>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td style="text-align:center">Cache-Control: no-cache</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">web服务器支持的返回内容压缩编码类型。</td>
<td style="text-align:center">Content-Encoding: gzip</td>
</tr>
<tr>
<td style="text-align:center">Content-Language</td>
<td style="text-align:center">响应体的语言</td>
<td style="text-align:center">Content-Language: en,zh</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">响应体的长度</td>
<td style="text-align:center">Content-Length: 348</td>
</tr>
<tr>
<td style="text-align:center">Content-Location</td>
<td style="text-align:center">请求资源可替代的备用的另一地址</td>
<td style="text-align:center">Content-Location: /index.htm</td>
</tr>
<tr>
<td style="text-align:center">Content-MD5</td>
<td style="text-align:center">返回资源的MD5校验值</td>
<td style="text-align:center">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td style="text-align:center">Content-Range</td>
<td style="text-align:center">在整个返回体中本部分的字节位置</td>
<td style="text-align:center">Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">返回内容的MIME类型</td>
<td style="text-align:center">Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">原始服务器消息发出的时间</td>
<td style="text-align:center">Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">请求变量的实体标签的当前值</td>
<td style="text-align:center">ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">响应过期的日期和时间</td>
<td style="text-align:center">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">请求资源的最后修改时间</td>
<td style="text-align:center">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td style="text-align:center">Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="external">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td style="text-align:center">Pragma: no-cache</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authenticate</td>
<td style="text-align:center">它指出认证方案和可应用到代理的该URL上的参数</td>
<td style="text-align:center">Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td style="text-align:center">refresh</td>
<td style="text-align:center">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td style="text-align:center">Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="external">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td style="text-align:center">Retry-After</td>
<td style="text-align:center">如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td style="text-align:center">Retry-After: 120</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">web服务器软件名称</td>
<td style="text-align:center">Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td style="text-align:center">Set-Cookie</td>
<td style="text-align:center">设置Http Cookie    Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">指出头域在分块传输编码的尾部存在</td>
<td style="text-align:center">Trailer: Max-Forwards</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center">文件传输编码</td>
<td style="text-align:center">Transfer-Encoding:chunked</td>
</tr>
<tr>
<td style="text-align:center">Vary</td>
<td style="text-align:center">告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td style="text-align:center">Vary: *</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">告知代理客户端响应是通过哪里发送的</td>
<td style="text-align:center">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">警告实体可能存在的问题</td>
<td style="text-align:center">Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td style="text-align:center">WWW-Authenticate</td>
<td style="text-align:center">表明客户端请求实体应该使用的授权方案</td>
<td style="text-align:center">WWW-Authenticate: Basic</td>
</tr>
</tbody>
</table>
<h2 id="附录3-HTTP响应报文状态码"><a href="#附录3-HTTP响应报文状态码" class="headerlink" title="附录3 HTTP响应报文状态码"></a>附录3 HTTP响应报文状态码</h2><p><strong>1xx:信息</strong></p>
<style>
table th:first-of-type {
    width: 150px;
}
</style>

<table>
<thead>
<tr>
<th style="text-align:center">消息</th>
<th style="text-align:center">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100 Continue</td>
<td style="text-align:center">服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td>
</tr>
<tr>
<td style="text-align:center">101 Switching Protocols</td>
<td style="text-align:center">服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td>
</tr>
</tbody>
</table>
<p><strong>2xx:成功</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息</th>
<th style="text-align:center">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">200 OK</td>
<td style="text-align:center">请求成功（其后是对GET和POST请求的应答文档。）</td>
</tr>
<tr>
<td style="text-align:center">201 Created</td>
<td style="text-align:center">请求被创建完成，同时新的资源被创建。</td>
</tr>
<tr>
<td style="text-align:center">202 Accepted</td>
<td style="text-align:center">供处理的请求已被接受，但是处理未完成。</td>
</tr>
<tr>
<td style="text-align:center">203 Non-authoritative Information</td>
<td style="text-align:center">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</td>
</tr>
<tr>
<td style="text-align:center">204 No Content</td>
<td style="text-align:center">没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td>
</tr>
<tr>
<td style="text-align:center">205 Reset Content</td>
<td style="text-align:center">没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td>
</tr>
<tr>
<td style="text-align:center">206 Partial Content</td>
<td style="text-align:center">客户发送了一个带有Range头的GET请求，服务器完成了它。</td>
</tr>
</tbody>
</table>
<p><strong>3xx:重定向</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息</th>
<th style="text-align:center">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">300 Multiple Choices</td>
<td style="text-align:center">多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td>
</tr>
<tr>
<td style="text-align:center">301 Moved Permanently</td>
<td style="text-align:center">所请求的页面已经转移至新的url。</td>
</tr>
<tr>
<td style="text-align:center">302 Found</td>
<td style="text-align:center">所请求的页面已经临时转移至新的url。</td>
</tr>
<tr>
<td style="text-align:center">303 See Other</td>
<td style="text-align:center">所请求的页面可在别的url下被找到。</td>
</tr>
<tr>
<td style="text-align:center">304 Not Modified</td>
<td style="text-align:center">未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td>
</tr>
<tr>
<td style="text-align:center">305 Use Proxy</td>
<td style="text-align:center">客户请求的文档应该通过Location头所指明的代理服务器提取。</td>
</tr>
<tr>
<td style="text-align:center">306 Unused</td>
<td style="text-align:center">此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</td>
</tr>
<tr>
<td style="text-align:center">307 Temporary Redirect</td>
<td style="text-align:center">被请求的页面已经临时移至新的url。</td>
</tr>
</tbody>
</table>
<p><strong>4xx:客户端错误</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息</th>
<th style="text-align:center">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">400 Bad Request</td>
<td style="text-align:center">服务器未能理解请求。</td>
</tr>
<tr>
<td style="text-align:center">401 Unauthorized</td>
<td style="text-align:center">被请求的页面需要用户名和密码。</td>
</tr>
<tr>
<td style="text-align:center">401.1</td>
<td style="text-align:center">登录失败。</td>
</tr>
<tr>
<td style="text-align:center">401.2</td>
<td style="text-align:center">服务器配置导致登录失败。</td>
</tr>
<tr>
<td style="text-align:center">401.3</td>
<td style="text-align:center">由于 ACL 对资源的限制而未获得授权。</td>
</tr>
<tr>
<td style="text-align:center">401.4</td>
<td style="text-align:center">筛选器授权失败。</td>
</tr>
<tr>
<td style="text-align:center">401.5</td>
<td style="text-align:center">ISAPI/CGI 应用程序授权失败。</td>
</tr>
<tr>
<td style="text-align:center">401.7</td>
<td style="text-align:center">访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td style="text-align:center">402 Payment Required</td>
<td style="text-align:center">此代码尚无法使用。</td>
</tr>
<tr>
<td style="text-align:center">403 Forbidden</td>
<td style="text-align:center">对被请求页面的访问被禁止。</td>
</tr>
<tr>
<td style="text-align:center">403.1</td>
<td style="text-align:center">执行访问被禁止。</td>
</tr>
<tr>
<td style="text-align:center">403.2</td>
<td style="text-align:center">读访问被禁止。</td>
</tr>
<tr>
<td style="text-align:center">403.3</td>
<td style="text-align:center">写访问被禁止。</td>
</tr>
<tr>
<td style="text-align:center">403.4</td>
<td style="text-align:center">要求 SSL。</td>
</tr>
<tr>
<td style="text-align:center">403.5</td>
<td style="text-align:center">要求 SSL 128。</td>
</tr>
<tr>
<td style="text-align:center">403.6</td>
<td style="text-align:center">IP 地址被拒绝。</td>
</tr>
<tr>
<td style="text-align:center">403.7</td>
<td style="text-align:center">要求客户端证书。</td>
</tr>
<tr>
<td style="text-align:center">403.8</td>
<td style="text-align:center">站点访问被拒绝。</td>
</tr>
<tr>
<td style="text-align:center">403.9</td>
<td style="text-align:center">用户数过多。</td>
</tr>
<tr>
<td style="text-align:center">403.10</td>
<td style="text-align:center">配置无效。</td>
</tr>
<tr>
<td style="text-align:center">403.11</td>
<td style="text-align:center">密码更改。</td>
</tr>
<tr>
<td style="text-align:center">403.12</td>
<td style="text-align:center">拒绝访问映射表。</td>
</tr>
<tr>
<td style="text-align:center">403.13</td>
<td style="text-align:center">客户端证书被吊销。</td>
</tr>
<tr>
<td style="text-align:center">403.14</td>
<td style="text-align:center">拒绝目录列表。</td>
</tr>
<tr>
<td style="text-align:center">403.15</td>
<td style="text-align:center">超出客户端访问许可。</td>
</tr>
<tr>
<td style="text-align:center">403.16</td>
<td style="text-align:center">客户端证书不受信任或无效。</td>
</tr>
<tr>
<td style="text-align:center">403.17</td>
<td style="text-align:center">客户端证书已过期或尚未生效。</td>
</tr>
<tr>
<td style="text-align:center">403.18</td>
<td style="text-align:center">在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td style="text-align:center">403.19</td>
<td style="text-align:center">不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td style="text-align:center">403.20</td>
<td style="text-align:center">Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td style="text-align:center">404 Not Found</td>
<td style="text-align:center">服务器无法找到被请求的页面。</td>
</tr>
<tr>
<td style="text-align:center">404.0</td>
<td style="text-align:center">（无）–没有找到文件或目录。</td>
</tr>
<tr>
<td style="text-align:center">404.1</td>
<td style="text-align:center">无法在所请求的端口上访问 Web 站点。</td>
</tr>
<tr>
<td style="text-align:center">404.2</td>
<td style="text-align:center">Web 服务扩展锁定策略阻止本请求。</td>
</tr>
<tr>
<td style="text-align:center">404.3</td>
<td style="text-align:center">MIME 映射策略阻止本请求。</td>
</tr>
<tr>
<td style="text-align:center">405 Method Not Allowed</td>
<td style="text-align:center">请求中指定的方法不被允许。</td>
</tr>
<tr>
<td style="text-align:center">406 Not Acceptable</td>
<td style="text-align:center">服务器生成的响应无法被客户端所接受。</td>
</tr>
<tr>
<td style="text-align:center">407 Proxy Authentication Required</td>
<td style="text-align:center">用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td>
</tr>
<tr>
<td style="text-align:center">408 Request Timeout</td>
<td style="text-align:center">请求超出了服务器的等待时间。</td>
</tr>
<tr>
<td style="text-align:center">409 Conflict</td>
<td style="text-align:center">由于冲突，请求无法被完成。</td>
</tr>
<tr>
<td style="text-align:center">410 Gone</td>
<td style="text-align:center">被请求的页面不可用。</td>
</tr>
<tr>
<td style="text-align:center">411 Length Required</td>
<td style="text-align:center">“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</td>
</tr>
<tr>
<td style="text-align:center">412 Precondition Failed</td>
<td style="text-align:center">请求中的前提条件被服务器评估为失败。</td>
</tr>
<tr>
<td style="text-align:center">413 Request Entity Too Large</td>
<td style="text-align:center">由于所请求的实体的太大，服务器不会接受请求。</td>
</tr>
<tr>
<td style="text-align:center">414 Request-url Too Long</td>
<td style="text-align:center">由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</td>
</tr>
<tr>
<td style="text-align:center">415 Unsupported Media Type</td>
<td style="text-align:center">由于媒介类型不被支持，服务器不会接受请求。</td>
</tr>
<tr>
<td style="text-align:center">416 Requested Range Not Satisfiable</td>
<td style="text-align:center">服务器不能满足客户在请求中指定的Range头。</td>
</tr>
<tr>
<td style="text-align:center">417 Expectation Failed</td>
<td style="text-align:center">执行失败。</td>
</tr>
<tr>
<td style="text-align:center">423</td>
<td style="text-align:center">锁定的错误。</td>
</tr>
</tbody>
</table>
<p><strong>5xx:服务端错误</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">消息</th>
<th style="text-align:center">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">500 Internal Server Error</td>
<td style="text-align:center">请求未完成。服务器遇到不可预知的情况。</td>
</tr>
<tr>
<td style="text-align:center">500.12</td>
<td style="text-align:center">应用程序正忙于在 Web 服务器上重新启动。</td>
</tr>
<tr>
<td style="text-align:center">500.13</td>
<td style="text-align:center">Web 服务器太忙。</td>
</tr>
<tr>
<td style="text-align:center">500.15</td>
<td style="text-align:center">不允许直接请求 Global.asa。</td>
</tr>
<tr>
<td style="text-align:center">500.16</td>
<td style="text-align:center">UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td style="text-align:center">500.18</td>
<td style="text-align:center">URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td style="text-align:center">500.100</td>
<td style="text-align:center">内部 ASP 错误。</td>
</tr>
<tr>
<td style="text-align:center">501 Not Implemented</td>
<td style="text-align:center">请求未完成。服务器不支持所请求的功能。</td>
</tr>
<tr>
<td style="text-align:center">502 Bad Gateway</td>
<td style="text-align:center">请求未完成。服务器从上游服务器收到一个无效的响应。</td>
</tr>
<tr>
<td style="text-align:center">502.1</td>
<td style="text-align:center">CGI 应用程序超时。</td>
</tr>
<tr>
<td style="text-align:center">502.2</td>
<td style="text-align:center">CGI 应用程序出错。</td>
</tr>
<tr>
<td style="text-align:center">503 Service Unavailable</td>
<td style="text-align:center">请求未完成。服务器临时过载或当机。</td>
</tr>
<tr>
<td style="text-align:center">504 Gateway Timeout</td>
<td style="text-align:center">网关超时。</td>
</tr>
<tr>
<td style="text-align:center">505 HTTP Version Not Supported</td>
<td style="text-align:center">服务器不支持请求中指明的HTTP协议版本。</td>
</tr>
</tbody>
</table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html" target="_blank" rel="external">HTTP请求报文和HTTP响应报文</a><br><a href="https://baike.baidu.com/item/http" target="_blank" rel="external">HTTP百科</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2017-06-03-分析HTTP协议.html">http://www.sguotao.com/Android进阶-2017-06-03-分析HTTP协议.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;所谓协议，是指指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。&lt;br&gt;Http协议，超文本传输协议(Http)是一种通信协议，它允许将超文本标记语言（HTML）文档从web服务器传送到客户端的浏览器。&lt;/p&gt;
&lt;/blockqu
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Http" scheme="http://www.sguotao.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>分析TCP/IP参考模型</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2017-06-03-%E5%88%86%E6%9E%90TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.html"/>
    <id>http://www.sguotao.com/Android进阶-2017-06-03-分析TCP-IP网络模型.html</id>
    <published>2017-06-03T02:27:04.000Z</published>
    <updated>2017-08-08T08:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP模型各个层次分别对应于不同的协议。TCP/IP协议栈是数据通信协议的集合 ，包含许多协议。其协议栈名字来源于其中最主要的两个协议TCP（传输控制协议）和IP（网际协议）。TCP/IP协议栈负责确保网络设备之间能够通信。它是一组规则，规定了信息如何在网络中传输。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017080815021784897401.png" alt="2017080815021784897401.png"></p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层功能:</p>
<ul>
<li>规定介质类型、接口类型、信令类型；</li>
<li>规范在终端系统之间激活、维护和关闭物理链路的电气、机械、流程和功能等方面的要求；</li>
<li>规范电平、数据速率、最大传输距离和物理接头等特征。</li>
</ul>
<p>物理层介质：</p>
<ul>
<li>同轴电缆（coaxical cable）</li>
<li>双绞线（twisted pair）</li>
<li>光纤（fiber）</li>
<li>无线电波（wireless raido）</li>
</ul>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层协议规定了数据链路层帧的封装方式。数据链路层又分为MAC子层和LLC子层:</p>
<ul>
<li>MAC子层负责指定数据如何通过物理线路进行传输，并向下与物理层通信，它定义了物理编址、网络拓扑、线路规范、错误通知、按序传递和流量控制等功能。</li>
<li>LLC子层负责识别协议类型并对数据进行封装以便通过网络进行传输。LLC子层主要执行数据链路层的大部分功能和网络层的部分功能。如帧的收发功能，在发送时，帧由发送的数据加上地址和CRC校验等构成，接收时将帧拆开，执行地址识别、CRC校验，并具有帧顺序控制、差错控制、流量控制等功能。此外，它还执行数据报、虚电路、多路复用等部分网络层的功能。</li>
</ul>
<h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><p>网络设备的MAC地址是全球唯一的。MAC地址由48个二进制位组成，通常我们用十六进制数字来表示。其中前6位十六进制数字由IEEE统一分配给设备制造商，后6位十六进制数字由厂商自行分配。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>由于以太网采用广播方式发送数据包，效率比较低，也无法区分哪些MAC地址属于同一子网，引入网络层后，能够区分哪些MAC地址属于同一个子网络，使得我们能够区分不同的计算机是否属于同一个子网络，并且在不同的网络之间转发数据包。</p>
<p>网络层常用协议:</p>
<ul>
<li>IP（Internet Protocol）IP为网络层最主要的协议，其功能即为网络层的主要功能，一是提供逻辑编址，二是提供路由功能，三是报文的封装和解封装。ICMP、ARP、RARP协议辅助IP工作。</li>
<li>ICMP（Internet Control Message Protocol）是一个管理协议并为IP提供信息服务，ICMP消息承载在IP报文中。</li>
<li>ARP（Address Resolution Protocol）实现IP地址到硬件地址的动态映射，即根据已知的IP地址获得相应的硬件地址。</li>
<li>RARP（Reverse Address Resolution Protocol）实现硬件地址到IP地址的动态映射，即根据已知的硬件地址获得相应的IP地址。</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>当一个数据包从互联网上发来的时候，怎么确定是网页的内容，还是在线聊天的内容？传输层的功能，实现端口到端口的通信。</p>
<p>传输层主要功能：</p>
<ul>
<li>分段上层数据；</li>
<li>建立端到端连接；</li>
<li>将数据从一端主机传送到另一端主机；</li>
<li>保证数据按序、可靠、正确传输。</li>
</ul>
<p>传输层协议主要包含传输控制协议TCP（transfer control protocol）和用户数据报文协议UDP（user datagram protocol）:</p>
<ul>
<li>TCP提供面向连接的、可靠的字节流服务。面向连接意味着使用TCP协议作为传输层协议的两个应用之间在相互交换数据之前必须建立一个TCP连接。TCP通过确认、校验、重组等机制为上层应用提供可靠的传输服务。但是TCP连接的建立以及确认、校验等机制都需要耗费大量的工作并且会带来大量的开销。</li>
<li>UDP提供简单的、面向数据报的服务。UDP不保证可靠性，即不保证报文能够到达目的地。UDP适用于更关注传输效率的应用，如SNMP、Radius等，SNMP监控网络并断续发送告警等消息，如果每次发送少量信息都需要建立TCP连接，无疑会降低传输效率，所以诸如SNMP、Radius等更注重传输效率的应用程序都会选择UDP作为传输层协议。另外，UDP还适用于本身具备可靠性机制的应用层协议。</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层主要功能:</p>
<ul>
<li>规定应用程序的数据格式。</li>
<li>为用户提供接口、处理特定的应用；</li>
<li>数据加密、解密、压缩、解压缩；</li>
<li>定义数据表示的标准。</li>
</ul>
<p>应用层的协议包括:</p>
<ul>
<li>FTP(File TransferProtocol) 文件传输协议。用于传输独立的文件，通常用于交互式用户会话。</li>
<li>HTTP(HypertextTransfer Protocol)超文本传输协议。 用于传输那些构成万维网上的页面的文件。</li>
<li>TELNET ：远程终端访问。用于传送具有TELNET控制信息的数据。它提供了与终端设备或终端进程交互的标准方法，支持终端到终端的连接及进程到进程分布式计算的通信。</li>
<li>SMTP(Simple MessageTransfer Protocol)简单邮件传输协议</li>
<li>POP3(Post OfficeProtocol)邮局协议用于发送和接收邮件。</li>
<li>DNS(Domain NameServer)是一个域名服务的协议，提供域名到IP地址的转换，允许对域名资源进行分散管理。</li>
<li>TFTP(Trivial FileTransfer Protocol)简单文件传输协议。设计用于一般目的的、高吞吐量的文件传输。</li>
<li>RIP(RoutingInformation Protocol)路由器用来在 IP 网络上交换路由信息的协议。</li>
<li>SNMP(Simple NetworkManagement Protocol)用于收集网络管理信息，并在网络管理控制台和网络设备（例如路由器、网桥和服务器）之间交换网络管理信息。</li>
<li>Radius(RemoteAuthentication Dial In User Service)拨号接入远端认证协议完成接入用户的认证、授权、计费功能的协议。</li>
</ul>
<h2 id="TCP-IP模型层间数据封装与解析过程"><a href="#TCP-IP模型层间数据封装与解析过程" class="headerlink" title="TCP/IP模型层间数据封装与解析过程"></a>TCP/IP模型层间数据封装与解析过程</h2><p>TCP/IP每一层都让数据得以通过网络进行传输，这些层之间使用PDU（协议数据单元）彼此交换信息，确保网络设备之间能够通信。数据封装的过程如图<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170808150217839042287.png" alt="20170808150217839042287.png"></p>
<ol>
<li>传输层数据中加入TCP报头后得到PDU被称为segment（数据段）；</li>
<li>数据段被传递给网络层，网络层添加IP报头得到的PDU被称为packet（数据包）；</li>
<li>数据包被传递到数据链路层，封装数据链路层报头得到的PDU被称为frame（数据帧）；</li>
<li>帧被转换为比特，通过网络介质传输。</li>
</ol>
<p>这种协议栈向下传递数据，并添加报头和报尾的过程称为封装，数据被封装并通过网络传输后，接收设备将删除添加的信息，并根据报头中的信息决定如何将数据沿协议栈上传给合适的应用程序，这个过程称为解封装。不同设备的对等层之间依靠封装和解封装来实现相互间的通信。数据解析的过程如图<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170808150217846881527.png" alt="20170808150217846881527.png"></p>
<h2 id="TCP-IP模型建立连接与断开连接"><a href="#TCP-IP模型建立连接与断开连接" class="headerlink" title="TCP/IP模型建立连接与断开连接"></a>TCP/IP模型建立连接与断开连接</h2><p>TCP/IP模型建立连接与断开连接过程如图<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170808150218203850506.png" alt="20170808150218203850506.png"></p>
<p> <strong>三次握手过程(建立连接)</strong></p>
<ol>
<li>请求端（通常也称为客户端）发送一个SYN段表示客户期望连接服务器端口，初始序列号为a。</li>
<li>服务器发回序列号为b的SYN段作为响应。同时设置确认序号为客户端的序列号加1（a+1）作为对客户端的SYN报文的确认。</li>
<li>客户端设置序列号为服务器端的序列号加1（b+1）作为对服务器端SYN报文段的确认。</li>
</ol>
<p><strong>四次挥手过程(断开连接)</strong></p>
<ol>
<li>请求端（通常也称为客户端）想终止连接则发送一个FIN段，序列号设置为a。</li>
<li>服务器回应一个确认序号为客户端的序列号加1（a+1）的ACK确认段，作为对客户端的FIN报文的确认。</li>
<li>服务器端向客户端发送一个FIN终止段（设置序列号为b，确认号为a+1）。</li>
<li>客户端返回一个确认报文（设置序列号为b+1）作为响应。</li>
</ol>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>所提供的服务是用来将主机名和域名转换为IP地址的工作。</p>
<h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><p>递归:DNS服务器可使用其自身的资源记录信息缓存来应答查询，也可以代表请求客户机来查询或联系其他DNS服务器，以完全解析该名称，并随后将应答返回至客户机。</p>
<p>迭代:客户机自己也可尝试联系其他的DNS服务器来解析名称。如果客户机这么做，它会使用基于服务器应答的独立和附加的查询。</p>
<ol>
<li>在浏览器中输入域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系；</li>
<li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存</li>
<li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器；</li>
<li>如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析。</li>
<li>本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名（.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。</li>
<li>如果用的是转发模式，此DNS服务器就会把请求转至上一级DNS服务器，由上一级服务器进行解析。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="http://blog.jobbole.com/91515/" target="_blank" rel="external">TCP/IP协议栈及OSI参考模型详解</a><br>2.<a href="http://swiftlet.net/archives/1082" target="_blank" rel="external">TCP三次握手和四次挥手协议</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2017-06-03-分析TCP-IP网络模型.html">http://www.sguotao.com/Android进阶-2017-06-03-分析TCP-IP网络模型.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP/IP模型各个层次分别对应于不同的协议。TCP/IP协议栈是数据通信协议的集合 ，包含许多协议。其协议栈名字来源于其中最主要的两个协议TCP（传输控制协议）和IP（网际协议）。TCP/IP协议栈负责确保网络设备之间能够通信。它是一组规则，规定了信息如何在网络中传输。&lt;
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Http" scheme="http://www.sguotao.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>【转】程序员为什么会忧虑自己的未来?</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2017-06-02-%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BF%A7%E8%99%91%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%AA%E6%9D%A5.html"/>
    <id>http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html</id>
    <published>2017-06-02T02:22:08.000Z</published>
    <updated>2017-06-02T10:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。</p>
</blockquote>
<a id="more"></a>
<p>文章作者:陈驰远，青橙科技CTO，互联网行业的一名老兵，以下是部分摘录。更多讨论，请戳原文。<br>原文链接:<a href="https://juejin.im/post/5930acd6a0bb9f0058af41e5" target="_blank" rel="external">https://juejin.im/post/5930acd6a0bb9f0058af41e5</a></p>
<p>从去年开始，我参加了一些分享交流，也对外发过一些自己对工作所遇问题的思考。不少程序员加我好友咨询问题，几乎每个人问的问题都跟职业规划有关。这提醒了我，其实我自己也一直在思考同样的问题并尝试规划未来。于是想和大家分享一下自己在这方面的感悟。</p>
<p>本文仅从我自己的角度来剖析对程序员职业规划的看法，并不全面。而下文中提到的程序员群体也泛指在一线具体执行编码任务的程序员，不包含一些高精尖技术岗位的专业技术人才或是已经有自己明确职业规划，已经进阶成功的工程师。</p>
<h2 id="什么引发了焦虑？"><a href="#什么引发了焦虑？" class="headerlink" title="什么引发了焦虑？"></a>什么引发了焦虑？</h2><p>互联网是一个新兴但高速发展的行业。新兴意味着没有那么多的职场楷模给新人指明方向，也没有一套公认的稳定可复制的职业发展路线。高速发展意味着变革与竞争，大量新人因为行业红利涌入，你无时无刻要跟一群优秀的热血青年同场竞技。</p>
<p>互联网行业工作强度很大，而中国的互联网从业者更忙。程序员更是战场中的排头兵，身体健康的透支导致很难长期抗战。当你意识到自己跟不上节奏的时候，不管是出于对身体状况的担忧，还是对未来潜在威胁的恐惧，又怎会不感到焦虑呢？而程序员的职业特性加剧了这种焦虑，主要表现在以下几方面：</p>
<h2 id="程序员职业复利性较低。"><a href="#程序员职业复利性较低。" class="headerlink" title="程序员职业复利性较低。"></a>程序员职业复利性较低。</h2><h3 id="什么叫复利性？"><a href="#什么叫复利性？" class="headerlink" title="什么叫复利性？"></a>什么叫复利性？</h3><p>就如同利息的计算方法一样，在本金相同的情况下，复利获得的利息回报要高于单利，而年期越长，复利效应越高。职业一样有复利效应，一个复利高的职业在职业生涯中后期会展现出越来越高的价值。医生、律师都是复利性很高的职业。而程序员职业复利性较低，主要有两个原因：</p>
<ul>
<li><strong>专业性强，通用性差。不同技术种类有着自己的技术栈，共用的只有设计思想、编程范式，基础技术等通用知识。</strong></li>
<li><strong>在没有明确规划的情况下，大多数程序员日常工作积累的不是通用知识与综合能力，而仅仅是某项技术的熟练度与经验。这是根本原因。</strong><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170602149637117527702.jpg" title="后端技术栈">
<img src="http://7u2np3.com1.z0.glb.clouddn.com/20170602149637119625879.jpg" title="前端技术栈">
这造成了一个问题——当职业生涯遇到瓶颈时，程序员很难完成一次完美的进阶。让我们分析下最常见的三类方案：</li>
</ul>
<ol>
<li><p><strong>技术职位之间的转岗。</strong>这是最普遍的一种情况，Android转IOS，后端转前端等都在此列。虽然设计原则、编程范式等技术知识是通用的，但作为一线的执行者，技术的熟练度才是影响你工作效率的最大因素，你必须对技术栈非常熟悉才能体现工作的专业度。 转岗往往是无奈之举。</p>
</li>
<li><p><strong>技术转产品/运营岗。</strong>很多工程师抱怨产品经理设计的产品有问题，逻辑不严密，用起来很别扭。但让工程师做产品，问题一般会更多。为什么呢？最大的原因在于程序员的思维模式或多或少会受到编程的影响，偏向理性与具象化，缺少了感性的察言观色以及换位思考的能力。设计好一个产品，逻辑严密只是条件之一，但并不是最重要的条件。产品经理需要从用户的行为中挖掘出用户真正的需求，提炼归纳并设计成一个可用的产品。这是大多数程序员很难做好的事情。</p>
</li>
<li><p><strong>技术转管理岗。</strong>BAT都有自己的M岗位，高工都可以选择是继续走技术路线还是尝试走管理路线。很多程序员安慰自己，哪天真写不动代码了，那我就做技术经理吧。但我认为管理岗的转变比前面两类都难。管理是一门很深的学问，执行和管理是两回事，需要从根本上改变思维模式。评判一个工程师的好坏可以看工程师的产出，而评判一个管理者的好坏在于整个团队的产出和效率。很多优秀的程序员自己技术能力很强，却很难带领整个团体一起向前进。</p>
</li>
</ol>
<h2 id="程序员职业的壁垒没想象中高，鲁棒性低。"><a href="#程序员职业的壁垒没想象中高，鲁棒性低。" class="headerlink" title="程序员职业的壁垒没想象中高，鲁棒性低。"></a>程序员职业的壁垒没想象中高，鲁棒性低。</h2><p>鲁棒性也指抗变换性，一个好的职业需要有高的鲁棒性。大部分程序员把自己的职业与某项技能绑定。做过编程的都知道，一个高耦合低抽象的编码鲁棒性一定低。互联网行业变化太快，回头看下诺基亚的发展，Windows桌面应用开发，整个行业如同大浪淘沙。随着云平台的崛起，公有化平台的发展，API服务的开放，可以预见从业者的工作效率会大幅提高，同时很多职业可能会再次洗牌：基础运维工程师，DBA，基础算法工程师，安全工程师，图像算法工程师，数据工程师等等都在此列。</p>
<p>从另外一个角度来说，假设你运气很好，选择了一项长期热门的技术比如Web前端开发。但是因为行业红利太高，无数聪明、努力、上进的热血青年涌入其中。随着社区的发展，在线教育的普及，达到同样熟练度的时间越来越短，而热门互联网技术的发展是以月计，你需要花费大量的时间去学习积累新技术。新人与你的差距会越来越小，你会随时面临被超车的局面。这意味着，很多时候即使你认为自己经验更丰富，能力更强，但你却得不到理想的职位及薪资待遇。</p>
<h2 id="程序员职业能撬动的价值有限。"><a href="#程序员职业能撬动的价值有限。" class="headerlink" title="程序员职业能撬动的价值有限。"></a>程序员职业能撬动的价值有限。</h2><p>这个概念受启发于《格鲁夫给经理人的第一课》一书。格鲁夫试图定量的分析经理人的产出，于是提出了一个公式：经理人的产出 = 他直接管辖部门的产出 + 他间接影响所及部门的产出。为了定量的分析职业的价值，我也引入了一个公式：产出的价值 = 他自身的产出 + 他直接影响部门的产出 + 他间接影响所及部门的产出</p>
<p><strong>职业能影响的人越多，创造的价值越高，职业的上限价值也越高。</strong></p>
<p>互联网行业的供求关系以及价值体系，造成了一个现象：程序员供不应求使其入行薪资高，但是工作五年以上薪资趋向于稳定。对于绝大部分公司的绝大部分职位，当熟练度和经验达到某一个阈值的时候，选择成本是趋同的，自身效率提高所能带动的价值提高已经很有限。正因为如此，从业者在享受了薪资高速增长之后，很难接受薪资增幅趋缓，职业生涯遇到瓶颈引发焦虑。</p>
<img src="http://7u2np3.com1.z0.glb.clouddn.com/2017060214963712208098.jpg" title="[薪资待遇]">
<h2 id="我的规划是什么？"><a href="#我的规划是什么？" class="headerlink" title="我的规划是什么？"></a>我的规划是什么？</h2><p>分析了这么多，我最想表达的意思是：所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。</p>
<p>首先我会分析自己的特点，这是建立与他人的差异性和自己独特标签的关键所在，也是最值得加强的地方。我最大的特点是什么？<br><strong>有野心。</strong>我不想选择一种得过且过的生活，而会选择一个产出价值更高的事情来做，影响更多的人，创造更高的价值。<br><strong>会沟通。</strong>我沟通能力不错，既可以对外谈合作，又可以对内做管理。这会是我相对一般技术型程序员一个很大的不同。<br><strong>专业强。</strong>在专业技能层面我有较深的认识与理解，虽然谈不上顶尖，但我知道怎么运用自己的知识能力找到最适合现状的方法解决几乎所有日常问题。技术积累永远是我最核心的竞争力。</p>
<p>知道自己特点之后，我会以此为基础来增强自己的不可替代性。不可替代性不仅仅只是基于个人的能力，还有这几点是需要日常注意积累的：<br><strong>健康的身体。</strong>在经历过一次生病后，我更加意识到拥有一个健康的身体才是最重要的。积极健身可是我们青橙员工的必备素质。<br><strong>思想与格局的高度。</strong>思想的高度并不是一朝一夕就能拔高的，而是在经历了来自工作与生活的各种挑战之后，静下心来反思总结，从而慢慢积累并提升。<br><strong>人脉与影响力。</strong>乐于记录和分享自己的工作感悟。抓住向其他人学习的机会，比如参加一些会议或交流，不管是同行业还是其他行业的，都是很有必要的。人脉和影响力的积累与格局的高度也是相辅相成的，与某些方面比自己优秀的人交流往往会收获满满。<br><strong>当我有了明确的方向并且每天都能看到自己进步的时候，就会对未来充满憧憬。</strong>我给自己未来的定位是做一名解决者。何谓解决者？面对未知或已知的问题，知道如何分析本质原因，制定并实施解决方案。附加打油诗一首：</p>
<blockquote>
<p>文能设计定需求，武可写码做架构。<br>进做招商引融资，退做大V占风口。<br>产品体验包上线，还要招人带节奏。</p>
</blockquote>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html">http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【RN笔记】ReactNative Flex整理</title>
    <link href="http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html"/>
    <id>http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html</id>
    <published>2017-05-17T02:27:04.000Z</published>
    <updated>2017-06-08T10:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex容器属性</h2><ul>
<li><p><strong>flex-direction 属性决定主轴的方向（即项目的排列方向）。</strong></p>
<pre><code>row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。
</code></pre></li>
<li><p><strong>flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</strong></p>
<pre><code>nowrap（默认）：不换行。
wrap：换行，第一行在上方。
wrap-reverse：换行，第一行在下方。
</code></pre></li>
<li><p><strong>flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</strong></p>
</li>
<li><p><strong>justify-content 属性定义了项目在主轴上的对齐方式。</strong></p>
<pre><code>flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，项目之间的间隔都相等。
space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
</code></pre></li>
<li><p><strong>align-items 属性定义项目在交叉轴上如何对齐。</strong></p>
<pre><code>flex-start：交叉轴的起点对齐。
flex-end：交叉轴的终点对齐。
center：交叉轴的中点对齐。
baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
</code></pre></li>
<li><p><strong>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</strong></p>
<pre><code>flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。
</code></pre></li>
</ul>
<h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h2><ul>
<li><p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
</li>
<li><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
</li>
<li><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
</li>
<li><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
</li>
<li><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
</li>
<li><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
</li>
</ul>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html">http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flex容器属性&quot;&gt;&lt;a href=&quot;#Flex容器属性&quot; class=&quot;headerlink&quot; title=&quot;Flex容器属性&quot;&gt;&lt;/a&gt;Flex容器属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;flex-direction 属性决定主轴的方向（即项目的
    
    </summary>
    
      <category term="ReactNative" scheme="http://www.sguotao.com/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://www.sguotao.com/tags/ReactNative/"/>
    
      <category term="Flex" scheme="http://www.sguotao.com/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】人民的名义</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2017-05-04-%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89.html"/>
    <id>http://www.sguotao.com/读书笔记-2017-05-04-人民的名义.html</id>
    <published>2017-05-04T04:00:00.000Z</published>
    <updated>2017-06-17T12:31:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>车窗外，严酷的冬季让广袤大地褪尽了五彩缤纷，裸露出素朴的本色，宛如卸妆后的母亲。<br>北风凛冽，裹挟着原野上的残草败叶，不时地扑打着路面。<br>然而冷峻的荒漠中，不也孕育着春天的希望吗？<br><a id="more"></a></p>
</blockquote>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017060914970149358704.png" alt="2017060914970149358704.png"><br>酣畅淋漓的读完了整本书，热播的电视剧也进入了收官，如何评价书中的人物？我想，不同的人，会因为个人经历的不同，看问题的角度不同，人生观、世界观和价值观不同，对同一个人物，会做出完全不同的评价。</p>
<blockquote>
<p>摘自公众号：闲人笔潭</p>
</blockquote>
<p>这部剧播出至今，不仅收视率火热，关于剧情、人物的讨论更是一浪高过一浪。而且有意思的地方在于，舆论的反转。</p>
<p>正义精明的检察官变成了何不食肉糜的既得利益者；<br>祁同伟从一个腐败官员变成了一个“寒门难出贵子”的悲情人物；<br>达康书记从一个有能力有抱负的政治家变成了伪君子。<br>而与之相对应的，是孙连城、高育良、沙瑞金甚至陈岩石评价的反转。</p>
<p>公众话题的有趣之处就在于：<strong>面对同一个问题，不同人会因为个人经历的不同、三观的不同、立场的不同与角度的不同发表出截然不同的评价。</strong></p>
<p>替祁同伟打抱不平，是因为祁同伟的悲情遭遇让诸多还在奋斗以及奋斗失败的人们心生共鸣。甚至不少人反对“阶级固化”更胜于反腐：<strong>腐败损失的是人民的经济利益，阶级固化是近乎堵死了寒门子弟上升的渠道与奋斗的动力。</strong></p>
<p>觉得侯亮平夫妇、陆亦可他们“何不食肉糜”的，也再正常不过。这个世界确实是分层的，但在你心里，可以不分。可钟小艾一句“摆得正自己的位置”，不知让多少人感受到了这种分层，以及优越感。</p>
<p>觉得李达康横行霸道的，是因为谁都不愿意身边有个这样一个聪明、有能力却“不粘锅”的人，“先生如万年青草，可以傲霜雪而不可充栋梁”大家都知道这个人好，但都想离他远点。</p>
<p>而大家讨论着，甚至吵得面红耳赤，当真是为了这么几个角色么？<strong>其实大多都是在讲自己的价值观，寻求价值认同啊</strong>。</p>
<p>价值观源自于出身、经历、读书思考，是每个人自身的精神之源，这样的动力才让我们每一个人都在为自己深有感触的地方发声。我们理解某些悲剧的时候也在潜意识的担心这些悲剧会不会在自己身上上演，我们控诉某些不公的时候更加感触得到这些不公就在自己的生活中，讨论的是剧情，共鸣的是每个人的经历。所以窃以为，大家最关注的、最感同身受的问题，恐怕也是当下社会存在的最显著的问题。</p>
<p>没错，就是阶级固化。中国是一个伪装成世界的国家，沿海是高楼大厦的现代社会，西部是还在等待扶贫的山区；南部的商业意识已发展数十年，深入人心，东北的人情关系更世代未变，根深蒂固；北上广的孩子们在排歌剧话剧的时候河南河北的学生还在“只要学不死，就往死里学”的标语下挑灯夜读。虽然在同一片土地上，却是不同的世界。</p>
<p>阶级固化所给人带来的就是像祁同伟那样“品学兼优的学生会主席，主动参加缉毒，身中三枪的英雄也被权力任意支配”的恐惧与无力感；还有钟小艾的“只要再努力一下就好了”的“何不食肉糜”般的轻描淡写。但是更会有人认为贪腐了就是贪腐了，没有任何贪腐的理由。这种撕裂的观点可能就是大家不同的经历：有些人苦于成才无门，有些人则受难于贪官污吏，正是这些不同的角度才有了前些天对“达康书记”的赞誉与这些天对“祁厅长”遭遇的同情，以及对这部剧的各种评判。</p>
<p>祁同伟是一个可惜可叹的悲剧，其实剧中哪一位有血有肉的人物不是呢？农民出身一分钱不敢花的赵德汉、善于谋划学识渊博的教授书记高育良、爷爷闹革命出身能熟练背出《共产党宣言》的刘新建。他们都曾拼搏奋斗，也都有了一般人很难拥有的学识、能力，他们最终也都贪污腐化了。有个人的原因，也有制度的原因。</p>
<p>想起几年前的“民国热”，当时还在热心科普民国的种种“真相”，想让向往民国的朋友们知道那是一个路有冻死骨的乱世，可应者渺渺。后来才被一句话点醒：“除了年轻学生，谁会真想去民国，连个手机都没有，只不过都是对现实有些不满罢了。”就如同文艺复兴从来就不是想回到希腊。</p>
<p>评《人民的名义》也不是真的想过天下大同，每个人都是圣人。<strong>这些激烈争吵，只是希望我们的价值观能得到更多的认同，希望社会能往更好的一点发展。当人们“一切向钱看”，而没有了价值信仰和精神寄托时，社会的稳定与繁荣就很难持续。当收入不高和升迁无望的政府官员面对诱惑而没有抵抗力时，就很难指望可以一劳永逸地使干部队伍保持廉洁。当某地的政治平衡和权力格局需要借助外力才能打破时，该地政治生态系统的自我修复功能就值得警惕。讨论《人民的名义》时，大概讨论的，可能都是自己的人生吧。</strong></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2017-05-04-人民的名义.html">http://www.sguotao.com/读书笔记-2017-05-04-人民的名义.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;车窗外，严酷的冬季让广袤大地褪尽了五彩缤纷，裸露出素朴的本色，宛如卸妆后的母亲。&lt;br&gt;北风凛冽，裹挟着原野上的残草败叶，不时地扑打着路面。&lt;br&gt;然而冷峻的荒漠中，不也孕育着春天的希望吗？&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="人民的名义" scheme="http://www.sguotao.com/tags/%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的Property Animation</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-05-20-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Property-Animation.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-05-20-分析Android中的Property-Animation.html</id>
    <published>2017-05-02T02:27:04.000Z</published>
    <updated>2017-07-13T10:04:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。<br><a href="/Android进阶-2016-05-18-android-view-animation.html">Android动画分析一 View Animation</a><br><a href="/Android进阶-2016-05-19-android-drawable-animation.html">Android动画分析二 Drawable Animation</a><br>在这一篇中，将对Android3.0之后出现的属性动画(Property Animation)进行整理。既然已经有了View Animation和Drawable Animation了，为什么还要引入Property Animation呢？</p>
<blockquote>
<p>1.使用动画场景的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么View动画就不能再帮我们忙了，也就是说View动画在功能和可扩展方面都有相当大的局限性。</p>
<p>2.Property Animation是改变对象的属性，不仅仅是对view本身做操作。传统的View动画只是改变view的显示效果，并不改变view的属性。郭霖介绍了一个比较形象的例子🌰，比如说，现在屏幕的左上角有一个按钮，然后我们通过View动画将它移动到了屏幕的右下角，点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过View动画将这个按钮绘制到了屏幕的右下角而已。属性动画的实现机制是通过对目标对象进行赋值并修改其属性来实现的，那么之前所说的按钮显示的问题也就不复存在了，如果我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。</p>
</blockquote>
<h2 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h2><p>Property Animation是Android3.0(API11)之后引入的动画，属性动画的引入，极大的地丰富了Android的动画体系，与传统的View动画和Drawable动画还是存在一些差别，在使用的过程中需要留意：</p>
<p>1.传统动画的xml文件存放在res/anim/目录下，而属性动画的xml文件存放在res/animator/目录下，虽然animator有着anim的前缀，但这是两个完全不同的目录。由于存放目录的不同，因此在代码中引用的方式也会有所差别，传统动画可以通过R.anim.filename获得动画的引用，属性通过则通过R.animator.filename获得动画的引用。</p>
<p>2.属性动画常用的Java类与传统动画Java类很相似，比如属性动画集AnimatorSet和传统动画集AnimationSet，在使用时注意区别，可以简化记忆“后缀是mator的是属性动画，后缀是mation的是传统动画”。属性动画中，常用的类，可以简单的用下面的类图进行概括。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170607149683875928772.png" alt="20170607149683875928772.png"><br>属性动画也支持xml标签的使用方式，Android API提供了三种类型的标签，分别是&lt;animator&gt;、&lt;objectAnimator&gt;、&lt;set&gt;每个标签都有对应的Java实现类。</p>
<h3 id="lt-animator-gt-ValueAnimator"><a href="#lt-animator-gt-ValueAnimator" class="headerlink" title="&lt;animator&gt;-ValueAnimator"></a>&lt;animator&gt;-ValueAnimator</h3><blockquote>
<p>ValueAnimator是整个属性动画机制当中最核心的一个类，属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，通过Handler来完成动画的绘制以确保属性的变化发生在UI线程，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。</p>
</blockquote>
<p>&lt;animator&gt;标签对应的Java实现类正是ValueAnimator类，&lt;animator&gt;包括以下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:duration</td>
<td style="text-align:center">动画从开始到结束持续的时长，单位为毫秒</td>
</tr>
<tr>
<td style="text-align:center">android:startOffset</td>
<td style="text-align:center">设置动画执行之前的等待时长，单位为毫秒</td>
</tr>
<tr>
<td style="text-align:center">android:repeatCount</td>
<td style="text-align:center">设置动画重复执行的次数，默认为0，不重复；可设为-1或infinite，表示无限重复</td>
</tr>
<tr>
<td style="text-align:center">android:repeatMode</td>
<td style="text-align:center">设置动画重复执行的模式，RESTART(默认值) 动画重复执行时从起点开始，REVERSE动画会反方向执行</td>
</tr>
<tr>
<td style="text-align:center">android:interpolator</td>
<td style="text-align:center">设置动画的插值器,若不设置，默认使用 AccelerateDecelerateInterpolator</td>
</tr>
<tr>
<td style="text-align:center">android:valueFrom</td>
<td style="text-align:center">动画开始的值，可以为int值、float值或color值</td>
</tr>
<tr>
<td style="text-align:center">android:valueTo</td>
<td style="text-align:center">动画结束的值，可以为int值、float值或color值</td>
</tr>
<tr>
<td style="text-align:center">android:valueType</td>
<td style="text-align:center">动画值类型，floatType(默认值) 指定动画值，即以上两个value属性的值为浮点型,intType 指定动画值，即以上两个value属性的值为整型,若为color值，则无需设置该属性</td>
</tr>
</tbody>
</table>
<p>同样的，属性动画也支持代码和资源文件两种创建方式。当使用资源文件时，需要通过AnimatorInflater中的loadAnimator()方法，将资源文件进行加载，得到Animator对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);  </div><div class="line">animator.setTarget(view);  </div><div class="line">animator.start();</div></pre></td></tr></table></figure></p>
<p>资源文件定义方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;1000&quot;</div><div class="line">    android:valueFrom=&quot;1&quot;</div><div class="line">    android:valueTo=&quot;0&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>代码的实现方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = ValueAnimator.ofFloat(1f, 0f);</div><div class="line">valueAnimator.setDuration(1000);</div><div class="line">valueAnimator.setRepeatCount(1);</div><div class="line">valueAnimator.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">valueAnimator.start();</div></pre></td></tr></table></figure></p>
<h3 id="lt-objectAnimator-gt-ObjectAnimator"><a href="#lt-objectAnimator-gt-ObjectAnimator" class="headerlink" title="&lt;objectAnimator&gt;-ObjectAnimator"></a>&lt;objectAnimator&gt;-ObjectAnimator</h3><blockquote>
<p>&lt;objectAnimator&gt;标签对应的Java实现类是ObjectAnimator，相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。ObjectAnimator是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。</p>
</blockquote>
<p>由于ObjectAnimation继承ValueAnimator，所以&lt;objectAnimator&gt;除了&lt;animator&gt;的属性外，还包括自身特有的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:propertyName</td>
<td style="text-align:center">目标对象的属性名，要求目标对象必须提供该属性的setter方法，如果动画的时候没有初始值，还需要提供getter方法</td>
</tr>
</tbody>
</table>
<p>xml资源文件创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;1000&quot;</div><div class="line">    android:valueTo=&quot;200&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:propertyName=&quot;y&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>代码创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator.ofFloat(view,&quot;alpha&quot;,0f,1f)</div><div class="line">            .setDuration(3000)</div><div class="line">            .start();</div></pre></td></tr></table></figure></p>
<p>ObjectAnimator提供了对View属性的设置，因为采用了反射的方式，所以要求View中要有该属性的setter和getter方法。当然，为了对View更方便的设置属性动画，Android系统也提供了View的一些属性和相应的setter和getter方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">alpha</td>
<td style="text-align:center">透明度，默认为1，表示不透明，0表示完全透明</td>
</tr>
<tr>
<td style="text-align:center">pivotX 和 pivotY</td>
<td style="text-align:center">缩放动画固定点坐标</td>
</tr>
<tr>
<td style="text-align:center">scaleX 和 scaleY</td>
<td style="text-align:center">水平方向和垂直方向的缩放比例</td>
</tr>
<tr>
<td style="text-align:center">rotation、rotationX 和 rotationY</td>
<td style="text-align:center">基于固定点(pivotX,pivotY)做旋转,rotation是旋转度数,rotationX是水平旋转度数,rotationY是竖直旋转度数</td>
</tr>
<tr>
<td style="text-align:center">translationX 和 translationY</td>
<td style="text-align:center">水平方向移动距离和竖直方向移动距离</td>
</tr>
<tr>
<td style="text-align:center">x 和 y</td>
<td style="text-align:center">View在父容器内左上角的坐标</td>
</tr>
</tbody>
</table>
<p>通过对上面这些属性的操作，就可以完成传统View动画实现的效果。上面的示例代码中，实现了对一个属性的修改，如果对多个属性进行修改，该如何操纵呢？<br>PropertyValuesHolder可以实现对一组属性或多组属性的持有，可以同时设置多个属性，通过ofPropertyValuesHolder()方法，设置到对应的动画view上，这样局完成了动画过程中，多个属性的修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PropertyValuesHolder pValue1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f, 1f);</div><div class="line">PropertyValuesHolder pValue2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 0f, 1f);</div><div class="line">PropertyValuesHolder pValue3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 0f, 1f);</div><div class="line">ObjectAnimator.ofPropertyValuesHolder(view, pValue1, pValue2, pValue3).setDuration(3000).start();</div></pre></td></tr></table></figure>
<p>PropertyValuesHolder类提供了多个of开头的方法，以实现不同数据类型属性的设置，其中有一组方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</div><div class="line">public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values)</div><div class="line">static PropertyValuesHolder ofKeyframes(String propertyName, Keyframes keyframes)</div><div class="line">static PropertyValuesHolder ofKeyframes(Property property, Keyframes keyframes)</div></pre></td></tr></table></figure></p>
<p>在这组方法中，用到了Keyframe和Keyframes两个类，那么这两个类是做什么用的？Keyframe，关键帧，该类型对象由一个time/value对组成，定义了指定时间点的指定值。Keyframe是一个抽象类，在该类中定义了三个实现类ObjectKeyframe，IntKeyframe，FloatKeyframe用来保存Object、Int、Float类型的value。Keyframes是一个接口，KeyframeSet是它的实现类，KeyframeSet可以认为是关键帧Keyframe的辅助类，在KeyframeSet中维护着一个Keyframe类型的list。在API 23以后，可以在xml文件中使用PropertyValuesHolder。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">                android:duration=&quot;1000&quot;</div><div class="line">                android:repeatCount=&quot;1&quot;</div><div class="line">                android:repeatMode=&quot;reverse&quot;&gt;</div><div class="line">    &lt;propertyValuesHolder android:propertyName=&quot;x&quot; android:valueTo=&quot;400&quot;/&gt;</div><div class="line">    &lt;propertyValuesHolder android:propertyName=&quot;y&quot; android:valueTo=&quot;200&quot;/&gt;</div><div class="line">&lt;/objectAnimator&gt;</div></pre></td></tr></table></figure></p>
<p>在API16(Android4.1)中，新添加了TimeAnimator类，这个类它并不能直接实现动画效果，这个类有一个TimeListener接口，TimeListener会返回动画持续的时间，与上次调用的间隔时间。</p>
<h3 id="lt-set-gt-AnimatorSet"><a href="#lt-set-gt-AnimatorSet" class="headerlink" title="&lt;set&gt;-AnimatorSet"></a>&lt;set&gt;-AnimatorSet</h3><p>属性动画也可以实现多个动画的组合效果，对应AnimatorSet类。由于&lt;set&gt;实现动画组合的标签，所以它有一个设定动画顺序的属性:</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:ordering</td>
<td style="text-align:center">设置动画的时序关系，together(默认值) 动画同时执行，sequentially 动画按顺序执行</td>
</tr>
</tbody>
</table>
<p>当使用组合动画时，既有同时执行，又有顺序执行时，可以通过&lt;set&gt;标签的嵌套来实现。<br>在AnimatorSet内部中定义了一个Builder类，下面几个方法的返回类型都是该Builder类，这样我们在使用这几个方法设定多个动画播放顺序的时候，可以直接通过链式的方式，简化代码，这几个比较常用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 将现有动画插入到传入的动画之后执行</div><div class="line">    * @param anim</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public AnimatorSet.Builder after(Animator anim)</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 将现有动画延迟指定毫秒后执行</div><div class="line">    * @param delay</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public AnimatorSet.Builder after(long delay)</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 将现有动画插入到传入的动画之前执行</div><div class="line">    * @param anim</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public AnimatorSet.Builder before(Animator anim)</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 将现有动画和传入的动画同时执行</div><div class="line">    * @param anim</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public AnimatorSet.Builder with(Animator anim)</div></pre></td></tr></table></figure></p>
<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>属性动画也提供了一下监听器Listener，实现对属性动画状态的监测，通过回调方法实现业务逻辑。在Animator类中定义了两个接口，分别是AnimatorListener和AnimatorPauseListener，使用时通过addListener()和addPauseListener()进行监听器的添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">valueAnimator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                //动画开始时调用</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;</div><div class="line">                //动画结束时调用</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;</div><div class="line">                //动画被取消时调用</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                //动画重复执行时调用</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>由于Animator是ValueAnimator的父类，ObjectAnimator又继承ValueAnimator，因此ValueAnimator和ObjectAnimator都可以对这两个监听器进行添加。注意的是AnimatorPauseListener需要API Level 19。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">valueAnimator.addPauseListener(new Animator.AnimatorPauseListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationPause(Animator animation) &#123;</div><div class="line">                //动画暂停时调用</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAnimationResume(Animator animation) &#123;</div><div class="line">                //动画恢复时调用</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>系统提供了AnimatorListenerAdapter抽象类实现了这两个接口，这样只需要重写需要的方法，而不必每个方法都重写了。在ValueAnimator中还添加接口AnimatorUpdateListener，可以实现对动画更新操作的监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                // 动画更新时调用</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><blockquote>
<p>在API17(Android3.1)中引入，属性动画的机制已经不是再针对于View而进行设计的了，而是一种不断地对值进行操作的机制，它可以将值赋值到指定对象的指定属性上。但是，在绝大多数情况下，我相信大家主要都还是对View进行动画操作的。Android开发团队也是意识到了这一点，没有为View的动画操作提供一种更加便捷的用法确实是有点太不人性化了，于是在Android 3.1系统当中补充了ViewPropertyAnimator这个机制。</p>
<ol>
<li>整个ViewPropertyAnimator的功能都是建立在View类新增的animate()方法之上的，这个方法会创建并返回一个ViewPropertyAnimator的实例，之后的调用的所有方法，设置的所有属性都是通过这个实例完成的。</li>
<li>大家注意到，在使用ViewPropertyAnimator时，我们自始至终没有调用过start()方法，这是因为新的接口中使用了隐式启动动画的功能，只要我们将动画定义完成之后，动画就会自动启动。并且这个机制对于组合动画也同样有效，只要我们不断地连缀新的方法，那么动画就不会立刻执行，等到所有在ViewPropertyAnimator上设置的方法都执行完毕后，动画就会自动启动。当然如果不想使用这一默认机制的话，我们也可以显式地调用start()方法来启动动画。</li>
<li>ViewPropertyAnimator的所有接口都是使用连缀的语法来设计的，每个方法的返回值都是它自身的实例，因此调用完一个方法之后可以直接连缀调用它的另一个方法，这样把所有的功能都串接起来，我们甚至可以仅通过一行代码就完成任意复杂度的动画功能。</li>
</ol>
</blockquote>
<h3 id="TypeEvaluator-估值器"><a href="#TypeEvaluator-估值器" class="headerlink" title="TypeEvaluator(估值器)"></a>TypeEvaluator(估值器)</h3><blockquote>
<p>简单来说，就是告诉动画系统如何从初始值过度到结束值。与Interpolator区别是，Interpolator主要是用来控制动画的播放速率。</p>
</blockquote>
<p>在TypeEvaluator接口中定义了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public T evaluate(float fraction, T startValue, T endValue);</div></pre></td></tr></table></figure></p>
<p>evaluate()方法当中传入了三个参数，第一个参数fraction用于表示动画的完成度，我们应该根据它来计算当前动画的值应该是多少，第二第三个参数分别表示动画的初始值和结束值。系统提供了7个实现类方便我们使用，分别是ArgbEvaluator、FloatArrayEvaluator、FloatEvaluator、IntArrayEvaluator、IntEvaluator、PointFEvaluator和RectEvaluator。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="external">Property Animation</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43536355" target="_blank" rel="external">Android属性动画完全解析(上)，初识属性动画的基本用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43816093" target="_blank" rel="external">Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/44171115" target="_blank" rel="external">Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-05-20-分析Android中的Property-Animation.html">http://www.sguotao.com/Android进阶-2016-05-20-分析Android中的Property-Animation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。&lt;br&gt;&lt;a href=&quot;/Android进阶-2016-05-18-android-vi
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="动画" scheme="http://www.sguotao.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="代码库" scheme="http://www.sguotao.com/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【RN笔记】ReactNative样式整理</title>
    <link href="http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html"/>
    <id>http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html</id>
    <published>2017-03-24T02:27:04.000Z</published>
    <updated>2017-07-13T10:13:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。</p>
<h2 id="引入样式的几种方法"><a href="#引入样式的几种方法" class="headerlink" title="引入样式的几种方法"></a>引入样式的几种方法</h2><p>常见的引用样式的几种方法，包括内嵌方式，外联方式和混合方式，还可以把样式定义在单独的文件中，通过import引用。</p>
<h3 id="1-内嵌方式"><a href="#1-内嵌方式" class="headerlink" title="1. 内嵌方式"></a>1. 内嵌方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">export default class appProject extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;</div><div class="line">                &#123;</div><div class="line">                marginTop:200,</div><div class="line">                marginLeft:5,</div><div class="line">                marginRight:5,</div><div class="line">                height:84,</div><div class="line">                flexDirection:&apos;row&apos;,</div><div class="line">                backgroundColor:&apos;#FF0067&apos;,</div><div class="line">                &#125;</div><div class="line">                &#125;&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-外联方式"><a href="#2-外联方式" class="headerlink" title="2. 外联方式"></a>2. 外联方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const Styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        marginTop:200,</div><div class="line">        marginLeft:5,</div><div class="line">        marginRight:5,</div><div class="line">        height:84,</div><div class="line">        flexDirection:&apos;row&apos;,</div><div class="line">        backgroundColor:&apos;#FF0067&apos;,</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="3-混合方式"><a href="#3-混合方式" class="headerlink" title="3. 混合方式"></a>3. 混合方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">export default class appProject extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            //外层容器</div><div class="line">            &lt;View style=&#123;[Styles.container,Styles.bg,&#123;color:&apos;red&apos;&#125;]&#125;&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-import引用"><a href="#4-import引用" class="headerlink" title="4.import引用"></a>4.import引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;</div><div class="line">import &#123;</div><div class="line">    StyleSheet,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        marginTop:200,</div><div class="line">        marginLeft:5,</div><div class="line">        marginRight:5,</div><div class="line">        height:84,</div><div class="line">        flexDirection:&apos;row&apos;,</div><div class="line">    &#125;,</div><div class="line">    bg:&#123;</div><div class="line">        backgroundColor:&apos;#FF0067&apos;,</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">module.exports = styles;</div></pre></td></tr></table></figure>
<p>通过import进行引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import styles from &apos;./styles/style&apos;;</div></pre></td></tr></table></figure></p>
<h2 id="常见的属性及说明"><a href="#常见的属性及说明" class="headerlink" title="常见的属性及说明"></a>常见的属性及说明</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">backgroundColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 background-color 属性</td>
</tr>
</tbody>
</table>
<h3 id="2-宽高尺寸"><a href="#2-宽高尺寸" class="headerlink" title="2.宽高尺寸"></a>2.宽高尺寸</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">width</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 width 属性</td>
</tr>
<tr>
<td style="text-align:center">height</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 height 属性</td>
</tr>
</tbody>
</table>
<h3 id="3-外边距相关-margin"><a href="#3-外边距相关-margin" class="headerlink" title="3.外边距相关(margin)"></a>3.外边距相关(margin)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">margin</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白</td>
</tr>
<tr>
<td style="text-align:center">marginHorizontal</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置marginRight和marginLeft</td>
</tr>
<tr>
<td style="text-align:center">marginVertical</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置marginTop和marginBottom</td>
</tr>
<tr>
<td style="text-align:center">marginTop</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-top 属性</td>
</tr>
<tr>
<td style="text-align:center">marginRight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-right 属性</td>
</tr>
<tr>
<td style="text-align:center">marginBottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">marginLeft</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-left 属性</td>
</tr>
</tbody>
</table>
<h3 id="4-内边距相关-padding"><a href="#4-内边距相关-padding" class="headerlink" title="4.内边距相关(padding)"></a>4.内边距相关(padding)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">padding</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白</td>
</tr>
<tr>
<td style="text-align:center">paddingHorizontal</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft</td>
</tr>
<tr>
<td style="text-align:center">paddingVertical</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom</td>
</tr>
<tr>
<td style="text-align:center">paddingTop</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-top 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingRight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-right 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingBottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingLeft</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-left 属性</td>
</tr>
</tbody>
</table>
<h3 id="5-边框相关-border"><a href="#5-边框相关-border" class="headerlink" title="5.边框相关(border)"></a>5.边框相关(border)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">borderStyle</td>
<td style="text-align:center">solid, dotted, dashed</td>
<td style="text-align:center">对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性</td>
</tr>
<tr>
<td style="text-align:center">borderWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRightWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-right-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderLeftWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-left-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-top-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRightColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-right-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderLeftColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-left-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopLeftRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-left-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopRightRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-right-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomLeftRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-left-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomRightRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-right-radius 属性</td>
</tr>
</tbody>
</table>
<h3 id="6-位置相关-position"><a href="#6-位置相关-position" class="headerlink" title="6.位置相关(position)"></a>6.位置相关(position)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">position</td>
<td style="text-align:center">absolute, relative</td>
<td style="text-align:center">对应 CSS 中的 position 属性，但阉割了 static, fixed 取值</td>
</tr>
<tr>
<td style="text-align:center">top</td>
<td style="text-align:center">number&gt;</td>
<td style="text-align:center">对应 CSS 中的 top 属性</td>
</tr>
<tr>
<td style="text-align:center">right</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 right 属性</td>
</tr>
<tr>
<td style="text-align:center">bottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">left</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 left 属性</td>
</tr>
</tbody>
</table>
<h3 id="7-文本相关-Text"><a href="#7-文本相关-Text" class="headerlink" title="7.文本相关(Text)"></a>7.文本相关(Text)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 color 属性</td>
</tr>
<tr>
<td style="text-align:center">fontFamily</td>
<td style="text-align:center">string</td>
<td style="text-align:center">对应 CSS 中的 font-family 属性</td>
</tr>
<tr>
<td style="text-align:center">fontSize</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 font-size 属性</td>
</tr>
<tr>
<td style="text-align:center">fontStyle</td>
<td style="text-align:center">normal, italic</td>
<td style="text-align:center">对应 CSS 中的 font-style 属性，但阉割了 oblique 取值</td>
</tr>
<tr>
<td style="text-align:center">fontWeight</td>
<td style="text-align:center">normal, bold 100~900</td>
<td style="text-align:center">对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值</td>
</tr>
<tr>
<td style="text-align:center">lineHeight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 line-height 属性</td>
</tr>
<tr>
<td style="text-align:center">textAlign</td>
<td style="text-align:center">auto, left, right, center, justifyiOS</td>
<td style="text-align:center">对应 CSS 中的 text-align 属性，增加了 auto 取值</td>
</tr>
<tr>
<td style="text-align:center">textAlignVertical<sup>Android</sup></td>
<td style="text-align:center">auto, top, bottom, center</td>
<td style="text-align:center">对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub 等值</td>
</tr>
<tr>
<td style="text-align:center">textShadowColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 text-shadow 属性中的颜色定义</td>
</tr>
<tr>
<td style="text-align:center">textShadowOffset</td>
<td style="text-align:center">{width: number, height: number}</td>
<td style="text-align:center">对应 CSS 中的 text-shadow 属性中的阴影偏移定义</td>
</tr>
<tr>
<td style="text-align:center">textShadowRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义</td>
</tr>
<tr>
<td style="text-align:center">letterSpacing<sup>iOS</sup></td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 letter-spacing 属性，但取值不同</td>
</tr>
<tr>
<td style="text-align:center">textDecorationColor<sup>iOS</sup></td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-color 属性</td>
</tr>
<tr>
<td style="text-align:center">textDecorationLine<sup>iOS</sup></td>
<td style="text-align:center">none, underline, line-through, underline line-through</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值</td>
</tr>
<tr>
<td style="text-align:center">textDecorationStyle<sup>iOS</sup></td>
<td style="text-align:center">solid, double, dotted, dashed</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值</td>
</tr>
<tr>
<td style="text-align:center">writingDirection<sup>iOS</sup></td>
<td style="text-align:center">auto, ltr, rtl</td>
<td style="text-align:center">对应 CSS 中的 direction 属性，增加了 auto 取值</td>
</tr>
</tbody>
</table>
<h3 id="8-弹性布局相关-Flex"><a href="#8-弹性布局相关-Flex" class="headerlink" title="8.弹性布局相关(Flex)"></a>8.弹性布局相关(Flex)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flex</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 flex 属性</td>
</tr>
<tr>
<td style="text-align:center">flexDirection</td>
<td style="text-align:center">row, column</td>
<td style="text-align:center">对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值</td>
</tr>
<tr>
<td style="text-align:center">flexWrap</td>
<td style="text-align:center">wrap, nowrap</td>
<td style="text-align:center">对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值</td>
</tr>
<tr>
<td style="text-align:center">justifyContent</td>
<td style="text-align:center">flex-start, flex-end, center, space-between, space-around</td>
<td style="text-align:center">对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。</td>
</tr>
<tr>
<td style="text-align:center">alignItems</td>
<td style="text-align:center">flex-start, flex-end, center, stretch</td>
<td style="text-align:center">对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。</td>
</tr>
<tr>
<td style="text-align:center">alignSelf</td>
<td style="text-align:center">auto, flex-start, flex-end, center, stretch</td>
<td style="text-align:center">对应 CSS 中的 align-self 属性，但阉割了 baseline 取值</td>
</tr>
</tbody>
</table>
<h3 id="9-转换相关-transform"><a href="#9-转换相关-transform" class="headerlink" title="9.转换相关(transform)"></a>9.转换相关(transform)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">transform</td>
<td style="text-align:center">[{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}]</td>
<td style="text-align:center">对应 CSS 中的 transform 属性</td>
</tr>
<tr>
<td style="text-align:center">transformMatrix</td>
<td style="text-align:center">TransformMatrixPropType</td>
<td style="text-align:center">类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数</td>
</tr>
<tr>
<td style="text-align:center">backfaceVisibility</td>
<td style="text-align:center">visible, hidden</td>
<td style="text-align:center">对应 CSS 中的 backface-visibility 属性</td>
</tr>
</tbody>
</table>
<h3 id="10-图片相关"><a href="#10-图片相关" class="headerlink" title="10.图片相关"></a>10.图片相关</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">resizeMode</td>
<td style="text-align:center">cover, contain, stretch</td>
<td style="text-align:center">contain是指无论如何图片都包含在指定区域内，假设设置的宽度高度比图片大，则图片居中显示，否则，图片等比缩小显示</td>
</tr>
<tr>
<td style="text-align:center">overflow</td>
<td style="text-align:center">visible, hidden</td>
<td style="text-align:center">超出部分是否显示，hidden为隐藏</td>
</tr>
<tr>
<td style="text-align:center">tintColor</td>
<td style="text-align:center">number</td>
<td style="text-align:center">着色，rgb字符串类型</td>
</tr>
<tr>
<td style="text-align:center">opacity</td>
<td style="text-align:center">number</td>
<td style="text-align:center">透明度</td>
</tr>
</tbody>
</table>
<h3 id="11-图像变换"><a href="#11-图像变换" class="headerlink" title="11.图像变换"></a>11.图像变换</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">rotation</td>
<td style="text-align:center">–</td>
<td style="text-align:center">旋转</td>
</tr>
<tr>
<td style="text-align:center">scaleX</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向缩放</td>
</tr>
<tr>
<td style="text-align:center">scaleY</td>
<td style="text-align:center">–</td>
<td style="text-align:center">垂直方向缩放</td>
</tr>
<tr>
<td style="text-align:center">translateX</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向平移</td>
</tr>
<tr>
<td style="text-align:center">translateY</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向平移</td>
</tr>
</tbody>
</table>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html">http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。&lt;/p&gt;
&lt;h2 id=&quot;引入样式的几种方法&quot;&gt;&lt;a href=&quot;#引入样式的几种方法&quot; class=&quot;headerlink&quot; title=&quot;引入样式的几种方法&quot;&gt;&lt;/a&gt;引入样式
    
    </summary>
    
      <category term="ReactNative" scheme="http://www.sguotao.com/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://www.sguotao.com/tags/ReactNative/"/>
    
      <category term="CSS" scheme="http://www.sguotao.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的内存泄露</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2017-03-24-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html"/>
    <id>http://www.sguotao.com/Android进阶-2017-03-24-分析Android中的内存泄露.html</id>
    <published>2017-03-24T02:27:04.000Z</published>
    <updated>2017-07-11T12:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存泄露与内存溢出"><a href="#内存泄露与内存溢出" class="headerlink" title="内存泄露与内存溢出"></a>内存泄露与内存溢出</h2><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露(Memory Leak)是指无用对象（不再使用的对象）持续占有内存，或者无用对象的内存得不到及时释放，从而造成内存空间得不到有效的利用。在Java中，内存泄露的原因，通常是长生命周期的对象，持有短生命周期对象的引用。在《深入理解Java虚拟机》中的解释是，当无用对象一直被有用对象引用，导致无用对象可达，JVM无法对无用对象完成回收。从而造成内存泄露。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170327149058275225194.png" alt="内存泄露"></p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出(Out of Memory)是指程序在运行过程中，无法申请到足够的的内存导致的一种错误。内存泄露是会导致内存溢出，但不是导致内存溢出的唯一原因。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170327149058290012605.png" alt="20170327149058290012605.png"></p>
<h2 id="Java中的内存泄露"><a href="#Java中的内存泄露" class="headerlink" title="Java中的内存泄露"></a>Java中的内存泄露</h2><h3 id="Java-内存分配"><a href="#Java-内存分配" class="headerlink" title="Java 内存分配"></a>Java 内存分配</h3><p>Java中的内存分配主要分三块，静态存储区，栈区和堆区。</p>
<ul>
<li>静态存储区，编译时分配，存在于程序的整个运行期间，主要用于存放静态数据和常量。</li>
<li>栈区，在方法执行时，用于存放方法内部的局部变量，方法结束后，内存释放。</li>
<li>堆区，通常用来存放new出来的对象，由JVM进行回收处理。</li>
</ul>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170329149077275371348.png" alt="20170329149077275371348.png"><br>从JDK1.2开始，Java将对象的引用分为了强引用、软引用、弱引用和虚引用。</p>
<ul>
<li>强引用(Strong Reference),平时使用最多的一种引用，<strong>如果一个对象的引用方式是强引用，垃圾回收器不会对该对象进行回收，即使出现了内存空间不足的情况，JVM会抛出Out of Memory,也不会对强引用的对象进行回收。</strong></li>
<li>软引用(Soft Reference),在对象的引用强度上若于强引用，对于弱引用的对象，<strong>当内存不足时，JVM会回收软引用对象，释放内存空间</strong>。通常情况下，缓存的创建，适合使用软引用的方式。</li>
<li>弱引用(Weak Reference),在对象的引用强度上，弱于软引用，相对于强引用对象的不可回收，弱引用的对象，不存在这种情况，<strong>在垃圾回收器工作时，不论内存空间是否充足，都会对弱引用的对象进行回收。</strong>弱引用的作用，主要在于解决强引用对象之前的耦合关系，如在集合类中，任何Java对象都可以作为键来使用，当一个键值对被放入到集合中，集合对象本身就对这些键和值产生引用，如果是强引用，只要集合对象本身存在，其中包含的键和值就不会被回收，当集合包含的键和值越来越多时，最后会消耗掉JVM中的全部内存。</li>
<li>虚引用(Phantom Reference)，使用的情况并不多见，主要用来实现比较清晰的内存控制，这对于内存有限的移动设备是很有意义的。<strong>虚引用用来跟踪对象被垃圾回收器回收的活动</strong>，虚引用和软引用，弱引用的一个明显的区别是，虚引用必须和引用队列联合使用，通过检查引用队列中的内容，可以判断一个对象是否即将被回收。</li>
</ul>
<p>一个对象的引用类型有多个，怎么判断？<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170329149077630884381.png" alt="20170329149077630884381.png"><br>判定规则如下：</p>
<ul>
<li>单条引用链上的可达性，以最弱的一个引用类型来决定；</li>
<li>多条引用链上的可达性，以最强的一个引用类型来决定；</li>
</ul>
<p>我们假设上图中，1和3为强引用，5为软引用，7为弱引用。对于对象5的引用类型，在路径1–5中，5为软引用类型，依据规则1，对象5为软引用类型。在路径3–7中，7为弱引用类型，所以对象5为弱引用类型。依据规则2，多条引用链上的可达性，以最强的一个引用类型决定，因此，对象5的引用类型为软引用类型。</p>
<h2 id="内存泄露检测工具"><a href="#内存泄露检测工具" class="headerlink" title="内存泄露检测工具"></a>内存泄露检测工具</h2><h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><p>Memory Monitors是AndroidStudio自带的一个性能检测工具，主要包含以下几个功能：</p>
<ul>
<li>实时查看app的内存使用情况；</li>
<li>能够比较直观的了解到app的运行卡顿是否跟GC的频繁操作有关；</li>
<li>能够了解到app的crash是否跟内存溢出有关；</li>
<li>能够发现内存抖动(在短时间内分配大量内存，频繁的引起GC操作)</li>
</ul>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170401149101636441749.png" alt="20170401149101636441749.png"></p>
<h3 id="DDMS-Dump"><a href="#DDMS-Dump" class="headerlink" title="DDMS Dump"></a>DDMS Dump</h3><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017040114910150822979.png" alt="2017040114910150822979.png"><br><strong>什么是Java Heap Dump？</strong>首先需要搞明白什么是Java Heap，Java Heap是分配给实例类和数组对象运行数据区，所有Java线程在运行期间共享heap中的数据，Java Heap Dump相当于在应用运行时，某个时间点进行一次快照，在AndroidStudio中，快照会被保存为.hprof类型的文件，保存在captures目录中。</p>
<p>分析.hprof文件，我们可以将.hprof视图分成A、B、C三个部分，在A部分中，可以看到app的整个堆内存信息，显示了在堆内存中的所有的java类。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Total Count</td>
<td style="text-align:center">内存中，当前Java类的实例数量</td>
</tr>
<tr>
<td style="text-align:center">Heap Count</td>
<td style="text-align:center">堆内存中，当前Java类的实例数量</td>
</tr>
<tr>
<td style="text-align:center">Size of</td>
<td style="text-align:center">当前Java类每个实例对象需要占用内存的物理大小</td>
</tr>
<tr>
<td style="text-align:center">Shallow Size</td>
<td style="text-align:center">当前Java实例对象占有的内存大小</td>
</tr>
<tr>
<td style="text-align:center">Retained Size</td>
<td style="text-align:center">释放当前Java实例对象后，节省的内存大小</td>
</tr>
</tbody>
</table>
<p>当选中A区域中的某个Java类，可以在B区域中看到选中Java类的所有实例对象。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Depth</td>
<td style="text-align:center">当前对象的深度</td>
</tr>
<tr>
<td style="text-align:center">Shallow Size</td>
<td style="text-align:center">当前对象占有的内存大小</td>
</tr>
<tr>
<td style="text-align:center">Dominating Size</td>
<td style="text-align:center">当前对象可支配的内存大小</td>
</tr>
</tbody>
</table>
<p>在B中看到选中Java类的所有实例对象的同时，在C区域能够看到哪些对象引用了该对象。</p>
<p><strong>什么是Allocation Tracker？</strong>Allocation Tracker主要用来追踪内存分配信息，Start Allocation Tracking 相当于在程序运行时，某个时间节点，对内存分配信息进行一次快照，生成的快照文件被保存为.alloc类型，保存在captures目录中。Allocation Tracker 也可以在Devices Monitor中启动，在Devices Monitor中使用时，需要设备有Root权限。</p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT(Eclipse Memory Analyzer)是一个堆转储文件分析工具，在Monitor的快照文件(.hprof)，需要转换成MAT可以打开的标准.hprof文件，使用Mat工具打开转换后的.hprof文件，会生成一个内存消耗整体状况的报告，从饼状图中，可以比较直观地看到哪些对象占用了多少的内存空间。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170419149258510813625.png" alt="20170419149258510813625.png"><br>这里介绍一下，MAT给我们提供的几个分析的维度。</p>
<ul>
<li>Histogram，在该视图中可以清晰的看出内存中对象的数量，及所占用内存空间的大小。</li>
<li>Dominator Tree:在该视图中，可以在线程的角度观察到哪些对象占用内存空间。</li>
<li>Top Consumers:从包，对象等角度，显示内存的占用情况，能够比较直观的找出占用内存比较多的对象。</li>
<li>Leak Suspects:分析内存泄露的情况，生成一份报表，给出一些problem的建议。</li>
</ul>
<p>下面介绍一些常用的操作，视图中支持正则表达式筛选，可以过滤出我们比较关心的对象，可以以列表或者树形的结构显示出来，其中：</p>
<ul>
<li>with incoming references:过滤出那些类引用了当前选中的类；</li>
<li>with outcoming references:过滤出当前选中类引用了哪些类；</li>
</ul>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017042014926559112895.png" alt="2017042014926559112895.png"></p>
<p>垃圾回收器会对虚拟机的内存空间，即堆空间中已经存在的对象进行识别，如果对象正在被引用，那么称其为存活对象，如果对象不在被引用，则为垃圾回收器回收的对象，这部分对象占用的内存空间可以被回收。</p>
<p>在垃圾回收机制中有一组元素被称为根元素集合，它们是一组被虚拟机直接引用的对象。堆空间中的每个对象都是由一个根元素为起点被层层调用的。所以，一个对象如果被一个存活的根元素所引用，就会被认为是存活对象，不能被回收。这时，可以通过分析一个对象到根元素的引用路径来分析该对象为什么不能够被顺利回收。</p>
<p>当选中某个对象，通过Merge Shortest Paths to GC Root的操作，可以显示对象之间的排除了软引用，弱引用和虚引用的引用关系，这样我们看到的就是被选中对象是否还存在强引用，通过分析 ，能够直接找到内存没有释放的原因。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170420149269042589662.png" alt="20170420149269042589662.png"></p>
<h2 id="开发中常见内存泄露的场景"><a href="#开发中常见内存泄露的场景" class="headerlink" title="开发中常见内存泄露的场景"></a>开发中常见内存泄露的场景</h2><h3 id="1-Context对象使用不当；"><a href="#1-Context对象使用不当；" class="headerlink" title="1.Context对象使用不当；"></a>1.Context对象使用不当；</h3><p>在Android中经常使用的单例模式，如果使用不当，会出现内存泄露，泄露的主要原因是因为，单例模式中的静态成员变量的生命周期与应用的生命周期一样长。比较常见的场景是，经常在一些工具类中使用单例模式，如xxManager,xxHelper，xxUtils,这些工具类中需要使用Context,由于Activity是间接继承Context，当Activity退出时，单例对象中持有了它的引用，导致Activity回收失败，从而出现内存泄露。处理方式是使用Application,由于Application的生命周期贯穿整个应用，所以当这些工具类需要使用到Context时，使用getApplication()或者getApplicationContext()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    public class Util &#123;</div><div class="line">        private Context mContext;</div><div class="line">        private static Util sInstance;</div><div class="line"></div><div class="line">        private Util(Context context) &#123;</div><div class="line">            this.mContext = context;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public static Util getInstance(Context context) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">//                sInstance = new Util(context);</div><div class="line">                sInstance = new Util(context.getApplicationContext());</div><div class="line">            &#125;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2-内部类使用不当"><a href="#2-内部类使用不当" class="headerlink" title="2.内部类使用不当"></a>2.内部类使用不当</h3><p>当使用非静态的内部类时，如果出现内部类持有外部类的引用，就会出现内存泄露，优化方法，可以使用静态的内部类，这样内部类就不在持有外部类的引用，不会影响GC对于外部类的回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 静态成员变量</div><div class="line">     */</div><div class="line">    public static InnerClass innerClass = null;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_my);</div><div class="line"></div><div class="line">        innerClass = new InnerClass();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class InnerClass &#123;</div><div class="line"></div><div class="line">        public void doSomeThing() &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Handler的异步消息通信"><a href="#3-Handler的异步消息通信" class="headerlink" title="3.Handler的异步消息通信"></a>3.Handler的异步消息通信</h3><p>在使用Handler时出现内存泄露的主要原因是Handler的生命周期与Activity的生命周期不一致，当应用启动时，创建UI主线程Looper对象，Looper实现了简单的消息队列，主线程Looper对象存在整个应用的生命周期中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class HandlerActivity extends Activity &#123;</div><div class="line"></div><div class="line">    private final Handler mHandler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            // ...</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mHandler.sendMessageDelayed(Message.obtain(), 10*000);</div><div class="line">        finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当在Actiivity中使用Handler时，就可能会产生内存泄露，究其根本原因，是我们使用的非静态内部类(或者匿名内部类)默认隐性持有外部类的引用，静态内部类不会持有外部类的引用。在Activity结束时，由于Message是延迟消息，会在主线程的消息队列中，该消息持有Activity中的Handler的引用，Handler默认持有Activity的引用，直至该消息被处理完。此时导致Activity对象无法被回收，就会出现内存泄露。优化方法，可以使用静态内部类继承Handler对象，或者在Activity的onDestory()方法中，调用mHandler.removeCallbacksAndMessages(null);</p>
<h3 id="4-Bitmap使用不当"><a href="#4-Bitmap使用不当" class="headerlink" title="4.Bitmap使用不当"></a>4.Bitmap使用不当</h3><p>使用Bitmap如果回收不及时，也会出现内存泄露。原因在于Bitmap类没有对外创建对象的构造方法，获得Bitmap对象只能通过BitmapFactory中的各种静态方法，生成Bitmap对象是通过JNI调用底层c来实现的。所以，当我们获取一个Bitmap对象时，其对应的内存中包含两部分内容，一部分是Java，一部分是c,Java部分的内存可以通过GC进行回收，但是c部分的内存GC是不会进行自动回收的，所以，我们在使用Bitmap对象时，需要调用recycle()来主动释放c部分的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 判断是否已经回收</div><div class="line">if(bitmap != null &amp;&amp; !bitmap.isRecycled())&#123; </div><div class="line">        // 回收并且置为null</div><div class="line">        bitmap.recycle(); </div><div class="line">        bitmap = null; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-资源性对象没有及时关闭"><a href="#5-资源性对象没有及时关闭" class="headerlink" title="5.资源性对象没有及时关闭"></a>5.资源性对象没有及时关闭</h3><p>当我们使用一些资源性对象时，如果没有做关闭操作，也会出现内存泄露，常见的资源性对象包括(Cursor、ContentProvider、File、Stream)等。还有一类如EventBus、BroadCastReceiver在注册后，为了避免重复注册，需要在退出时及时的销毁。</p>
<h3 id="6-集合列表相关"><a href="#6-集合列表相关" class="headerlink" title="6.集合列表相关"></a>6.集合列表相关</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。</p>
<h3 id="7-Native中存在内存泄露"><a href="#7-Native中存在内存泄露" class="headerlink" title="7.Native中存在内存泄露"></a>7.Native中存在内存泄露</h3><p>由于Native层的代码多用c或c++来实现，GC无法对这部分内存进行会后处理，这时可能会出现内存泄露，这时候就需要c工程师帮助分析，如Malloc的内存是否做了free处理，指针使用完成后，是否进行了置空处理等等。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.jianshu.com/p/e97ed5d8a403" target="_blank" rel="external">科普：内存泄漏与内存溢出</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank" rel="external">Java的内存泄漏</a></li>
<li><a href="https://segmentfault.com/a/1190000006852540" target="_blank" rel="external">Android 内存泄露总结</a></li>
<li><a href="https://segmentfault.com/a/1190000003910496" target="_blank" rel="external">Java四种引用类型</a></li>
<li><a href="http://blog.csdn.net/itomge/article/details/48719527" target="_blank" rel="external">MAT使用教程</a></li>
</ol>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2017-03-24-分析Android中的内存泄露.html">http://www.sguotao.com/Android进阶-2017-03-24-分析Android中的内存泄露.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存泄露与内存溢出&quot;&gt;&lt;a href=&quot;#内存泄露与内存溢出&quot; class=&quot;headerlink&quot; title=&quot;内存泄露与内存溢出&quot;&gt;&lt;/a&gt;内存泄露与内存溢出&lt;/h2&gt;&lt;h3 id=&quot;内存泄露&quot;&gt;&lt;a href=&quot;#内存泄露&quot; class=&quot;headerli
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="内存泄露" scheme="http://www.sguotao.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="MAT" scheme="http://www.sguotao.com/tags/MAT/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的动态加载机制</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2017-03-17-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
    <id>http://www.sguotao.com/Android进阶-2017-03-17-分析Android中的动态加载机制.html</id>
    <published>2017-03-17T02:27:04.000Z</published>
    <updated>2017-08-08T03:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java的类加载机制ClassLoader"><a href="#Java的类加载机制ClassLoader" class="headerlink" title="Java的类加载机制ClassLoader"></a>Java的类加载机制ClassLoader</h2><p>我们编写的java代码，最终会编译成.class字节码的形式，一个完整的Java程序，通常会由若干个.class文件组成，在程序运行时，通过该程序的入口函数来调用系统的各个功能，但是程序启动时，并不会一次性将.class文件加载到内存中，根据程序的需要，通过Java的类加载机制来动态加载.class文件，ClassLoader就是来实现.class文件的动态加载的。</p>
<h2 id="Java中各类加载器的关系"><a href="#Java中各类加载器的关系" class="headerlink" title="Java中各类加载器的关系"></a>Java中各类加载器的关系</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974200061820.png" alt="20170317148974200061820.png"><br>Java默认会提供三个类加载器，分别为BootStrapClassLoader,ExtClassLoader和AppClassLoader;</p>
<ul>
<li>BootStrapLoader，启动类加载器，是Java类加载层次中最顶层的类加载器，由c代码编写，负责加载JDK中的核心类库（包括JRE classes目录下的.class文件，libs目录下的jar文件）。可以使用System.getProperty(“sun.boot.class.path”)来显示BootStrapLoader加载的jar和.class文件；</li>
<li>ExtClassLoader,扩展类加载器，负责加载Java的扩展类库，默认加载/jre/lib/ext目录下的所有jar和.class文件。可以通过可以使用System.getProperty(“java.ext.dirs”)来显示ExtClassLoader加载的jar和.class文件；</li>
<li>AppClassLoader,系统类加载器，负责加载classpath目录下所有的jar和class文件。</li>
</ul>
<h2 id="Java类加载的实现过程"><a href="#Java类加载的实现过程" class="headerlink" title="Java类加载的实现过程"></a>Java类加载的实现过程</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974217438657.jpg" alt="20170317148974217438657.jpg"></p>
<ul>
<li>执行程序代码，找到JRE所在目录；</li>
<li>找到jvm.dll(Windows)或者libjvm.so(Linux);</li>
<li>启动JVM，并进行初始化工作</li>
<li>创建BootStrapClassLoader;</li>
<li>BootStrapClassLoader会加载ExtClassLoader，并设定ExtClassLoader的parent为BootStrapClassLoader;</li>
<li>BootStrapClassLoader会加载AppClassLoader,并设定AppClassLoader的parent为ExtClassLoader;</li>
</ul>
<p>当AppClassLoader开始加载xxx.class时，类加载器会现将加载的任务交给其parent来完成，如果parent找不到，则自己负责加载。所以在加载xxx.class时的顺序是，BootstrapClassLoader –&gt; ExtClassLoader –&gt; AppClassLoader，如果都找不到，则抛出ClassNotFoundException。这就是非常有名的双亲委托模型。</p>
<p>使用双亲委托模型，有效地解决了.class字节码重复加载的问题，当parent已经加载类某各类的.class字节码时，子类就没有必要再重新进行加载。举个例子，来说明一下双亲委托模型。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974220124844.png" alt="20170317148974220124844.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 取得SomeClass的Class实例</div><div class="line">   Class c = Class.forName(&quot;SomeClass&quot;);</div><div class="line">   // 取得ClassLoader</div><div class="line">   ClassLoader loader = c.getClassLoader();</div><div class="line">   System.out.println(loader);</div><div class="line">   // 取得父ClassLoader</div><div class="line">   System.out.println(loader.getParent());</div><div class="line">   // 再取得父ClassLoader</div><div class="line">   System.out.println(loader.getParent().getParent());</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher\$AppClassLoader@19821f</div><div class="line">sun.misc.Launcher\$ExtClassLoader@addbf1</div><div class="line">null</div></pre></td></tr></table></figure>
<p>由于SomeClass是自定义的一个Java类，通常会java.class.path中产生字节码，首先AppClassLoader会将加载的任务交给其parent,ExtClassLaoder,ExtClassLoader将加载任务交给其parent，BootStrapClassLoader,由于BootStrapLoader在其目录(sun.boot.class.path)下没有找到该类的字节码，所以由ExtClassLoader来加载，ExtClassLoader在其目录(java.ext.dirs)也没有发现SomeClass的字节码，交给AppClassLoader进行加载，AppClassLoader在(java.class.path)中找到，并进行加载。</p>
<p>加载SomeClass的ClassLoader是AppClassLoader,其parent是ExtClassLoader,<br>而ExtClassLoader的parent是null，这是因为BootStrapClassLoader是由c代码编写的，在JVM中并没有对应的实例对象，所以显示为null。</p>
<h2 id="Dalvik与JVM"><a href="#Dalvik与JVM" class="headerlink" title="Dalvik与JVM"></a>Dalvik与JVM</h2><p>在Java中，把一些Java类编译成.class文件，通过ClassLoader进行加载，但是在Android上边，情况有所不同，主要的原因在于Android中使用的虚拟机是Dalvik。Android中的Dalvik和Java中的JVM都是将对应的Java类加载到内存中运行。不同的是JVM加载的是.class字节码文件，或是通过defineClass方式产生class，进行加载。Dalvik加载的是.dex文件，.dex文件是Android对.class文件进行了优化，更加适合内存和处理器有限的系统。</p>
<ul>
<li>Dalvik是基于寄存器的，而JVM是基于栈的。</li>
<li>Dalvik运行dex文件，而JVM运行java字节码</li>
<li>自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。</li>
</ul>
<p>很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。2014年6月25日,Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。ART,即Android Runtime。ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time,JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time)。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<h2 id="DexClassLoader与PathClassLoader"><a href="#DexClassLoader与PathClassLoader" class="headerlink" title="DexClassLoader与PathClassLoader"></a>DexClassLoader与PathClassLoader</h2><p>在使用Java虚拟机时，我们经常自定义继承自ClassLoader的类加载器。然后通过defineClass方法来从一个二进制流中加载Class。而在Android中我们无法这么使用，Android中ClassLoader的defineClass方法具体是调用VMClassLoader的defineClass本地静态方法。而这个本地方法什么都没做，只是抛出了一个“UnsupportedOperationException”异常。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</div><div class="line">        <span class="keyword">throws</span> ClassFormatError</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"can't load this type of class file"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>既然在Dalvik虚拟机里，ClassLoader不好用，那么Android官方为了解决这个问题，帮我们从ClassLoader中派生出了两个类：DexClassLoader和PathClassLoader。先来看一下DexClassLoader和PahtClassLoader的继承关系。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170322149015010153287.png" alt="20170322149015010153287.png"></p>
<h3 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h3><p>DexClassLoader可以加载jar,apk,dex,可以从SD卡进行加载，可以实现dex的动态加载与更新，DexClassLoader要有一个app私有且可写的目录来存储经过优化的.odex文件。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *</div><div class="line">		 * <span class="doctag">@param</span> dexPath .dex文件路径,多个文件路径使用':'分隔</div><div class="line">		 * <span class="doctag">@param</span> optimizedDirectory .dex文件优化后生成的.odex文件的路径</div><div class="line">		 * <span class="doctag">@param</span> librarySearchPath 动态库路径</div><div class="line">		 * <span class="doctag">@param</span> parent 双亲委派模式,指定父类加载器</div><div class="line">		 */</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h3><p>PathClassLoader只能加载已经安装的apk文件。Android系统默认使用的类加载器。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *</div><div class="line">		 * <span class="doctag">@param</span> dexPath .dex文件路径</div><div class="line">		 * <span class="doctag">@param</span> librarySearchPath 本地库路径</div><div class="line">		 * <span class="doctag">@param</span> parent 双亲委派模式,指定父类加载器</div><div class="line">		 */</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="DexClassLoader与PathClassLoader的比较"><a href="#DexClassLoader与PathClassLoader的比较" class="headerlink" title="DexClassLoader与PathClassLoader的比较"></a>DexClassLoader与PathClassLoader的比较</h3><p>通过两个类加载构造函数的对比发现，区别在于DexClassLoader构造函数中的参数optimizedDirectory。Google官方文档中给出optimizedDirectory的说明是，用来存储经过优化后的.odex文件的路径。optimizedDirectory必须是一个内部存储路径，DexClassLoader可以通过构造函数指定optimizedDirectory，所以DexClassLoader可以实现动态加载，外部的.jar/.dex文件，优化后会存在在optimizedDirectory目录中。PathClassLoader由于没有指定该路径，所以只能加载内部的，已经安装的apk中的.odex文件。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170322149015373793574.png" alt="20170322149015373793574.png"></p>
<p>整个类加载过程可以简单描述为上面的时序图。ClassLoader在加载过程中，通过loadClass方法，调用BaseDexClassLoader中重载的findClass方法，该方法会遍历DexPathList列表。DexPathList的创建过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></div><div class="line">                              String libraryPath, ClassLoader parent) &#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">        <span class="keyword">this</span>.originalPath = dexPath;</div><div class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>optimizedDirectory用来缓存优化过的.odex文件，在DexClassLoader中可以通过构造函数进行制定，在PathClassLoader中，optimizedDirectory为null，会直接使用系统中已经安装的apk文件的.odex目录。DexPathList完整的创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></div><div class="line">                       String libraryPath, File optimizedDirectory) &#123;</div><div class="line">        ……</div><div class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</div><div class="line">                                             File optimizedDirectory) &#123;</div><div class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</div><div class="line">        <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">            ZipFile zip = <span class="keyword">null</span>;</div><div class="line">            DexFile dex = <span class="keyword">null</span>;</div><div class="line">            String name = file.getName();</div><div class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</div><div class="line">                dex = loadDexFile(file, optimizedDirectory);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</div><div class="line">                || name.endsWith(ZIP_SUFFIX)) &#123;</div><div class="line">                zip = <span class="keyword">new</span> ZipFile(file);</div><div class="line">            &#125;</div><div class="line">            ……</div><div class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</div><div class="line">                elements.add(<span class="keyword">new</span> Element(file, zip, dex));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</div><div class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Converts a dex/jar file path and an output directory to an</div><div class="line">     * output file path for an associated optimized dex file.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">optimizedPathFor</span><span class="params">(File path,</span></span></div><div class="line">                                           File optimizedDirectory) &#123;</div><div class="line">        String fileName = path.getName();</div><div class="line">        <span class="keyword">if</span> (!fileName.endsWith(DEX_SUFFIX)) &#123;</div><div class="line">            <span class="keyword">int</span> lastDot = fileName.lastIndexOf(<span class="string">"."</span>);</div><div class="line">            <span class="keyword">if</span> (lastDot &lt; <span class="number">0</span>) &#123;</div><div class="line">                fileName += DEX_SUFFIX;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(lastDot + <span class="number">4</span>);</div><div class="line">                sb.append(fileName, <span class="number">0</span>, lastDot);</div><div class="line">                sb.append(DEX_SUFFIX);</div><div class="line">                fileName = sb.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        File result = <span class="keyword">new</span> File(optimizedDirectory, fileName);</div><div class="line">        <span class="keyword">return</span> result.getPath();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="http://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="external">深入分析Java ClassLoader原理</a><br>2.<a href="http://blog.csdn.net/irelandken/article/details/7048817" target="_blank" rel="external">分析BootstrapClassLoader/ExtClassLoader/AppClassLoader的加载路径 及”父委托机制”</a><br>3.<a href="https://openhome.cc/Gossip/JavaEssence/ClassLoader.html" target="_blank" rel="external">簡介類別載入器</a><br>4.<a href="http://www.infoq.com/cn/articles/android-in-depth-dalvik" target="_blank" rel="external">Java虚拟机Dalvik</a><br>5<a href="http://www.jianshu.com/p/669fc4858194" target="_blank" rel="external">Android动态加载——DexClassloader分析</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2017-03-17-分析Android中的动态加载机制.html">http://www.sguotao.com/Android进阶-2017-03-17-分析Android中的动态加载机制.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java的类加载机制ClassLoader&quot;&gt;&lt;a href=&quot;#Java的类加载机制ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;Java的类加载机制ClassLoader&quot;&gt;&lt;/a&gt;Java的类加载机制ClassLoader&lt;/
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="JVM" scheme="http://www.sguotao.com/tags/JVM/"/>
    
      <category term="插件框架" scheme="http://www.sguotao.com/tags/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ClassLoader" scheme="http://www.sguotao.com/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>怎样才能让别人觉得与你合作愉快</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2016-08-17-pleasure-working-with-you.html"/>
    <id>http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html</id>
    <published>2016-08-17T09:00:00.000Z</published>
    <updated>2017-06-02T10:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章作者：咪喵<br>文章来源： TalentGuide </p>
</blockquote>
<p>为什么有的人，明明事情做得不少，却永远没人说他好？有的人，不管做什么都得到周围人众口一词的称赞？</p>
<p>真的是因为两个人做的事差很多吗？也许是。<br>也许，只是一些小习惯改变了他们的口碑。</p>
<h2 id="1-收到请回答"><a href="#1-收到请回答" class="headerlink" title="1. 收到请回答"></a>1. 收到请回答</h2><p>一些人，交给他的事情永远没下文。你不知道他收到了没有，是不是正在做，已经做到了什么进展，啥时候能交付。即使这件事他已经做完了，不去问，他也永远不会告诉你。</p>
<ol>
<li>收到任务，请告诉对方“我收到了。”</li>
<li>需要时间消化，请告诉对方“我看一下，晚点（给出具体时间段更佳）给你答复。”</li>
<li>事情有进展时，及时周知相关人等最新进度。</li>
<li>事情完成时，通知相关方，并感谢在其中给过帮助的人。</li>
</ol>
<p>做到这些，不需要很多时间，却会让与你合作的人感到轻松愉快。</p>
<h2 id="2-要做就别抱怨"><a href="#2-要做就别抱怨" class="headerlink" title="2. 要做就别抱怨"></a>2. 要做就别抱怨</h2><p>有的人，接受任务时永远不情不愿，嘴里没完没了地抱怨，最后虽仍然接下了任务，却留下了难以合作的印象。</p>
<p>如果别人的行为确实给自己带来了麻烦或是有为难之处，可以清晰告知对方自己难做的原因，说清楚希望对方如何改进，并告知这样的改进会给双方带来什么好处。</p>
<p>比如对方总给你扔急活，你为了这个急活不得不加班加点，到处求人。正确的做法是<strong>告诉对方这件事有哪些环节，分别需要多长时间，以后请提早多少天告知，以便更好的完成。这次帮忙加急，下不为例</strong>。这样对方能理解你这次加急赶完是帮了他忙，而不会抱怨每次给你事情都推三阻四还完成得不好。</p>
<h2 id="3-推进事情要推到有进展才算数"><a href="#3-推进事情要推到有进展才算数" class="headerlink" title="3. 推进事情要推到有进展才算数"></a>3. 推进事情要推到有进展才算数</h2><p>有些人，推进一件事的方法是：每隔一段时间，发封不痛不痒的邮件，抄送所有人，摆个样子跟进一下，也不在乎对方是否给了结果。仿佛在说“你看，我推过了，是对方不给做，推不动不关我事哦。出了问题责任是他是他还是他。”</p>
<p>如果是自家孩子病了，有哪位家长会说“我给医生发邮件了，他没回我，所以病治不了了。”显然，孩子生病时家长都是心急火燎的，医生不在会找护士，找主管，找院长，找媒体。用尽一切可用的渠道，一切可用的方法，直到医生给孩子看病为止。</p>
<p>当说一件事情推不动时，扪心自问自己真的做到了像家长为生病的孩子找医生那样努力吗？真的已经用尽了一切可用的力量，找尽了一切可找的人去推动这件事吗？</p>
<p>装模作样推一推是没有意义的，一定要推到这件事有实质进展为止。<strong>实质进展是对方给排期、给解决方案、给具体处理这件事的人</strong>。如果什么都没拿到，那根本不算推进过一件事。</p>
<h2 id="4-做不到早说"><a href="#4-做不到早说" class="headerlink" title="4. 做不到早说"></a>4. 做不到早说</h2><p>有的人，交给他的事情，不问永远没问题，一问全是问题。拖过了截止期做不到，罗列出一堆原因，都是ABCDE的问题，与他无关。</p>
<p>OK，就算ABCDE的问题确实与他无关，为什么不能在发现有这些问题时及时反馈呢？自己解决不了的问题，及时反馈并暴露，让有能力解决的人去解决，是靠谱最重要的表现之一。</p>
<p>又有人说，我要是暴露了这些问题得罪了别人怎么办？请问不暴露这些问题，任由时间资源浪费，事情最终没做到，就谁都不得罪了吗？<strong>作为一个团队，成事是最重要的。暴露问题是为了解决问题，而不是为了挑事，关键是把握分寸</strong>。</p>
<p>还有人说，跟别人没关系，就是堆给我的活太多了，我做不完怎么办？如果是这种情况，更要尽早反馈了。或许你花了大量时间在一件优先级比较低的事情上，导致最重要的事情没有做完。结果把自己累得半死，还谁都不满意。<strong>发现自己做不完，就要第一时间跟相关方确认优先级，力保最重要的事情能够及时完成。如果被插入了其他优先级更高的事，也要尽快知会事情被推迟的相关方</strong>。</p>
<h2 id="5-功劳是大家的"><a href="#5-功劳是大家的" class="headerlink" title="5. 功劳是大家的"></a>5. 功劳是大家的</h2><p>有些人，干活的时候一天八回地狂催别人。活干完了，人没影了，汇报工作成果时只字不提其他人，仿佛活全是他自己一人干的。这样的人，执行力再好，下次再找人干活时，也难得到别人心甘情愿的帮忙。</p>
<p><strong>无论别人是帮了多小的忙，在事情结束后也要表示感谢</strong>。道谢要不嫌隆重，能当面谢的尽量当面去谢，能单独打电话谢的就不要讲其他事情时顺便谢，发邮件表示感谢的话尽量抄送对方老板详细说明感谢的事由。这些事情并不费劲，却会让别人更愿意帮助你。</p>
<h2 id="6-别吐槽，给解决方案"><a href="#6-别吐槽，给解决方案" class="headerlink" title="6. 别吐槽，给解决方案"></a>6. 别吐槽，给解决方案</h2><p>有的人，你一找他解决问题，就开启吐槽模式，内容全是“我有多辛苦多不容易，能做的我都做了，这些问题全是因为balabala……”</p>
<p>每当这时我都好想告诉对方“亲，没有人关心你的心路历程。”我不关心你有多辛苦多不容易你做了多少事情，为什么别人就是没按照你设定的剧本做。我只知道现在有一个问题，我找你只想知道“怎样解决这个问题”。</p>
<p><strong>当有一个问题时，请直奔主题，给解决方案</strong>。</p>
<h2 id="7-敢作敢当"><a href="#7-敢作敢当" class="headerlink" title="7. 敢作敢当"></a>7. 敢作敢当</h2><p>当事情搞砸时，最次的做法是想尽办法推卸责任，最好的做法是<strong>诚恳道歉，评估影响范围，想尽办法用最快速度修正错误，弥补损失</strong>。</p>
<p>不要耍滑头，得意于自己把责任都推出去了，推卸得越成功，实际越失败。不要怕承担，勇于承担责任的人，别人才敢赋予你更大的责任。</p>
<h2 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h2><p>做到上面这些条，说难不难，说易也不易。说白了，就是要多操些心，多费些力。</p>
<p>有的人说一份工作而已，干嘛把自己搞这么累。我就做好自己这部分，别人的事我不管，跟我没关系，只要出事了别怪我头上就行。当然，若真这么想，没什么不行的，您高兴就好。只是请不要再抱怨为什么自己怀才不遇，升职加薪总是比别人慢。多劳多得，很公平，不是么？</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html">http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章作者：咪喵&lt;br&gt;文章来源： TalentGuide &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么有的人，明明事情做得不少，却永远没人说他好？有的人，不管做什么都得到周围人众口一词的称赞？&lt;/p&gt;
&lt;p&gt;真的是因为两个人做的事差很多吗？也
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的Fragment</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-07-21-%E5%88%86%E6%9E%90Androdi%E4%B8%AD%E7%9A%84Fragment.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-07-21-分析Androdi中的Fragment.html</id>
    <published>2016-07-21T02:27:04.000Z</published>
    <updated>2017-08-08T03:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fragment介绍"><a href="#Fragment介绍" class="headerlink" title="Fragment介绍"></a>Fragment介绍</h2><p>Android 在 Android 3.0（API 级别 11）中引入了Fragment，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。</p>
<h3 id="Fragment加载到Activity中的两种方式"><a href="#Fragment加载到Activity中的两种方式" class="headerlink" title="Fragment加载到Activity中的两种方式"></a>Fragment加载到Activity中的两种方式</h3><p><strong>静态加载方式</strong><br>静态加载方式，直接在布局文件中添加fragment，示例代码:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">"com.example.news.ArticleListFragment"</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/list"</span></div><div class="line">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">"com.example.news.ArticleReaderFragment"</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/viewer"</span></div><div class="line">            <span class="attr">android:layout_weight</span>=<span class="string">"2"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>动态加载方式</strong><br>动态加载方式，即在Activity运行过程中，将fragment加载到布局文件中，示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.获取一个FragmentTransaction实例</span></div><div class="line">FragmentManager fragmentManager = getFragmentManager();</div><div class="line">FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div><div class="line"><span class="comment">//2.调用add()方法添加Fragment对象</span></div><div class="line">ExampleFragment fragment = <span class="keyword">new</span> ExampleFragment();</div><div class="line">fragmentTransaction.add(R.id.fragment_container, fragment);</div><div class="line"><span class="comment">//3.调用commit()方法使得fragmentTransaction实例的改变生效</span></div><div class="line">fragmentTransaction.commit();</div></pre></td></tr></table></figure>
<h3 id="FragmentPagerAdapter与FragmentStatePagerAdapter的区别"><a href="#FragmentPagerAdapter与FragmentStatePagerAdapter的区别" class="headerlink" title="FragmentPagerAdapter与FragmentStatePagerAdapter的区别"></a>FragmentPagerAdapter与FragmentStatePagerAdapter的区别</h3><p>FragmentPagerAdapter和FragmentStatePagerAdapter都是PagerAdapter的子类，先来看他们的父类PagerAdapter。</p>
<p>PagerAdapter是ViewPager的适配器，ViewPager将调用它来取得所需显示的页，而 PagerAdapter也会在数据变化时，通知ViewPager。如果继承自该类，至少需要实现 instantiateItem(), destroyItem(), getCount() 以及 isViewFromObject()。</p>
<p>FragmentPagerAdapter继承自PagerAdapter。相比通用的PagerAdapter，该类更专注于每一页均为Fragment的情况。该类内的每一个生成的Fragment都将保存在内存之中，因此适用于那些相对静态的页，数量也比较少的那种；如果需要处理有很多页，并且数据动态性较大、占用内存较多的情况，应该使用FragmentStatePagerAdapter。FragmentPagerAdapter 重载实现了几个必须的函数，因此来自 PagerAdapter 的函数，我们只需要实现 getCount()，即可。且，由于 FragmentPagerAdapter.instantiateItem() 的实现中，调用了一个新增的虚函数 getItem()，因此，我们还至少需要实现一个 getItem()。</p>
<p>FragmentStatePagerAdapter 和前面的 FragmentPagerAdapter 一样，是继承子 PagerAdapter。和 FragmentPagerAdapter 不一样的是，正如其类名中的 ‘State’ 所表明的含义一样，该 PagerAdapter 的实现将只保留当前页面，当页面离开视线后，就会被消除，释放其资源；而在页面需要显示时，生成新的页面。这么实现的好处就是当拥有大量的页面时，不必在内存中占用大量的内存。</p>
<p>为什么FragmentPagerAdapter占用内存会比FragmentStatePagerAdapter呢？看一下FragmentPagerAdapter的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</div><div class="line">        mCurTransaction = mFragmentManager.beginTransaction();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Detaching item #"</span> + getItemId(position) + <span class="string">": f="</span> + object</div><div class="line">            + <span class="string">" v="</span> + ((Fragment)object).getView());</div><div class="line">    mCurTransaction.detach((Fragment)object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再对比看一下FragmentStatePagerAdapter对应的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</div><div class="line">       Fragment fragment = (Fragment) object;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</div><div class="line">           mCurTransaction = mFragmentManager.beginTransaction();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Removing item #"</span> + position + <span class="string">": f="</span> + object</div><div class="line">               + <span class="string">" v="</span> + ((Fragment)object).getView());</div><div class="line">       <span class="keyword">while</span> (mSavedState.size() &lt;= position) &#123;</div><div class="line">           mSavedState.add(<span class="keyword">null</span>);</div><div class="line">       &#125;</div><div class="line">       mSavedState.set(position, fragment.isAdded()</div><div class="line">               ? mFragmentManager.saveFragmentInstanceState(fragment) : <span class="keyword">null</span>);</div><div class="line">       mFragments.set(position, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">       mCurTransaction.remove(fragment);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>FragmentStatePagerAdapter在每次destroyItem()时，将Fragment移除掉，而FragmentPagerAdapter只是detach()，失去关联而已。</p>
<h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p>一个Fragment从创建到销毁的完整的生命周期如图:<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170722150069331557277.png" alt="20170722150069331557277.png"><br>图中给出了Fragment在创建和销毁的过程中对一个的Activity的回调方法。对比发现，Fragment生命周期过程中的回调状态比Activity的状态多。</p>
<p><strong>onAttch（Activity activity）</strong>，这个回调方法是在fragment与activity关联之后调用，我们能在这个方法中获取这个关联的activity的实例。但是当你的sdk更新到android6.0（api-23）是就会显示这个方法是过时的，系统建议使用onAttach（Context  context）这个方法代替。</p>
<p><strong>onCreate()</strong>，这个回调方法是在fragment初始化的时候调用，我们通常在这个方法中使用getArgument()获取Activity传来的初始化Fragment的参数。需要注意的是，在这个方法中不能获取Activity中的控件，因为此时Activity的onCreate()还没有执行完，即Activity还没有创建完，要想获取Activity相关的资源应该在onActivityCreated()中获取。</p>
<p><strong>onCreateView()</strong>：这个回调方法中我们主要是通过布局填充器获取Fragment布局。我们在这个方法中通过view.findViewById()初始化Fragment中的控件。</p>
<p><strong>onActivityCreated()</strong>，这个回调方法是在Activity的onCreate()方法执行完执行，通知Fragment，其关联的Activity的onCreate()方法执行完了，即Activity创建完成，可以在这个方法中获取Activity中的资源。</p>
<p><strong>onStart()</strong>，这个回调方法是在Activity的onstart()执行完立即执行，这个方法执行完Fragment界面就显示出来了，但是现在还没有获取焦点，用户不能进行交互操作。</p>
<p><strong>onResume()</strong>，这个回调方法是在Activity的onResume()方法执行完立即执行，此时Fragment的获取了界面，用户可以操作。</p>
<p><strong>onPause()</strong>，Fragment失去焦点，此时用户是不能操作的，执行完立即执行Activity的onPause()方法。</p>
<p><strong>onStop()</strong>，Fragment不可见，执行完立即执行Activity的onStop()方法。</p>
<p><strong>onDestroyView()</strong>,在onCreateView()中创建的Fragment视图会被销毁。Fragment的视图被回收。</p>
<p><strong>onDestroy()</strong>，当这个Fragment不再使用时调用。需要注意的是，它即使经过了onDestroy()阶段，但仍然能从Activity中找到，因为它还没有Detach()。</p>
<p><strong>onDetach()</strong>，Fragment与Activity解除关联，Fragment的所有的资源都被回收。</p>
<h2 id="Fragment的通信"><a href="#Fragment的通信" class="headerlink" title="Fragment的通信"></a>Fragment的通信</h2><p>Fragment的通信，概括起来主要包含以下三种情况:</p>
<ol>
<li>在Fragment中调用Activity中的方法，通过getActivity()获取到关联的Activity，然后通过获取的Activity实例，调用Activity中的方法。</li>
<li>在Activity中调用Fragment中的方法，Activity中维护着其关联的Fragment的实例，可以直接调用其方法。</li>
<li>在Fragment中调用Fragment中的方法，通过getActivity()获取到关联的Activity，然后通过获取的Activity实例，通过findFragmentById()方法，知道要与之通信的Fragment。</li>
</ol>
<p>除了上面中介绍的方法，还可以通过接口回调的方法。这里以Fragment调用Activity中的方法为例，介绍接口回调的方式,接口回调主要经历三个步骤:</p>
<ul>
<li>在Fragment中定义回调接口，声明回调方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 1.在Fragment中定义回调接口，声明回调方法</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComminuteListener</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">comminute</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Fragment关联的Activity实现接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFragmentActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">TestFragment</span>.<span class="title">ComminuteListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">comminute</span><span class="params">()</span> </span>&#123;</div><div class="line">        showToast();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">()</span> </span>&#123;</div><div class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"toast from Activity"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在Fragment的onAttach()方法中，获取接口实例，调用回调方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onAttach(context);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          comminuteListener = (ComminuteListener) getActivity();</div><div class="line">      &#125;<span class="keyword">catch</span> (ClassCastException e)&#123;</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      comminuteListener.comminute();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]<a href="https://developer.android.com/guide/components/fragments.html" target="_blank" rel="external">Google-API指南-应用组件-Fragment</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-07-21-分析Androdi中的Fragment.html">http://www.sguotao.com/Android进阶-2016-07-21-分析Androdi中的Fragment.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Fragment介绍&quot;&gt;&lt;a href=&quot;#Fragment介绍&quot; class=&quot;headerlink&quot; title=&quot;Fragment介绍&quot;&gt;&lt;/a&gt;Fragment介绍&lt;/h2&gt;&lt;p&gt;Android 在 Android 3.0（API 级别 11）中引入了Fr
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Fragment" scheme="http://www.sguotao.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的Binder</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-07-21-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Binder.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-07-21-分析Android中的Binder.html</id>
    <published>2016-07-21T02:27:04.000Z</published>
    <updated>2017-08-08T03:38:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分析Binder之前，需要先了解几个Linux的几个概念。</p>
<h2 id="Linux内核的基础知识"><a href="#Linux内核的基础知识" class="headerlink" title="Linux内核的基础知识"></a>Linux内核的基础知识</h2><ol>
<li><p>进程隔离/虚拟地址空间:每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。虚拟地址不是现实存在的地址空间。操作系统可以根据分段和分页两种方式，实现虚拟地址到真实物理地址的映射。</p>
</li>
<li><p>系统调用:计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源，进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的系统调用（System Call）。</p>
</li>
<li><p>Binder驱动:Binder驱动是作为一个特殊字符型设备存在，设备节点为/dev/binder，遵循Linux设备驱动模型。在驱动实现过程中，实现与用户空间进程的数据通信。</p>
</li>
</ol>
<h2 id="Binder的通信机制"><a href="#Binder的通信机制" class="headerlink" title="Binder的通信机制"></a>Binder的通信机制</h2><h3 id="什么是Binder？"><a href="#什么是Binder？" class="headerlink" title="什么是Binder？"></a>什么是Binder？</h3><ol>
<li>通常意义下，Binder是Android中的一个类，它继承了IBinder接口；</li>
<li>从IPC角度，Binder指的是跨进程通信机制；对于Server进程来说，Binder指的是Binder本地对象,对于Client进程来说，Binder指的是Binder代理对象。在整个传输过程，Binder是可以进行跨进程传递对象的。</li>
<li>从Android Framework角度，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁；</li>
<li>从Android应用层，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ol>
<h3 id="为什么使用binder"><a href="#为什么使用binder" class="headerlink" title="为什么使用binder"></a>为什么使用binder</h3><p>Android中有大量的CS（Client-Server）应用方式，这就要求Android内部提供IPC方法，Android使用Linux内核，拥有着非常多的跨进程通信机制，但是linux所支持的进程通信方式有两个问题：性能和安全性。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>目前linux支持的IPC包括传统的管道，System V IPC(消息队列/共享内存/信号量)，以及socket，但只有socket支持Client-Server的通信方式，由于socket是一套通用的网络通信方式，其传输效率低下切有很大的开销，比如socket的连接建立过程和中断连接过程都是有一定开销的。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。<strong>传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。</strong>使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</p>
<p>基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。</p>
<h3 id="Binder通信模型"><a href="#Binder通信模型" class="headerlink" title="Binder通信模型"></a>Binder通信模型</h3><p>Binder的通信过程可以用下图来简单的描述。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170807150209709476434.png" alt="20170807150209709476434.png"></p>
<p>Client与Server通过Binder进行通信的过程可以概括为:</p>
<ol>
<li>ServiceManager的建立；</li>
<li>启动的Service在ServiceManager中进行注册，在已经建立的ServiceManager维护的一张表；</li>
<li>Client向ServiceManager中进行查询Service中注册的方法；</li>
<li>ServiceManager返回一个代理对象，Client可以通过该代理对象实现与Server的通信。代理对象中有空方法，代理对象中方法的实现是Binder驱动来完成的。整个过程对Client是透明的。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.任玉刚.Android开发艺术探索[M].电子工业出版社, 2015.9:1 - 507<br>2.<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Bander设计与实现 - 设计篇</a><br>3.<a href="http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html" target="_blank" rel="external">Android深入浅出之Binder机制</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-07-21-分析Android中的Binder.html">http://www.sguotao.com/Android进阶-2016-07-21-分析Android中的Binder.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分析Binder之前，需要先了解几个Linux的几个概念。&lt;/p&gt;
&lt;h2 id=&quot;Linux内核的基础知识&quot;&gt;&lt;a href=&quot;#Linux内核的基础知识&quot; class=&quot;headerlink&quot; title=&quot;Linux内核的基础知识&quot;&gt;&lt;/a&gt;Linux内核的基础知识
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Binder" scheme="http://www.sguotao.com/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的Activity</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-07-21-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Activity.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-07-21-分析Android中的Activity.html</id>
    <published>2016-07-21T02:27:04.000Z</published>
    <updated>2017-08-08T03:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><blockquote>
<p>Activity是Android与用户进行交互的接口，Activity提供了界面用于处理用户的点击和滑动等交互。</p>
</blockquote>
<h3 id="Activity的四种状态"><a href="#Activity的四种状态" class="headerlink" title="Activity的四种状态"></a>Activity的四种状态</h3><p>Activity主要包括四种状态，分别是:running、paused、stopped和killed。</p>
<ol>
<li>running状态，Activity处于活动状态，用户可以点击屏幕，Activity会做出响应，此时Activity处于栈顶的状态。</li>
<li>paused状态，Activity失去焦点，此时Activity被一个非全屏的Activity覆盖，或者被一个全屏的透明的Activity覆盖。在paused状态暂时无法与用户进行交互，Activity的成员变量的状态除非因为内存紧张被回收，否则都存在的。</li>
<li>stopped状态，Activity被另外一个Activity完全覆盖，在内存不紧张的情况，Activity成员变量的状态都存在。</li>
<li>killed状态，Activity已经被系统回收，Activity的成员变量状态都不存在了。</li>
</ol>
<h3 id="Activity的生命周期分析"><a href="#Activity的生命周期分析" class="headerlink" title="Activity的生命周期分析"></a>Activity的生命周期分析</h3><p>先看官网给出的Activity生命周期的流程图:<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170721150060766016240.png" alt="20170721150060766016240.png"><br>根据流程图，来分析一下Activity的几个主要的回调方法:</p>
<ol>
<li>onCreate()，Activity创建的时候被回调，是Activity生命周期第一个被回调的方法，在onCreate()中可以setContentview(),还可以设置一些预加载功能。</li>
<li>onStart()，Activity已经启动处于用户可见，但是还不能与用户交互的状态。</li>
<li>onResume()，Activity前台可见，可以与用户进行交互。</li>
<li>onPause()，Activity处于暂停状态，Activity可见，但已经不在栈顶。</li>
<li>onStop()，Activity处于停止状态，被完全覆盖，如果系统内存紧张，Activity可能会被回收。</li>
<li>onRestart()，Activity从停止状态被重新调用时，会回调该方法。</li>
<li>onDestroy()，退出当前Activity时会被回调，是整个生命周期的最后一个方法，可以在该方法中做一些资源释放的操作。</li>
</ol>
<p>几种主要场景中,Activity回调方法的执行过程:</p>
<ol>
<li>Activity启动过程中: onCreate() –&gt; onStart() –&gt; onResume()</li>
<li>点击Home键回到主界面时,Activity变为不可见状态: onPause() –&gt; onStop()</li>
<li>再次点击Home键返回到之前的Activity时: onRestart() –&gt; onStart() –&gt; onResume()</li>
<li>退出当前Activity时: onPause() –&gt; onStop() –&gt; onDestroy()</li>
</ol>
<h3 id="Activity进程优先级"><a href="#Activity进程优先级" class="headerlink" title="Activity进程优先级"></a>Activity进程优先级</h3><p>Android中的进程可以根据优先级的不同划分为:前台进程、可见进程、服务进程、后台进程和空进程。当系统资源紧张时，Android系统会优先考虑回收优先级比较低的进程。</p>
<ol>
<li>系统中前台进程的数量很少, 前台进程几乎不会被系统回收. 只有当内存低到无法保证所有的前台进程同时运行时才会选择杀死某个前台进程。前台进程包含以下场景:进程中包含处于前台的正与用户交互的Activity;进程中包含与前台Activity绑定的Service;进程中包含调用了startForeground()方法的Service;进程中包含正在执行onCreate(),onStart(), 或onDestroy()方法的service;进程中包含正在执行onReceive()方法的BroadcastReceiverd。</li>
<li>可见进程，可视进程不会被系统回收, 除非为了保证前台进程的运行而不得已为之。可见进程的场景:进程中包含未处于前台但仍然可见的Activity(调用了Activity的onPause()方法, 但没有调用onStop()方法)。进程中包含与可见Activity绑定的Service。</li>
<li>服务进程，顾名思义，进程中包含已启动的Service。</li>
<li>后台进程，进程中包含不可见的Activity(onStop()方法调用后的activity)。后台进程不会直接影响用户体验, 为了保证前台进程/可见进程/服务进程的运行, 系统随时都有可能回收一个后台进程。</li>
<li>空进程，不包含任何处于活动状态的进程是一个空进程。系统经常杀死空进程，这不会造成任何影响。空进程存在的唯一理由是为了缓存一些启动数据，以便下次可以更快的启动。</li>
</ol>
<h2 id="Android任务栈"><a href="#Android任务栈" class="headerlink" title="Android任务栈"></a>Android任务栈</h2><p>当应用程序打开时就创建了一个任务栈，用于存储当前应用程序的Activity，一个任务栈就是一个Activity的集合，只有在任务栈栈顶的Activity才可以跟用户进行交互。任务栈可以移动到后台，并且保留每一个Activity的状态。退出应用程序时，需要把所有任务栈中的Activity清除出栈。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170721150062514810176.png" alt="20170721150062514810176.png"><br>当我们每打开一个Activity的时候它会就往Activity任务栈中压入一个Activity，当我们每销毁一个Activity的时候它会从Activity任务栈中弹出一个Activity。</p>
<h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><p>启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它决定着是否生成新的Activity实例，是否重用已经存在的Activity实例，是否和其他实例共用一个任务栈。Activity的启动模式有四种，分别是:standard、singTop singTask和singleInstance，可以通过在AndroidManifest.xml中Activity的android:launchMode属性进行设置。</p>
<p>Android启动模式:</p>
<ol>
<li><strong>标准模式standard</strong>，默认启动模式，每次激活Activity时都会创建Activity，并放入任务栈中。</li>
<li><strong>栈顶复用模式singletop</strong>，如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例)。</li>
<li><strong>栈内复用模式singletask</strong>，如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中。</li>
<li><strong>singleinstance</strong>， 在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦该模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。</li>
</ol>
<h2 id="Scheme跳转协议"><a href="#Scheme跳转协议" class="headerlink" title="Scheme跳转协议"></a>Scheme跳转协议</h2><p>Android中的Scheme是一种页面内跳转协议，通过自定义的Scheme协议，可以非常方便的跳转app中的各个页面，通过Scheme协议服务器可以定制化告诉App跳转哪个页面，可以通过通知栏消息定制化跳转页面，也可以实现H5页面跳转页面。scheme协议，主要用于支持一下几种场景：</p>
<ol>
<li>服务器下发跳转路径，客户端根据服务器下发跳转路径跳转相应的页面；</li>
<li>H5页面点击锚点，根据锚点具体跳转路径App端跳转具体的页面；</li>
<li>App之间根据跳转路径进行跳转。</li>
</ol>
<p>使用方式包含下面几个步骤:</p>
<ol>
<li>在清单文件AndroidManifest中声明用来处理通过Scheme协议跳转的Activity；</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">    <span class="attr">Android:name</span>=<span class="string">".NativeAppActivity"</span></div><div class="line">    <span class="attr">Android:label</span>=<span class="string">"@string/app_name"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 协议部分--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">data</span></span></div><div class="line">            <span class="attr">android:host</span>=<span class="string">"shareAction"</span></div><div class="line">            <span class="attr">android:scheme</span>=<span class="string">"letvclient"</span> /&gt;</div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">Android:name</span>=<span class="string">"Android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">Android:name</span>=<span class="string">"Android.intent.category.BROWSABLE"</span> /&gt;</span></div><div class="line">        </div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">Android:name</span>=<span class="string">"Android.intent.action.VIEW"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>调起处理跳转协议的Activity</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startActivity(<span class="keyword">new</span> Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"letvclient://shareAction?actionType=xxx&amp;appName=xxx"</span>)));</div></pre></td></tr></table></figure>
<ol>
<li>在处理跳转协议的Activity中解析数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resolveUri</span><span class="params">(Intent intent, Uri data)</span> </span>&#123;</div><div class="line">        String scheme = intent.getScheme();</div><div class="line">        <span class="keyword">if</span> (scheme == <span class="keyword">null</span> || !LETV_CLIENT.equalsIgnoreCase(scheme)) &#123;<span class="comment">// 判断来源</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        String actionType;</div><div class="line">        String appName;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            actionType = data.getQueryParameter(<span class="string">"actionType"</span>);</div><div class="line">            appName = data.getQueryParameter(<span class="string">"appName"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ……</div><div class="line">        </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]<a href="https://developer.android.com/guide/components/processes-and-threads.html?hl=zh-cn" target="_blank" rel="external">GoogleAPI指南-进程和线程</a><br>[2]<a href="https://developer.android.com/guide/components/activities.html?hl=zh-cn" target="_blank" rel="external">GoogleAPI指南-Activity</a><br>[3]<a href="https://developer.android.com/guide/components/tasks-and-back-stack.html?hl=zh-cn" target="_blank" rel="external">GoogleAPI指南-任务栈和返回栈</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-07-21-分析Android中的Activity.html">http://www.sguotao.com/Android进阶-2016-07-21-分析Android中的Activity.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Activity的生命周期&quot;&gt;&lt;a href=&quot;#Activity的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Activity的生命周期&quot;&gt;&lt;/a&gt;Activity的生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Activity是Andr
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://www.sguotao.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的自定义View</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-07-08-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89View.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-07-08-分析Android中的自定义View.html</id>
    <published>2016-07-08T02:27:04.000Z</published>
    <updated>2017-07-13T09:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义View的分类"><a href="#自定义View的分类" class="headerlink" title="自定义View的分类"></a>自定义View的分类</h2><ol>
<li><p><strong>继承View重写onDraw()</strong>，这种方法主要用于实现一些不规则的效果，即这种效果不方便通过布局的组合方式来达到，往往需要静态或者动态地显示一些不规则的图形。很显然这需要通过绘制的方式来实现，即重写onDraw方法。采用这种方式需要自己支持wrap_content，并且padding也需要自己处理。</p>
</li>
<li><p><strong>继承ViewGroup派生出特殊的Layout布局</strong>，这种方法主要用于实现自定义的布局，即除了LinearLayout、RelativeLayout、FrameLayout这几种系统的布局之外，我们重新定义一种新布局，当某种效果看起来很像几种View组合在一起的时候，可以采用这种方法来实现。采用这种方式稍微复杂一些，需要合适地处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。</p>
</li>
<li><p><strong>继承具体的View</strong>，这种方法比较常见，一般是用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现。这种方法不需要自己支持wrap_content和padding等。</p>
</li>
<li><p><strong>继承具体的ViewGroup</strong>，这种方法也比较常见，当某种效果看起来很像几种View组合在一起的时候，可以采用这种方法来实现。采用这种方法不需要自己处理ViewGroup的测量和布局这两个过程。需要注意这种方法和方法2的区别，一般来说方法2能实现的效果方法4也都能实现，两者的主要差别在于方法2更接近View的底层。</p>
</li>
</ol>
<h2 id="添加自定义属性"><a href="#添加自定义属性" class="headerlink" title="添加自定义属性"></a>添加自定义属性</h2><p><strong>1.在values目录下面创建自定义属性的XML，比如attrs.xml，也可以选择类似于attrs_circle<em>view.xml等这种以attrs</em>开头的文件名。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;declare-styleable name=&quot;CircleView&quot;&gt;</div><div class="line">        &lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p><strong>2.在View的构造方法中解析自定义属性的值并做相应处理。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">    super(context, attrs, defStyleAttr);</div><div class="line">    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleView);</div><div class="line">    mColor = a.getColor(styleable.CircleView_circle_color, Color.RED); a.recycle();</div><div class="line">    init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3.在布局文件中使用自定义属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:background=&quot;#ffffff&quot;</div><div class="line">    android:orientation=&quot;vertical&quot;&gt;</div><div class="line">    </div><div class="line">    &lt;com.scott.codelibrary.view.CustomView</div><div class="line">        android:id=&quot;@+id/cv&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;100dp&quot; </div><div class="line">        android:layout_margin=&quot;20dp&quot; </div><div class="line">        android:background=&quot;#000000&quot; </div><div class="line">        android:padding=&quot;20dp&quot; </div><div class="line">        app:circle_color=&quot;@color/light_green&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<h2 id="自定义View的注意事项"><a href="#自定义View的注意事项" class="headerlink" title="自定义View的注意事项"></a>自定义View的注意事项</h2><h3 id="让View支持wrap-content"><a href="#让View支持wrap-content" class="headerlink" title="让View支持wrap_content"></a>让View支持wrap_content</h3><p>这是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。为什么呢？</p>
<p>如果View在布局中使用wrap_content，那么它的specMode是AT_MOST模式，在这种模式下，它的宽/高等于specSize；这种情况下View的specSize是parentSize，而parentSize是父容器中目前可以使用的大小，也就是父容器当前剩余的空间大小。很显然，View的宽/高就等于父容器当前剩余的空间大小，这种效果和在布局中使用match_parent完全一致。怎么处理呢？直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">        int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line"></div><div class="line">        if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">            //给View指定默认的宽mWidth，高mHeight</div><div class="line">            setMeasuredDimension(mWidth, mHeight);</div><div class="line">        &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">            setMeasuredDimension(mWidth, heightSpecSize);</div><div class="line">        &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">            setMeasuredDimension(widthSpecSize, mHeight);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="让View支持padding"><a href="#让View支持padding" class="headerlink" title="让View支持padding"></a>让View支持padding</h3><p>这是因为直接继承View的控件，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。</p>
<h3 id="不要在View中使用Handler"><a href="#不要在View中使用Handler" class="headerlink" title="不要在View中使用Handler"></a>不要在View中使用Handler</h3><p>这是因为View内部本身就提供了post系列的方法，完全可以替代Handler的作用，当然除非你很明确地要使用Handler来发送消息。</p>
<h3 id="View中如果有线程或者动画，需要及时停止，"><a href="#View中如果有线程或者动画，需要及时停止，" class="headerlink" title="View中如果有线程或者动画，需要及时停止，"></a>View中如果有线程或者动画，需要及时停止，</h3><p>参考View#onDetachedFromWindow这一条也很好理解，如果有线程或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄漏。</p>
<h3 id="View带有滑动嵌套情形时，需要处理好滑动冲突"><a href="#View带有滑动嵌套情形时，需要处理好滑动冲突" class="headerlink" title="View带有滑动嵌套情形时，需要处理好滑动冲突"></a>View带有滑动嵌套情形时，需要处理好滑动冲突</h3><p>如果有滑动冲突的话，那么要合适地处理滑动冲突，否则将会严重影响View的效果。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-07-08-分析Android中的自定义View.html">http://www.sguotao.com/Android进阶-2016-07-08-分析Android中的自定义View.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自定义View的分类&quot;&gt;&lt;a href=&quot;#自定义View的分类&quot; class=&quot;headerlink&quot; title=&quot;自定义View的分类&quot;&gt;&lt;/a&gt;自定义View的分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;继承View重写onDraw()&lt;/str
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="View" scheme="http://www.sguotao.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中View的事件分发流程</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-07-06-%E5%88%86%E6%9E%90Android%E4%B8%ADView%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-07-06-分析Android中View的事件分发流程.html</id>
    <published>2016-07-06T02:27:04.000Z</published>
    <updated>2017-07-12T09:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会有事件分发机制"><a href="#为什么会有事件分发机制" class="headerlink" title="为什么会有事件分发机制"></a>为什么会有事件分发机制</h2><p>在Android中，View是以树形结构的形式存在的，View可能会重叠在一起，当我们点击的地方有多个View可以响应时，这个点击事件应该由哪个View来处理呢?很多情况下我们的应用都需要支持滑动操作，当处于不同层级的View都可以响应用户的滑动操作时，会出现滑动冲突。如何解决滑动冲突呢？为了解决这样的问题，就引入了事件分发机制。</p>
<p>在分析事件分发之前，有必要理清几个类之间的关系，先看一张类图。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170705149924486487719.png" alt="20170705149924486487719.png"></p>
<h3 id="Activity与Window、DecorView"><a href="#Activity与Window、DecorView" class="headerlink" title="Activity与Window、DecorView"></a>Activity与Window、DecorView</h3><p>Activity是Android中处理UI交互的组件，但是Activity并没有直接与View产生联系，而是通过Window产生关联。具体可以查看Activity的attach方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">final void attach(Context context, ActivityThread aThread,</div><div class="line">            Instrumentation instr, IBinder token, int ident,</div><div class="line">            Application application, Intent intent, ActivityInfo info,</div><div class="line">            CharSequence title, Activity parent, String id,</div><div class="line">            NonConfigurationInstances lastNonConfigurationInstances,</div><div class="line">            Configuration config, String referrer, IVoiceInteractor voiceInteractor,</div><div class="line">            Window window) &#123;</div><div class="line">        attachBaseContext(context);</div><div class="line">        mFragments.attachHost(null /*parent*/);</div><div class="line">        mWindow = new PhoneWindow(this, window);</div><div class="line">        mWindow.setWindowControllerCallback(this);</div><div class="line">        mWindow.setCallback(this);</div><div class="line">        mWindow.setOnWindowDismissedCallback(this);</div><div class="line">        mWindow.getLayoutInflater().setPrivateFactory(this);</div><div class="line">        ……</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>Window是一个抽象类，它有一个唯一实现子类PhoneWindow。Window可以理解为“UI界面的外框”，外框内的具体布局，背景的显示，标题栏的管理，都在window的管理范畴，是view的最顶层的管理容器。DecorView则是PhoneWindow类的一个内部类，继承于FrameLayout，DecorView是整个ViewTree的最顶层View，它是一个FrameLayout布局，代表了整个应用的界面。在该布局下面，有标题view和内容view这两个子元素。其中内容view对应着Acitivity中setContentView()中的view。</p>
<p>Window的另外一个作用，负责与WindowManagerService进行通信，但具体的实现逻辑并没有在Window中，而是交由Window的管理者WindowManager。WindowManager是一个接口，WindowManagerImpl中是其具体实现类，在WindowManagerImpl中通过WindowMangerGlobal来统一管理。</p>
<h3 id="View与ViewRoot"><a href="#View与ViewRoot" class="headerlink" title="View与ViewRoot"></a>View与ViewRoot</h3><p>从源码上看,ViewRoot与View没有任何血缘关系，ViewRoot是final类型，没有派生子类，也不是View的子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> @SuppressWarnings(&#123;&quot;EmptyCatchBlock&quot;&#125;)</div><div class="line"> public final class ViewRoot extends Handler implements ViewParent,</div><div class="line">View.AttachInfo.Callbacks &#123;</div><div class="line">……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ViewRoot是连接WindowManager与DecorView的纽带，View的绘制流程都是通过ViewRoot来完成的。</p>
<p>在ViewRootImpl的构造方法中，有一个成员变量mWindowSession，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ViewRootImpl(Context context, Display display) &#123;</div><div class="line">    mContext = context;</div><div class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</div><div class="line">    mDisplay = display;</div><div class="line">    mBasePackageName = context.getBasePackageName();</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看WindowManagerGlobal.getWindowSession()的实现，发现mWindowSession它是ViewRoot利用WMS的openSession()接口来创建得到，用于ViewRoot到WMS的连接，从而实现与WindowManagerService的通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public static IWindowSession getWindowSession() &#123;</div><div class="line">        synchronized (WindowManagerGlobal.class) &#123;</div><div class="line">            if (sWindowSession == null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    InputMethodManager imm = InputMethodManager.getInstance();</div><div class="line">                    IWindowManager windowManager = getWindowManagerService();</div><div class="line">                    sWindowSession = windowManager.openSession(</div><div class="line">                            new IWindowSessionCallback.Stub() &#123;</div><div class="line">                                @Override</div><div class="line">                                public void onAnimatorScaleChanged(float scale) &#123;</div><div class="line">                                    ValueAnimator.setDurationScale(scale);</div><div class="line">                                &#125;</div><div class="line">                            &#125;,</div><div class="line">                            imm.getClient(), imm.getInputContext());</div><div class="line">                    ValueAnimator.setDurationScale(windowManager.getCurrentAnimatorScale());</div><div class="line">                &#125; catch (RemoteException e) &#123;</div><div class="line">                    Log.e(TAG, &quot;Failed to open window session&quot;, e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return sWindowSession;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>ViewRootImpl并非ViewRoot的实现类</strong>，两个类都是final类型，没有派生子类，这两个类实现的功能是一样的，这是在Android不同版本中的称呼不同而已。<br>总结一下：</p>
<ol>
<li>Activity通过Window的唯一派生类PhoneWindow与view产生联系；</li>
<li>PhoneWindow内部的DecorView是View的最顶层容器。</li>
<li>ViewRoot是WindowServiceManager与DecorView的纽带，View的绘制流程是都是通过ViewRoot完成。</li>
</ol>
<h2 id="三个重要的事件分发方法"><a href="#三个重要的事件分发方法" class="headerlink" title="三个重要的事件分发方法"></a>三个重要的事件分发方法</h2><p>所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。三个方法之间的关系，可以通过一段伪代码的表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">       boolean consume = false;</div><div class="line">       if (onInterceptTouchEvent(ev)) &#123;</div><div class="line">               consume = onTouchEvent(ev);</div><div class="line">       &#125; else &#123;</div><div class="line">               consume = child.dispatchTouchEvent(ev);</div><div class="line">       &#125;</div><div class="line">       return consume;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>通过上面的伪代码，我们也可以大致了解点击事件的传递规则：对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。</p>
<h3 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h3><p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</p>
<h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a>onInterceptTouchEvent</h3><p>Activity和View中是没有该事件，如果在Activity作为事件的原始分发者，如果进行拦截，事件就无法传递到ViewGroup，整个屏幕就无法响应事件，同样View作为事件传递的最末端，没有需要事件分发的子控件，要么消费事件，要么不处理回传。</p>
<p>onInterceptTouchEvent是dispatchTouchEvent内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p>
<h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。</p>
<h2 id="事件分发流程"><a href="#事件分发流程" class="headerlink" title="事件分发流程"></a>事件分发流程</h2><p>如果想让图中的View获取事件，事件的分发流程是怎样的？<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170705149924809957687.png" alt="20170705149924809957687.png"></p>
<p>当屏幕被点击时，由于View是树形结构，首先事件传递到Activity，Activity在其dispatchTouchEvent中进行处理，然后传递到Window的实际实现类PhoneWindow，PhoneWindow所有关于事件的处理是在其内部类DecorView中完成的，如果在DecorView中的dispatchTouchEvent对事件不进行拦截，会将事件传递到RootView，在RootView的dispatchTouchEvent中调用onInterceptTouchEvent,如果对事件不进行拦截处理，事件会传递到ViewGroup，在ViewGroup中如果对事件不进行拦截，事件会传递到View，View收到事件后，在onTouchEvent中进行消耗处理，同时返回true，返回值经View-&gt;ViewGroup-&gt;RootView-&gt;DecorView-&gt;PhoneWindow-&gt;Activity的路径，最终会传到事件的发起点Activity，至此，完成了事件从Activity到View的分发过程。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017070614993116201116.png" alt="2017070614993116201116.png"></p>
<h2 id="OnTouchListener与OnClickListener"><a href="#OnTouchListener与OnClickListener" class="headerlink" title="OnTouchListener与OnClickListener"></a>OnTouchListener与OnClickListener</h2><p>当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的OnTouchListener，其优先级优先级比onTouchEvent要高。在onTouchEvent方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件传递的尾端。</p>
<h2 id="事件分发的完整过程"><a href="#事件分发的完整过程" class="headerlink" title="事件分发的完整过程"></a>事件分发的完整过程</h2><p>首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用。由于Window的唯一实现是PhoneWindow，PhoneWindow将事件直接传递给了DecorView，由于DecorView继承自FrameLayout且是父View，所以最终事件会传递给View。即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。</p>
<p>事件达到顶级View（一般是一个ViewGroup）以后，会调用ViewGroup的dispatchTouchEvent方法，然后的逻辑是这样的：如果顶级ViewGroup拦截事件即onInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvent。在onTouchEvent中，如果设置了mOnClickListener，则onClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此为止，事件已经从顶级View传递给了下一层View，接下来的传递过程和顶级View是一致的，如此循环，完成整个事件的分发。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于事件传递的机制，这里给出一些结论，根据这些结论可以更好地理解整个传递机制：</p>
<ol>
<li>同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。</li>
<li>正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。</li>
<li>某个View一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的onInterceptTouchEvent不会再被调用。这条也很好理解，就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列内的其他方法都直接交给它来处理，因此就不用再调用这个View的onInterceptTouchEvent去询问它是否要拦截了。</li>
<li>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。</li>
<li>如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</li>
<li>ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouch-Event方法默认返回false。</li>
<li>View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。</li>
<li>View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。</li>
<li>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。</li>
<li>onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 任玉刚.Android开发艺术探索[M].电子工业出版社, 2015.9:1 - 507</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-07-06-分析Android中View的事件分发流程.html">http://www.sguotao.com/Android进阶-2016-07-06-分析Android中View的事件分发流程.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么会有事件分发机制&quot;&gt;&lt;a href=&quot;#为什么会有事件分发机制&quot; class=&quot;headerlink&quot; title=&quot;为什么会有事件分发机制&quot;&gt;&lt;/a&gt;为什么会有事件分发机制&lt;/h2&gt;&lt;p&gt;在Android中，View是以树形结构的形式存在的，View可能会
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="View" scheme="http://www.sguotao.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中View的工作流程</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-07-07-%E5%88%86%E6%9E%90Android%E4%B8%ADView%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-07-07-分析Android中View的绘制流程.html</id>
    <published>2016-07-06T02:27:04.000Z</published>
    <updated>2017-07-13T08:12:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分析View的工作流程时，需要先分析一个很重要的类,MeasureSpec。这个类在View的测量(Measure)过程中会用到。</p>
<h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><p>MeasureSpec是View的静态内部类，可以理解为是一种测量规格，是一个32位int值，高2位代表SpecMode，低30位代表SpecSize，SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170712149986966667975.png" alt="20170712149986966667975.png"><br>SpecMode有三种模式，分别为：</p>
<ol>
<li>UNSPECIFIED:父容器不对View做限制</li>
<li>EXACTLY:父容器已经检测出View所需的精确大小，View的大小为SpecSize中指定的值。</li>
<li>AT_MOST:父容器指定了一个SpecSize，View的大小不大大于该值。</li>
</ol>
<h3 id="MeasureSpec与LayoutParams"><a href="#MeasureSpec与LayoutParams" class="headerlink" title="MeasureSpec与LayoutParams"></a>MeasureSpec与LayoutParams</h3><p>系统通过MeasureSpec作为测量规格，对View进行测量，但在设置View的宽高时，都是通过LayoutParams，因此系统在测量View的时候，会将LayoutParams在父容器的约束下转换成MeasureSpec，然后根据确定的MeasureSepc得到View测量后的宽高。有几点需要说明：</p>
<ol>
<li>LayoutParams和父容器一起确定MeasureSpec；</li>
<li>对于DecorView，其MeasureSpec是由窗口的尺寸和自身的LayoutParams共同确定的；由于窗口尺寸是确定的，因此主要与DecorView自身的LayoutParams有关，具体的对应关系如下图描述：<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017071314999163655874.png" alt="2017071314999163655874.png"></li>
<li>对于普通View，其MeasureSpec是由父容器的MeasureSpec和自身的LayoutParams共同确定的。其对应关系如下图描述：<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017071314999164201334.png" alt="2017071314999164201334.png"><br><strong>对普通View，简单总结一下：</strong></li>
</ol>
<ul>
<li>当View采用固定宽/高的时候，不管父容器的MeasureSpec是什么，View的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小。</li>
<li>当View的宽/高是match_parent时，如果父容器的模式是精准模式，那么View也是精准模式并且其大小是父容器的剩余空间；如果父容器是最大模式，那么View也是最大模式并且其大小不会超过父容器的剩余空间。</li>
<li>当View的宽/高是wrap_content时，不管父容器的模式是精准还是最大模式，View的模式总是最大模式并且大小不能超过父容器的剩余空间。</li>
<li>在UNSPECIFIED模式中，系统内部会进行多次Measure过程，才能确定View的宽高。</li>
</ul>
<h2 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h2><p>ViewRoot是连接WindowManager与DecorView的纽带，View的绘制流程都是通过ViewRoot来完成的。</p>
<p>View的工作流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制在屏幕上。用一张图来描述View的工作过程：<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170712149985760240189.png" alt="20170712149985760240189.png"></p>
<h3 id="View的测量-Measure-过程"><a href="#View的测量-Measure-过程" class="headerlink" title="View的测量(Measure)过程"></a>View的测量(Measure)过程</h3><p>在View的Measure过程中，完成对View的测量，确定View的宽高。ViewRoot中的performTraversals()会依次调用ViewRoot中的performMeasure()、performLayout()和performDraw()三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程。其中在performMeasure()中会调用View的measure()方法，在measure()方法中又会调用onMeasure()方法。在onMeasure()中将View宽/高的测量值传给setMeasuredDimension()方法，完成View的测量过程。</p>
<p>对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有子元素的measure()方法，各个子元素再递归去执行这个过程。和View不同的是，ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，因为不同的ViewGroup子类有不同的布局特性，这导致它们的测量细节各不相同。在ViewGroup的onMeasure()中最后也会调用setMeasuredDimension()方法，完成测量过程。</p>
<p>measure完成以后，通过getMeasuredWidth()/Height()方法就可以正确地获取到View的测量宽/高。需要注意的是，在某些极端情况下，系统可能需要多次measure才能确定最终的测量宽/高，在这种情形下，在onMeasure方法中拿到的测量宽/高很可能是不准确的。一个比较好的习惯是在onLayout方法中去获取View的测量宽/高或者最终宽/高。</p>
<h3 id="View的布局-Layout-过程"><a href="#View的布局-Layout-过程" class="headerlink" title="View的布局(Layout)过程"></a>View的布局(Layout)过程</h3><p>Layout的作用是ViewGroup用来确定子元素的位置，ViewRoot中的performLayout()中会调用View的layout()方法，在layout()方法中onLayout()方法又会被调用。onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正实现onLayout方法。</p>
<p>当ViewGroup的位置被确定后，它在onLayout()中会遍历所有的子元素并调用其layout()方法，layout()方法确定View本身的位置，而onLayout()方法则会确定所有子元素的位置。</p>
<h3 id="View的绘制-Draw-过程"><a href="#View的绘制-Draw-过程" class="headerlink" title="View的绘制(Draw)过程"></a>View的绘制(Draw)过程</h3><p>Draw的作用是将View绘制到屏幕上面。View的绘制过程遵循如下几步：</p>
<ol>
<li>绘制背景background.draw(canvas)</li>
<li>绘制自己（onDraw）</li>
<li>绘制children（dispatchDraw）</li>
<li>绘制装饰（onDrawScrollBars）</li>
</ol>
<p>View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递了下去。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 任玉刚.Android开发艺术探索[M].电子工业出版社, 2015.9:1 - 507</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-07-07-分析Android中View的绘制流程.html">http://www.sguotao.com/Android进阶-2016-07-07-分析Android中View的绘制流程.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分析View的工作流程时，需要先分析一个很重要的类,MeasureSpec。这个类在View的测量(Measure)过程中会用到。&lt;/p&gt;
&lt;h2 id=&quot;MeasureSpec&quot;&gt;&lt;a href=&quot;#MeasureSpec&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="View" scheme="http://www.sguotao.com/tags/View/"/>
    
  </entry>
  
</feed>
