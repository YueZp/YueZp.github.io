<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sguotao.com/"/>
  <updated>2017-06-02T06:54:34.000Z</updated>
  <id>http://www.sguotao.com/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【转】程序员为什么会忧虑自己的未来?</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2017-06-02-%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BF%A7%E8%99%91%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%AA%E6%9D%A5.html"/>
    <id>http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html</id>
    <published>2017-06-02T02:22:08.000Z</published>
    <updated>2017-06-02T06:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。</p>
</blockquote>
<a id="more"></a>
<p>文章作者:陈驰远，青橙科技CTO，互联网行业的一名老兵，以下是部分摘录。更多讨论，请戳原文。<br>原文链接:<a href="https://juejin.im/post/5930acd6a0bb9f0058af41e5" target="_blank" rel="external">https://juejin.im/post/5930acd6a0bb9f0058af41e5</a></p>
<p>从去年开始，我参加了一些分享交流，也对外发过一些自己对工作所遇问题的思考。不少程序员加我好友咨询问题，几乎每个人问的问题都跟职业规划有关。这提醒了我，其实我自己也一直在思考同样的问题并尝试规划未来。于是想和大家分享一下自己在这方面的感悟。</p>
<p>本文仅从我自己的角度来剖析对程序员职业规划的看法，并不全面。而下文中提到的程序员群体也泛指在一线具体执行编码任务的程序员，不包含一些高精尖技术岗位的专业技术人才或是已经有自己明确职业规划，已经进阶成功的工程师。</p>
<h2 id="什么引发了焦虑？"><a href="#什么引发了焦虑？" class="headerlink" title="什么引发了焦虑？"></a>什么引发了焦虑？</h2><p>互联网是一个新兴但高速发展的行业。新兴意味着没有那么多的职场楷模给新人指明方向，也没有一套公认的稳定可复制的职业发展路线。高速发展意味着变革与竞争，大量新人因为行业红利涌入，你无时无刻要跟一群优秀的热血青年同场竞技。</p>
<p>互联网行业工作强度很大，而中国的互联网从业者更忙。程序员更是战场中的排头兵，身体健康的透支导致很难长期抗战。当你意识到自己跟不上节奏的时候，不管是出于对身体状况的担忧，还是对未来潜在威胁的恐惧，又怎会不感到焦虑呢？而程序员的职业特性加剧了这种焦虑，主要表现在以下几方面：</p>
<h2 id="程序员职业复利性较低。"><a href="#程序员职业复利性较低。" class="headerlink" title="程序员职业复利性较低。"></a>程序员职业复利性较低。</h2><h3 id="什么叫复利性？"><a href="#什么叫复利性？" class="headerlink" title="什么叫复利性？"></a>什么叫复利性？</h3><p>就如同利息的计算方法一样，在本金相同的情况下，复利获得的利息回报要高于单利，而年期越长，复利效应越高。职业一样有复利效应，一个复利高的职业在职业生涯中后期会展现出越来越高的价值。医生、律师都是复利性很高的职业。而程序员职业复利性较低，主要有两个原因：</p>
<ul>
<li><strong>专业性强，通用性差。不同技术种类有着自己的技术栈，共用的只有设计思想、编程范式，基础技术等通用知识。</strong></li>
<li><strong>在没有明确规划的情况下，大多数程序员日常工作积累的不是通用知识与综合能力，而仅仅是某项技术的熟练度与经验。这是根本原因。</strong><br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170602149637117527702.jpg" alt="后端技术栈"><br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170602149637119625879.jpg" alt="前端技术栈"><br>这造成了一个问题——当职业生涯遇到瓶颈时，程序员很难完成一次完美的进阶。让我们分析下最常见的三类方案：</li>
</ul>
<ol>
<li><p><strong>技术职位之间的转岗。</strong>这是最普遍的一种情况，Android转IOS，后端转前端等都在此列。虽然设计原则、编程范式等技术知识是通用的，但作为一线的执行者，技术的熟练度才是影响你工作效率的最大因素，你必须对技术栈非常熟悉才能体现工作的专业度。 转岗往往是无奈之举。</p>
</li>
<li><p><strong>技术转产品/运营岗。</strong>很多工程师抱怨产品经理设计的产品有问题，逻辑不严密，用起来很别扭。但让工程师做产品，问题一般会更多。为什么呢？最大的原因在于程序员的思维模式或多或少会受到编程的影响，偏向理性与具象化，缺少了感性的察言观色以及换位思考的能力。设计好一个产品，逻辑严密只是条件之一，但并不是最重要的条件。产品经理需要从用户的行为中挖掘出用户真正的需求，提炼归纳并设计成一个可用的产品。这是大多数程序员很难做好的事情。</p>
</li>
<li><p><strong>技术转管理岗。</strong>BAT都有自己的M岗位，高工都可以选择是继续走技术路线还是尝试走管理路线。很多程序员安慰自己，哪天真写不动代码了，那我就做技术经理吧。但我认为管理岗的转变比前面两类都难。管理是一门很深的学问，执行和管理是两回事，需要从根本上改变思维模式。评判一个工程师的好坏可以看工程师的产出，而评判一个管理者的好坏在于整个团队的产出和效率。很多优秀的程序员自己技术能力很强，却很难带领整个团体一起向前进。</p>
</li>
</ol>
<h2 id="程序员职业的壁垒没想象中高，鲁棒性低。"><a href="#程序员职业的壁垒没想象中高，鲁棒性低。" class="headerlink" title="程序员职业的壁垒没想象中高，鲁棒性低。"></a>程序员职业的壁垒没想象中高，鲁棒性低。</h2><p>鲁棒性也指抗变换性，一个好的职业需要有高的鲁棒性。大部分程序员把自己的职业与某项技能绑定。做过编程的都知道，一个高耦合低抽象的编码鲁棒性一定低。互联网行业变化太快，回头看下诺基亚的发展，Windows桌面应用开发，整个行业如同大浪淘沙。随着云平台的崛起，公有化平台的发展，API服务的开放，可以预见从业者的工作效率会大幅提高，同时很多职业可能会再次洗牌：基础运维工程师，DBA，基础算法工程师，安全工程师，图像算法工程师，数据工程师等等都在此列。</p>
<p>从另外一个角度来说，假设你运气很好，选择了一项长期热门的技术比如Web前端开发。但是因为行业红利太高，无数聪明、努力、上进的热血青年涌入其中。随着社区的发展，在线教育的普及，达到同样熟练度的时间越来越短，而热门互联网技术的发展是以月计，你需要花费大量的时间去学习积累新技术。新人与你的差距会越来越小，你会随时面临被超车的局面。这意味着，很多时候即使你认为自己经验更丰富，能力更强，但你却得不到理想的职位及薪资待遇。</p>
<h2 id="程序员职业能撬动的价值有限。"><a href="#程序员职业能撬动的价值有限。" class="headerlink" title="程序员职业能撬动的价值有限。"></a>程序员职业能撬动的价值有限。</h2><p>这个概念受启发于《格鲁夫给经理人的第一课》一书。格鲁夫试图定量的分析经理人的产出，于是提出了一个公式：经理人的产出 = 他直接管辖部门的产出 + 他间接影响所及部门的产出。为了定量的分析职业的价值，我也引入了一个公式：产出的价值 = 他自身的产出 + 他直接影响部门的产出 + 他间接影响所及部门的产出</p>
<p><strong>职业能影响的人越多，创造的价值越高，职业的上限价值也越高。</strong></p>
<p>互联网行业的供求关系以及价值体系，造成了一个现象：程序员供不应求使其入行薪资高，但是工作五年以上薪资趋向于稳定。对于绝大部分公司的绝大部分职位，当熟练度和经验达到某一个阈值的时候，选择成本是趋同的，自身效率提高所能带动的价值提高已经很有限。正因为如此，从业者在享受了薪资高速增长之后，很难接受薪资增幅趋缓，职业生涯遇到瓶颈引发焦虑。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017060214963712208098.jpg" alt="薪资待遇"></p>
<h2 id="我的规划是什么？"><a href="#我的规划是什么？" class="headerlink" title="我的规划是什么？"></a>我的规划是什么？</h2><p>分析了这么多，我最想表达的意思是：所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。</p>
<p>首先我会分析自己的特点，这是建立与他人的差异性和自己独特标签的关键所在，也是最值得加强的地方。我最大的特点是什么？<br><strong>有野心。</strong>我不想选择一种得过且过的生活，而会选择一个产出价值更高的事情来做，影响更多的人，创造更高的价值。<br><strong>会沟通。</strong>我沟通能力不错，既可以对外谈合作，又可以对内做管理。这会是我相对一般技术型程序员一个很大的不同。<br><strong>专业强。</strong>在专业技能层面我有较深的认识与理解，虽然谈不上顶尖，但我知道怎么运用自己的知识能力找到最适合现状的方法解决几乎所有日常问题。技术积累永远是我最核心的竞争力。</p>
<p>知道自己特点之后，我会以此为基础来增强自己的不可替代性。不可替代性不仅仅只是基于个人的能力，还有这几点是需要日常注意积累的：<br><strong>健康的身体。</strong>在经历过一次生病后，我更加意识到拥有一个健康的身体才是最重要的。积极健身可是我们青橙员工的必备素质。<br><strong>思想与格局的高度。</strong>思想的高度并不是一朝一夕就能拔高的，而是在经历了来自工作与生活的各种挑战之后，静下心来反思总结，从而慢慢积累并提升。<br><strong>人脉与影响力。</strong>乐于记录和分享自己的工作感悟。抓住向其他人学习的机会，比如参加一些会议或交流，不管是同行业还是其他行业的，都是很有必要的。人脉和影响力的积累与格局的高度也是相辅相成的，与某些方面比自己优秀的人交流往往会收获满满。<br><strong>当我有了明确的方向并且每天都能看到自己进步的时候，就会对未来充满憧憬。</strong>我给自己未来的定位是做一名解决者。何谓解决者？面对未知或已知的问题，知道如何分析本质原因，制定并实施解决方案。附加打油诗一首：</p>
<blockquote>
<p>文能设计定需求，武可写码做架构。<br>进做招商引融资，退做大V占风口。<br>产品体验包上线，还要招人带节奏。</p>
</blockquote>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html">http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】ReactNative Flex整理</title>
    <link href="http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html"/>
    <id>http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html</id>
    <published>2017-05-17T02:27:04.000Z</published>
    <updated>2017-05-17T08:04:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex容器属性</h2><ul>
<li><p><strong>flex-direction 属性决定主轴的方向（即项目的排列方向）。</strong></p>
<pre><code>row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。
</code></pre></li>
<li><p><strong>flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</strong></p>
<pre><code>nowrap（默认）：不换行。
wrap：换行，第一行在上方。
wrap-reverse：换行，第一行在下方。
</code></pre></li>
<li><p><strong>flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</strong></p>
</li>
<li><p><strong>justify-content 属性定义了项目在主轴上的对齐方式。</strong></p>
<pre><code>flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，项目之间的间隔都相等。
space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
</code></pre></li>
<li><p><strong>align-items 属性定义项目在交叉轴上如何对齐。</strong></p>
<pre><code>flex-start：交叉轴的起点对齐。
flex-end：交叉轴的终点对齐。
center：交叉轴的中点对齐。
baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
</code></pre></li>
<li><p><strong>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</strong></p>
<pre><code>flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。
</code></pre></li>
</ul>
<h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h2><ul>
<li><p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
</li>
<li><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
</li>
<li><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
</li>
<li><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
</li>
<li><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
</li>
<li><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
</li>
</ul>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html">http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flex容器属性&quot;&gt;&lt;a href=&quot;#Flex容器属性&quot; class=&quot;headerlink&quot; title=&quot;Flex容器属性&quot;&gt;&lt;/a&gt;Flex容器属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;flex-direction 属性决定主轴的方向（即项目的
    
    </summary>
    
      <category term="ReactNative" scheme="http://www.sguotao.com/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://www.sguotao.com/tags/ReactNative/"/>
    
      <category term="Flex" scheme="http://www.sguotao.com/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】明朝那些事儿</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2017-05-11-%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF.html"/>
    <id>http://www.sguotao.com/读书笔记-2017-05-11-明朝那些事儿.html</id>
    <published>2017-05-11T04:00:00.000Z</published>
    <updated>2017-05-16T07:40:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>《明朝那些事儿(典藏全集)(套装共9本)》共九部，包括《朱元璋，从和尚到皇帝》、《朱棣：逆子还明明君》、《太监弄乱的王朝》、《妖孽横行的宫廷》等。《明朝那些事儿(典藏全集)(套装共9本)》这篇文主要讲述的是从1344年到1644年这三百年间关于明朝的一些事情，以史料为基础，以年代和具体人物为主线，并加入了小说的笔法，对明朝十七帝和其他王公权贵和小人物的命运进行全景展示，尤其对官场政治、战争、帝王心术着墨最多，并加入对当时政治经济制度、人伦道德的演义。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2017-05-11-明朝那些事儿.html">http://www.sguotao.com/读书笔记-2017-05-11-明朝那些事儿.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;《明朝那些事儿(典藏全集)(套装共9本)》共九部，包括《朱元璋，从和尚到皇帝》、《朱棣：逆子还明明君》、《太监弄乱的王朝》、
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android动画分析三 Property Animation</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-05-20-android-property-animation.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-05-20-android-property-animation.html</id>
    <published>2017-05-02T02:27:04.000Z</published>
    <updated>2017-06-01T07:08:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。<br><a href="/blog/2016/05/Android进阶-2016-05-18-android-view-animation.html">Android动画分析一 View Animation</a><br><a href="/blog/2016/05/Android进阶-2016-05-19-android-drawable-animation.html">Android动画分析二 Drawable Animation</a><br>在这一篇中，将对Android3.0之后出现的属性动画(Property Animation)进行整理。既然已经有了View Animation和Drawable Animation了，为什么还要引入Property Animation呢？</p>
<blockquote>
<p>1.使用动画场景的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么View动画就不能再帮我们忙了，也就是说View动画在功能和可扩展方面都有相当大的局限性。</p>
<p>2.Property Animation是改变对象的属性，不仅仅是对view本身做操作。传统的View动画只是改变view的显示效果，并不改变view的属性。郭霖介绍一个比较形象的例子🌰，比如说，现在屏幕的左上角有一个按钮，然后我们通过View动画将它移动到了屏幕的右下角，点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过View动画将这个按钮绘制到了屏幕的右下角而已。属性动画的实现机制是通过对目标对象进行赋值并修改其属性来实现的，那么之前所说的按钮显示的问题也就不复存在了，如果我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。</p>
</blockquote>
<h2 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h2><p>Property Animation是Android3.0(API11)之后引入的动画，属性动画的引入，极大的地丰富了Android的动画体系，与传统的View动画和Drawable动画还是存在一些差别，在使用的过程中需要留意：<br>1.传统动画的xml文件存放在res/anim/目录下，而属性动画的xml文件存放在res/animator/目录下，虽然animator有这anim的前缀，但这是两个完全不同的目录。由于存放目录的不同，因此在代码中引用的方式也会有所差别，传统动画可以通过R.anim.filename获得动画的引用，属性通过则通过R.animator.filename获得动画的引用。<br>2.属性动画常用的Java类与传统动画Java类很相似，比如属性动画集AnimatorSet和传统动画集AnimationSet，在使用时注意区别，可以简化记忆“后缀是mator的是属性动画，后缀是mation的是传统动画”。属性动画中，常用的类，可以简单的用下面的类图进行概括。</p>
<h3 id="Animatior"><a href="#Animatior" class="headerlink" title="Animatior"></a>Animatior</h3><h3 id="ValueAnimator-和-ObjectAnimator"><a href="#ValueAnimator-和-ObjectAnimator" class="headerlink" title="ValueAnimator 和 ObjectAnimator"></a>ValueAnimator 和 ObjectAnimator</h3><h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h3><h2 id="属性动画实现点赞效果"><a href="#属性动画实现点赞效果" class="headerlink" title="属性动画实现点赞效果"></a>属性动画实现点赞效果</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="external">Property Animation</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43536355" target="_blank" rel="external">Android属性动画完全解析(上)，初识属性动画的基本用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43816093" target="_blank" rel="external">Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/44171115" target="_blank" rel="external">Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-05-20-android-property-animation.html">http://www.sguotao.com/Android进阶-2016-05-20-android-property-animation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。&lt;br&gt;&lt;a href=&quot;/blog/2016/05/Android进阶-2016-05-
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="代码库" scheme="http://www.sguotao.com/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
      <category term="动画" scheme="http://www.sguotao.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】人民的名义</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2017-05-04-%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89.html"/>
    <id>http://www.sguotao.com/读书笔记-2017-05-04-人民的名义.html</id>
    <published>2017-05-01T04:00:00.000Z</published>
    <updated>2017-05-16T03:10:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用五一假期的时间，读完了小说《人民的名义》，看完小说，看了电视剧，可能是出于剧情的考虑，电视剧对书中的内容作了部分的扩展，但是整体的主线被完整的保存了下来。看一本小说，有时候很难理清小说中出现的各个人物的关系，这种感觉，在读国外小说时，感觉尤其明显。先上一张剧中的任务关系图(来源网络)<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170504149389960494219.png" alt="20170504149389960494219.png"></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2017-05-04-人民的名义.html">http://www.sguotao.com/读书笔记-2017-05-04-人民的名义.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用五一假期的时间，读完了小说《人民的名义》，看完小说，看了电视剧，可能是出于剧情的考虑，电视剧对书中的内容作了部分的扩展，但是整体的主线被完整的保存了下来。看一本小说，有时候很难理清小说中出现的各个人物的关系，这种感觉，在读国外小说时，感觉尤其明显。先上一张剧中的任务关系
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android内存泄露</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2017-03-24-android-memory-leak.html"/>
    <id>http://www.sguotao.com/Android进阶-2017-03-24-android-memory-leak.html</id>
    <published>2017-03-24T02:27:04.000Z</published>
    <updated>2017-05-03T12:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存泄露与内存溢出"><a href="#内存泄露与内存溢出" class="headerlink" title="内存泄露与内存溢出"></a>内存泄露与内存溢出</h2><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露(Memory Leak)是指无用对象（不再使用的对象）持续占有内存，或者无用对象的内存得不到及时释放，从而造成内存空间得不到有效的利用。在Java中，内存泄露的原因，通常是长生命周期的对象，持有短生命周期对象的引用。在《深入理解Java虚拟机》中的解释是，当无用对象一直被有用对象引用，导致无用对象可达，JVM无法对无用对象完成回收。从而造成内存泄露。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170327149058275225194.png" alt="内存泄露"></p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出(Out of Memory)是指程序在运行过程中，无法申请到足够的的内存导致的一种错误。内存泄露是会导致内存溢出，但不是导致内存溢出的唯一原因。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170327149058290012605.png" alt="20170327149058290012605.png"></p>
<h2 id="Java中的内存泄露"><a href="#Java中的内存泄露" class="headerlink" title="Java中的内存泄露"></a>Java中的内存泄露</h2><h3 id="Java-内存分配"><a href="#Java-内存分配" class="headerlink" title="Java 内存分配"></a>Java 内存分配</h3><p>Java中的内存分配主要分三块，静态存储区，栈区和堆区。</p>
<ul>
<li>静态存储区，编译时分配，存在于程序的整个运行期间，主要用于存放静态数据和常量。</li>
<li>栈区，在方法执行时，用于存放方法内部的局部变量，方法结束后，内存释放。</li>
<li>堆区，通常用来存放new出来的对象，由JVM进行回收处理。</li>
</ul>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170329149077275371348.png" alt="20170329149077275371348.png"><br>从JDK1.2开始，Java将对象的引用分为了强引用、软引用、弱引用和虚引用。</p>
<ul>
<li>强引用(Strong Reference),平时使用最多的一种引用，<strong>如果一个对象的引用方式是强引用，垃圾回收器不会对该对象进行回收，即使出现了内存空间不足的情况，JVM会抛出Out of Memory,也不会对强引用的对象进行回收。</strong></li>
<li>软引用(Soft Reference),在对象的引用强度上若于强引用，对于弱引用的对象，<strong>当内存不足时，JVM会回收软引用对象，释放内存空间</strong>。通常情况下，缓存的创建，适合使用软引用的方式。</li>
<li>弱引用(Weak Reference),在对象的引用强度上，弱于软引用，相对于强引用对象的不可回收，弱引用的对象，不存在这种情况，<strong>在垃圾回收器工作时，不论内存空间是否充足，都会对弱引用的对象进行回收。</strong>弱引用的作用，主要在于解决强引用对象之前的耦合关系，如在集合类中，任何Java对象都可以作为键来使用，当一个键值对被放入到集合中，集合对象本身就对这些键和值产生引用，如果是强引用，只要集合对象本身存在，其中包含的键和值就不会被回收，当集合包含的键和值越来越多时，最后会消耗掉JVM中的全部内存。</li>
<li>虚引用(Phantom Reference)，使用的情况并不多见，主要用来实现比较清晰的内存控制，这对于内存有限的移动设备是很有意义的。<strong>虚引用用来跟踪对象被垃圾回收器回收的活动</strong>，虚引用和软引用，弱引用的一个明显的区别是，虚引用必须和引用队列联合使用，通过检查引用队列中的内容，可以判断一个对象是否即将被回收。</li>
</ul>
<p>一个对象的引用类型有多个，怎么判断？<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170329149077630884381.png" alt="20170329149077630884381.png"><br>判定规则如下：</p>
<ul>
<li>单条引用链上的可达性，以最弱的一个引用类型来决定；</li>
<li>多条引用链上的可达性，以最强的一个引用类型来决定；</li>
</ul>
<p>我们假设上图中，1和3为强引用，5为软引用，7为弱引用。对于对象5的引用类型，在路径1–5中，5为软引用类型，依据规则1，对象5为软引用类型。在路径3–7中，7为弱引用类型，所以对象5为弱引用类型。依据规则2，多条引用链上的可达性，以最强的一个引用类型决定，因此，对象5的引用类型为软引用类型。</p>
<h2 id="内存泄露检测工具"><a href="#内存泄露检测工具" class="headerlink" title="内存泄露检测工具"></a>内存泄露检测工具</h2><h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><p>Memory Monitors是AndroidStudio自带的一个性能检测工具，主要包含以下几个功能：</p>
<ul>
<li>实时查看app的内存使用情况；</li>
<li>能够比较直观的了解到app的运行卡顿是否跟GC的频繁操作有关；</li>
<li>能够了解到app的crash是否跟内存溢出有关；</li>
<li>能够发现内存抖动(在短时间内分配大量内存，频繁的引起GC操作)</li>
</ul>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170401149101636441749.png" alt="20170401149101636441749.png"></p>
<h3 id="DDMS-Dump"><a href="#DDMS-Dump" class="headerlink" title="DDMS Dump"></a>DDMS Dump</h3><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017040114910150822979.png" alt="2017040114910150822979.png"><br><strong>什么是Java Heap Dump？</strong>首先需要搞明白什么是Java Heap，Java Heap是分配给实例类和数组对象运行数据区，所有Java线程在运行期间共享heap中的数据，Java Heap Dump相当于在应用运行时，某个时间点进行一次快照，在AndroidStudio中，快照会被保存为.hprof类型的文件，保存在captures目录中。</p>
<p>分析.hprof文件，我们可以将.hprof视图分成A、B、C三个部分，在A部分中，可以看到app的整个堆内存信息，显示了在堆内存中的所有的java类。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Total Count</td>
<td style="text-align:center">内存中，当前Java类的实例数量</td>
</tr>
<tr>
<td style="text-align:center">Heap Count</td>
<td style="text-align:center">堆内存中，当前Java类的实例数量</td>
</tr>
<tr>
<td style="text-align:center">Size of</td>
<td style="text-align:center">当前Java类每个实例对象需要占用内存的物理大小</td>
</tr>
<tr>
<td style="text-align:center">Shallow Size</td>
<td style="text-align:center">当前Java实例对象占有的内存大小</td>
</tr>
<tr>
<td style="text-align:center">Retained Size</td>
<td style="text-align:center">释放当前Java实例对象后，节省的内存大小</td>
</tr>
</tbody>
</table>
<p>当选中A区域中的某个Java类，可以在B区域中看到选中Java类的所有实例对象。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Depth</td>
<td style="text-align:center">当前对象的深度</td>
</tr>
<tr>
<td style="text-align:center">Shallow Size</td>
<td style="text-align:center">当前对象占有的内存大小</td>
</tr>
<tr>
<td style="text-align:center">Dominating Size</td>
<td style="text-align:center">当前对象可支配的内存大小</td>
</tr>
</tbody>
</table>
<p>在B中看到选中Java类的所有实例对象的同时，在C区域能够看到哪些对象引用了该对象。</p>
<p><strong>什么是Allocation Tracker？</strong>Allocation Tracker主要用来追踪内存分配信息，Start Allocation Tracking 相当于在程序运行时，某个时间节点，对内存分配信息进行一次快照，生成的快照文件被保存为.alloc类型，保存在captures目录中。Allocation Tracker 也可以在Devices Monitor中启动，在Devices Monitor中使用时，需要设备有Root权限。</p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT(Eclipse Memory Analyzer)是一个堆转储文件分析工具，在Monitor的快照文件(.hprof)，需要转换成MAT可以打开的标准.hprof文件，使用Mat工具打开转换后的.hprof文件，会生成一个内存消耗整体状况的报告，从饼状图中，可以比较直观地看到哪些对象占用了多少的内存空间。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170419149258510813625.png" alt="20170419149258510813625.png"><br>这里介绍一下，MAT给我们提供的几个分析的维度。</p>
<ul>
<li>Histogram，在该视图中可以清晰的看出内存中对象的数量，及所占用内存空间的大小。</li>
<li>Dominator Tree:在该视图中，可以在线程的角度观察到哪些对象占用内存空间。</li>
<li>Top Consumers:从包，对象等角度，显示内存的占用情况，能够比较直观的找出占用内存比较多的对象。</li>
<li>Leak Suspects:分析内存泄露的情况，生成一份报表，给出一些problem的建议。</li>
</ul>
<p>下面介绍一些常用的操作，视图中支持正则表达式筛选，可以过滤出我们比较关心的对象，可以以列表或者树形的结构显示出来，其中：</p>
<ul>
<li>with incoming references:过滤出那些类引用了当前选中的类；</li>
<li>with outcoming references:过滤出当前选中类引用了哪些类；</li>
</ul>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017042014926559112895.png" alt="2017042014926559112895.png"></p>
<p>垃圾回收器会对虚拟机的内存空间，即堆空间中已经存在的对象进行识别，如果对象正在被引用，那么称其为存活对象，如果对象不在被引用，则为垃圾回收器回收的对象，这部分对象占用的内存空间可以被回收。</p>
<p>在垃圾回收机制中有一组元素被称为根元素集合，它们是一组被虚拟机直接引用的对象。堆空间中的每个对象都是由一个根元素为起点被层层调用的。所以，一个对象如果被一个存活的根元素所引用，就会被认为是存活对象，不能被回收。这时，可以通过分析一个对象到根元素的引用路径来分析该对象为什么不能够被顺利回收。</p>
<p>当选中某个对象，通过Merge Shortest Paths to GC Root的操作，可以显示对象之间的排除了软引用，弱引用和虚引用的引用关系，这样我们看到的就是被选中对象是否还存在强引用，通过分析 ，能够直接找到内存没有释放的原因。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170420149269042589662.png" alt="20170420149269042589662.png"></p>
<h2 id="开发中常见内存泄露的场景"><a href="#开发中常见内存泄露的场景" class="headerlink" title="开发中常见内存泄露的场景"></a>开发中常见内存泄露的场景</h2><h3 id="1-Context对象使用不当；"><a href="#1-Context对象使用不当；" class="headerlink" title="1.Context对象使用不当；"></a>1.Context对象使用不当；</h3><p>在Android中经常使用的单例模式，如果使用不当，会出现内存泄露，泄露的主要原因是因为，单例模式中的静态成员变量的生命周期与应用的生命周期一样长。比较常见的场景是，经常在一些工具类中使用单例模式，如xxManager,xxHelper，xxUtils,这些工具类中需要使用Context,由于Activity是间接继承Context，当Activity退出时，单例对象中持有了它的引用，导致Activity回收失败，从而出现内存泄露。处理方式是使用Application,由于Application的生命周期贯穿整个应用，所以当这些工具类需要使用到Context时，使用getApplication()或者getApplicationContext()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    public class Util &#123;</div><div class="line">        private Context mContext;</div><div class="line">        private static Util sInstance;</div><div class="line"></div><div class="line">        private Util(Context context) &#123;</div><div class="line">            this.mContext = context;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public static Util getInstance(Context context) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">//                sInstance = new Util(context);</div><div class="line">                sInstance = new Util(context.getApplicationContext());</div><div class="line">            &#125;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2-内部类使用不当"><a href="#2-内部类使用不当" class="headerlink" title="2.内部类使用不当"></a>2.内部类使用不当</h3><p>当使用非静态的内部类时，如果出现内部类持有外部类的引用，就会出现内存泄露，优化方法，可以使用静态的内部类，这样内部类就不在持有外部类的引用，不会影响GC对于外部类的回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 静态成员变量</div><div class="line">     */</div><div class="line">    public static InnerClass innerClass = null;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_my);</div><div class="line"></div><div class="line">        innerClass = new InnerClass();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class InnerClass &#123;</div><div class="line"></div><div class="line">        public void doSomeThing() &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Handler的异步消息通信"><a href="#3-Handler的异步消息通信" class="headerlink" title="3.Handler的异步消息通信"></a>3.Handler的异步消息通信</h3><p>在使用Handler时出现内存泄露的主要原因是Handler的生命周期与Activity的生命周期不一致，当应用启动时，创建UI主线程Looper对象，Looper实现了简单的消息队列，主线程Looper对象存在整个应用的生命周期中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class HandlerActivity extends Activity &#123;</div><div class="line"></div><div class="line">    private final Handler mHandler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            // ...</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mHandler.sendMessageDelayed(Message.obtain(), 10*000);</div><div class="line">        finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当在Actiivity中使用Handler时，就可能会产生内存泄露，究其根本原因，是我们使用的非静态内部类(或者匿名内部类)默认隐性持有外部类的引用，静态内部类不会持有外部类的引用。在Activity结束时，由于Message是延迟消息，会在主线程的消息队列中，该消息持有Activity中的Handler的引用，Handler默认持有Activity的引用，直至该消息被处理完。此时导致Activity对象无法被回收，就会出现内存泄露。优化方法，可以使用静态内部类继承Handler对象，或者在Activity的onDestory()方法中，调用mHandler.removeCallbacksAndMessages(null);</p>
<h3 id="4-Bitmap使用不当"><a href="#4-Bitmap使用不当" class="headerlink" title="4.Bitmap使用不当"></a>4.Bitmap使用不当</h3><p>使用Bitmap如果回收不及时，也会出现内存泄露。原因在于Bitmap类没有对外创建对象的构造方法，获得Bitmap对象只能通过BitmapFactory中的各种静态方法，生成Bitmap对象是通过JNI调用底层c来实现的。所以，当我们获取一个Bitmap对象时，其对应的内存中包含两部分内容，一部分是Java，一部分是c,Java部分的内存可以通过GC进行回收，但是c部分的内存GC是不会进行自动回收的，所以，我们在使用Bitmap对象时，需要调用recycle()来主动释放c部分的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 判断是否已经回收</div><div class="line">if(bitmap != null &amp;&amp; !bitmap.isRecycled())&#123; </div><div class="line">        // 回收并且置为null</div><div class="line">        bitmap.recycle(); </div><div class="line">        bitmap = null; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-资源性对象没有及时关闭"><a href="#5-资源性对象没有及时关闭" class="headerlink" title="5.资源性对象没有及时关闭"></a>5.资源性对象没有及时关闭</h3><p>当我们使用一些资源性对象时，如果没有做关闭操作，也会出现内存泄露，常见的资源性对象包括(Cursor、ContentProvider、File、Stream)等。还有一类如EventBus、BroadCastReceiver在注册后，为了避免重复注册，需要在退出时及时的销毁。</p>
<h3 id="6-集合列表相关"><a href="#6-集合列表相关" class="headerlink" title="6.集合列表相关"></a>6.集合列表相关</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。</p>
<h3 id="7-Native中存在内存泄露"><a href="#7-Native中存在内存泄露" class="headerlink" title="7.Native中存在内存泄露"></a>7.Native中存在内存泄露</h3><p>由于Native层的代码多用c或c++来实现，GC无法对这部分内存进行会后处理，这时可能会出现内存泄露，这时候就需要c工程师帮助分析，如Malloc的内存是否做了free处理，指针使用完成后，是否进行了置空处理等等。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.jianshu.com/p/e97ed5d8a403" target="_blank" rel="external">科普：内存泄漏与内存溢出</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank" rel="external">Java的内存泄漏</a></li>
<li><a href="https://segmentfault.com/a/1190000006852540" target="_blank" rel="external">Android 内存泄露总结</a></li>
<li><a href="https://segmentfault.com/a/1190000003910496" target="_blank" rel="external">Java四种引用类型</a></li>
<li><a href="http://blog.csdn.net/itomge/article/details/48719527" target="_blank" rel="external">MAT使用教程</a></li>
</ol>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2017-03-24-android-memory-leak.html">http://www.sguotao.com/Android进阶-2017-03-24-android-memory-leak.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存泄露与内存溢出&quot;&gt;&lt;a href=&quot;#内存泄露与内存溢出&quot; class=&quot;headerlink&quot; title=&quot;内存泄露与内存溢出&quot;&gt;&lt;/a&gt;内存泄露与内存溢出&lt;/h2&gt;&lt;h3 id=&quot;内存泄露&quot;&gt;&lt;a href=&quot;#内存泄露&quot; class=&quot;headerli
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="内存泄露" scheme="http://www.sguotao.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="MAT" scheme="http://www.sguotao.com/tags/MAT/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】ReactNative样式整理</title>
    <link href="http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html"/>
    <id>http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html</id>
    <published>2017-03-24T02:27:04.000Z</published>
    <updated>2017-05-17T07:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。</p>
<h2 id="引入样式的几种方法"><a href="#引入样式的几种方法" class="headerlink" title="引入样式的几种方法"></a>引入样式的几种方法</h2><p>常见的引用样式的几种方法，包括内嵌方式，外联方式和混合方式，还可以把样式定义在单独的文件中，通过import引用。</p>
<h3 id="1-内嵌方式"><a href="#1-内嵌方式" class="headerlink" title="1. 内嵌方式"></a>1. 内嵌方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">export default class appProject extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;</div><div class="line">                &#123;</div><div class="line">                marginTop:200,</div><div class="line">                marginLeft:5,</div><div class="line">                marginRight:5,</div><div class="line">                height:84,</div><div class="line">                flexDirection:&apos;row&apos;,</div><div class="line">                backgroundColor:&apos;#FF0067&apos;,</div><div class="line">                &#125;</div><div class="line">                &#125;&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-外联方式"><a href="#2-外联方式" class="headerlink" title="2. 外联方式"></a>2. 外联方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const Styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        marginTop:200,</div><div class="line">        marginLeft:5,</div><div class="line">        marginRight:5,</div><div class="line">        height:84,</div><div class="line">        flexDirection:&apos;row&apos;,</div><div class="line">        backgroundColor:&apos;#FF0067&apos;,</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="3-混合方式"><a href="#3-混合方式" class="headerlink" title="3. 混合方式"></a>3. 混合方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">export default class appProject extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            //外层容器</div><div class="line">            &lt;View style=&#123;[Styles.container,Styles.bg,&#123;color:&apos;red&apos;&#125;]&#125;&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-import引用"><a href="#4-import引用" class="headerlink" title="4.import引用"></a>4.import引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;</div><div class="line">import &#123;</div><div class="line">    StyleSheet,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        marginTop:200,</div><div class="line">        marginLeft:5,</div><div class="line">        marginRight:5,</div><div class="line">        height:84,</div><div class="line">        flexDirection:&apos;row&apos;,</div><div class="line">    &#125;,</div><div class="line">    bg:&#123;</div><div class="line">        backgroundColor:&apos;#FF0067&apos;,</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">module.exports = styles;</div></pre></td></tr></table></figure>
<p>通过import进行引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import styles from &apos;./styles/style&apos;;</div></pre></td></tr></table></figure></p>
<h2 id="常见的属性及说明"><a href="#常见的属性及说明" class="headerlink" title="常见的属性及说明"></a>常见的属性及说明</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">backgroundColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 background-color 属性</td>
</tr>
</tbody>
</table>
<h3 id="2-宽高尺寸"><a href="#2-宽高尺寸" class="headerlink" title="2.宽高尺寸"></a>2.宽高尺寸</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">width</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 width 属性</td>
</tr>
<tr>
<td style="text-align:center">height</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 height 属性</td>
</tr>
</tbody>
</table>
<h3 id="3-外边距相关-margin"><a href="#3-外边距相关-margin" class="headerlink" title="3.外边距相关(margin)"></a>3.外边距相关(margin)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">margin</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白</td>
</tr>
<tr>
<td style="text-align:center">marginHorizontal</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置marginRight和marginLeft</td>
</tr>
<tr>
<td style="text-align:center">marginVertical</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置marginTop和marginBottom</td>
</tr>
<tr>
<td style="text-align:center">marginTop</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-top 属性</td>
</tr>
<tr>
<td style="text-align:center">marginRight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-right 属性</td>
</tr>
<tr>
<td style="text-align:center">marginBottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">marginLeft</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-left 属性</td>
</tr>
</tbody>
</table>
<h3 id="4-内边距相关-padding"><a href="#4-内边距相关-padding" class="headerlink" title="4.内边距相关(padding)"></a>4.内边距相关(padding)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">padding</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白</td>
</tr>
<tr>
<td style="text-align:center">paddingHorizontal</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft</td>
</tr>
<tr>
<td style="text-align:center">paddingVertical</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom</td>
</tr>
<tr>
<td style="text-align:center">paddingTop</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-top 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingRight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-right 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingBottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingLeft</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-left 属性</td>
</tr>
</tbody>
</table>
<h3 id="5-边框相关-border"><a href="#5-边框相关-border" class="headerlink" title="5.边框相关(border)"></a>5.边框相关(border)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">borderStyle</td>
<td style="text-align:center">solid, dotted, dashed</td>
<td style="text-align:center">对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性</td>
</tr>
<tr>
<td style="text-align:center">borderWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRightWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-right-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderLeftWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-left-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-top-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRightColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-right-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderLeftColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-left-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopLeftRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-left-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopRightRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-right-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomLeftRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-left-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomRightRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-right-radius 属性</td>
</tr>
</tbody>
</table>
<h3 id="6-位置相关-position"><a href="#6-位置相关-position" class="headerlink" title="6.位置相关(position)"></a>6.位置相关(position)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">position</td>
<td style="text-align:center">absolute, relative</td>
<td style="text-align:center">对应 CSS 中的 position 属性，但阉割了 static, fixed 取值</td>
</tr>
<tr>
<td style="text-align:center">top</td>
<td style="text-align:center">number&gt;</td>
<td style="text-align:center">对应 CSS 中的 top 属性</td>
</tr>
<tr>
<td style="text-align:center">right</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 right 属性</td>
</tr>
<tr>
<td style="text-align:center">bottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">left</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 left 属性</td>
</tr>
</tbody>
</table>
<h3 id="7-文本相关-Text"><a href="#7-文本相关-Text" class="headerlink" title="7.文本相关(Text)"></a>7.文本相关(Text)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 color 属性</td>
</tr>
<tr>
<td style="text-align:center">fontFamily</td>
<td style="text-align:center">string</td>
<td style="text-align:center">对应 CSS 中的 font-family 属性</td>
</tr>
<tr>
<td style="text-align:center">fontSize</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 font-size 属性</td>
</tr>
<tr>
<td style="text-align:center">fontStyle</td>
<td style="text-align:center">normal, italic</td>
<td style="text-align:center">对应 CSS 中的 font-style 属性，但阉割了 oblique 取值</td>
</tr>
<tr>
<td style="text-align:center">fontWeight</td>
<td style="text-align:center">normal, bold 100~900</td>
<td style="text-align:center">对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值</td>
</tr>
<tr>
<td style="text-align:center">lineHeight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 line-height 属性</td>
</tr>
<tr>
<td style="text-align:center">textAlign</td>
<td style="text-align:center">auto, left, right, center, justifyiOS</td>
<td style="text-align:center">对应 CSS 中的 text-align 属性，增加了 auto 取值</td>
</tr>
<tr>
<td style="text-align:center">textAlignVertical<sup>Android</sup></td>
<td style="text-align:center">auto, top, bottom, center</td>
<td style="text-align:center">对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub 等值</td>
</tr>
<tr>
<td style="text-align:center">textShadowColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 text-shadow 属性中的颜色定义</td>
</tr>
<tr>
<td style="text-align:center">textShadowOffset</td>
<td style="text-align:center">{width: number, height: number}</td>
<td style="text-align:center">对应 CSS 中的 text-shadow 属性中的阴影偏移定义</td>
</tr>
<tr>
<td style="text-align:center">textShadowRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义</td>
</tr>
<tr>
<td style="text-align:center">letterSpacing<sup>iOS</sup></td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 letter-spacing 属性，但取值不同</td>
</tr>
<tr>
<td style="text-align:center">textDecorationColor<sup>iOS</sup></td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-color 属性</td>
</tr>
<tr>
<td style="text-align:center">textDecorationLine<sup>iOS</sup></td>
<td style="text-align:center">none, underline, line-through, underline line-through</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值</td>
</tr>
<tr>
<td style="text-align:center">textDecorationStyle<sup>iOS</sup></td>
<td style="text-align:center">solid, double, dotted, dashed</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值</td>
</tr>
<tr>
<td style="text-align:center">writingDirection<sup>iOS</sup></td>
<td style="text-align:center">auto, ltr, rtl</td>
<td style="text-align:center">对应 CSS 中的 direction 属性，增加了 auto 取值</td>
</tr>
</tbody>
</table>
<h3 id="8-弹性布局相关-Flex"><a href="#8-弹性布局相关-Flex" class="headerlink" title="8.弹性布局相关(Flex)"></a>8.弹性布局相关(Flex)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flex</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 flex 属性</td>
</tr>
<tr>
<td style="text-align:center">flexDirection</td>
<td style="text-align:center">row, column</td>
<td style="text-align:center">对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值</td>
</tr>
<tr>
<td style="text-align:center">flexWrap</td>
<td style="text-align:center">wrap, nowrap</td>
<td style="text-align:center">对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值</td>
</tr>
<tr>
<td style="text-align:center">justifyContent</td>
<td style="text-align:center">flex-start, flex-end, center, space-between, space-around</td>
<td style="text-align:center">对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。</td>
</tr>
<tr>
<td style="text-align:center">alignItems</td>
<td style="text-align:center">flex-start, flex-end, center, stretch</td>
<td style="text-align:center">对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。</td>
</tr>
<tr>
<td style="text-align:center">alignSelf</td>
<td style="text-align:center">auto, flex-start, flex-end, center, stretch</td>
<td style="text-align:center">对应 CSS 中的 align-self 属性，但阉割了 baseline 取值</td>
</tr>
</tbody>
</table>
<h3 id="9-转换相关-transform"><a href="#9-转换相关-transform" class="headerlink" title="9.转换相关(transform)"></a>9.转换相关(transform)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">transform</td>
<td style="text-align:center">[{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}]</td>
<td style="text-align:center">对应 CSS 中的 transform 属性</td>
</tr>
<tr>
<td style="text-align:center">transformMatrix</td>
<td style="text-align:center">TransformMatrixPropType</td>
<td style="text-align:center">类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数</td>
</tr>
<tr>
<td style="text-align:center">backfaceVisibility</td>
<td style="text-align:center">visible, hidden</td>
<td style="text-align:center">对应 CSS 中的 backface-visibility 属性</td>
</tr>
</tbody>
</table>
<h3 id="10-图片相关"><a href="#10-图片相关" class="headerlink" title="10.图片相关"></a>10.图片相关</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">resizeMode</td>
<td style="text-align:center">cover, contain, stretch</td>
<td style="text-align:center">contain是指无论如何图片都包含在指定区域内，假设设置的宽度高度比图片大，则图片居中显示，否则，图片等比缩小显示</td>
</tr>
<tr>
<td style="text-align:center">overflow</td>
<td style="text-align:center">visible, hidden</td>
<td style="text-align:center">超出部分是否显示，hidden为隐藏</td>
</tr>
<tr>
<td style="text-align:center">tintColor</td>
<td style="text-align:center">number</td>
<td style="text-align:center">着色，rgb字符串类型</td>
</tr>
<tr>
<td style="text-align:center">opacity</td>
<td style="text-align:center">number</td>
<td style="text-align:center">透明度</td>
</tr>
</tbody>
</table>
<h3 id="11-图像变换"><a href="#11-图像变换" class="headerlink" title="11.图像变换"></a>11.图像变换</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">rotation</td>
<td style="text-align:center">–</td>
<td style="text-align:center">旋转</td>
</tr>
<tr>
<td style="text-align:center">scaleX</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向缩放</td>
</tr>
<tr>
<td style="text-align:center">scaleY</td>
<td style="text-align:center">–</td>
<td style="text-align:center">垂直方向缩放</td>
</tr>
<tr>
<td style="text-align:center">translateX</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向平移</td>
</tr>
<tr>
<td style="text-align:center">translateY</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向平移</td>
</tr>
</tbody>
</table>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html">http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。&lt;/p&gt;
&lt;h2 id=&quot;引入样式的几种方法&quot;&gt;&lt;a href=&quot;#引入样式的几种方法&quot; class=&quot;headerlink&quot; title=&quot;引入样式的几种方法&quot;&gt;&lt;/a&gt;引入样式
    
    </summary>
    
      <category term="ReactNative" scheme="http://www.sguotao.com/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://www.sguotao.com/tags/ReactNative/"/>
    
      <category term="CSS" scheme="http://www.sguotao.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Android动态加载机制</title>
    <link href="http://www.sguotao.com/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6-2017-03-17-classloader.html"/>
    <id>http://www.sguotao.com/插件框架-2017-03-17-classloader.html</id>
    <published>2017-03-17T02:27:04.000Z</published>
    <updated>2017-05-04T11:35:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java的类加载机制ClassLoader"><a href="#Java的类加载机制ClassLoader" class="headerlink" title="Java的类加载机制ClassLoader"></a>Java的类加载机制ClassLoader</h2><p>我们编写的java代码，最终会编译成.class字节码的形式，一个完整的Java程序，通常会由若干个.class文件组成，在程序运行时，通过该程序的入口函数来调用系统的各个功能，但是程序启动时，并不会一次性将.class文件加载到内存中，根据程序的需要，通过Java的类加载机制来动态加载.class文件，ClassLoader就是来实现.class文件的动态加载的。</p>
<h2 id="Java中各类加载器的关系"><a href="#Java中各类加载器的关系" class="headerlink" title="Java中各类加载器的关系"></a>Java中各类加载器的关系</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974200061820.png" alt="20170317148974200061820.png"><br>Java默认会提供三个类加载器，分别为BootStrapClassLoader,ExtClassLoader和AppClassLoader;</p>
<ul>
<li>BootStrapLoader，启动类加载器，是Java类加载层次中最顶层的类加载器，由c代码编写，负责加载JDK中的核心类库（包括JRE classes目录下的.class文件，libs目录下的jar文件）。可以使用System.getProperty(“sun.boot.class.path”)来显示BootStrapLoader加载的jar和.class文件；</li>
<li>ExtClassLoader,扩展类加载器，负责加载Java的扩展类库，默认加载/jre/lib/ext目录下的所有jar和.class文件。可以通过可以使用System.getProperty(“java.ext.dirs”)来显示ExtClassLoader加载的jar和.class文件；</li>
<li>AppClassLoader,系统类加载器，负责加载classpath目录下所有的jar和class文件。</li>
</ul>
<h2 id="Java类加载的实现过程"><a href="#Java类加载的实现过程" class="headerlink" title="Java类加载的实现过程"></a>Java类加载的实现过程</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974217438657.jpg" alt="20170317148974217438657.jpg"></p>
<ul>
<li>执行程序代码，找到JRE所在目录；</li>
<li>找到jvm.dll(Windows)或者libjvm.so(Linux);</li>
<li>启动JVM，并进行初始化工作</li>
<li>创建BootStrapClassLoader;</li>
<li>BootStrapClassLoader会加载ExtClassLoader，并设定ExtClassLoader的parent为BootStrapClassLoader;</li>
<li>BootStrapClassLoader会加载AppClassLoader,并设定AppClassLoader的parent为ExtClassLoader;</li>
</ul>
<p>当AppClassLoader开始加载xxx.class时，类加载器会现将加载的任务交给其parent来完成，如果parent找不到，则自己负责加载。所以在加载xxx.class时的顺序是，BootstrapClassLoader –&gt; ExtClassLoader –&gt; AppClassLoader，如果都找不到，则抛出ClassNotFoundException。这就是非常有名的双亲委托模型。</p>
<p>使用双亲委托模型，有效地解决了.class字节码重复加载的问题，当parent已经加载类某各类的.class字节码时，子类就没有必要再重新进行加载。举个例子，来说明一下双亲委托模型。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974220124844.png" alt="20170317148974220124844.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 取得SomeClass的Class实例</div><div class="line">   Class c = Class.forName(&quot;SomeClass&quot;);</div><div class="line">   // 取得ClassLoader</div><div class="line">   ClassLoader loader = c.getClassLoader();</div><div class="line">   System.out.println(loader);</div><div class="line">   // 取得父ClassLoader</div><div class="line">   System.out.println(loader.getParent());</div><div class="line">   // 再取得父ClassLoader</div><div class="line">   System.out.println(loader.getParent().getParent());</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher\$AppClassLoader@19821f</div><div class="line">sun.misc.Launcher\$ExtClassLoader@addbf1</div><div class="line">null</div></pre></td></tr></table></figure>
<p>由于SomeClass是自定义的一个Java类，通常会java.class.path中产生字节码，首先AppClassLoader会将加载的任务交给其parent,ExtClassLaoder,ExtClassLoader将加载任务交给其parent，BootStrapClassLoader,由于BootStrapLoader在其目录(sun.boot.class.path)下没有找到该类的字节码，所以由ExtClassLoader来加载，ExtClassLoader在其目录(java.ext.dirs)也没有发现SomeClass的字节码，交给AppClassLoader进行加载，AppClassLoader在(java.class.path)中找到，并进行加载。</p>
<p>加载SomeClass的ClassLoader是AppClassLoader,其parent是ExtClassLoader,<br>而ExtClassLoader的parent是null，这是因为BootStrapClassLoader是由c代码编写的，在JVM中并没有对应的实例对象，所以显示为null。</p>
<h2 id="Dalvik与JVM"><a href="#Dalvik与JVM" class="headerlink" title="Dalvik与JVM"></a>Dalvik与JVM</h2><p>在Java中，把一些Java类编译成.class文件，通过ClassLoader进行加载，但是在Android上边，情况有所不同，主要的原因在于Android中使用的虚拟机是Dalvik。Android中的Dalvik和Java中的JVM都是将对应的Java类加载到内存中运行。不同的是JVM加载的是.class字节码文件，或是通过defineClass方式产生class，进行加载。Dalvik加载的是.dex文件，.dex文件是Android对.class文件进行了优化，更加适合内存和处理器有限的系统。</p>
<ul>
<li>Dalvik是基于寄存器的，而JVM是基于栈的。</li>
<li>Dalvik运行dex文件，而JVM运行java字节码</li>
<li>自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。</li>
</ul>
<p>很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。2014年6月25日,Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。ART,即Android Runtime。ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time,JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time)。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<h2 id="DexClassLoader与PathClassLoader"><a href="#DexClassLoader与PathClassLoader" class="headerlink" title="DexClassLoader与PathClassLoader"></a>DexClassLoader与PathClassLoader</h2><p>在使用Java虚拟机时，我们经常自定义继承自ClassLoader的类加载器。然后通过defineClass方法来从一个二进制流中加载Class。而在Android中我们无法这么使用，Android中ClassLoader的defineClass方法具体是调用VMClassLoader的defineClass本地静态方法。而这个本地方法什么都没做，只是抛出了一个“UnsupportedOperationException”异常。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</div><div class="line">        <span class="keyword">throws</span> ClassFormatError</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"can't load this type of class file"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>既然在Dalvik虚拟机里，ClassLoader不好用，那么Android官方为了解决这个问题，帮我们从ClassLoader中派生出了两个类：DexClassLoader和PathClassLoader。先来看一下DexClassLoader和PahtClassLoader的继承关系。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170322149015010153287.png" alt="20170322149015010153287.png"></p>
<h3 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h3><p>DexClassLoader可以加载jar,apk,dex,可以从SD卡进行加载，可以实现dex的动态加载与更新，DexClassLoader要有一个app私有且可写的目录来存储经过优化的.odex文件。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *</div><div class="line">		 * <span class="doctag">@param</span> dexPath .dex文件路径,多个文件路径使用':'分隔</div><div class="line">		 * <span class="doctag">@param</span> optimizedDirectory .dex文件优化后生成的.odex文件的路径</div><div class="line">		 * <span class="doctag">@param</span> librarySearchPath 动态库路径</div><div class="line">		 * <span class="doctag">@param</span> parent 双亲委派模式,指定父类加载器</div><div class="line">		 */</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h3><p>PathClassLoader只能加载已经安装的apk文件。Android系统默认使用的类加载器。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *</div><div class="line">		 * <span class="doctag">@param</span> dexPath .dex文件路径</div><div class="line">		 * <span class="doctag">@param</span> librarySearchPath 本地库路径</div><div class="line">		 * <span class="doctag">@param</span> parent 双亲委派模式,指定父类加载器</div><div class="line">		 */</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="DexClassLoader与PathClassLoader的比较"><a href="#DexClassLoader与PathClassLoader的比较" class="headerlink" title="DexClassLoader与PathClassLoader的比较"></a>DexClassLoader与PathClassLoader的比较</h3><p>通过两个类加载构造函数的对比发现，区别在于DexClassLoader构造函数中的参数optimizedDirectory。Google官方文档中给出optimizedDirectory的说明是，用来存储经过优化后的.odex文件的路径。optimizedDirectory必须是一个内部存储路径，DexClassLoader可以通过构造函数指定optimizedDirectory，所以DexClassLoader可以实现动态加载，外部的.jar/.dex文件，优化后会存在在optimizedDirectory目录中。PathClassLoader由于没有指定该路径，所以只能加载内部的，已经安装的apk中的.odex文件。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170322149015373793574.png" alt="20170322149015373793574.png"></p>
<p>整个类加载过程可以简单描述为上面的时序图。ClassLoader在加载过程中，通过loadClass方法，调用BaseDexClassLoader中重载的findClass方法，该方法会遍历DexPathList列表。DexPathList的创建过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></div><div class="line">                              String libraryPath, ClassLoader parent) &#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">        <span class="keyword">this</span>.originalPath = dexPath;</div><div class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>optimizedDirectory用来缓存优化过的.odex文件，在DexClassLoader中可以通过构造函数进行制定，在PathClassLoader中，optimizedDirectory为null，会直接使用系统中已经安装的apk文件的.odex目录。DexPathList完整的创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></div><div class="line">                       String libraryPath, File optimizedDirectory) &#123;</div><div class="line">        ……</div><div class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</div><div class="line">                                             File optimizedDirectory) &#123;</div><div class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</div><div class="line">        <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">            ZipFile zip = <span class="keyword">null</span>;</div><div class="line">            DexFile dex = <span class="keyword">null</span>;</div><div class="line">            String name = file.getName();</div><div class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</div><div class="line">                dex = loadDexFile(file, optimizedDirectory);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</div><div class="line">                || name.endsWith(ZIP_SUFFIX)) &#123;</div><div class="line">                zip = <span class="keyword">new</span> ZipFile(file);</div><div class="line">            &#125;</div><div class="line">            ……</div><div class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</div><div class="line">                elements.add(<span class="keyword">new</span> Element(file, zip, dex));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</div><div class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Converts a dex/jar file path and an output directory to an</div><div class="line">     * output file path for an associated optimized dex file.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">optimizedPathFor</span><span class="params">(File path,</span></span></div><div class="line">                                           File optimizedDirectory) &#123;</div><div class="line">        String fileName = path.getName();</div><div class="line">        <span class="keyword">if</span> (!fileName.endsWith(DEX_SUFFIX)) &#123;</div><div class="line">            <span class="keyword">int</span> lastDot = fileName.lastIndexOf(<span class="string">"."</span>);</div><div class="line">            <span class="keyword">if</span> (lastDot &lt; <span class="number">0</span>) &#123;</div><div class="line">                fileName += DEX_SUFFIX;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(lastDot + <span class="number">4</span>);</div><div class="line">                sb.append(fileName, <span class="number">0</span>, lastDot);</div><div class="line">                sb.append(DEX_SUFFIX);</div><div class="line">                fileName = sb.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        File result = <span class="keyword">new</span> File(optimizedDirectory, fileName);</div><div class="line">        <span class="keyword">return</span> result.getPath();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="http://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="external">深入分析Java ClassLoader原理</a><br>2.<a href="http://blog.csdn.net/irelandken/article/details/7048817" target="_blank" rel="external">分析BootstrapClassLoader/ExtClassLoader/AppClassLoader的加载路径 及”父委托机制”</a><br>3.<a href="https://openhome.cc/Gossip/JavaEssence/ClassLoader.html" target="_blank" rel="external">簡介類別載入器</a><br>4.<a href="http://www.infoq.com/cn/articles/android-in-depth-dalvik" target="_blank" rel="external">Java虚拟机Dalvik</a><br>5<a href="http://www.jianshu.com/p/669fc4858194" target="_blank" rel="external">Android动态加载——DexClassloader分析</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/插件框架-2017-03-17-classloader.html">http://www.sguotao.com/插件框架-2017-03-17-classloader.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java的类加载机制ClassLoader&quot;&gt;&lt;a href=&quot;#Java的类加载机制ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;Java的类加载机制ClassLoader&quot;&gt;&lt;/a&gt;Java的类加载机制ClassLoader&lt;/
    
    </summary>
    
      <category term="插件框架" scheme="http://www.sguotao.com/categories/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JVM" scheme="http://www.sguotao.com/tags/JVM/"/>
    
      <category term="插件框架" scheme="http://www.sguotao.com/tags/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ClassLoader" scheme="http://www.sguotao.com/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】追风筝的人</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2017-01-04-%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BA.html"/>
    <id>http://www.sguotao.com/读书笔记-2017-01-04-追风筝的人.html</id>
    <published>2017-01-04T04:00:00.000Z</published>
    <updated>2017-05-16T02:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>为你，千千万万遍</p>
<p>阿米尔问哈桑为什么知道被切断绳线的风筝的掉落地点，<br>哈桑肯定会对阿米尔说，我就是知道，然后反问，我什么时候骗过你。<br>阿米尔轻声说，我怎么知道有没有骗过我。<br>哈桑发誓，为了你，我宁可啃烂泥。阿米尔进一步确定，你真的会为我啃烂泥？<br>哈桑坚定的说，我肯定，然后又说，但是你又怎么能忍心让我啃烂泥。</p>
<p>同哈桑洋溢着笑脸对阿米尔说：为你，千千万万遍。</p>
<p>一个是主人，一个是仆人；<br>一个是普什图，一个是哈扎拉；<br>一个是逊尼派，一个是什叶派；</p>
<p>从他们出生的那一刻起，他们的命运就被这些他们所不能理解的标签所分隔开来，尽管他们是亲密无间的朋友，尽管他们事实上拥有同一位父亲。无论是平凡的阿米尔和哈桑，还是高高在上的查希尔国王或者卡尔扎伊，都不得不接受社会为他们预定的座位——阿米尔不再是阿米尔，哈桑也不再是哈桑，他们必须戴上社会分给他们的面具。</p>
<p>哈桑总是说“为你，千千万万遍”，而生性懦弱的阿米尔却选择沉默冷酷的逃避，这样的悲剧性结果并不单单是个性差异所造成的，在这些年少无知的孩子的潜意识里早已被灌输了相应于自身社会地位的“应该”与“不应该”，一个哈扎拉仆人理应为主人尽忠，而高贵的普什图少爷不值得为一个卑贱的哈扎拉仆人冒任何风险。</p>
<p>“阿米尔和哈桑，喀布尔的统治者”，这样的誓言只能是石榴树下的童话，“王子与贫儿”不可能成为兄弟，因为他们命中注定不平等。包括二十年后，阿米尔重返阿富汗的自我救赎行为，也只不过是在获知自己与哈桑的同父异母兄弟关系之后对身世的无奈认可，也就是说，他仍然没有证明自己已经找到了“重新成为好人的路”。</p>
<p>我们少年的时候，总是意气风发，三五结伴，促膝长谈。那是在我们其乐融融的环境中构建的虚拟场景，属于物理学讲究的理想状态，然而在残酷的现实面前，在微弱的友谊遇到挑战的时刻，只要有一方露出破绽，友谊的桥梁必然坍塌。</p>
<p>于是当阿米尔在看到哈桑被大一些的孩子欺负甚至猥亵的时候，他选择沉默和逃避；与此同时，哈桑却为了阿米尔的风筝坚定不动摇的和对手较量，对手残忍的揭示阿米尔和哈桑之间的主仆关系，哈桑大声反驳说两个人是朋友。躲在角落里不敢出现的阿米尔听到这句话不但没有一点激励也没有丝毫感动，他心底里的怯懦终于将他的灵魂吞噬，于是悲剧发生。</p>
<p>这就是我们对友谊最大的误解，认为它是万能的。</p>
<p>即使是存在这样的问题，《追风筝的人》也还是一本出色的小说。主和仆、贵族和贱民、朋友和兄弟，历史和现实，种种转变都被刻画得生动而细腻。放在历史的宏大背景下，更洞见人生和人性的复杂。</p>
<p>友谊和爱。</p>
<p>是在困难之中由弱变强的柔韧派还是在权衡利弊之中土崩瓦解的懦弱派。</p>
<p>谁敢真的站出来举起右手发誓，我从来没有辜负过任何一段纯粹的友谊，谁敢真的抬头挺胸说自己对朋友忠心不二。</p>
<p>我们总是太自信，对友谊误解，对自己的爱误解，对不可能的事信以为真。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2017-01-04-追风筝的人.html">http://www.sguotao.com/读书笔记-2017-01-04-追风筝的人.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为你，千千万万遍&lt;/p&gt;
&lt;p&gt;阿米尔问哈桑为什么知道被切断绳线的风筝的掉落地点，&lt;br&gt;哈桑肯定会对阿米尔说，我就是知道，然后反问，我什么时候骗过你。&lt;br&gt;阿米尔轻声说，我怎么知道有没有骗过我。&lt;br&gt;哈桑发誓，为了你，我宁可啃烂泥。阿米尔进一步确定，你真的会为我啃烂泥
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】跟任何人都聊得来</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-11-16-%E8%B7%9F%E4%BB%BB%E4%BD%95%E4%BA%BA%E9%83%BD%E8%81%8A%E5%BE%97%E6%9D%A5.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-11-16-跟任何人都聊得来.html</id>
    <published>2017-01-04T04:00:00.000Z</published>
    <updated>2017-05-16T02:58:03.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-11-16-跟任何人都聊得来.html">http://www.sguotao.com/读书笔记-2016-11-16-跟任何人都聊得来.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.sguotao.com/读书笔记-2016-11-16-跟任何人都聊得来.html&quot;&gt;http://www.sguotao.com/读书笔记-2016-11-16-跟任何人都聊得来.html&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】阿弥陀佛么么哒</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-11-30-%E9%98%BF%E5%BC%A5%E9%99%80%E4%BD%9B%E4%B9%88%E4%B9%88%E5%93%92.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-11-30-阿弥陀佛么么哒.html</id>
    <published>2016-11-30T04:00:00.000Z</published>
    <updated>2017-05-16T07:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>《阿弥陀佛么么哒》一书记录了大冰十余年的江湖游历，以及他和他朋友们的爱与温暖的传奇故事。<br>这些故事与风花雪月无关，与鸡汤小清新无关，有的是无畏的奋斗和孤身的寻找，有的是疯狂的爱情和极致的浪漫……12个故事，12种善意，如点点星光与烛火，给所有心怀希望的人们以温暖和光芒。<br>请相信，这个世界上真的有人在过着你想要的生活。<br>忽晴忽雨的江湖，祝你有梦为马，随处可栖。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-11-30-阿弥陀佛么么哒.html">http://www.sguotao.com/读书笔记-2016-11-30-阿弥陀佛么么哒.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;《阿弥陀佛么么哒》一书记录了大冰十余年的江湖游历，以及他和他朋友们的爱与温暖的传奇故事。&lt;br&gt;这些故事与风花雪月无关，与鸡
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】乖,摸摸头</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-11-21-%E4%B9%96-%E6%91%B8%E6%91%B8%E5%A4%B4.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-11-21-乖-摸摸头.html</id>
    <published>2016-11-21T04:00:00.000Z</published>
    <updated>2017-05-16T07:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>真实的故事自有万钧之力<br>这本书讲述了12个真实的故事<br>或许会让你看到那些你永远无法去体会的生活<br>见识那些可能你永远都无法结交的人<br>【乖，摸摸头】：“杂草敏”是一只南方姑娘，辞去了稳定的幼儿园老师工作，跑到济南某电视台，从剪片子做起。后来又离开了山东，蒲公英一样漂去了北京又漂回了南方，甚至还漂到了澳大利亚……<br>【我有一碗酒，可以慰风尘】：这是一个关于越战老兵的故事。他将所有用命换来的补贴终身无偿捐献给希望工程、自费组建了第一支民间消防队，从不屑解释也不愿争辩的老兵，心里藏着一个关于铭记与奉献的故事。<br>【普通朋友】：每个硬着骨头敢拼敢搏的人都有个柔软的理由。所有人都看到“屌丝男士”大鹏光辉灿烂的现在，而在此之前，他也曾经独自经历过漫长的黑夜。<br>【唱歌人不许掉眼泪】：唱歌的人，到底靠什么而活呢？这个故事里，有金三角的连绵雨水，孟定的香蕉园，新千年的建筑工地……故事里有穷困窘迫、颠沛流离、渺茫的希望、忽晴忽雨的前路，还有一把红棉吉他和一个很想唱歌的孩子。<br>…… ……<br>《乖，摸摸头》是一本让你舍不得读完的短篇故事集。畅销书作者大冰，在《乖，摸摸头》一书中记录了他在拉萨、丽江与大理路上遇到12个人，以及关于他们的爱与温暖的故事。这些人的故事，有的是无畏的奋斗和孤身的寻找，有的是疯狂的爱情和极致的浪漫，有的是你我不曾尝试却跃跃欲试的生活，这些真实的故事，如点点星光，又如支支火把，给所有心怀梦想的年轻人以温暖、以力量、以方向。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-11-21-乖-摸摸头.html">http://www.sguotao.com/读书笔记-2016-11-21-乖-摸摸头.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;真实的故事自有万钧之力&lt;br&gt;这本书讲述了12个真实的故事&lt;br&gt;或许会让你看到那些你永远无法去体会的生活&lt;br&gt;见识那些可
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】谁动了我的奶酪</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-10-31-%E8%B0%81%E5%8A%A8%E4%BA%86%E6%88%91%E7%9A%84%E5%A5%B6%E9%85%AA.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-10-31-谁动了我的奶酪.html</id>
    <published>2016-10-31T04:00:00.000Z</published>
    <updated>2017-05-16T07:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>人生犹如“迷宫”，每个人都在其中寻找各自的“奶酪”——稳定的工作、身心的健康、和谐的人际关系、甜蜜美满的爱情，或是令人充满想象的财富…… 那么，你是否正在享受你的奶酪呢？ 如果是的，恭喜你，你只需要阅读一下书中的小故事即可，因为它会时刻提醒你，你的奶酪是否已经变质； 如果不是，欢迎你，请你把这本书从头到尾阅读一下，希望你能够从中受到启发，尽快享受你的奶酪。 自本书出版以来，已经有众多读者从奶酪的故事中得到启发，从而改善了自己的事业、婚姻和生活，同时也引起了广泛的讨论。 变化总在时时发生，我们每个人都要认真思考，究竟是谁动了我的“奶酪”，我们又该如何发现新的“奶酪”？</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-10-31-谁动了我的奶酪.html">http://www.sguotao.com/读书笔记-2016-10-31-谁动了我的奶酪.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;人生犹如“迷宫”，每个人都在其中寻找各自的“奶酪”——稳定的工作、身心的健康、和谐的人际关系、甜蜜美满的爱情，或是令人充满想
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】最好的我们</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-10-11-%E6%9C%80%E5%A5%BD%E7%9A%84%E6%88%91%E4%BB%AC.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-10-11-最好的我们.html</id>
    <published>2016-10-11T04:00:00.000Z</published>
    <updated>2017-05-16T07:28:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>你总是说青春从不曾永远，而那时候的我们，就是最好的我们。<br>这一次，我们和整个青春做告别。<br>八月长安全新力作。<br>你还记得高中时的同桌吗？那个少年有世界上最明朗的笑容，那个女生有世界上最好看的侧影。高中三年，两个人的影子和粉笔灰交织在一起，黑白分明，在记忆里面转圈。本书以怀旧的笔触讲述了女主角耿耿和男主角余淮同桌三年的故事，耿耿余淮，这么多年一路走过的成长故事极为打动人心，整个故事里有的都是在成长过程中细碎的点点滴滴，将怀旧写到了极致，将记忆也写到了极致。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-10-11-最好的我们.html">http://www.sguotao.com/读书笔记-2016-10-11-最好的我们.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;你总是说青春从不曾永远，而那时候的我们，就是最好的我们。&lt;br&gt;这一次，我们和整个青春做告别。&lt;br&gt;八月长安全新力作。&lt;b
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】你只是看起来很努力</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-09-21-%E4%BD%A0%E5%8F%AA%E6%98%AF%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E5%8A%AA%E5%8A%9B.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-09-21-你只是看起来很努力.html</id>
    <published>2016-09-21T04:00:00.000Z</published>
    <updated>2017-05-16T07:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>为什么你一直努力，却还是没有满意的成果？为什么你每天都很忙碌，却始终看不到终点？……你是真的努力了，还是，只是看起来很努力？<br>本书是中国优质新偶像李尚龙先生写给千万年轻人的成长和成功之书。本书以夯实别致的内容，独特另类的思考，让你在面对学业的压力，青春的迷茫，爱情的复杂中保持无畏无惧的心态，成为最好的自己。<br>在本书中，作者提到了很多朋友，他们有的因为父母的压力一直待在军校，有的因为和朋友爱上同一个女孩，坚持放弃了自己的爱情。有的人是在孤寂的大山之中的一面之缘，有的是教学课上的数面之交，虽是小角色，却都熠熠发光。因为他们受伤，他们坚强，他们努力，他们有勇气。<br>这本书的文字，没有无聊的励志。这些故事也许你生活中永远不会碰触，亦或许曾经经历，它会告诉你“只是看起来很努力”的生活状态是可怕的；它会告诉你“再好的朋友也经不起你过分直白”；它还会告诉你不要为讨好别人而为难自己，因为“你以为你在合群，其实你在浪费青春”……<br>47篇随笔和故事，或让人忍俊不禁，或让人潸然泪下，或让人茅塞顿开，或让人微笑释然，最终汇集成被《人民日报》盛赞的“改变千万热血青年的思维轨迹”。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-09-21-你只是看起来很努力.html">http://www.sguotao.com/读书笔记-2016-09-21-你只是看起来很努力.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;为什么你一直努力，却还是没有满意的成果？为什么你每天都很忙碌，却始终看不到终点？……你是真的努力了，还是，只是看起来很努力？
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】查令十字街84号</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-09-11-%E6%9F%A5%E4%BB%A4%E5%8D%81%E5%AD%97%E8%A1%9784%E5%8F%B7.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-09-11-查令十字街84号.html</id>
    <published>2016-09-11T04:00:00.000Z</published>
    <updated>2017-05-16T07:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>1949年的纽约，曼哈顿一间没有暖气的公寓里，三十三岁的穷作家海莲，偶然看到一则伦敦旧书店的广告，凭着一股莽撞劲，她开始给这个伦敦地址写信。这一写，就写了二十年。<br>很多年后，她和这家书店的通信集，被称为“爱书人的圣经”，不断演绎。而那家书店的地址——查令十字街84号，已经成为全球爱书人之间的一个暗号。<br>三十多年来，人们读它、写它、演它，在这段传奇里彼此问候，相互取暖。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-09-11-查令十字街84号.html">http://www.sguotao.com/读书笔记-2016-09-11-查令十字街84号.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;1949年的纽约，曼哈顿一间没有暖气的公寓里，三十三岁的穷作家海莲，偶然看到一则伦敦旧书店的广告，凭着一股莽撞劲，她开始给这
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】白说</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-08-21-%E7%99%BD%E8%AF%B4.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-08-21-白说.html</id>
    <published>2016-08-21T04:00:00.000Z</published>
    <updated>2017-05-16T07:33:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>《白说》是央视资深新闻人白岩松继《幸福了吗》《痛并快乐着》之后的全新作品，一部言语中的心灵之路。通过近年来于各个场合与公众的深入交流，以平等自由的态度，分享其世界观和价值观。时间跨度长达十五年，涵盖时政、教育、改革、音乐、阅读、人生等多个领 域，温暖发声，理性执言。<br>在有权保持沉默的年纪拒绝沉默，为依然热血有梦的人们敲鼓拨弦。尽管“说话不是件好玩的事儿”，依然向往“说出一个更好点儿的未来”，就算“说了白说”，可是“不说，白不说”。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-08-21-白说.html">http://www.sguotao.com/读书笔记-2016-08-21-白说.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;《白说》是央视资深新闻人白岩松继《幸福了吗》《痛并快乐着》之后的全新作品，一部言语中的心灵之路。通过近年来于各个场合与公众的
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>怎样才能让别人觉得与你合作愉快</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2016-08-17-pleasure-working-with-you.html"/>
    <id>http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html</id>
    <published>2016-08-17T09:00:00.000Z</published>
    <updated>2017-05-04T11:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章作者：咪喵<br>文章来源： TalentGuide </p>
</blockquote>
<p>为什么有的人，明明事情做得不少，却永远没人说他好？有的人，不管做什么都得到周围人众口一词的称赞？</p>
<p>真的是因为两个人做的事差很多吗？也许是。<br>也许，只是一些小习惯改变了他们的口碑。</p>
<h2 id="1-收到请回答"><a href="#1-收到请回答" class="headerlink" title="1. 收到请回答"></a>1. 收到请回答</h2><p>一些人，交给他的事情永远没下文。你不知道他收到了没有，是不是正在做，已经做到了什么进展，啥时候能交付。即使这件事他已经做完了，不去问，他也永远不会告诉你。</p>
<ol>
<li>收到任务，请告诉对方“我收到了。”</li>
<li>需要时间消化，请告诉对方“我看一下，晚点（给出具体时间段更佳）给你答复。”</li>
<li>事情有进展时，及时周知相关人等最新进度。</li>
<li>事情完成时，通知相关方，并感谢在其中给过帮助的人。</li>
</ol>
<p>做到这些，不需要很多时间，却会让与你合作的人感到轻松愉快。</p>
<h2 id="2-要做就别抱怨"><a href="#2-要做就别抱怨" class="headerlink" title="2. 要做就别抱怨"></a>2. 要做就别抱怨</h2><p>有的人，接受任务时永远不情不愿，嘴里没完没了地抱怨，最后虽仍然接下了任务，却留下了难以合作的印象。</p>
<p>如果别人的行为确实给自己带来了麻烦或是有为难之处，可以清晰告知对方自己难做的原因，说清楚希望对方如何改进，并告知这样的改进会给双方带来什么好处。</p>
<p>比如对方总给你扔急活，你为了这个急活不得不加班加点，到处求人。正确的做法是<strong>告诉对方这件事有哪些环节，分别需要多长时间，以后请提早多少天告知，以便更好的完成。这次帮忙加急，下不为例</strong>。这样对方能理解你这次加急赶完是帮了他忙，而不会抱怨每次给你事情都推三阻四还完成得不好。</p>
<h2 id="3-推进事情要推到有进展才算数"><a href="#3-推进事情要推到有进展才算数" class="headerlink" title="3. 推进事情要推到有进展才算数"></a>3. 推进事情要推到有进展才算数</h2><p>有些人，推进一件事的方法是：每隔一段时间，发封不痛不痒的邮件，抄送所有人，摆个样子跟进一下，也不在乎对方是否给了结果。仿佛在说“你看，我推过了，是对方不给做，推不动不关我事哦。出了问题责任是他是他还是他。”</p>
<p>如果是自家孩子病了，有哪位家长会说“我给医生发邮件了，他没回我，所以病治不了了。”显然，孩子生病时家长都是心急火燎的，医生不在会找护士，找主管，找院长，找媒体。用尽一切可用的渠道，一切可用的方法，直到医生给孩子看病为止。</p>
<p>当说一件事情推不动时，扪心自问自己真的做到了像家长为生病的孩子找医生那样努力吗？真的已经用尽了一切可用的力量，找尽了一切可找的人去推动这件事吗？</p>
<p>装模作样推一推是没有意义的，一定要推到这件事有实质进展为止。<strong>实质进展是对方给排期、给解决方案、给具体处理这件事的人</strong>。如果什么都没拿到，那根本不算推进过一件事。</p>
<h2 id="4-做不到早说"><a href="#4-做不到早说" class="headerlink" title="4. 做不到早说"></a>4. 做不到早说</h2><p>有的人，交给他的事情，不问永远没问题，一问全是问题。拖过了截止期做不到，罗列出一堆原因，都是ABCDE的问题，与他无关。</p>
<p>OK，就算ABCDE的问题确实与他无关，为什么不能在发现有这些问题时及时反馈呢？自己解决不了的问题，及时反馈并暴露，让有能力解决的人去解决，是靠谱最重要的表现之一。</p>
<p>又有人说，我要是暴露了这些问题得罪了别人怎么办？请问不暴露这些问题，任由时间资源浪费，事情最终没做到，就谁都不得罪了吗？<strong>作为一个团队，成事是最重要的。暴露问题是为了解决问题，而不是为了挑事，关键是把握分寸</strong>。</p>
<p>还有人说，跟别人没关系，就是堆给我的活太多了，我做不完怎么办？如果是这种情况，更要尽早反馈了。或许你花了大量时间在一件优先级比较低的事情上，导致最重要的事情没有做完。结果把自己累得半死，还谁都不满意。<strong>发现自己做不完，就要第一时间跟相关方确认优先级，力保最重要的事情能够及时完成。如果被插入了其他优先级更高的事，也要尽快知会事情被推迟的相关方</strong>。</p>
<h2 id="5-功劳是大家的"><a href="#5-功劳是大家的" class="headerlink" title="5. 功劳是大家的"></a>5. 功劳是大家的</h2><p>有些人，干活的时候一天八回地狂催别人。活干完了，人没影了，汇报工作成果时只字不提其他人，仿佛活全是他自己一人干的。这样的人，执行力再好，下次再找人干活时，也难得到别人心甘情愿的帮忙。</p>
<p><strong>无论别人是帮了多小的忙，在事情结束后也要表示感谢</strong>。道谢要不嫌隆重，能当面谢的尽量当面去谢，能单独打电话谢的就不要讲其他事情时顺便谢，发邮件表示感谢的话尽量抄送对方老板详细说明感谢的事由。这些事情并不费劲，却会让别人更愿意帮助你。</p>
<h2 id="6-别吐槽，给解决方案"><a href="#6-别吐槽，给解决方案" class="headerlink" title="6. 别吐槽，给解决方案"></a>6. 别吐槽，给解决方案</h2><p>有的人，你一找他解决问题，就开启吐槽模式，内容全是“我有多辛苦多不容易，能做的我都做了，这些问题全是因为balabala……”</p>
<p>每当这时我都好想告诉对方“亲，没有人关心你的心路历程。”我不关心你有多辛苦多不容易你做了多少事情，为什么别人就是没按照你设定的剧本做。我只知道现在有一个问题，我找你只想知道“怎样解决这个问题”。</p>
<p><strong>当有一个问题时，请直奔主题，给解决方案</strong>。</p>
<h2 id="7-敢作敢当"><a href="#7-敢作敢当" class="headerlink" title="7. 敢作敢当"></a>7. 敢作敢当</h2><p>当事情搞砸时，最次的做法是想尽办法推卸责任，最好的做法是<strong>诚恳道歉，评估影响范围，想尽办法用最快速度修正错误，弥补损失</strong>。</p>
<p>不要耍滑头，得意于自己把责任都推出去了，推卸得越成功，实际越失败。不要怕承担，勇于承担责任的人，别人才敢赋予你更大的责任。</p>
<h2 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h2><p>做到上面这些条，说难不难，说易也不易。说白了，就是要多操些心，多费些力。</p>
<p>有的人说一份工作而已，干嘛把自己搞这么累。我就做好自己这部分，别人的事我不管，跟我没关系，只要出事了别怪我头上就行。当然，若真这么想，没什么不行的，您高兴就好。只是请不要再抱怨为什么自己怀才不遇，升职加薪总是比别人慢。多劳多得，很公平，不是么？</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html">http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章作者：咪喵&lt;br&gt;文章来源： TalentGuide &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么有的人，明明事情做得不少，却永远没人说他好？有的人，不管做什么都得到周围人众口一词的称赞？&lt;/p&gt;
&lt;p&gt;真的是因为两个人做的事差很多吗？也
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】一切都是最好的安排</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-08-11-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E5%AE%89%E6%8E%92.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-08-11-一切都是最好的安排.html</id>
    <published>2016-08-11T04:00:00.000Z</published>
    <updated>2017-05-16T07:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>在人的一生中所遭遇的困境和不解，在当下或许是如此难以接受。但在过后某一时刻会突然觉得，这是最好的安排。<br>全文始终以“一切都是最好的安排”为主线，传递着正能量。十个“最好”篇章里，52个温暖人心的故事，入世、出世中贯穿着对人生、对情感、对事业的感悟，折射出生活 的简单与复杂，在世间百态中领略禅意的美。<br>时间扑面而来，我们终将释怀。<br>这不是一本“心灵鸡汤”，而是“心灵鱼汤”，营养丰富，同时也要小心刺。<br>《一切都是最好的安排》，这本书，你看不透可惜，看透了又可悲。<br>它给所有钻牛角尖、走进死胡同的人挖一条出路。<br>本书作者辉姑娘，长年从事艺人经纪的工作，与当红明星接触多了，在娱乐圈混迹久了，训练出百毒不侵的强大心理素质，这本书也是她自己每每感到活不下去时的一粒速效救心丸，关键时刻真能救命。<br>只有放弃问为什么，我们才能安于当下，以臣服之心，接受一切。不说悲，不说愁，一生故事独自守。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-08-11-一切都是最好的安排.html">http://www.sguotao.com/读书笔记-2016-08-11-一切都是最好的安排.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h2&gt;&lt;p&gt;在人的一生中所遭遇的困境和不解，在当下或许是如此难以接受。但在过后某一时刻会突然觉得，这是最好的安排。&lt;br&gt;全文始终以“一
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】成大事者不纠结</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-08-09-%E6%88%90%E5%A4%A7%E4%BA%8B%E8%80%85%E4%B8%8D%E7%BA%A0%E7%BB%93.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-08-09-成大事者不纠结.html</id>
    <published>2016-08-09T04:00:00.000Z</published>
    <updated>2017-05-16T02:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-08-09-成大事者不纠结.html">http://www.sguotao.com/读书笔记-2016-08-09-成大事者不纠结.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.sguotao.com/读书笔记-2016-08-09-成大事者不纠结.html&quot;&gt;http://www.sguotao.com/读书笔记-2016-08-09-成大事者不纠结.html&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
