<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <subtitle>和光同尘,静水流深</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sguotao.top/"/>
  <updated>2018-07-03T06:39:02.000Z</updated>
  <id>http://www.sguotao.top/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何下载并查看Android源码</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2018-07-03-%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E5%B9%B6%E6%9F%A5%E7%9C%8BAndroid%E6%BA%90%E7%A0%81.html"/>
    <id>http://www.sguotao.top/Android进阶-2018-07-03-如何下载并查看Android源码.html</id>
    <published>2018-07-03T02:55:25.000Z</published>
    <updated>2018-07-03T06:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为一名Android 开发人员，很有必要阅读Android源码，平时在编译器如AndroidStudio或IntelliJ中，只要是创建Android项目工程，就能够查看到Framework层的源码，但是这样看源码有两个弊端：</p><p>1.容易处在一种盲人摸象的状态，只能看到局部，不能总览全局；<br>2.看到的Framework层源码跟编译时使用的版本号相关，如果版本号很低，想看到最新的Android源码就十分的不方便。</p><p>还有一个很重要的原因，Google在Android P版本中，对非SDK接口进行了限制，什么意思？Google建议使用官方提供的SDK接口，对一些私有的API，Google是限制，甚至是禁止使用的。</p><h2 id="Android-P中SDK接口限制"><a href="#Android-P中SDK接口限制" class="headerlink" title="Android P中SDK接口限制"></a>Android P中SDK接口限制</h2><p>Google在最新的Android P版本中，对SDK接口的使用进行了严格的限制，这样的限制必将会对Android 应用的开发者带了影响，Google限制通过反射，JNI等方式调用非SDK接口，如果调用这些接口势必会带来兼容性问题，甚至会出现Crash。为了降低影响的程度，有必要了解一下SDK接口限制。</p><h3 id="什么是SDK接口"><a href="#什么是SDK接口" class="headerlink" title="什么是SDK接口"></a>什么是SDK接口</h3><p>凡是能够在<a href="https://developer.android.google.cn/reference/packages" target="_blank" rel="noopener">Google官网上查到的接口</a>，都是SDK接口，这些API是可以直接使用的。除了上面提到的接口，剩下的接口都是限制使用的。</p><h3 id="继续使用非SDK接口会有哪些影响"><a href="#继续使用非SDK接口会有哪些影响" class="headerlink" title="继续使用非SDK接口会有哪些影响"></a>继续使用非SDK接口会有哪些影响</h3><p>Google对非SDK接口提供了灰名单机制，将目前Android应用或定制OS调用的非SDK接口分进行了分级，分别为浅灰名单，深灰名单和黑名单。不同名单中的接口有不同的处理策略。</p><ol><li>浅灰名单，Google目前还没有可替代的SDK接口，暂时放在浅灰名单中。在Android P预览版上调用时会出现警告。</li><li>深灰名单，Google目前已经提供了可替代的SDK接口，开发者需要进行整改。这部分接口在Android P以下设备调用时出现警告，Android P及以上设备调用时出现Crash。</li><li>黑名单，浅灰名单和深灰名单之外的非SDK接口，都放在了这个名单中，这部分接口调用就会出现Crash。</li></ol><p>Google也提供了一个过渡期，这个过渡期是随着Android P版本同步的，在Android P最终版本发布之前，可以向Google发邮件申请，进行评估。<a href="https://issuetracker.google.com/issues/new?component=328403&amp;template=1027267" target="_blank" rel="noopener">地址</a><br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153058913695268.png" alt="20180703153058913695268.png"></p><h3 id="如何修改使用到的非SDK接口"><a href="#如何修改使用到的非SDK接口" class="headerlink" title="如何修改使用到的非SDK接口"></a>如何修改使用到的非SDK接口</h3><p>Google提供的 Veridex 扫描工具，可以扫描apk中使用的API。</p><p><a href="https://android.googlesource.com/platform/prebuilts/runtime/+/master/appcompat/" target="_blank" rel="noopener">Veridex下载地址</a></p><p><a href="https://android.googlesource.com/platform/prebuilts/runtime/+/master/appcompat/README.txt" target="_blank" rel="noopener">Veridex使用方法</a></p><p>解压下载的Veridex压缩包，Terminal进入到解压后的目录，将要进行扫描的APK拷贝到解压后的目录中，执行命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./appcompat.sh --dex-file=test.apk</span><br></pre></td></tr></table></figure><p>扫描完成后，就可以看到扫描之后的结果，这里扫描到了98个非SDK API的调用，下面就要针对扫描出来的各个API进行调整了。开发者需要重点关注深灰名单及黑名单中的接口。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153059903252234.png" alt="20180703153059903252234.png"></p><h2 id="如何下载Android源码"><a href="#如何下载Android源码" class="headerlink" title="如何下载Android源码"></a>如何下载Android源码</h2><p>这里介绍一下Android Framework源码的下载，这里提供两个下载地址，下载之前可能需要准备好梯子，关于如何优雅的翻墙，可以看之前分享的一篇文章<a href="http://sguotao.top/读书笔记-2018-06-29-如何优雅的飞跃长城.html" target="_blank" rel="noopener">如何优雅的飞跃长城</a></p><p><a href="https://github.com/android/platform_frameworks_base" target="_blank" rel="noopener">github下载地址</a><br><a href="https://android.googlesource.com/platform/frameworks/base/" target="_blank" rel="noopener">Google官方下载地址</a></p><p>这里使用git的方式下载，方便后面更新。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153059988163024.png" alt="20180703153059988163024.png"></p><h2 id="如何查看Android源码"><a href="#如何查看Android源码" class="headerlink" title="如何查看Android源码"></a>如何查看Android源码</h2><p>在Windows平台，有一个看源码的神器SourceInsight，但是在Mac平台还没有替代产品，这里介绍使用Sublime Text。</p><h2 id="遇到的问题及处理办法"><a href="#遇到的问题及处理办法" class="headerlink" title="遇到的问题及处理办法"></a>遇到的问题及处理办法</h2><p><strong>1.下载源码过程中遇到 error: RPC failed; curl 56 SSLRead() return error -9806835.00 KiB/s</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://testerhome.com/topics/13699" target="_blank" rel="noopener">https://testerhome.com/topics/13699</a></li><li><a href="https://developer.android.google.cn/reference/packages" target="_blank" rel="noopener">https://developer.android.google.cn/reference/packages</a></li></ol><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2018-07-03-如何下载并查看Android源码.html">http://www.sguotao.top/Android进阶-2018-07-03-如何下载并查看Android源码.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;作为一名Android 开发人员，很有必要阅读Android源码，平时在编译器如AndroidStudio或IntelliJ中，只要是创建A
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="源码" scheme="http://www.sguotao.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Google" scheme="http://www.sguotao.top/tags/Google/"/>
    
      <category term="Github" scheme="http://www.sguotao.top/tags/Github/"/>
    
      <category term="Framework" scheme="http://www.sguotao.top/tags/Framework/"/>
    
      <category term="SDK限制" scheme="http://www.sguotao.top/tags/SDK%E9%99%90%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的飞跃长城</title>
    <link href="http://www.sguotao.top/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2018-06-29-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E9%A3%9E%E8%B7%83%E9%95%BF%E5%9F%8E.html"/>
    <id>http://www.sguotao.top/读书笔记-2018-06-29-如何优雅的飞跃长城.html</id>
    <published>2018-06-29T08:39:15.000Z</published>
    <updated>2018-07-03T02:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Vultr和搬瓦工"><a href="#1-Vultr和搬瓦工" class="headerlink" title="1.Vultr和搬瓦工"></a>1.Vultr和搬瓦工</h2><p>Vultr和搬瓦工哪个好？从以下几方面做个对比：</p><h3 id="1-1-Vultr"><a href="#1-1-Vultr" class="headerlink" title="1.1 Vultr"></a>1.1 Vultr</h3><p>官网地址：<a href="https://www.vultr.com" target="_blank" rel="noopener">https://www.vultr.com</a>，月付低至2.5美元，按照小时付费，($0.004/小时)，可随时关停，不用不收费。目前在全球有15个数据中心，基于KVM虚拟，免费snapshots（快照，一键备份VPS）、免费50G备份空间，允许自定义ISO（方便安装windows）等功能；隶属于顶级机房choopa，有实力、有资金，靠谱！</p><p>这是注册优惠地址：<a href="https://www.vultr.com/?ref=7463051" target="_blank" rel="noopener">注册优惠地址</a>，通过这个链接，注册可以享受优惠。</p><h3 id="1-2-搬瓦工"><a href="#1-2-搬瓦工" class="headerlink" title="1.2 搬瓦工"></a>1.2 搬瓦工</h3><p>官方网站：<a href="https://bwh1.net" target="_blank" rel="noopener">https://bwh1.net</a>，目前搬瓦工VPS机房已经达到7个，分别是New York [USNY_2]，Los Angeles, California (DC1 QNET)，Los Angeles, California (DC2 MCOM)，Fremont, California，Phoenix, Arizona，Jacksonville, Florida，Amsterdam, Netherlands。没有特殊需求下，建议使用洛杉矶（Los Angeles）。常规最低配置$19.99/年，相当于每月1美金多一点。不过经常缺货，需要的要赶机会。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><strong>1.背景</strong></p><p>Vultr隶属其母公司choopa.com，2000年开始进入IDC行业，有自己的多处机房（Tier4），完全独立自主，实力雄厚，能够提供SLA保障。</p><p>bandwagonhost，隶属于IT7公司，从2005年开始进入IDC行业，没有自己的机房，在相关机房租用机柜运作。</p><p><strong>2.售后</strong></p><p>Vultr：有专门的团队，多人处理；</p><p>搬瓦工：基本为固定的一个人处理；</p><p><strong>3.价格</strong></p><p>Vultr：最低配置的VPS月付2.5美元，512M内存，KVM虚拟；由于vultr已经大规模部署，所以在不同价格阶段的配置都比搬瓦工便宜，所以价格上vultr胜出。</p><p>搬瓦工：最低配置的KVM月付2.88美元，最低OVZ月付2.99美元</p><p><strong>4.资源配置</strong></p><p>抛开VPS本身的硬件资源不谈，我们只说额外的附加产品</p><p>vultr：免费50G备份空间、免费snapshots快照、支持额外购买多个IP，支持升级到10Gbps端口，支持IP广播，支持DDOS防护，启动脚本设置，一键部署多种APP，支持按小时付款，可以随意删除和创建VPS。</p><p>搬瓦工：免费snapshot，常规版本VPS支持转移机房。</p><h2 id="2-新用户注册购买"><a href="#2-新用户注册购买" class="headerlink" title="2.新用户注册购买"></a>2.新用户注册购买</h2><p>文无第一，武无第二，经过再三的抉择之后，我选择了Vlutr，基本上充10美刀，能够用半年，而且不定期的活动还会有美元送。本人之前也用过很多的科学上网的方法，最后都不是很理想，最后还是决定搭建自己的VPS，主要经常使用Google，看Youtube的视频，下面把自己的搭建过程做一个分享和整理。</p><h3 id="2-1-创建账户"><a href="#2-1-创建账户" class="headerlink" title="2.1 创建账户"></a>2.1 创建账户</h3><p>进入官网<a href="https://www.vultr.com/?ref=7463051" target="_blank" rel="noopener">https://www.vultr.com</a>，登录注册邮箱，进行验证，验证成功后，就注册完成了。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/2018070115304344097889.png" alt="2018070115304344097889.png"></p><h3 id="2-2-充值"><a href="#2-2-充值" class="headerlink" title="2.2 充值"></a>2.2 充值</h3><p>Vlutr目标支持5中支付方式，我们常用的可能是支付宝和信用卡，选择好支付方式和充值金额之后，按照提示进行一步步的操作。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043474915453.png" alt="20180701153043474915453.png"></p><h2 id="3-Vultr搭建"><a href="#3-Vultr搭建" class="headerlink" title="3.Vultr搭建"></a>3.Vultr搭建</h2><p>在搭建自己的VPS之前，需要根据自己的网络环境，确定使用的是联通，移动，电信还是其它的二级运营商，不同的运营商可能连接不同机房的速度是不一样的，比如我在家就使用东京的机房，在公司使用西雅图的机房，在公司使用东京的机房，会出现丢包比较严重的情况。</p><p>Vultr提供了测试地址，只需要在ping一下。</p><table><thead><tr><th style="text-align:center">测试机房</th><th style="text-align:center">地址</th></tr></thead><tbody><tr><td style="text-align:center">日本 东京</td><td style="text-align:center">hnd-jp-ping.vultr.com</td></tr><tr><td style="text-align:center">新加坡</td><td style="text-align:center">sgp-ping.vultr.com</td></tr><tr><td style="text-align:center">悉尼</td><td style="text-align:center">syd-au-ping.vultr.com</td></tr><tr><td style="text-align:center">华盛顿州 西雅图</td><td style="text-align:center">wa-us-ping.vultr.com</td></tr><tr><td style="text-align:center">美西 加州 硅谷</td><td style="text-align:center">sjo-ca-us-ping.vultr.com</td></tr><tr><td style="text-align:center">美西 加州 洛杉矶</td><td style="text-align:center">lax-ca-us-ping.vultr.com</td></tr></tbody></table><p>这是我在公司测试的结果，发现西雅图机房的丢包率和连接速度都优于其他期房，于是选择了西雅图机房。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043531033607.png" alt="20180701153043531033607.png"></p><h3 id="3-1-创建虚拟机"><a href="#3-1-创建虚拟机" class="headerlink" title="3.1 创建虚拟机"></a>3.1 创建虚拟机</h3><p>1.在页面中点击<strong>+</strong>图标开始创建虚拟机。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043620261378.png" alt="20180701153043620261378.png"></p><p>2.根据自己的测试结果，选择创建服务器的位置。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043636657206.png" alt="20180701153043636657206.png"></p><p>3.选择安装虚拟机的系统，如果选择Windows系统，需要付费，当然可以选择自己上传的ISO镜像。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043642838215.png" alt="20180701153043642838215.png"></p><p>4.选择虚拟机的配置，不同的配置，价钱也不相同，如果只是用来搭建VPS，选择5美刀的完全够用，新推出的2.5美刀，只支持IPV6。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043652432473.png" alt="20180701153043652432473.png"></p><p>5.剩下的选项我们直接选择默认即可。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/2018070115304366146794.png" alt="2018070115304366146794.png"></p><p>6.创建成功后，虚拟机会显示Running运行的状态。这里的Server Stop和Server Destroy都可以暂停虚拟机，区别是Stop状态，还是会进行计费的。所以如果一段时间不使用，为了避免损失，可以选择Destroy。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043681761707.png" alt="20180701153043681761707.png"></p><h3 id="3-2-搭建Shadowsocks服务端"><a href="#3-2-搭建Shadowsocks服务端" class="headerlink" title="3.2 搭建Shadowsocks服务端"></a>3.2 搭建Shadowsocks服务端</h3><p>虚拟机创建完成之后，下面就是搭建Shadowsocks服务器了，如果是Windows系统，建议安装Xshell，如果是mac或linux系统，可以在Terminal中使用ssh直接连接。</p><p>关于Xshell，目前最新的版本是Xshell6，如果是只是为了连接我们创建的虚拟机，可以去官网下载xshell6的免费版本。</p><p>连接上虚拟机后，复制下面命令，然后在Xshell或Terminal中回车运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocksR.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/shadowsocksR.sh &amp;&amp; bash shadowsocksR.sh</span><br></pre></td></tr></table></figure><p>回车后会自动下载脚本并运行，依次输入各项信息之后，按回车继续。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043741869105.png" alt="20180701153043741869105.png"></p><p>如果在输入过程中，需要进行修改，需要按ctrl或command键加删除键进行删除。等待几分钟后，Shadowsocks搭建成功。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153043752163957.png" alt="20180701153043752163957.png"></p><p>有时候我们需要修改已经搭建好的Shadowsocket的配置信息。不需要重新进行安装，运行下面的命令,然后重新输入各项配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocksR.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/shadowsocksR.sh &amp;&amp; bash shadowsocksR.sh modify</span><br></pre></td></tr></table></figure><h3 id="3-3-安装速锐"><a href="#3-3-安装速锐" class="headerlink" title="3.3 安装速锐"></a>3.3 安装速锐</h3><p>到这里已经搭建好了Shadowsockets服务器，但是由于服务器都在国外，会出现链接比较慢的情况，这里需要安装加速软件来进行提速。</p><p>需要说明的是，加速软件有很多，比如速锐和Google BBR，由于速锐会降级系统内核，而Google BBR会升级系统内核，两个加速器存在冲突，不能同时安装。这里安装的是速锐。</p><p>在安装速锐之前，需要先确定安装的虚拟机的系统的版本。在Xshell或者Terminal中运行命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><ul><li>结果以 2 开头，例如 2.6.32-696.18.7.el6.x86_64。这种输出结果说明我们的服务器为 CentOS6 x64 系统。</li><li>结果以 3 开头，例如 3.10.0-693.11.6.el7.x86_64。这种输出结果说明我们的服务器为 CentOS7 x64 系统，。</li><li>结果以 4 开头，例如 4.12.10-1.el7.elrepo.x86_64。这种输出结果说明我们的服务器已经安装 Google BBR 拥塞控制算法，此时已经无法继续安装锐速。</li></ul><p><strong>这里以CentOS6 x64 系统进行说明，后面也会提供CentOS7 x64 系统的下载及安装命令。</strong></p><p>当确认我们的系统是CentOS6 x64后，复制并运行下面命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install &apos;2.6.32-642.el6.x86_64&apos;</span><br></pre></td></tr></table></figure><p>如果虚拟机是CentOS7 x64系统，需要运行下面的命令，<strong>注意与CentOS6 x64系统的区别。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/rskernel.sh &amp;&amp; bash rskernel.sh</span><br></pre></td></tr></table></figure><p>运行命令后，会出现三项的提示信息，这里使用默认值即可，直接按三次回车。安装成功后会看到 <strong><em>ServerSpeeder is running!</em></strong> 的提示信息。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180701153044054987445.png" alt="20180701153044054987445.png"></p><p>如果是CentOS7 x64的系统，需要多运行一次下面的命令，在安装完速锐后，会重启虚拟机，待虚拟机启动完成后，使用Xshell或Terminal连接服务器，运行命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install net-tools -y &amp;&amp; wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install</span><br></pre></td></tr></table></figure><p>运行命令后出现的三项提示信息，也是用默认值即可，直接三次回车。安装成功后，也会看到<strong><em>ServerSpeeder is running!</em></strong> 的提示信息。</p><h3 id="3-4-安装客户端"><a href="#3-4-安装客户端" class="headerlink" title="3.4 安装客户端"></a>3.4 安装客户端</h3><p>进行到这里，服务端VPS的搭建已经完成了，下面就是客户端如何使用我们已经搭建好的VPS了。这里使用的是Shadowsocks的客户端。</p><p><a href="https://curls.fun/Shadowsocks/ShadowsocksR-Windows-4.9.0.zip" target="_blank" rel="noopener">Windows客户端</a></p><p><a href="https://www.vultrcn.com/goto/?url=aHR0cHM6Ly9jdXJscy5mdW4vU2hhZG93c29ja3MvU2hhZG93c29ja3NSLU1hY09TLTEuNy4wLnppcA==" target="_blank" rel="noopener">MacOS客户端</a></p><p><a href="https://www.vultrcn.com/goto/?url=aHR0cHM6Ly9jdXJscy5mdW4vU2hhZG93c29ja3MvU2hhZG93c29ja3NSLUFuZHJvaWQtMy40LjAuOC5hcGs=" target="_blank" rel="noopener">Android客户端</a></p><p>如果是Iphone等IOS设备，需要使用PP助手进行安装。<a href="https://www.25pp.com/ios/detail_1923429/" target="_blank" rel="noopener">IOS客户端</a></p><p>另外可以在App Store中搜索 BestWingy 进行下载安装。</p><h2 id="4-常见问题及解决办法"><a href="#4-常见问题及解决办法" class="headerlink" title="4.常见问题及解决办法"></a>4.常见问题及解决办法</h2><h3 id="4-1-注册Vlutr"><a href="#4-1-注册Vlutr" class="headerlink" title="4.1 注册Vlutr"></a>4.1 注册Vlutr</h3><p>注册Vlutr时可以使用下面的<a href="https://www.vultr.com/?ref=7463051" target="_blank" rel="noopener">推广链接</a>，或者直接点击图片，这样就有机会获得10美刀，差不多是两个月的VPS的使用权。</p><p><a href="https://www.vultr.com/?ref=7463051" target="_blank" rel="noopener"><img src="https://www.vultr.com/media/banner_1.png" alt=""></a></p><h3 id="4-2-如果在安装过程中出现“Resolving-raw-githubusercontent-com…-failed-Temporary-failure-in-name-resolution-”提示，可以使用如下命令"><a href="#4-2-如果在安装过程中出现“Resolving-raw-githubusercontent-com…-failed-Temporary-failure-in-name-resolution-”提示，可以使用如下命令" class="headerlink" title="4.2 如果在安装过程中出现“Resolving raw.githubusercontent.com… failed: Temporary failure in name resolution.”提示，可以使用如下命令"></a>4.2 如果在安装过程中出现“Resolving raw.githubusercontent.com… failed: Temporary failure in name resolution.”提示，可以使用如下命令</h3><p>wget: unable to resolve host address “raw.githubusercontent.com”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;nameserver 8.8.8.8&apos;&gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure><hr><p>本文链接：<a href="http://www.sguotao.top/读书笔记-2018-06-29-如何优雅的飞跃长城.html">http://www.sguotao.top/读书笔记-2018-06-29-如何优雅的飞跃长城.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Vultr和搬瓦工&quot;&gt;&lt;a href=&quot;#1-Vultr和搬瓦工&quot; class=&quot;headerlink&quot; title=&quot;1.Vultr和搬瓦工&quot;&gt;&lt;/a&gt;1.Vultr和搬瓦工&lt;/h2&gt;&lt;p&gt;Vultr和搬瓦工哪个好？从以下几方面做个对比：&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="飞跃长城" scheme="http://www.sguotao.top/tags/%E9%A3%9E%E8%B7%83%E9%95%BF%E5%9F%8E/"/>
    
      <category term="Vultr" scheme="http://www.sguotao.top/tags/Vultr/"/>
    
  </entry>
  
  <entry>
    <title>学习一门语言大致经历的阶段</title>
    <link href="http://www.sguotao.top/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2018-06-26-%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%A4%A7%E8%87%B4%E7%BB%8F%E5%8E%86%E7%9A%84%E9%98%B6%E6%AE%B5.html"/>
    <id>http://www.sguotao.top/生活感悟-2018-06-26-学习一门编程语言大致经历的阶段.html</id>
    <published>2018-06-26T09:47:12.000Z</published>
    <updated>2018-06-26T09:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习一门语言大概会经历如下几步。</p><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><p>学习任何东西，都是一个由表及里的过程。学习一门编程语言也一样。对于一门编程语言来说，“表” 就是基本词汇和语法。对于基础语法的学习，我们可以看一些简短而又系统的教程。</p><h2 id="2-编码实践"><a href="#2-编码实践" class="headerlink" title="2.编码实践"></a>2.编码实践</h2><blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>掌握基础，持续练习。每一门编程语言的学习内容都会涉及：</p><ul><li>运行环境</li><li>数据类型（数字、字符串、数组、集合、映射字典等）</li><li>表达式</li><li>函数</li><li>流程控制</li><li>类、方法等等</li></ul><p>不同的语言还有一些不同的特性，<strong>可以通过对比学习来加深理解</strong>。并通过大量实践深入理解，达到熟练使用。后面还要再去深入了解面向对象编程OOP、函数式编程FP、并发、异常、文件IO、网络、标准库等内容，并辅以持续的练习，这些内容才能够让你真正进入编程领域并做出实际的软件。在实践的过程中，</p><blockquote><p>相信10000小时定律，No Pain, No Gain。</p></blockquote><p>学习一门新的语言的时候，<strong>要利用以前所学的语言的功底，但是也要保持开放的心态。</strong>这些在认知心理学中有相应的讲述。</p><h2 id="3-技近乎道"><a href="#3-技近乎道" class="headerlink" title="3.技近乎道"></a>3.技近乎道</h2><p>基础语法学习，能让你快速上手，应用实践。对技巧和坑的关注，一定程度上拓展了你的知识面。系统学习，一方面会进一步拓展你的知识面。另一方面，也有利于你语言知识结构的形成。</p><p>任何一门成熟语言，都有其特有的生态。这个生态包括: </p><ul><li>框架</li><li>扩展包</li><li>解决方案</li><li>模式</li><li>规范等。</li></ul><p>在不断编码实践过程中，我们逐步熟练使用很多API库、框架，也不断踩坑填坑、看源代码、不断解决问题，不断加深对语言的理解，同时会看一些优秀的框架源代码。</p><p>如果还有精力，我们再去学习语言更底层的东西，而不仅仅停留在应用层面。如Java中的集合类实现的算法与数据结构，如JVM是如何执行Java代码的。如Java的线程和操作系统线程的关系。以及一些操作系统方面的知识。</p><p>最后，达到游刃有余的境界。这一层级，基本可入武林高手之列了。</p><blockquote><p>庖丁释刀对曰：“臣之所好者，道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而神欲行。依乎天理，批大郤，导大窾，因其固然，技经肯綮之未尝，而况大軱乎！</p></blockquote><p>这里的“牛”，可以理解为我们所说的各种编程思想，编程范式，编程方法，编程技巧等等。最后，达到“运用之妙，存乎一心”之境也。</p><h2 id="4-创造新世界"><a href="#4-创造新世界" class="headerlink" title="4.创造新世界"></a>4.创造新世界</h2><p>编程的本质就是创造世界。达到这个境界的，基本都是世界顶尖大牛了。</p><hr><p>本文链接：<a href="http://www.sguotao.top/生活感悟-2018-06-26-学习一门编程语言大致经历的阶段.html">http://www.sguotao.top/生活感悟-2018-06-26-学习一门编程语言大致经历的阶段.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习一门语言大概会经历如下几步。&lt;/p&gt;
&lt;h2 id=&quot;1-基本语法&quot;&gt;&lt;a href=&quot;#1-基本语法&quot; class=&quot;headerlink&quot; title=&quot;1.基本语法&quot;&gt;&lt;/a&gt;1.基本语法&lt;/h2&gt;&lt;p&gt;学习任何东西，都是一个由表及里的过程。学习一门编程语言也一样
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="编程" scheme="http://www.sguotao.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin笔记</title>
    <link href="http://www.sguotao.top/Kotlin-2018-06-22-kotlin.html"/>
    <id>http://www.sguotao.top/Kotlin-2018-06-22-kotlin.html</id>
    <published>2018-06-22T07:25:42.000Z</published>
    <updated>2018-06-29T08:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kotlin介绍"><a href="#Kotlin介绍" class="headerlink" title="Kotlin介绍"></a>Kotlin介绍</h2><blockquote><p>Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可以被编译成为JavaScript源代码。Kotlin与Java 100%兼容，能够运行在Android平台和浏览器上。</p></blockquote><h2 id="Kotlin的应用场景"><a href="#Kotlin的应用场景" class="headerlink" title="Kotlin的应用场景"></a>Kotlin的应用场景</h2><p><strong>1.Kotlin Script</strong><br>在IntellJ Idea中创建后缀为.kts的脚本文件，可以直接运行。Gradle在3.0之后部分支持Kotlin作为其脚本语言。</p><p><strong>2.Java虚拟机应用</strong><br>常见的Web应用，JavaFx应用，Kotlin都完美支持。</p><p><strong>3.前端开发</strong><br>Kotlin从1.1版本开始，Kotlin可以编译成JavaScript代码，运行在浏览器上。</p><p><strong>4.Android应用开发</strong><br>Kotlin应用的主战场</p><p><strong>5.Native程序开发</strong><br>直接将Kotlin代码编译成机器码，不依赖JVM，区别于JNI，能与C直接进行交互。</p><h2 id="Kotlin语法特性"><a href="#Kotlin语法特性" class="headerlink" title="Kotlin语法特性"></a>Kotlin语法特性</h2><h3 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1.定义类"></a>1.定义类</h3><p>定义类，使用class关键字，它有一个默认的构造器，只需要在类名后面写上参数，如果类没有任何内容，可以省略大括号。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name:String,age:<span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>构造函数的函数体卸载init代码块中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name:String,age:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    init&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><p>在Kotlin中任何类都是继承自Any，所有类默认是不以被继承的，都是final类型，如果想让类被继承，可以使用open或abstract关键字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>(name:String)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name:String,age:<span class="built_in">Int</span>): Animal(name) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h3><p>使用fun关键字声明函数，如果没有指定函数的返回类型，默认为Unit</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">如果返回的结果可以使用一个表达式来表示，可以省略大括号，使用等号。</span><br><span class="line"></span><br><span class="line">```Kotlin</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x + y</span><br></pre></td></tr></table></figure><p>Kotlin中定义的函数可以指定默认参数，在调用函数的时候，可以省略这个参数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showToast</span><span class="params">(message: <span class="type">String</span>, tag: <span class="type">String</span> = javaClass.simpleName, length: <span class="type">Int</span> = Toast.LENGTH_SHORT)</span></span> &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"[<span class="variable">$tag</span>] <span class="variable">$message</span>"</span>, length).show()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用时</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showToast(<span class="string">"Hello Kotlin"</span>)</span><br><span class="line">showToast(<span class="string">"Hello Kotlin"</span>, <span class="string">"Letv"</span>, Toast.LENGTH_LONG)</span><br><span class="line">showToast(message = <span class="string">"Hello Kotlin"</span>, tag = <span class="string">"sguotao"</span>)</span><br></pre></td></tr></table></figure><h3 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4.基本类型"></a>4.基本类型</h3><p><strong>1.数字类型不会进行自动转型，必须要做一个明确的类型转换</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i:<span class="built_in">Int</span> = <span class="number">7</span></span><br><span class="line"><span class="keyword">val</span> d:<span class="built_in">Double</span> = i.toDouble()</span><br></pre></td></tr></table></figure><p><strong>2.字符Char不能直接作为一个数字来处理，需要进行类型转换。</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c:<span class="built_in">Char</span> = <span class="string">'c'</span></span><br><span class="line"><span class="keyword">val</span> i:<span class="built_in">Int</span> = c.toInt()</span><br></pre></td></tr></table></figure><p><strong>3.位运算符使用and or 区别与Java的“ &amp; |”</strong><br><strong>4.Kotlin编译器可以推断出变量的类型，此时可以省略声明时的具体类型</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">5</span> <span class="comment">//Int</span></span><br><span class="line"><span class="keyword">val</span> d = <span class="number">4.5</span> <span class="comment">//Double</span></span><br><span class="line"><span class="keyword">val</span> iHex = <span class="number">0x1f</span> <span class="comment">//十六进制Int</span></span><br><span class="line"><span class="keyword">val</span> l = <span class="number">2</span>l <span class="comment">//Long</span></span><br><span class="line"><span class="keyword">val</span> f = <span class="number">3.5</span>f <span class="comment">//Float</span></span><br></pre></td></tr></table></figure><p><strong>5.String类型可以像数组一样访问和迭代</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"sample"</span></span><br><span class="line"><span class="keyword">val</span> a = s[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (a <span class="keyword">in</span> s)&#123;</span><br><span class="line">    print(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5.变量"></a>5.变量</h3><p>在Kotlin中变量分为可变变量(var)和不可变变量(val)，一个不可变变量在实例化之后，其状态就不能被改变，所以不可变变量可以认为是线程安全的。在Java中也分为可变和不可变（final），在kotlin中只要有可能，尽量使用val声明的不可变量，因为事实上大多数情况使用的变量都是不可变量，这样可以带来诸如线程安全的好处。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">"sample"</span></span><br></pre></td></tr></table></figure><p>如果使用泛型类型，声明变量时需要指定类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: Any = <span class="number">12</span></span><br></pre></td></tr></table></figure><p>声明变量时，编译器会根据变量初始化时的赋值类型，推断变量的类型。对类型转换的情况，需要显示的调用，如不能将Int类型直接转换为Long类型，编译器会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun Int2Long()&#123;</span><br><span class="line">        val x:Int = 10</span><br><span class="line">        //val y:Long = x // Type mismatch</span><br><span class="line">        </span><br><span class="line">        val y:Long = x.toLong()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时需要使用is关键字来进行类型的检测。</p><h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6.属性"></a>6.属性</h3><p>在Kotlin中，属性会默认创在getter和setter方法，如果需要重写getter和setter方法，使用field关键字访问属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> field.toUpperCase()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = <span class="string">"Name: <span class="variable">$value</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-扩展函数"><a href="#7-扩展函数" class="headerlink" title="7.扩展函数"></a>7.扩展函数</h3><p>扩展函数是指在一个类上增加一种新的行为，即使没有对这个类的访问权限。扩展函数并不是真正修改原来的类，它是以静态导入的方式来实现的。扩展函数表现的就像是该函数属于该类一样，甚至可以使用this关键字调用类中的public方法。</p><p>声明一个扩展函数，需要用一个<strong><em>接收者类型</em></strong>也就是被扩展的类型来作为他的前缀。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1] <span class="comment">// “this”对应该列表</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-伴生对象"><a href="#8-伴生对象" class="headerlink" title="8.伴生对象"></a>8.伴生对象</h3><p>使用伴生对象实际上是在这个类内部创建了一个名为 Companion 的静态单例内部类，伴生对象中定义的属性会直接编译为外部类的静态字段，而函数会被编译为伴生对象的方法。</p><h3 id="9-内置函数"><a href="#9-内置函数" class="headerlink" title="9.内置函数"></a>9.内置函数</h3><p>支持闭包(block)，如果函数中最后一个参数为闭包，那么最后一个参可以不写在括号中，而写在括号后面，如果只有一个参数，括号也可以去掉。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toast</span><span class="params">()</span></span> &#123;</span><br><span class="line">    button.setOnClickListener(&#123;</span><br><span class="line">       Toast.makeText(context, <span class="string">"test"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">toast</span><span class="params">()</span></span> &#123;</span><br><span class="line">    button.setOnClickListener &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"test"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-repeat函数"><a href="#9-1-repeat函数" class="headerlink" title="9.1 repeat函数"></a>9.1 repeat函数</h4><p>循环执行多次block中内容。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">3</span>) &#123;</span><br><span class="line">        println(<span class="string">"Hello world"</span>)<span class="comment">//打印3遍“Hello World”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-with函数"><a href="#9-2-with函数" class="headerlink" title="9.2 with函数"></a>9.2 with函数</h4><p>with函数接收一个对象和一个函数，这个函数会作为这个对象的扩展函数来执行。即指定的T作为闭包的receiver，使用参数中闭包的返回结果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.()</span></span> -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-let函数（TODO）"><a href="#9-3-let函数（TODO）" class="headerlink" title="9.3 let函数（TODO）"></a>9.3 let函数（TODO）</h4><p>let函数可以被任意对象调用，它接收一个函数作为参数，作为参数的函数的返回结果作为整个整个函数的返回值。</p><h4 id="9-4-apply函数（TODO）"><a href="#9-4-apply函数（TODO）" class="headerlink" title="9.4 apply函数（TODO）"></a>9.4 apply函数（TODO）</h4><p>与with函数类似，apply可以以避免创建Builder的方式来使用，因为对象调用的函数可以根据需要来初始化自己，并且返回它同一个对象。</p><h4 id="9-5-run函数（TODO）"><a href="#9-5-run函数（TODO）" class="headerlink" title="9.5 run函数（TODO）"></a>9.5 run函数（TODO）</h4><h3 id="10-“-”与“-”"><a href="#10-“-”与“-”" class="headerlink" title="10.“===”与“!==”"></a>10.“===”与“!==”</h3><p>操作符“===”与“!===”用来判断两个对象是否为同一个对象，对应Java中的“==”和“!=”</p><h3 id="11-Lambda表达式-TODO"><a href="#11-Lambda表达式-TODO" class="headerlink" title="11.Lambda表达式(TODO)"></a>11.Lambda表达式(TODO)</h3><h3 id="12-内联函数-inline"><a href="#12-内联函数-inline" class="headerlink" title="12.内联函数(inline)"></a>12.内联函数(inline)</h3><p>被inline修饰的函数或lambda表达式,在调用时都会被内联(在调用处插入函数体代码)</p><h3 id="13-操作符重载（TODO）"><a href="#13-操作符重载（TODO）" class="headerlink" title="13.操作符重载（TODO）"></a>13.操作符重载（TODO）</h3><h3 id="14-委托属性（TODO）"><a href="#14-委托属性（TODO）" class="headerlink" title="14.委托属性（TODO）"></a>14.委托属性（TODO）</h3><h3 id="15-总数操作符"><a href="#15-总数操作符" class="headerlink" title="15.总数操作符"></a>15.总数操作符</h3><p><strong>1.any 如果有一个元素符合给出的判断条件，返回true*</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> listwithNull = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">null</span>, <span class="number">5</span>, <span class="literal">null</span>, <span class="number">6</span>, <span class="literal">null</span>)</span><br><span class="line">assertTrue(list.any &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure><p><strong>2.all 如果全部的元素符合给出的判断条件，返回true</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertTrue &#123; list.all &#123; it &gt; <span class="number">0</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>3.count 返回符合给出判断条件的元素的个数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(<span class="number">3</span>, list.count &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure><p><strong>4.fold 在一个初始值的基础上从第一项到最后一项进行累加</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(<span class="number">220</span>, list.fold(<span class="number">10</span>) &#123; total, next -&gt; total + next * <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure><p><strong>5.foldRight 与fold类似，但顺序是从最后一项到第一项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(31, list.foldRight(10) &#123; total, next -&gt; total + next &#125;)</span><br></pre></td></tr></table></figure><p><strong>6.forEach 遍历所有元素并执行给定操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach() &#123; print(it) &#125;</span><br></pre></td></tr></table></figure><p><strong>7.forEachIndexed 与forEach类似，同时可以获取元素的index</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEachIndexed() &#123; index, value -&gt; println(<span class="string">"position:<span class="variable">$index</span>,value:<span class="variable">$value</span>"</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>8.max 返回最大一项，如果没有返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(6, list.max())</span><br></pre></td></tr></table></figure><p><strong>9.maxBy 根据给定的函数，返回最大一项，如果没有返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(1, list.maxBy &#123; -it &#125;)</span><br></pre></td></tr></table></figure><p><strong>10.min 返回最小一项，如果没有返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(1, list.min())</span><br></pre></td></tr></table></figure><p><strong>11.minBy 根据给定的函数，返回最小的一项，如果没有返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(6, list.minBy &#123; -it &#125;)</span><br></pre></td></tr></table></figure><p><strong>12.none 如果没有任何元素与给定的函数匹配，返回true</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertTrue &#123; list.none() &#123; it &gt;= 7 &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>13.reduce 与fold类似，但没有初始值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(21, list.reduce() &#123; total, next -&gt; total + next &#125;)</span><br></pre></td></tr></table></figure><p><strong>14.reduceRight 与reduce类似，但顺序是从最后一项到第一项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(21, list.reduceRight() &#123; total, next -&gt; total + next &#125;)</span><br></pre></td></tr></table></figure><p><strong>15.sumBy 返回每一项通过函数转换后的数据总和</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(-21, list.sumBy &#123; -it &#125;)</span><br></pre></td></tr></table></figure><h3 id="16-过滤操作符"><a href="#16-过滤操作符" class="headerlink" title="16.过滤操作符"></a>16.过滤操作符</h3><p><strong>16.drop 返回包含去掉前n个元素的所有元素的列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(5, 6), list.drop(4))</span><br></pre></td></tr></table></figure><p><strong>17.dropWhile 返回去掉满足指定函数要求的，从第一个元素开始的所有元素的列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(4, 5, 6), list.dropWhile &#123; it &lt; 4 &#125;)</span><br></pre></td></tr></table></figure><p><strong>18.dropLastWhile 返回去掉指定函数要求的，从最后一个元素开始的所有元素的列表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(1, 2, 3, 4), list.dropLastWhile &#123; it &gt; 4 &#125;)</span><br></pre></td></tr></table></figure><p><strong>19.filter 保留所有满足指定函数要求的元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(2, 4, 6), list.filter &#123; it % 2 == 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>20.filterNot 过滤掉所有满足指定函数要求的元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(1, 3, 5), list.filterNot &#123; it % 2 == 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>21.filterNotNull 保留所有不为null的元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(1, 2, 3, 4, 5, 6), listwithNull.filterNotNull())</span><br></pre></td></tr></table></figure><p><strong>22.slice 保留list中指定index的元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(2, 4, 5), list.slice(listOf(1, 3, 4)))</span><br></pre></td></tr></table></figure><p><strong>23.take 保留从第一个元素开始的n个元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(1, 2, 3), list.take(3))</span><br></pre></td></tr></table></figure><p><strong>24.takeLast 保留从最后一个元素开始的n个元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(4, 5, 6), list.takeLast(3))</span><br></pre></td></tr></table></figure><p><strong>25.takeWhile 保留从第一个元素开始，满足指定函数的元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(1, 2), list.takeWhile &#123; it &lt; 3 &#125;)</span><br></pre></td></tr></table></figure><h3 id="17-映射操作符"><a href="#17-映射操作符" class="headerlink" title="17.映射操作符"></a>17.映射操作符</h3><p><strong>26.flatMap 遍历每一个元素，为每一个元素创建一个集合，最后把所有集合合并为一个集合</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(list)//list:[1,2,3,4,5,6]</span><br><span class="line">//[1,2],[2,3],[3,4],[4,5],[5,6],[6,7] =&gt; [1,2,2,3,3,4,4,5,5,6,6,7]</span><br><span class="line">println(list.flatMap &#123; listOf(it, it + 1) &#125;)</span><br></pre></td></tr></table></figure><p><strong>27.groupBy 返回一个根据指定函数分组的map</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(mapOf(&quot;odd&quot; to listOf(1, 3, 5)))</span><br><span class="line">println(mapOf(&quot;even&quot; to listOf(2, 4, 6)))</span><br><span class="line">println(list.groupBy &#123; if (it % 2 == 0) &quot;even&quot; else &quot;odd&quot; &#125;)</span><br></pre></td></tr></table></figure><p><strong>28.map 返回一个，每个元素都按照指定函数进行转换后的集合</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(2, 4, 6, 8, 10, 12), list.map &#123; it -&gt; it * 2 &#125;)</span><br></pre></td></tr></table></figure><p><strong>29.mapIndexed 返回一个，每个元素按照包含元素index的指定函数转换后的集合</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(0, 2, 6, 12, 20, 30), list.mapIndexed &#123; it, index -&gt; index * it &#125;)</span><br></pre></td></tr></table></figure><p><strong>30.mapNotNull 返回一个过滤掉null元素，并且非null元素按照指定函数进行转换后的集合</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(listwithNull)</span><br><span class="line">println(listwithNull.mapNotNull &#123; it &#125;)</span><br></pre></td></tr></table></figure><h3 id="18-元素操作符"><a href="#18-元素操作符" class="headerlink" title="18.元素操作符"></a>18.元素操作符</h3><p><strong>31.contains 如果指定元素在集合中，返回true</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertTrue(list.contains(1))</span><br></pre></td></tr></table></figure><p><strong>32.elementAt 返回指定index对应的元素，如果index越界，抛IndexOutOfBoundsException</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(1, list.elementAt(0))</span><br></pre></td></tr></table></figure><p><strong>33.elementAtOrElse 返回指定index对应的元素，如果index越界，返回指定函数中设置的默认值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(20, list.elementAtOrElse(10, &#123; 2 * it &#125;))</span><br></pre></td></tr></table></figure><p><strong>34.elementAtOrNull 返回指定index对应的元素，如果index越界，返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertNull(list.elementAtOrNull(10))</span><br></pre></td></tr></table></figure><p><strong>35.first 返回第一个满足指定函数的元素，如果没有，抛出NoSuchElementException</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(2, list.first() &#123; it % 2 == 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>36.firstOrNull 返回第一个满足指定函数的元素，如果没有返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertNull(list.firstOrNull() &#123; it &lt; 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>37.indexOf 返回指定元素的第一个index，如果不存在返回-1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(-1, list.indexOf(7))</span><br></pre></td></tr></table></figure><p><strong>38.indexOfFirst 返回第一个满足指定函数的元素的index，如果不存在返回-1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(1, list.indexOfFirst &#123; it % 2 == 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>39.indexOfLast 返回最后一个满足指定函数的元素的index，如果不存在返回-1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(5, list.indexOfLast &#123; it % 2 == 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>40.last 返回最后一个满足指定函数的元素，如果没有，抛出NoSuchElementException</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.last() &#123; it % 2 == 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>41.lastIndexOf 返回指定元素的最后一个index，如果不存在返回-1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(listwithNull.lastIndexOf(null))</span><br></pre></td></tr></table></figure><p><strong>42.lastOrNull 返回最后一个满足指定函数的元素，如果没有返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertNull(list.lastOrNull() &#123; it &lt; 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>43.single 返回满足指定函数的单个元素，如果没有，或者满足条件的元素个数超过一个，抛出异常</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(1, list.single() &#123; it &lt; 2 &#125;)</span><br></pre></td></tr></table></figure><p><strong>44.singleOrNull 返回满足指定函数的单个元素，如果没有，或者满足条件的元素个数超过一个，返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.singleOrNull() &#123; it % 2 == 0 &#125;)</span><br></pre></td></tr></table></figure><h3 id="19-生产操作符"><a href="#19-生产操作符" class="headerlink" title="19.生产操作符"></a>19.生产操作符</h3><p><strong>45.partition 将一个给定的集合分割成两个集合，第一个集合是由匹配指定函数，返回true的元素组成。第二个集合是由匹配指定函数，返回false的元素组成。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(Pair(listOf(1, 3, 5), listOf(2, 4, 6)), list.partition &#123; it % 2 != 0 &#125;)</span><br></pre></td></tr></table></figure><p><strong>46.plus 返回一个包含原集合和给定集合中所有元素的集合，可以使用“+”操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(1, 2, 3, 4, 5, 6, 6, 7, 8), list + listOf(6, 7, 8))</span><br></pre></td></tr></table></figure><p><strong>47.plusElement 在集合中添加元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.plusElement(7))</span><br></pre></td></tr></table></figure><p><strong>48.zip 将两个集合按照下标进行配对，组成的Pair是由两个集合中相同index的元素组成，如果两个集合长度不一致，取短的集合的长度。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(listOf(Pair(1, &apos;x&apos;), Pair(2, &apos;y&apos;)), list.zip(listOf(&apos;x&apos;, &apos;y&apos;)))</span><br></pre></td></tr></table></figure><p><strong>49.unzip 作用在包含Pair的集合上，依次取各个Pair的first和second值，放入List<t>和List<r>中，然后返回包含List<t>和List<r>的Pair</r></t></r></t></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val listPair = listOf(Pair(1, 2), Pair(&apos;a&apos;, &apos;b&apos;), Pair(3, 4), Pair(&apos;c&apos;, &apos;d&apos;))</span><br><span class="line">println(listPair)</span><br><span class="line">println(listPair.unzip())</span><br></pre></td></tr></table></figure><h3 id="20-顺序操作符"><a href="#20-顺序操作符" class="headerlink" title="20.顺序操作符"></a>20.顺序操作符</h3><p><strong>50.reversed 返回一个与指定list顺序相反的list</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(list)</span><br><span class="line">println(list.reversed())</span><br></pre></td></tr></table></figure><p><strong>51.sorted 升序排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.sorted())</span><br></pre></td></tr></table></figure><p><strong>52.sortBy 返回一个按照指定函数变换后的升序排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.sortedBy &#123; it -&gt; it % 3 &#125;)</span><br></pre></td></tr></table></figure><p><strong>53.sortDescending 降序排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.sortedDescending())</span><br></pre></td></tr></table></figure><p><strong>54.sortDescendingBy 返回一个按照指定函数变换后的降序排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.sortedByDescending &#123; it -&gt; it % 3 &#125;)</span><br></pre></td></tr></table></figure><h3 id="21-空指针安全-Null-safety"><a href="#21-空指针安全-Null-safety" class="headerlink" title="21.空指针安全(Null-safety)"></a>21.空指针安全(Null-safety)</h3><p><strong>1.在Kotlin中，一个非空引用不能赋值为null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=&quot;abc&quot;</span><br><span class="line">a=null</span><br><span class="line">error: null can not be a value of a non-null type String</span><br></pre></td></tr></table></figure><p>这样就可以放心的调用a的方法，或者访问a的属性，而不用担心NPE问题。<br><strong>2.可以在变量的类型后加？来声明变量为可空类型的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a:String?=&quot;abc&quot;</span><br><span class="line">a=null</span><br><span class="line">var one:Int?=1</span><br><span class="line">one=null</span><br></pre></td></tr></table></figure><p>这样在调用a的方法或访问a的属性时，将是不安全的，编译器会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var na:String?=&quot;abc&quot;</span><br><span class="line">na=null</span><br><span class="line">na.length</span><br><span class="line">error: only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?</span><br></pre></td></tr></table></figure><p><strong>3.可以使用空安全调用？.或者非空断言!!</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">na?.length</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">na!!.length</span><br><span class="line">kotlin.KotlinNullPointerException</span><br></pre></td></tr></table></figure><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ol><li><a href="https://classroom.udacity.com/courses/ud9011" target="_blank" rel="noopener">Kotlin Bootcamp for Programmers</a></li><li><a href="https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Hello,%20world!/Task.kt" target="_blank" rel="noopener">Kotlin Koans</a></li></ol><hr><p>本文链接：<a href="http://www.sguotao.top/Kotlin-2018-06-22-kotlin.html">http://www.sguotao.top/Kotlin-2018-06-22-kotlin.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kotlin介绍&quot;&gt;&lt;a href=&quot;#Kotlin介绍&quot; class=&quot;headerlink&quot; title=&quot;Kotlin介绍&quot;&gt;&lt;/a&gt;Kotlin介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Kotlin" scheme="http://www.sguotao.top/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android P（Android 9.0）的新特性</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2018-06-15-Android-P%EF%BC%88Android-9-0%EF%BC%89%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7.html"/>
    <id>http://www.sguotao.top/Android进阶-2018-06-15-Android-P（Android-9-0）的新特性.html</id>
    <published>2018-06-15T07:56:19.000Z</published>
    <updated>2018-07-03T08:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-P（Android-9-0）的新特性"><a href="#Android-P（Android-9-0）的新特性" class="headerlink" title="Android P（Android 9.0）的新特性"></a>Android P（Android 9.0）的新特性</h1><ol><li>Google I/O 2018   <a href="https://www.youtube.com/watch?v=ogfYd705cRs" target="_blank" rel="noopener">watch</a></li><li>Google I/O 2018 for developer  <a href="https://www.youtube.com/watch?v=flU42CTF3MQ" target="_blank" rel="noopener">watch</a></li><li>What’s new in Android Overview(Google I/O ‘18)  <a href="https://www.youtube.com/watch?v=eMHsnvhcf78&amp;t=584s" target="_blank" rel="noopener">watch</a></li></ol><h2 id="1-Android-P"><a href="#1-Android-P" class="headerlink" title="1.Android P"></a>1.Android P</h2><h3 id="1-1-Android-P上的新功能"><a href="#1-1-Android-P上的新功能" class="headerlink" title="1.1 Android P上的新功能"></a>1.1 Android P上的新功能</h3><h4 id="1-使用-WiFi-RTT-进行室内定位"><a href="#1-使用-WiFi-RTT-进行室内定位" class="headerlink" title="1. 使用 WiFi RTT 进行室内定位"></a>1. 使用 WiFi RTT 进行室内定位</h4><div align="center"><br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060113647948.png" width="300" height="600" align="center"><br></div><p>在Android P版本中在硬件设备中添加对IEEE 802.11mc WiFi协议的支持，并对上层封装了API，从而可以在应用中使用室内定位。室内定位具体是怎么做到的呢？这里有一个概念RTT，也称为WIFI往返时间，具体来说，移动设备会根据RTT来计算移动设备与附近WIFI接入点的距离，WIFI接入点越多，计算的位置越准确，具体可以精确到1-2m，在此过程中移动设备不需要连接到WIFI接入点，保证了移动设备的隐私。</p><h4 id="2-凹口屏幕的支持"><a href="#2-凹口屏幕的支持" class="headerlink" title="2. 凹口屏幕的支持"></a>2. 凹口屏幕的支持</h4><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060177753280.png" alt="20180703153060177753280.png"><br>在Android P上添加了对凹口屏幕的支持，并且提供了相关个API，可以调用 <em>getDisplayCutout()</em> 来判断本地设备是否具有凹口屏幕，然后再确定裁切区域的位置和形状。可以在设置里，设置凹口屏的显示方式。</p><h4 id="3-消息通知的改进"><a href="#3-消息通知的改进" class="headerlink" title="3. 消息通知的改进"></a>3. 消息通知的改进</h4><div style="float:left;border:solid 1px 000;margin:2px;"><br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060189596612.png" width="300" height="400" align="center"></div><div style="float:left;border:solid 1px 000;margin:2px;"><br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060190827364.png" width="300" height="400" align="center"><br></div><p>在Android O上，Google引入了一种全新的显示样式，<em>MessagingStyle</em> 突出强调了来信人以及可采用的回复方式。在Android P上对这种样式又进行了优化，当收到短信后，可以选择智能回复，甚至可以附加照片和表情。</p><h4 id="4-多摄像头-API"><a href="#4-多摄像头-API" class="headerlink" title="4. 多摄像头 API"></a>4. 多摄像头 API</h4><p>在Android P的设备中，添加对多个摄像头的API支持，可以通过两个或更多实体摄像头同时访问视频流。所以您可以在具有双前置或双后置摄像头的设备上，实现单摄像头无法实现的创新功能：如无缝变焦、散景和立体视觉。</p><h4 id="5-用于位图和-drawable-的-ImageDecoder"><a href="#5-用于位图和-drawable-的-ImageDecoder" class="headerlink" title="5. 用于位图和 drawable 的 ImageDecoder"></a>5. 用于位图和 drawable 的 ImageDecoder</h4><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060216289421.png" alt="20180703153060216289421.png"><br>Android P 引入了一种更简单的方法来将图像解码为位图或 drawable，即用 ImageDecoder 替代了 BitmapFactory。ImageDecoder 允许您从字节缓冲区、文件或 URI 创建位图或 drawable。它比 BitmapFactory 多出了几个优势，包括对精确缩放的支持，单步解码至硬件存储器，对解码后处理的支持，以及对动画图像的解码。</p><h4 id="6-HDR-VP9-视频、HEIF-以及媒体-APIs"><a href="#6-HDR-VP9-视频、HEIF-以及媒体-APIs" class="headerlink" title="6. HDR VP9 视频、HEIF 以及媒体 APIs"></a>6. HDR VP9 视频、HEIF 以及媒体 APIs</h4><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060219040472.png" alt="20180703153060219040472.png"><br>添加了对 HEIF 图像编码的支持，这种格式被广泛使用，改善了照片压缩效果，并减少了所需的存储空间和网络流量。</p><h4 id="7-JobScheduler-中的数据费用敏感度"><a href="#7-JobScheduler-中的数据费用敏感度" class="headerlink" title="7. JobScheduler 中的数据费用敏感度"></a>7. JobScheduler 中的数据费用敏感度</h4><p>任务现在可以声明其估计的数据大小、信号预取以及指定详细的网络要求 —— 运营商可以报告网络状况是拥塞还是不计量，然后，JobScheduler 会根据网络状态管理工作。例如，当网络拥塞时，JobScheduler 可能推迟大型网络请求。而在网络可以不计量使用时，则可以运行多种预加载作业 (例如，预读标题) 来改进用户体验。</p><h4 id="8-神经网络-API-1-1"><a href="#8-神经网络-API-1-1" class="headerlink" title="8. 神经网络 API 1.1"></a>8. 神经网络 API 1.1</h4><p>加速 Android 上设备内置的机器学习。</p><h4 id="9-自动填充的改进"><a href="#9-自动填充的改进" class="headerlink" title="9. 自动填充的改进"></a>9. 自动填充的改进</h4><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060227647836.png" alt="20180703153060227647836.png"><br>在 Android P 中，此版本还包含新的 API，允许密码管理程序 (Password Manager) 改进 Autofill 用户体验，例如更好的数据集过滤，输入清理和兼容模式。</p><h4 id="10-用于-NFC-支付和安全交易的-Open-Mobile-API"><a href="#10-用于-NFC-支付和安全交易的-Open-Mobile-API" class="headerlink" title="10. 用于 NFC 支付和安全交易的 Open Mobile API"></a>10. 用于 NFC 支付和安全交易的 Open Mobile API</h4><p>Android P 将 GlobalPlatform Open Mobile API 的实现添加到 Android 中。在支持的设备上，应用可以使用 OMAPI API 访问 Android 设备上的安全元素 (SE) ，以启用智能卡支付等安全服务。</p><h4 id="11-在Android-P的设备中优化了任务栏的显示"><a href="#11-在Android-P的设备中优化了任务栏的显示" class="headerlink" title="11.在Android P的设备中优化了任务栏的显示"></a>11.在Android P的设备中优化了任务栏的显示</h4><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060238237889.gif" alt="20180703153060238237889.gif"></p><h4 id="12-在Android-P中提供了新型的快捷方式App-Action和Slices"><a href="#12-在Android-P中提供了新型的快捷方式App-Action和Slices" class="headerlink" title="12.在Android P中提供了新型的快捷方式App Action和Slices"></a>12.在Android P中提供了新型的快捷方式App Action和Slices</h4><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060348129235.gif" alt="20180703153060348129235.gif"></p><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2018070315306035231551.gif" alt="2018070315306035231551.gif"></p><h3 id="1-2-Android-P版本中进行的优化"><a href="#1-2-Android-P版本中进行的优化" class="headerlink" title="1.2 Android P版本中进行的优化"></a>1.2 Android P版本中进行的优化</h3><h4 id="1-应用安全"><a href="#1-应用安全" class="headerlink" title="1. 应用安全"></a>1. 应用安全</h4><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060377944006.png" alt="20180703153060377944006.png"><br>Android P 现在提供了一个标准系统对话框，以提示用户触摸指纹传感器，并且在文案和位置管理方面会根据不同的设备做相应的匹配。同时，应用可以使用新的 <em>FingerprintDialog API</em> 触发系统指纹对话框。</p><p>将所有网络流量从明文 (未加密的 HTTP) 转向 TLS，我们还将更改网络安全性配置 (Network Security Configuration) 的默认值，以阻止所有明文流量。</p><h4 id="2-用户隐私"><a href="#2-用户隐私" class="headerlink" title="2.用户隐私"></a>2.用户隐私</h4><p>为了更好地保证隐私，Android P 限制所有处于空闲状态的应用对话筒、摄像头和所有 SensorManager 传感器的访问。当一个应用的 UID 空闲时，麦克风将会报告系统 “无音频信号”，传感器将会停止报告事件。应用使用的摄像头也会断开连接。</p><h4 id="3-ART-性能提升"><a href="#3-ART-性能提升" class="headerlink" title="3.ART 性能提升"></a>3.ART 性能提升</h4><p>扩展了 ART 对执行配置文件的使用，以优化应用并减少已编译应用代码的内存占用量。ART 现可使用配置文件信息在设备上重写 DEX 文件，在多个人气的应用中内存占用减少高达 11％。</p><h4 id="4-Kotlin-优化"><a href="#4-Kotlin-优化" class="headerlink" title="4.Kotlin 优化"></a>4.Kotlin 优化</h4><p>改进了一些编译器优化，尤其是那些针对循环的编译器优化，以实现更好的性能。</p><h4 id="5-电耗优化"><a href="#5-电耗优化" class="headerlink" title="5.电耗优化"></a>5.电耗优化</h4><p>在 Android P 中继续优化 Doze、App 待命模式以及后台限制，进一步改善电池寿命。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060370845336.gif" alt="20180703153060370845336.gif"></p><h4 id="6-针对现阶段的Android版本"><a href="#6-针对现阶段的Android版本" class="headerlink" title="6.针对现阶段的Android版本"></a>6.针对现阶段的Android版本</h4><p>Google Play 将要求所有应用在 2018 年 11 月之前针对 Android Oreo (targetSdkVersion 26 或更高版本) 进行更新，并支持将在 2019 年提供 64 位支持。</p><p>Android P 将在安装针对 Android 4.2 之前的平台 (targetSdkVersion 小于17) 的应用时通过对话框向用户发出警告，未来平台将会继续提高版本下限。</p><h4 id="7-通过公开-API-增强应用兼容性"><a href="#7-通过公开-API-增强应用兼容性" class="headerlink" title="7.通过公开 API 增强应用兼容性"></a>7.通过公开 API 增强应用兼容性</h4><p>确保应用从一开始就支持新平台，并让用户远离崩溃风险，以及开发者不再需要针对兼容性问题做紧急更新。<strong>从 SDK 到 NDK 都使用 Android 公开 API 的应用拥有较好的兼容性，而使用私有 Android 接口和库的应用则兼容性较差。</strong> 在Android P中，开始逐步限制对特定非 SDK 接口的访问权限，并要求开发者 (包括 Google 内部的应用团队) 使用公开 API 里的替代接口。</p><p>Google对非SDK接口提供了灰名单机制，将目前Android应用或定制OS调用的非SDK接口分进行了分级，分别为浅灰名单，深灰名单和黑名单。不同名单中的接口有不同的处理策略。</p><ol><li>浅灰名单，Google目前还没有可替代的SDK接口，暂时放在浅灰名单中。在Android P预览版上调用时会出现警告。</li><li>深灰名单，Google目前已经提供了可替代的SDK接口，开发者需要进行整改。这部分接口在Android P以下设备调用时出现警告，Android P及以上设备调用时出现Crash。</li><li>黑名单，浅灰名单和深灰名单之外的非SDK接口，都放在了这个名单中，这部分接口调用就会出现Crash。</li></ol><h2 id="2-Android-App-Bundle"><a href="#2-Android-App-Bundle" class="headerlink" title="2.Android App Bundle"></a>2.Android App Bundle</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060375326969.gif" alt="20180703153060375326969.gif"><br>App Bundle可以理解为一种新的文件格式，配和着Google的应用市场Google Play，当用户下载一个app时，不用再去下载一个全量的包，而只需下载跟自己设备相关的一系列Bundle。比如，用户设备是arm结构，就只需下载arm平台相关的so，没有必要下载x86平台下的so。这在以前，用户会下载两个甚至更多平台下的so，这无疑会节省用户的流量，减小下载的apk的体积。遗憾的是，目前只能在Google Play上使用。</p><p>关于App Bundle的介绍，可以浏览以下视频。<br>Build the new, modular Android App Bundle (Google I/O ‘18) <a href="https://www.youtube.com/watch?v=bViNOUeFuiQ" target="_blank" rel="noopener">watch</a></p><p>App Bundle的思想类似于已经普遍使用的插件框架，插件后台换成了GooglePlay而已。如果App Bundle能够普及，相信会替代目前使用的插件框架。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180703153060380188748.png" alt="20180703153060380188748.png"></p><h2 id="3-Android-JetPack"><a href="#3-Android-JetPack" class="headerlink" title="3.Android JetPack"></a>3.Android JetPack</h2><p>Android JetPack可以理解为Google 为开发人员提供的一个开发工具包，在这个包里，集成了一些模板代码，使用这些已经封装好的代码，可以更加快速高效的开发一款应用。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20180606152825601059704.png" alt="20180606152825601059704.png"></p><h3 id="Introducing"><a href="#Introducing" class="headerlink" title="Introducing"></a>Introducing</h3><p>关于JetPack中每一项具体的介绍，可以浏览下面的视频。</p><p>Introducing Android Jetpack for Developers <a href="https://www.youtube.com/watch?v=r8U5Rtcr5UU&amp;t=83s" target="_blank" rel="noopener">watch</a></p><ol><li>Android Jetpack: Improve Your App’s Architecture <a href="https://www.youtube.com/watch?v=7p22cSzniBM" target="_blank" rel="noopener">watch</a></li><li>Android Jetpack: KTX - Sweeter Kotlin Android Development <a href="https://www.youtube.com/watch?v=r_19VZ0xRO8" target="_blank" rel="noopener">watch</a></li><li>Android Jetpack: Room <a href="https://www.youtube.com/watch?v=SKWh4ckvFPM" target="_blank" rel="noopener">watch</a></li><li>Android Jetpack: ViewModel <a href="https://www.youtube.com/watch?v=5qlIPTDE274" target="_blank" rel="noopener">watch</a></li><li>Android Jetpack: LiveData <a href="https://www.youtube.com/watch?v=OMcDk2_4LSk" target="_blank" rel="noopener">watch</a></li><li>Android Jetpack: Paging <a href="https://www.youtube.com/watch?v=QVMqCRs0BNA" target="_blank" rel="noopener">watch</a></li><li>Android Jetpack: Autosizing TextView <a href="https://www.youtube.com/watch?v=JYrpEAz_A1U" target="_blank" rel="noopener">watch</a></li><li>Android Jetpack: EmojiCompat <a href="https://www.youtube.com/watch?v=sYGKUtM2ga8" target="_blank" rel="noopener">watch</a></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://android-developers.googleblog.com/2018/03/previewing-android-p.html?m=1" target="_blank" rel="noopener">https://android-developers.googleblog.com/2018/03/previewing-android-p.html?m=1</a></li><li><a href="https://developer.android.com/studio/preview/features/?utm_source=android-studio&amp;utm_medium=studio-assistant" target="_blank" rel="noopener">https://developer.android.com/studio/preview/features/?utm_source=android-studio&amp;utm_medium=studio-assistant</a></li><li><a href="https://developer.android.com/jetpack/behavior/" target="_blank" rel="noopener">https://developer.android.com/jetpack/behavior/</a></li><li><a href="https://android-developers.googleblog.com/2018/05/whats-new-in-android-p-beta.html" target="_blank" rel="noopener">https://android-developers.googleblog.com/2018/05/whats-new-in-android-p-beta.html</a></li><li><a href="https://developer.android.com/platform/technology/app-bundle/" target="_blank" rel="noopener">https://developer.android.com/platform/technology/app-bundle/</a></li><li><a href="https://developer.android.com/studio/preview/features/?utm_source=android-studio&amp;utm_medium=studio-assistant" target="_blank" rel="noopener">https://developer.android.com/studio/preview/features/?utm_source=android-studio&amp;utm_medium=studio-assistant</a></li><li><a href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing#kotlin" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/architecture/navigation/navigation-implementing#kotlin</a></li><li><a href="https://android-developers.googleblog.com/2018/05/use-android-jetpack-to-accelerate-your.html" target="_blank" rel="noopener">https://android-developers.googleblog.com/2018/05/use-android-jetpack-to-accelerate-your.html</a></li><li><a href="https://android-developers.googleblog.com/2018/05/android-studio-3-2-canary.html" target="_blank" rel="noopener">https://android-developers.googleblog.com/2018/05/android-studio-3-2-canary.html</a></li></ol><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2018-06-15-Android-P（Android-9-0）的新特性.html">http://www.sguotao.top/Android进阶-2018-06-15-Android-P（Android-9-0）的新特性.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-P（Android-9-0）的新特性&quot;&gt;&lt;a href=&quot;#Android-P（Android-9-0）的新特性&quot; class=&quot;headerlink&quot; title=&quot;Android P（Android 9.0）的新特性&quot;&gt;&lt;/a&gt;Android 
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="AndroidP" scheme="http://www.sguotao.top/tags/AndroidP/"/>
    
      <category term="GoogleI/O" scheme="http://www.sguotao.top/tags/GoogleI-O/"/>
    
      <category term="AppBundle" scheme="http://www.sguotao.top/tags/AppBundle/"/>
    
      <category term="Kotlin" scheme="http://www.sguotao.top/tags/Kotlin/"/>
    
      <category term="Flutter" scheme="http://www.sguotao.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>树獭先生谈写作</title>
    <link href="http://www.sguotao.top/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2018-06-15-%E6%A0%91%E7%8D%AD%E5%85%88%E7%94%9F%E8%B0%88%E5%86%99%E4%BD%9C.html"/>
    <id>http://www.sguotao.top/读书笔记-2018-06-15-树獭先生谈写作.html</id>
    <published>2018-06-15T07:52:27.000Z</published>
    <updated>2018-06-15T07:52:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="01-因为感兴趣，所以开始动手尝试。"><a href="#01-因为感兴趣，所以开始动手尝试。" class="headerlink" title="01 因为感兴趣，所以开始动手尝试。"></a>01 因为感兴趣，所以开始动手尝试。</h3><p>自从4月份（2016年）在简书上开始了第一篇文章之后，开始了自己写作的漫漫征程。3个月的坚持写作，在简书上了几篇三十日热门，十几篇七日热门，在简书收获粉丝6000，喜欢数将近2万，也得到了很多人的认可，认识了很多有趣的作者。</p><p>今天参加了一个分享，将写作三个月的一些经验和想法汇总出来，分享给大家。欢迎拍砖。</p><p>友情提示：只针对刚开始写作，跟我一样的小透明，大咖请绕路，我紧张。欢迎拍砖，不要人身攻击。</p><p><strong>我最开始是从写书评开始写作的。</strong>当时对书评比较感兴趣，最重要的是，只要你认真写书评的话，可以免费看到很多书。因为我比较喜欢看书，每个月要花在看书上的资金，不是一小笔钱，所以还是蛮心疼的。</p><p>一次偶然的机会认识到一个出版社的编辑，发现可以写书评，免费看书，想着试试吧。</p><p>也就是从那个时候起，我才正式认识了简书。我是4月份在简书上写的，我的第一篇文章，因为简书的页面很干净，你看上去的首页全部是文章，所以那个时候就一次性读了很多文章。</p><p><strong>读了大量的文章之后，自己的脑海中，也有了一定的构思，加之生活中也有一些事情，就激起了我很强烈的表达欲望，然后我就开始尝试动笔，将我想表达的东西，想表达的观点尝试着写出来。</strong></p><p>于是写出了我的第一篇正式文章，现在看来，那只是一篇比较水的鸡汤文，也有一点吐槽成分，但是确实是这一篇文章让我正式开始了写作。</p><p>比较幸运的是，那一篇文章，通过了简书的首页，我觉得很好奇，也觉得这个软件很好玩，然后就尝试着在，简书上开始写起来了我的文章，慢慢正式开始写作。<br>因为感兴趣，所以开始动手尝试。</p><h3 id="02-写作的捷径是什么？我的独特办法是什么？"><a href="#02-写作的捷径是什么？我的独特办法是什么？" class="headerlink" title="02 写作的捷径是什么？我的独特办法是什么？"></a>02 写作的捷径是什么？我的独特办法是什么？</h3><p>刚开始写作，确实是比较难的，因为自己有很多想法，很多素材，但是表达不出来，或者是表达出来之后也不能完整的表现出自己想表现的意思，反正就是写得不太好。</p><p>那个时候最重要的事情是一定要将一篇文章完整地写出来，不要太苛求质量。因为刚开始写作的时候，最容易放弃了，尤其是一篇文章写到一半写不下去的时候，最容易就搁笔，就撂那儿不写了，然后这一篇文章基本就废掉了。<strong>所以一定要努力将一篇文章写完，然后再去修改。</strong></p><p>我刚开始每次写文章的时候都告诉我自己，先不要在意这篇文章写的好不好？你现在动笔之后，你的唯一的想法就是，将你的思想全部表达出来，尽全力把这一篇文章给写出来，写出来之后再谈其他的。</p><p><strong>对于我而言，写作的捷径就是多看和模仿。</strong></p><p>刚开始写作的时候，我会经常看一些阅读量比较高，比较受大家欢迎，而且质量还不错的文章，很多文章的阅读量和喜欢数是由读者自主选择的，在很大程度上表示了读者对这一类文章的类型、素材、以及文笔的喜欢和认可，也侧面反映，这种文章，目前是有价值和有意义的。</p><p>所以在写作初期，我就会多看一些比较火的文章，把他们的文章看多了之后，就会找到他们中的一定的规律，比如说哪一类文章更受读者欢迎，文章的布局要是怎么样的？才能，看起来比较清楚，一篇文章多少字，读者才能看得下去。</p><p>这些都是刚开始，看别人的文章的时候所获得的。将这些研究透，然后脑海里就不自觉有了自己的一个小模板，有了特定的思路和表达方式，然后就写出来开始练习。</p><p>再后来的时候，我发现了几个我特别喜欢的作者，他们的文风，文采和语言表达能力，都是我特别喜欢的。我就关注了他们的公众号，每天都会看他们当天发出来的文章，看他们写了哪些内容，用了哪些素材，想表达的道理是怎样的？然后去刻意模仿他们。</p><p>当我在表达其他观点的时候，写其他的东西的时候，想着如果是他们的话，他们会有什么样的表达方式，会选择什么样的素材？<br>我觉得对于刚开始写作的作者来说，多看和模仿，是写作的最大捷径。</p><p>但是要注意：模仿只是一种学习的手段，可以模仿风格和类型，但是故事素材和选题还是尽量原创比较好，千万不能抄袭和洗稿。</p><p>平常除了网上传阅分享的一些文章外，<strong>也要定期多看一些比较经典的名著和一些比较好的书，因为那些大作家的书，一般更有深度，更有学习意义。</strong>他们的文笔和思想可能更值得我们借鉴，可以加深我们的思想深度，以及我们的一些见解。用模仿和观察去学习，然后通过不断地输入，形成自己的风格和特色。</p><h3 id="03-遇到难点的时候，我是怎么样解决的？"><a href="#03-遇到难点的时候，我是怎么样解决的？" class="headerlink" title="03 遇到难点的时候，我是怎么样解决的？"></a>03 遇到难点的时候，我是怎么样解决的？</h3><p>写作遇到的最大的难点就是，写不出来，把自己给掏空了。</p><p>我中间有一段时间是坚持日更，也就是说每天写一篇文章，白天上班，晚上回来写东西，但是我发现，这样的时间，隔了不到一个月之后，我就发现我坚持不下去了，不是因为太累，而是因为写不出东西。</p><p>我大脑里的素材和我的阅历就那么多，我每天都写，很容易就把自己写空了。导致的问题是你坐在电脑前你也不知道写什么，你也根本写不出来。</p><p>那个时候最重要的事情就是充电，于是我就慢慢的，不那么非要坚持日更了。用更多的时间去看书，比如说看小说看干货，看一些故事书，然后再看综艺，看电影，看电视剧？以前看这些可能只是为了放松，但是写作以来，看的目的就是为了给自己补充素材，给自己充电。</p><p><strong>要想持续输出是续写东西，最重要的是一定要持续输入，你只有给自己的大脑里面输入了足够的东西，你才能写出来写出好的，写出有深度的。</strong>所以我现在，每个月基本都会买一些书，基本都是两三天看一本书，两三天更新一篇文章。</p><p>写作还有的一个难点，就是坚持不下去，写着写着就累了，就不知道自己的意义是什么了。这个时候，<strong>不要想太多，不要怀疑自己这样做有没有意义，不要觉得文章写的不好，不想写。</strong>这个阶段是比较难熬的，将自己的大脑清空，然后专心写作这一件事，认真将手头的素材写完即可，<strong>不要追问意义，也不要寻求结果。</strong></p><p>等过了这一个阶段，自己养成一个良好的写作习惯，有了一定的输入和输出时，再想自己应该往哪个方面发展，写什么类型的文章。</p><p>我在中间写作的时候，认识了很多作者，也加了一些作者群，也有一些关系比较好的作者，所以平常就会跟他们交流，我们的写作感想，最近写了哪些文章？最近有什么收获？平常写不下去的话，也就会跟他们聊聊天，讲一讲大家互相鼓励鼓励打打气，一起支撑下去。</p><p>写作这条路上，有时候一群人走可能会，比一个人走，更有勇气，虽然走得慢，但是能走的更长一点。</p><h3 id="04-怎么样写出别人都喜欢的文章？"><a href="#04-怎么样写出别人都喜欢的文章？" class="headerlink" title="04 怎么样写出别人都喜欢的文章？"></a>04 怎么样写出别人都喜欢的文章？</h3><p>这一点基本是不现实的，因为你不论写什么文章，肯定都是有人喜欢有人讨厌的，我之前写过几篇文章，被意林、领英等几个大号转载，也有很多人分享，那几篇文章给我吸了不少粉，很多人都在下面写，说特别喜欢我的文章，喜欢我的写字风格。但是与之相反的是，也有一部分人在下面骂我骂的特别狠特别惨，不是很认可我的观点，觉得我写的东西毫无意义。</p><p>包括我认识的一些作者，有时候被清华南都或者一些大号转发的时候，阅读量很多，也会吸很多粉，但是评论下面依然会有很多人骂的，因为每个人的阅历和想法是不一样的，每个人对问题的思考程度和理解也是不一样的。所以一篇文章想让大多数人喜欢基本是不太可能的。</p><p><strong>所以在写作的过程中，一方面要敢于表达自己的观点，另外一方面是，一定不能玻璃心。</strong>别人骂你，你就可以换一方面想，是因为他看了你的文章才骂你的，骂你的人也给你的文章增加了不少阅读量，所以千万不要把他们的话放在心上。</p><p>刚开始写作的时候听过这样一句话，中国有1/3的网红，都是被别人给骂死的。所以当别人骂你的时候，一定不要太在意。但是如果想让大多数人都喜欢你的文章的话，去看一看那些大号，转的是什么文章和那些，阅读量比较高的文章是什么样子？找到你喜欢的类型和风格，然后尝试模仿他们。</p><p>并不是说去模仿他们的观点和故事，而是去看一看哪一类的文章，更容易火，比如情感类的故事类的，或者是，同样一种观点，为什么别人表达出来之后那么受大家喜欢呢？可以去研究一下。</p><p>最重要的是，将自己内心想真正表达的看法，以自己擅长的方式和读者可以接受的方式表达出来，可能更受欢迎。写作，最害怕，你明明表达出来了，但是读者看不懂，根本不知道你在说什么。或者是，你写的内容已经有N多人写过了，读者看腻了，这些都要注意。其实最后写的，还是写自己。</p><h3 id="05-在长时间的写作里，会不会迷失初衷，变得为别人而写作？"><a href="#05-在长时间的写作里，会不会迷失初衷，变得为别人而写作？" class="headerlink" title="05 在长时间的写作里，会不会迷失初衷，变得为别人而写作？"></a>05 在长时间的写作里，会不会迷失初衷，变得为别人而写作？</h3><p>这一点的问题是绝对存在的。尤其是在网上写作的作者吗？很难说不去在意阅读量和粉丝数，不论在哪个平台写作，我们都会发现存在一些这样的现象，很多有深度的文章，阅读量和点赞数很惨，反而是一些比较浅显的鸡汤，或者是一些干货书评之类的，阅读量超级高。</p><p>所以我们在写作的过程中，写着就有可能为了得到读者的认可，为了粉丝数和和点赞数，去写那些迎合读者口味的文章。因为毕竟，那一种文章喜欢的人更多一些，可能更会火一些。</p><p>但是，能火一时的东西不一定会活很久，而且，那些东西也不一定是真正有意义的。我们在写作的这条路上，最终的目的是，提高自己的写作水平，将自己的，真实想法用语言表达出来。而且写作是一条极其漫长的道路，一定要找到自己所擅长的自己所喜欢的才能走下去。</p><p><strong>所以偶尔的投机取巧是可以的，刷一刷存在感，增加一些粉丝。但是不能把这个作为你的写作之本，不然你，很快就会发现你找不到写作的乐趣，不知道为什么而写了，很容易放弃。</strong></p><p>只有时刻记住，自己当时为什么写作，自己的写作初衷，以及坚持下去的动力，才能在写作这条路上走的更远。</p><h3 id="06-写作最重要的几件事"><a href="#06-写作最重要的几件事" class="headerlink" title="06 写作最重要的几件事"></a>06 写作最重要的几件事</h3><h4 id="第一、找到合适的写作平台。"><a href="#第一、找到合适的写作平台。" class="headerlink" title="第一、找到合适的写作平台。"></a>第一、找到合适的写作平台。</h4><p>写作的平台有很多，包括一些小说网站，微信公众号，简书，微博，一点，资讯豆瓣等各种网站。一定要找到适合你的，比如说你写作的是小说，或者是你写作的，是一些情感故事之类的，看看对应哪个平台，然后在这个平台长期发展下来。每个平台都有它的长处和劣势，比如：</p><ul><li>头条号的阅读量可能更高一些，但是要熬新手期；</li><li>知乎的回答更专业一些，吸的粉丝更有粘度，但是，它要求的专业性比较强；</li><li>简书容易出豹纹，但是鸡汤和干货可能更受读者欢迎，因为毕竟读者群体学生居多，其他比较有深度的文章，阅读量就可能有点惨淡；</li><li>如果你喜欢写书评，不妨尝试豆瓣，因为豆瓣的书影音，做的很棒。</li></ul><p>找到你最适合的平台，以这个平台为主，其他平台为辅，去分享传播你的文章。</p><h4 id="第二、一定要善于找到成就感。"><a href="#第二、一定要善于找到成就感。" class="headerlink" title="第二、一定要善于找到成就感。"></a>第二、一定要善于找到成就感。</h4><p>写作的过程中，最容易有挫败感。比如，有一段时间，你的文章打开率普遍不高，点赞数也少得可怜，朋友们都说这一篇文章写得不好，你也觉得其实一般。有时候，就会觉得很失落，明明认真写了，但是结果还是不太好。很多事情都足以让我们崩溃，让我们怀疑我们的，努力是否有意义。</p><p><strong>所以在写作的过程中，我们要自己去寻找成就感，自己给自己制造一点成就感</strong>，这样的话才能坚持下去。以前别人写东西，都是用纸写，写了好多好多之后才发表出来，但是有更多的人是写了很多东西之后没发布出来的。</p><p>所以我们平常写的时候尽量加自己的文章发布出来，你会发现有很多喜欢你的文章和喜欢你的风格的人，然后他们会在评论里面告诉他们很喜欢你的文章，偶尔会私信来，给你鼓励打打气，这样，你会更有信心的写下去。</p><p>给自己定一个小目标，比如说，这一周写满五篇文章就好好出去吃一顿，周末看个电影。写够10万字的时候，好好出去玩一趟给自己，放松一下。自己给自己一些成就感，鼓励自己可能会走得更远一些。</p><h4 id="第三、学会将写作能力变现"><a href="#第三、学会将写作能力变现" class="headerlink" title="第三、学会将写作能力变现"></a>第三、学会将写作能力变现</h4><p>我们暂时不谈情怀，谈一谈钱，因为要想生活，你得先学会生存。况且，一般情况下，一个生存窘迫的作者是很难写出自己真正想写的东西的，由于生存，他不得不先暂时迎合读者的口味和市场环境。</p><p>所以，在写作的过程中，如果有机会，可以尝试着将自己的文章变现，不仅会刺激自己在写作的道路上走下去，还能稍微改善一下生活，让自己过得更轻松。</p><p>变现有很多方式，最简单的就是给一些付费公众号以及一些平台投稿，一般是千字百元或者两百，高的话，一篇文章可以得到一两千块的报酬。</p><p>还有就是写软文的方式，比如给一些品牌写一些他们想要的推广之类的，也是蛮不错的方式。还有编辑约稿、专栏等方式，都可以将你的才华变现。</p><h4 id="第四、一群人走，比一个人走更快。"><a href="#第四、一群人走，比一个人走更快。" class="headerlink" title="第四、一群人走，比一个人走更快。"></a>第四、一群人走，比一个人走更快。</h4><p>我在写作的过程中认识了很多作者，很多时候我写不下去的时候，都是他们来鼓励我的，给我打气，分享他们的经验，我才能坚持下来。</p><p>我刚开始的文章是有一些戾气，还有一些吐槽成分，这些都是我的短板，但是是我看不到的，都是一些作者朋友帮我指出来，给我提建议，才慢慢改正了这些缺点。</p><p>所以我建议大家在闲的时候，也去多和别人沟通沟通，去问问别人的看法，然后一起走会好一些。码字重要，但是一味沉浸在写字里，很容易让人看不到外面的世界，写出的东西没有人情味，写的东西也很片面，很受限制。所以，多和别人打交道，听听别人的故事，看看不同的东西，是有助于写作的。</p><h4 id="第五、内容要有，技巧也要有。"><a href="#第五、内容要有，技巧也要有。" class="headerlink" title="第五、内容要有，技巧也要有。"></a>第五、内容要有，技巧也要有。</h4><p>酒香也怕巷子深，有很多时候很多人的，东西写出来，但是过不了简书首页或者是阅读量并不高，有的时候并不仅仅是，作者自己的原因，作品的原因有可能是技巧和方法不得当。</p><p>每个平台都有自己的运行规则，包括一些技巧，甚至是绿色通道等。在写作之余，不妨多和别人聊聊，懂你擅长的一些平台的小技巧，可能更方便一些。毕竟，站在前人的肩膀上，比自己绕弯子走弯路好多了。</p><hr><p>本文链接：<a href="http://www.sguotao.top/读书笔记-2018-06-15-树獭先生谈写作.html">http://www.sguotao.top/读书笔记-2018-06-15-树獭先生谈写作.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;01-因为感兴趣，所以开始动手尝试。&quot;&gt;&lt;a href=&quot;#01-因为感兴趣，所以开始动手尝试。&quot; class=&quot;headerlink&quot; title=&quot;01 因为感兴趣，所以开始动手尝试。&quot;&gt;&lt;/a&gt;01 因为感兴趣，所以开始动手尝试。&lt;/h3&gt;&lt;p&gt;自从4月份（
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书写作" scheme="http://www.sguotao.top/tags/%E8%AF%BB%E4%B9%A6%E5%86%99%E4%BD%9C/"/>
    
      <category term="树獭先生谈写作" scheme="http://www.sguotao.top/tags/%E6%A0%91%E7%8D%AD%E5%85%88%E7%94%9F%E8%B0%88%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>树獭先生写作课</title>
    <link href="http://www.sguotao.top/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2018-06-15-%E6%A0%91%E7%8D%AD%E5%85%88%E7%94%9F%E5%86%99%E4%BD%9C%E8%AF%BE.html"/>
    <id>http://www.sguotao.top/读书笔记-2018-06-15-树獭先生写作课.html</id>
    <published>2018-06-15T07:52:27.000Z</published>
    <updated>2018-07-01T03:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day1，3月14日，星期三"><a href="#Day1，3月14日，星期三" class="headerlink" title="Day1，3月14日，星期三"></a>Day1，3月14日，星期三</h2><p><a href="https://m.weike.fm/channel/143745?st=sharelink&amp;inviter_id=24244100" target="_blank" rel="noopener">怎样投稿效率最高、稿费最多？</a></p><h3 id="【读书语录】"><a href="#【读书语录】" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>愿上帝赐我一个平静的心，去接纳我所不能改变的事物；赐我无限勇气，去改变那有可能改变的东西；并且赐我智慧，去辨别这两者的差异。 ——古典 《拆掉思维里的墙》</p></blockquote><h3 id="【今日选题】"><a href="#【今日选题】" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【励志】大学毕业之前，你必须明白的那些道理</li><li>【校园】学生会和你想象的不一样</li><li>【恋爱】喜欢的那个人，和你还有多远的距离？</li><li>【亲子】熊孩子的背后都会有一个熊家长！</li><li>【生活】买三五个廉价的不喜欢的不如下定决心买下那个很喜欢的</li></ul><h2 id="Day2，3月15日，星期四"><a href="#Day2，3月15日，星期四" class="headerlink" title="Day2，3月15日，星期四"></a>Day2，3月15日，星期四</h2><h3 id="【读书语录】-1"><a href="#【读书语录】-1" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>独特性，就是你的核心竞争力。——采铜</p></blockquote><h3 id="【今日选题】-1"><a href="#【今日选题】-1" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【思路】所有的弯路，其实都是必经之路</li><li>【婚姻】为什么心中有爱，却说不出口呢</li><li>【励志】最怕一生碌碌无为，却安慰自己平凡可贵</li><li>【成长】成长是一种带着疼痛的喜悦 </li><li>【青春】敬往昔一杯酒，不堪回首的过往随风走</li></ul><h2 id="Day3，3月16日，星期五"><a href="#Day3，3月16日，星期五" class="headerlink" title="Day3，3月16日，星期五"></a>Day3，3月16日，星期五</h2><h3 id="【读书语录】-2"><a href="#【读书语录】-2" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>真正有气质的淑女，从不玄耀她所拥有的一切，她不告诉人她读过什么书，去过什么地方，有多少件衣裳，买过什么珠宝，因她没有自卑感。——亦舒</p></blockquote><h3 id="【今日选题】-2"><a href="#【今日选题】-2" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【励志】哪怕有1%的希望，也要尽100%的努力</li><li>【奋斗】星光不问赶路人，时光不负有心人。</li><li>【爱情】要相信总有一个人，爱你如生命</li><li>【心理】内向的人，最懂社交恐惧症</li><li>【职场】那些能每天保质保量或超额完成任务的人，究竟哪里比你强？</li></ul><h2 id="Day4，3月17日，星期六"><a href="#Day4，3月17日，星期六" class="headerlink" title="Day4，3月17日，星期六"></a>Day4，3月17日，星期六</h2><p><a href="https://m.weike.fm/channel/143745?st=sharelink&amp;inviter_id=24244100" target="_blank" rel="noopener">如何写出影响大传播广的10W+公众号文章</a></p><h3 id="【读书语录】-3"><a href="#【读书语录】-3" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>我不觉得人的心智成熟是越来越宽容涵盖，什么都可以接受。相反，我觉得那应该是一个逐渐剔除的过程，知道自己最重要的是什么，知道不重要的东西是什么。而后，做一个纯简的人。——张爱玲</p></blockquote><h3 id="【今日选题】-3"><a href="#【今日选题】-3" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【友情】分享最好的给对方，而不是你不要的</li><li>【婚姻】两个人结婚应不应该门当户</li><li>【人生】你的下一个五年目标是什么</li><li>【青春】那个我花了整个青春去喜欢的人</li><li>【亲子】孩子的起跑线到底重不重要</li></ul><h2 id="Day5，3月18日，星期日"><a href="#Day5，3月18日，星期日" class="headerlink" title="Day5，3月18日，星期日"></a>Day5，3月18日，星期日</h2><h3 id="【读书语录】-4"><a href="#【读书语录】-4" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>你要允许自己有写不好的权利。总得大体上写完，才能开始修改。即便是再妙的句子，你也只能暂时放在那里继续向前写，一直写到最后。到那时，你很可能会有不同的感受。——拉里·格尔巴特</p></blockquote><h3 id="【今日选题】-4"><a href="#【今日选题】-4" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【健康】减肥的头号敌人，你知道吗？</li><li>【生活】生活中，我们如何避免拖延症？</li><li>【理财】闲置资金，你如何打理？</li><li>【社交】你的微信好友早都被工作掩埋了吧</li><li>【情感】相爱容易相处难，恋人之间的朝朝暮暮。</li></ul><h2 id="Day6，3月19日，星期一"><a href="#Day6，3月19日，星期一" class="headerlink" title="Day6，3月19日，星期一"></a>Day6，3月19日，星期一</h2><h3 id="【读书语录】-5"><a href="#【读书语录】-5" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>一个人必须能狠下心修改自己写的东西，不然会有别人来完成这件事。——约翰·贝里曼</p></blockquote><h3 id="【今日选题】-5"><a href="#【今日选题】-5" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【励志】不努力，就出局</li><li>【友情】你不说，我不问，这成了我们间最遥远的距离</li><li>【恋爱】姑娘，你把男朋友当垃圾桶了</li><li>【励志】无人问津的黑夜才成就了强大的自己</li><li>【亲情】我和你渐行渐远，直至再也不见</li></ul><h2 id="Day7，3月20日，星期二"><a href="#Day7，3月20日，星期二" class="headerlink" title="Day7，3月20日，星期二"></a>Day7，3月20日，星期二</h2><h3 id="【读书语录】-6"><a href="#【读书语录】-6" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>强大的人不是征服什么，而是能承受什么。——柴静</p></blockquote><h3 id="【今日选题】-6"><a href="#【今日选题】-6" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【人生】谈谈你最近的人生感悟</li><li>【友情】疏远的友情，还要不要挽回？</li><li>【婚姻】那个不舍得为自己花钱的妻子</li><li>【写作】如果再给你一次机会，你还会选择写作这条路吗？</li><li>【成长】工作之外的8小时，决定你的高度</li></ul><h3 id="Day8，3月21日，星期三"><a href="#Day8，3月21日，星期三" class="headerlink" title="Day8，3月21日，星期三"></a>Day8，3月21日，星期三</h3><p><a href="https://m.weike.fm/channel/143745?st=sharelink&amp;inviter_id=24244100" target="_blank" rel="noopener">如何写出单篇稿费过千的拆书稿？</a></p><h3 id="【读书语录】-7"><a href="#【读书语录】-7" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>作家更关注的是了解人性，而不是判断人性。——毛姆《月亮和六便士》</p></blockquote><h3 id="【今日选题】-7"><a href="#【今日选题】-7" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【职场】拖延症不会帮你完成你的工作</li><li>【感情】原来这就是嫁给初恋最好的样子</li><li>【心理】吃亏是福？</li><li>【爱情】对不起，我不想再继续爱你了</li><li>【励志】高效的努力到底有多重要</li></ul><h2 id="Day9，3月22日，星期四"><a href="#Day9，3月22日，星期四" class="headerlink" title="Day9，3月22日，星期四"></a>Day9，3月22日，星期四</h2><h3 id="【读书语录】-8"><a href="#【读书语录】-8" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>我们错过了诺亚方舟，错过了泰坦尼克号，错过了一切的惊险与不惊险，我们还要继续错过。——几米</p></blockquote><h3 id="【今日选题】-8"><a href="#【今日选题】-8" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【干货】如何做好自己的时间管理？</li><li>【道理】对不起，你的运气真的不太好</li><li>【婚姻】婚姻中，最好的相处方式是不累就好</li><li>【励志】不要做那个越努力越失败的人</li><li>【生活】远离那些满身负能量的人</li></ul><h2 id="Day10，3月23日，星期五"><a href="#Day10，3月23日，星期五" class="headerlink" title="Day10，3月23日，星期五"></a>Day10，3月23日，星期五</h2><h3 id="【读书语录】-9"><a href="#【读书语录】-9" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>对于三十岁以后的人来说，十年八年不过是指缝间的事，而对于年轻人而言，三年五年就可以是一生一世。——亦舒</p></blockquote><h3 id="【今日选题】-9"><a href="#【今日选题】-9" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【成长】为什么你的妈妈总是唠叨你</li><li>【微信】微信上那个永远置顶的人</li><li>【心理】你那么怯场，不仅仅是自卑</li><li>【励志】优秀的人，从来不会输给小肚鸡肠</li><li>【生活】格局比努力重要一百倍</li></ul><h2 id="Day11，3月24日，星期六"><a href="#Day11，3月24日，星期六" class="headerlink" title="Day11，3月24日，星期六"></a>Day11，3月24日，星期六</h2><p><a href="https://m.weike.fm/channel/143745?st=sharelink&amp;inviter_id=24244100" target="_blank" rel="noopener">从接软文到写软文的干货技巧</a></p><h3 id="【读书语录】-10"><a href="#【读书语录】-10" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>因为爱过，所以慈悲；因为懂得，所以宽容。——张爱玲</p></blockquote><h3 id="【今日选题】-10"><a href="#【今日选题】-10" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【励志】默默付出很多年，女神终于看到我了</li><li>【职场】世界正在奖励会工作的人</li><li>【读书】读书，让容颜和灵魂变得优雅</li><li>【生活】懂得极简的人，成长得更快</li><li>【婚姻】婚姻好不好，看女人的容貌就知道</li></ul><h2 id="Day12，3月25日，星期日"><a href="#Day12，3月25日，星期日" class="headerlink" title="Day12，3月25日，星期日"></a>Day12，3月25日，星期日</h2><h3 id="【读书语录】-11"><a href="#【读书语录】-11" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>如果你喜欢一个事，又有这样的才干，那就把整个人都投入进去，就要象一把刀直扎下去直到刀柄一样，不要问为什么，也不要管会碰到什么。——柴静</p></blockquote><h3 id="【今日选题】-11"><a href="#【今日选题】-11" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【励志】人可以穷，但是一定不能心穷</li><li>【故事】那个一年看200本书的人</li><li>【干货】你觉得要迅速成长，哪4点最重要？</li><li>【婚姻】比起相爱，更重要的是包容</li><li>【道理】网络暴力到底有多可怕？</li></ul><h2 id="Day13，3月26日，星期一"><a href="#Day13，3月26日，星期一" class="headerlink" title="Day13，3月26日，星期一"></a>Day13，3月26日，星期一</h2><h3 id="【读书语录】-12"><a href="#【读书语录】-12" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>零星的诗句是学海中的一点浪花罢：然而它们是光明闪烁的繁星般嵌在心灵的天空里。 ——冰心</p></blockquote><h3 id="【今日选题】-12"><a href="#【今日选题】-12" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【父母】你给男/女朋友的爱是爸妈的多少倍</li><li>【友情】那个对同学斤斤计较的人到底有几个真心朋友</li><li>【女性】成熟的女人都怎么说话？</li><li>【爱情】男朋友宠你的十个等级</li><li>【人生】自律的人生，到底有多爽</li></ul><h2 id="Day14，3月27日，星期二"><a href="#Day14，3月27日，星期二" class="headerlink" title="Day14，3月27日，星期二"></a>Day14，3月27日，星期二</h2><h3 id="【读书语录】-13"><a href="#【读书语录】-13" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>我希望能做到融奇崛于平淡，纳外来于传统，不今不古，不中不西。 ——《汪曾祺：文与画》</p></blockquote><h3 id="【今日选题】-13"><a href="#【今日选题】-13" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【励志】人与人的差距，藏在每一天的坚持里</li><li>【生活】三观合不合，要看这五件事</li><li>【思维】快停止你的无效努力吧</li><li>【婚姻】那些离婚的女人，后来都怎么样了</li><li>【青春】那些年错过的爱情，还能回来吗？</li></ul><h2 id="Day15，3月28日，星期三"><a href="#Day15，3月28日，星期三" class="headerlink" title="Day15，3月28日，星期三"></a>Day15，3月28日，星期三</h2><p><a href="https://m.weike.fm/channel/143745?st=sharelink&amp;inviter_id=24244100" target="_blank" rel="noopener">短篇小说必须要掌握的3大技巧</a></p><h3 id="【读书语录】-14"><a href="#【读书语录】-14" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>交到朋友的前提是自己修身养性，自己是一个良性元素，还是个惰性元素，诘问自己配交到怎样的朋友。 ——于丹</p></blockquote><h3 id="【今日选题】-14"><a href="#【今日选题】-14" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【亲子】孩子被欺负，该不该打回去？</li><li>【生活】这个世界没有你的那么坏，也没有你想的那么好</li><li>【职场】职场菜鸟，如何提升你的个人竞争力？</li><li>【情感】分手，一定要拉黑么？</li><li>【职场】刚毕业，真的不要计较那一两千块钱</li></ul><h2 id="Day16，3月29日，星期四"><a href="#Day16，3月29日，星期四" class="headerlink" title="Day16，3月29日，星期四"></a>Day16，3月29日，星期四</h2><h3 id="【读书语录】-15"><a href="#【读书语录】-15" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>对于三十岁以后的人来说，十年八年不过是指缝间的事，而对于年轻人而言，三年五年就可以是一生一世。 ——张爱玲</p></blockquote><h3 id="【今日选题】-15"><a href="#【今日选题】-15" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【道理】层次越高的人，越不会轻易撕逼</li><li>【爱情】真正爱你的人，肯定会为你做这件事</li><li>【励志】青春，总要拼搏努力一次</li><li>【婚姻】好的婚姻是这样的</li><li>【恋爱】求求你，别逼着我秒回了</li></ul><h2 id="Day17，3月30日，星期五"><a href="#Day17，3月30日，星期五" class="headerlink" title="Day17，3月30日，星期五"></a>Day17，3月30日，星期五</h2><h3 id="【读书语录】-16"><a href="#【读书语录】-16" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>人生就像滚雪球，重要的是发现够湿的雪，和一道够长的山坡。如果你所处正确的雪中，雪球自然会滚起来，我就是如此。所谓滚雪球，我并不仅仅指赚钱。它指的是你对于这个世界的领悟和朋友的累积。——巴菲特</p></blockquote><h3 id="【今日选题】-16"><a href="#【今日选题】-16" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【励志】不要小看那些不合群的人</li><li>【生活】你过得好不好，看你朋友圈就知道</li><li>【女性】不要小看那个在哪里都涂口红的女人</li><li>【青春】如果可以，我希望可以晚一点遇见你</li><li>【职场】职场不相信眼泪，其实是对自己</li></ul><h2 id="Day18，3月31日，星期六"><a href="#Day18，3月31日，星期六" class="headerlink" title="Day18，3月31日，星期六"></a>Day18，3月31日，星期六</h2><p><a href="https://m.weike.fm/channel/143745?st=sharelink&amp;inviter_id=24244100" target="_blank" rel="noopener">如何链接读书和写作、实现个人的闭环文章</a></p><h3 id="【读书语录】-17"><a href="#【读书语录】-17" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>当我们第一遍读一本好书的时候，我们仿佛觉得找到了一个朋友；当我们再一次读这本好书的时候，仿佛与一个老朋友重逢 —— 伏尔泰</p></blockquote><h3 id="【今日选题】-17"><a href="#【今日选题】-17" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【生活】你对待家人的态度，藏着你的未来</li><li>【青春】好好谈一场不分手的恋爱</li><li>【励志】我拼了命，就是为了摆脱原生阶层</li><li>【思维】群聊见智商</li><li>【微信】求求你，不要再给我发微信语音了</li></ul><h2 id="Day19，4月1日，星期日"><a href="#Day19，4月1日，星期日" class="headerlink" title="Day19，4月1日，星期日"></a>Day19，4月1日，星期日</h2><h3 id="【读书语录】-18"><a href="#【读书语录】-18" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>女人20岁之前的容貌是天生的，20岁之后就是自己塑造的，成长，经历，环境，都会影响你的眼神和姿态。——董卿</p></blockquote><h3 id="【今日选题】-18"><a href="#【今日选题】-18" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【生活】做一个高情商的人，你的生活将会好过一百倍</li><li>【亲子】过年串门，孩子的这三个动作体现了教养</li><li>【婚姻】婚姻中，比起相爱，更重要的是…</li><li>【爱情】找一个愿意为你变成熟的人在一起</li><li>【励志】你可以让自己变得更好</li></ul><h2 id="Day20，4月2日，星期一"><a href="#Day20，4月2日，星期一" class="headerlink" title="Day20，4月2日，星期一"></a>Day20，4月2日，星期一</h2><h3 id="【读书语录】-19"><a href="#【读书语录】-19" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>成功之花，人们往往惊羡它现时的明艳，然而当初，它的芽儿却浸透了奋斗的泪泉，洒满了牺牲的血雨。——冰心</p></blockquote><h3 id="【今日选题】-19"><a href="#【今日选题】-19" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【人物】剽悍的人生，不需要解释</li><li>【爱情】当你一个女生彻底爱上你的时候</li><li>【职场】职场，不相信没有任何成果的努力</li><li>【生活】有些人30岁了，却像死了一样</li><li>【情感】一个人的情人节，我也可以过得很好</li></ul><h2 id="Day21，4月3日，星期二"><a href="#Day21，4月3日，星期二" class="headerlink" title="Day21，4月3日，星期二"></a>Day21，4月3日，星期二</h2><h3 id="【读书语录】-20"><a href="#【读书语录】-20" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>今后我也不知道会怎么样，生活的魅力就在于它的不可知，我们只是去为未来做努力。——董卿</p></blockquote><h3 id="【今日选题】-20"><a href="#【今日选题】-20" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【职场】年轻人，不要只看当下的路</li><li>【观点】为什么越来越多的人，选择了离婚？</li><li>【爱情】他只是暧昧，并不是喜欢你</li><li>【励志】那些又美又努力的女人，最可怕</li><li>【观点】“对不起，本公司只招男职员”</li></ul><h2 id="Day22，4月4日，星期三"><a href="#Day22，4月4日，星期三" class="headerlink" title="Day22，4月4日，星期三"></a>Day22，4月4日，星期三</h2><p><a href="https://m.weike.fm/channel/143745?st=sharelink&amp;inviter_id=24244100" target="_blank" rel="noopener">文学大师的这些写作方法，让你终生写作</a></p><h3 id="【读书语录】-21"><a href="#【读书语录】-21" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>善于识别与把握时机是极为重要的。在一切大事业上，人在开始做事前要象千眼神那样察视时机，而在进行时要象千手神那样抓住时机。——培根</p></blockquote><h3 id="【今日选题】-21"><a href="#【今日选题】-21" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【友情】珍惜那些不常联系，但是却一直惦记着你的朋友</li><li>【观点】那些喊着读书无用论的人，现在怎么样了？</li><li>【励志】别让舒适区毁了你</li><li>【婚姻】中国式父母，你的付出正在毁掉下一代</li><li>【情感】这句话让我明白了什么是爱情</li></ul><h2 id="Day23，4月5日，星期四"><a href="#Day23，4月5日，星期四" class="headerlink" title="Day23，4月5日，星期四"></a>Day23，4月5日，星期四</h2><h3 id="【读书语录】-22"><a href="#【读书语录】-22" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>吾志所向，一往无前；愈挫愈奋，再接再励。——孙中山</p></blockquote><h3 id="【今日选题】-22"><a href="#【今日选题】-22" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【亲子】父母的格局，影响着孩子的未来</li><li>【其他】决定你生活的，从来不是别人的评论，而是……</li><li>【观点】学业、赚钱，大学生该何去何从？</li><li>【生活】为什么越长大越不快乐？这是我听过最动人的回答。</li><li>【励志】20岁不拼命，40岁等待你的就是裁员</li></ul><h2 id="Day24，4月6日，星期五"><a href="#Day24，4月6日，星期五" class="headerlink" title="Day24，4月6日，星期五"></a>Day24，4月6日，星期五</h2><h3 id="【读书语录】-23"><a href="#【读书语录】-23" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>相貌的美高于色泽的美，而秀雅合适的动作的美，又高于相貌的美，这是美的精华。</p></blockquote><h3 id="【今日选题】-23"><a href="#【今日选题】-23" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【情感】为什么我宁愿单着，也不愿意找个人嫁了</li><li>【励志】哪怕只有1%的希望，也要付出100%的努力</li><li>【生活】你的这个小动作，暴露了你的性格</li><li>【励志】谋生要趁早，努力要尽早</li><li>【爱情】因为……，我不想再爱了</li></ul><h2 id="Day25，4月7日，星期六"><a href="#Day25，4月7日，星期六" class="headerlink" title="Day25，4月7日，星期六"></a>Day25，4月7日，星期六</h2><p><a href="https://m.weike.fm/channel/143745?st=sharelink&amp;inviter_id=24244100" target="_blank" rel="noopener">4大平台、迅速建立起自己的自媒体矩阵</a></p><h3 id="【读书语录】-24"><a href="#【读书语录】-24" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>一个人从另一个人的诤言中所得来的光明，比从他自己的理解力、判断力所得出的光明更是干净纯粹。</p></blockquote><h3 id="【今日选题】-24"><a href="#【今日选题】-24" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【教养】一个人有没有教养，看细节就知道</li><li>【励志】25岁之前，你必须明白的10个道理（男女角度都可以）</li><li>【读书】读书和不读书的人生，究竟有什么不一样？</li><li>【情感】你终于成了我最熟悉的陌生人</li><li>【生活】你对待朋友的态度，体现了你的修养</li></ul><h2 id="Day26，4月8日，星期日"><a href="#Day26，4月8日，星期日" class="headerlink" title="Day26，4月8日，星期日"></a>Day26，4月8日，星期日</h2><h3 id="【读书语录】-25"><a href="#【读书语录】-25" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>世界上没有一条道路是重复的，也没有一个人生是可以替代的。——余华</p></blockquote><h3 id="【今日选题】-25"><a href="#【今日选题】-25" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【家庭】远嫁的姑娘，是父母最深的牵挂</li><li>【生活】这辈子最重要的事，是经营好自己</li><li>【观点】为什么我宁可在租房也要生活在大城市里？（正反均可）</li><li>【励志】现在经历的苦难，是为了明日的自由</li><li>【爱情】爱没爱对人，吵架的时候才知道</li></ul><h2 id="Day27，4月9日，星期一"><a href="#Day27，4月9日，星期一" class="headerlink" title="Day27，4月9日，星期一"></a>Day27，4月9日，星期一</h2><h3 id="【读书语录】-26"><a href="#【读书语录】-26" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>猛兽总是独行，牛羊才成群结队。<br>               ——鲁迅《鲁迅杂文精选》</p></blockquote><h3 id="【今日选题】-26"><a href="#【今日选题】-26" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【女性】会花钱的女人，才是一个家的稀缺品</li><li>【爱情】你有没有一个，放不下也忘不掉的人？</li><li>【观点】AA制，到底应不应该？</li><li>【励志】学校可以是二流的，但你不是</li><li>【道理】不要和总是说“忙”的人在一起</li></ul><h2 id="Day28，4月10日，星期二"><a href="#Day28，4月10日，星期二" class="headerlink" title="Day28，4月10日，星期二"></a>Day28，4月10日，星期二</h2><h3 id="【读书语录】-27"><a href="#【读书语录】-27" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>当我们回头看自己走过来的路时，所看到的仍似乎只是依稀莫辩的‘或许’。我们所能明确认知的仅仅是现在这一瞬间，而这也只是与我们擦间而过。<br>                ——村上春树</p></blockquote><h3 id="【今日选题】-27"><a href="#【今日选题】-27" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【生活】小年到了，你准备好回家过年了吗？</li><li>【婚姻】层次越高的女人，越不会做这件事</li><li>【亲子】为什么越长大，跟父母越没话说？</li><li>【励志】每一个你讨厌的现在，都有一个不努力的曾经</li><li>【自律】坚持这件事，一年后你会感激现在的自己！</li></ul><h2 id="Day29，4月11日，星期三"><a href="#Day29，4月11日，星期三" class="headerlink" title="Day29，4月11日，星期三"></a>Day29，4月11日，星期三</h2><h3 id="【读书语录】-28"><a href="#【读书语录】-28" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>年轻的时候，即使身无分文，一贫如洗，也会享受生活。 在没有列车的时候，我和她和猫躺在铁轨上，安静地简直像坐在湖底，我们年轻，新婚不久，阳光免费。<br>               ——村上春树 《遇到百分之百的女孩》</p></blockquote><h3 id="【今日选题】-28"><a href="#【今日选题】-28" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【婚姻】最应该富养的不是孩子，是妻子</li><li>【生活】世界正在偷偷奖励爱读书的人</li><li>【情感】我暗恋的那个人，现在变成了……</li><li>【生活】一个人过得好不好，看他吃饭的样子就知道</li><li>【自律】光鲜靓丽背后，是你看不到的自律</li></ul><h2 id="Day30，4月12日，星期四"><a href="#Day30，4月12日，星期四" class="headerlink" title="Day30，4月12日，星期四"></a>Day30，4月12日，星期四</h2><h3 id="【读书语录】-29"><a href="#【读书语录】-29" class="headerlink" title="【读书语录】"></a>【读书语录】</h3><blockquote><p>希望你下辈子不要改名，这样我会好找你一点。</p></blockquote><h3 id="【今日选题】-29"><a href="#【今日选题】-29" class="headerlink" title="【今日选题】"></a>【今日选题】</h3><ul><li>【亲子】孩子从小要知道的5个道理</li><li>【青春】那个你卸载了微信也忘不了的人</li><li>【女性】女生25岁，你必须要懂的10件事</li><li>【情感】因为贫穷，连爱TA都是一种奢侈</li><li>【情感】异地恋：不靠谱的是人，从来不是感情</li></ul><hr><p>本文链接：<a href="http://www.sguotao.top/读书笔记-2018-06-15-树獭先生写作课.html">http://www.sguotao.top/读书笔记-2018-06-15-树獭先生写作课.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Day1，3月14日，星期三&quot;&gt;&lt;a href=&quot;#Day1，3月14日，星期三&quot; class=&quot;headerlink&quot; title=&quot;Day1，3月14日，星期三&quot;&gt;&lt;/a&gt;Day1，3月14日，星期三&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://m.wei
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书写作" scheme="http://www.sguotao.top/tags/%E8%AF%BB%E4%B9%A6%E5%86%99%E4%BD%9C/"/>
    
      <category term="树獭先生写作课" scheme="http://www.sguotao.top/tags/%E6%A0%91%E7%8D%AD%E5%85%88%E7%94%9F%E5%86%99%E4%BD%9C%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>三十而立，生活不易</title>
    <link href="http://www.sguotao.top/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2018-06-15-%E4%B8%89%E5%8D%81%E8%80%8C%E7%AB%8B%E7%94%9F%E6%B4%BB%E4%B8%8D%E6%98%93.html"/>
    <id>http://www.sguotao.top/生活感悟-2018-06-15-三十而立生活不易.html</id>
    <published>2018-06-15T07:50:16.000Z</published>
    <updated>2018-06-15T07:50:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>三十而立，才真切的感觉到生活的不易，我是一个程序员，一个自以为年轻，熬夜晚点起就可以扛过去的人，一个自以为身体很好，直到有一天发现自己中了大奖的人。</p><p>2017年8月19日，发现自己右肩刺痛，以为是肩周炎加重了，挂朝阳医院门诊，做了腰椎CT和胸部CT，诊断结果腰椎骨质轻度退行性变，椎体骨密度减低，肝右叶低密度灶。骨科大夫说是轻度骨质增生，开了一些止疼药，建议挂内科大夫的号，看一下肝脏。</p><p>朝阳医院内科的号要排到一个月以后，再排号做检查，估计要等两个月，于是挂了安贞医院的号。2017年9月18日，拿到腹部CT结果，肝右叶低密度影，建议进一步增强检查。9月20日，拿到腹部增强CT结果，肝右叶富血供占位，考虑恶性可能。</p><p>看到检查结果的时候，心理还有一丝侥幸，挂了内科大夫的号，我清楚的记得内科医生看到检查结果皱起了眉头，然后一脸惋惜的对我说“你这个是恶性肿瘤，我推荐给你三家医院，你自己考虑”。从医院出来，眼前是黑的，给媳妇儿打了电话，说检查结果不太理想，媳妇儿安慰说，“没事儿，再去别的医院看看”。</p><p>2017年9月22日，我和媳妇儿从网上挂了301医院的号，结果到医院才发现，没有本人身份证和四大银行的卡，只拿社保卡是取不出来号的，我记得当时天气很热，取不出号，看不了大夫，更让人焦躁的抓狂。用手机查了附近的医院，最近的是北京大学肿瘤医院，当时已经是下午四点多，担心医生下班，于是打车到了北肿。</p><p>北肿的大夫看了我带的片子，支开了媳妇儿（让她去重新买个病历本），告诉我，你这个基本可以确诊是恶性肿瘤，肿瘤位置比较特殊，我先给你开验血的单子，你周一挂主任的号，再确认一下。大夫还问我要不要告诉媳妇，我想了一下，先别告诉她，她还太年轻，怕她承受不了。后来发现，媳妇儿远比我想象中的坚强。</p><p>2017年9月25日，带着片子看主任的号，当时心里还存在一丝丝的侥幸，没想到主任说，一看你的脸色，就知道你的肝有问题，他又看了一下片子，肿瘤的位置有些特殊，靠近门静脉，先安排你住院，现在床位紧张，等电话通知。最后的一丝侥幸也没有了，心里像塞了棉花一样。</p><p>2017年9月30日，接到医院电话，赶上国庆节，刚好有人出院，问我要不要住院，可能多花一点钱，先占上床位。于是当天下午，去医院办理了住院手续，找主治医生请了假，节后回来报道。</p><p>父亲从老家赶来，一家人第一次过了一个团圆的中秋节，带着刚10个月的女儿和父母去了天安门，去了在郊区刚装修完不久的新家，现在都能清晰的记得女儿在新家时开心的样子。</p><p>2017年10月8日，我一个人带着换洗的衣服，洗漱用品，背着书包去医院。我没有让人送我，一个人坐地铁，一个人去医院，当时只觉得自己太渺小，生命太卑微。</p><p>2017年10月16日，主治医生找父亲和媳妇儿谈了话，给我办理了出院手续。出院报告上写着，肝S8区肿块，伴周围多发结节，考虑HCC可能，伴门静脉右前支瘤栓形成，肝硬化较重，且肝内病灶边界不清。综合考虑，行索拉菲尼+介入治疗。</p><p>介入治疗需要转入到介入科做手术，没想到介入科排队等待做手术的人那么多，一大摞的单子，要排到一个月之后，父亲几乎是用央求的口吻和大夫说，我儿子还这么年轻，等不起呀，不能耽误呀，帮帮忙往前排一下吧。大夫指着那一摞单子，这里边也有比你儿子年轻的，回家等消息吧。</p><p>没有办法，只能回家等消息，那一段时间，家里人都着急上火，生怕治疗的速度赶不上病情发展的速度，家里人动用了一切可能帮上忙的资源。终于找到了一个很久都不联系的亲戚，安排增加手术。</p><p>2017年10月19日，到远在郊区的北肿附属医院介入科住院，住院当天下午就安排了手术，这是自己在30年的人生中，第一次做手术，来不及做太多的心理准备，就被推进了手术室。手术采用局部麻醉，我躺在手术台上，盯着头上的白炽灯，那一刻，脑海里像放电影一样，最多的都是女儿那幼小稚嫩的脸。</p><p>经过40多分钟的手术，被送回了病房，手术后需要在病床上躺48小时，由于有一条腿不能动，担心引起出血，使得身体可活动的范围比较小，伴随着高烧，恶心，强烈的腹痛，那48小时在床上辗转反侧，半睡半醒。</p><p>介入手术在医院住了8天，转氨酶一直居高不下，肝功能严重受损，前三天，一直没有排便，医生给开了开塞露，结果之后一直拉肚子，一天5、6次，本来就进食不多，拉的昏天黑地。同一天做手术的病友，已经能在楼道里溜达，我还只能扶着墙，一步步挪。这是父亲第一次陪床，大夫每次的医嘱，父亲都像是个小学生一样认真，生怕漏掉一点。</p><p>临床的病友和我年纪差不多大，已经发生了骨转移，这已经是第6次介入治疗了，平时只能躺在床上，日常生活只能靠他父亲来帮忙。当时我没有多想，剧烈的反应已经让我疲于应付。父亲说，那时候他已经做了最坏的打算，如果我像这个病友一样，只要我还在，他能接受我少胳膊少腿。如果我不在了，他就直接从楼上跳下去，一了百了。</p><p>接下来的一个月，剧烈的反应并没有减轻，每天都是一把一把的药片，我数过，最多的一次是36片，大部分都是保肝的药。多吉美也开始有了副作用，手指脚趾发红，疼痛。每天夜里都会醒来几次，都是胃疼疼醒的，起来吃点东西，吃一片止痛药，才能入睡，那些日子，早上起来，枕巾和睡衣都是被汗水打湿的。</p><p>2017年12月初，再次到医院复查，介入科大夫说，介入效果不错，建议再转到外科进行手术。</p><p>2017年12月11日，第二次住进了肝胆外科，这一次没有了第一次住院时的好奇和新鲜，更多的是，那种死亡临近，让人窒息的感觉。大夫说，手术安排在一周后进行。接着就是一项又一项的检查，一瓶又一瓶液体，每天最期待的，就是能在上午输完液后，坐在走廊尽头的椅子上晒太阳。吃完晚饭，在病房的窗前看外面的夜景，窗外车水马龙，窗里鸦雀无声，一层玻璃，两个世界。</p><p>2017年12月18日，一个让人难忘的日子，我又一次感受到，自己的人生轨迹会在某个结点，因为一个结果的不同，而发生转变。上一次有这种感觉还是在高考放榜的时候，而今天，显然就是我人生中的又一次高考。手术前，大夫已经找家属谈过话，好的坏的，都交代了一遍。手术定在早上8点，第一台手术。</p><p>家里人经历了太多太多的担心，一点点的变化都能给他们带来不同的心理暗示，比如早上第一台手术，他们会想，第一台手术大夫的精力最好，肿瘤切除的也最干净。早上6点就起床，到护士站插胃管，插尿管，做备皮，一些列手术之前的准备。最难受的是插胃管的时候，要从鼻孔插一根管子到胃里，不停的干呕，那时候，想的最多的就是，如果有些痛苦不能避免，那么唯一能做的就是接受。父亲把我从护士站扶到病床，短短的几十米，感觉走了好久。后来父亲说，那时候我浑身都在不停的发抖。</p><p>进手术室需要被推出病房，坐电梯到手术室。由于是周一，病房外挤满了前来探视的家属。从病房门口到电梯门口只有十几米的距离，我从来没有试过躺在移动的病床上去看这一张张陌生的脸，也从来没有被这么多双眼睛看我躺在床上。被推进病房，感觉一阵阵寒气从头顶凉到脚跟，照例要扎针，输液，量体温，鼻孔上的胃管让我一动都不敢动，连呼吸都是轻轻的，生怕一点点的刺激带来的强烈的干呕。</p><p>事情的发展有时候总是不能够按照我们预期的轨迹进行，打麻药的时候照例要量体温，结果体温偏高，负责打麻药的大夫拒绝打麻药。不打麻药就没有办法进行手术，于是我又在众人的注视下被送回了病房，这感觉，就像好不容易赶到了考场，结果发现准考证没带在身上。于是，我在病房又有了新的标签“进手术室发烧的那位”，关于发烧的原因，护士和病友们都认为是心理素质不好，太紧张了。</p><p>这一点变化让家人们急坏了，如果今天做不了手术，不知道要排到什么时候。我想，那一刻，能做手术，是他们在那段黑暗日子里唯一能感到光亮的一件事。下午4点28分，我第二次被推进了手术室，我躺在床上，盯着移动的天花板，努力的平复自己的心情，这一次不能再让亲人们担心了，我让自己一遍一遍回忆女儿的小脸，心里一遍一遍默念“一切都会好起来”。</p><p>晚上7点多，我被推出了病房，醒来的时候，自己已经被推到了病房，父亲和亲人们把我抬到病床上，护士们过来输液，插各种仪器。看我手术顺利，亲人们悬着的一颗心能稍稍放下一点了。</p><p>2018年12月25日，我出院了，父亲想把我安排在医院附近的宾馆，这样万一有什么不舒服能随时到医院，现在住的一室一厅条件不是太好，阴暗潮湿，不利于我恢复，我当时只想能天天看到女儿，强烈要求回家住。母亲，女儿和媳妇儿挤在里屋的大床上，我睡在隔出来的客厅里的一张单人床上，父亲打地铺。那一段时间，只有一个念头，要和亲人在一起。</p><p>在这个一室一厅的出租屋里，我们迎来了女儿的第一个生日和我劫后重生的第一个新年，我不知道未来的日子还有多久，但我想，只要我还在，就不要离开他们。向死而生，在没有经历过生死考验是感触不深的，所谓梦想，当没有生命承载时也变成了奢望，死亡很容易，困难的是有面对死亡的勇气。原来死亡从来都不是一个人的事，对于父母，他们要经历老年丧子；对于爱人，她要经历青年丧夫，对于女儿，在还未懂世事时就要经历幼年丧父。所以，唯有一遍遍发愿，我身体的一切都在朝好的方向发展，一切都会好起来，everything will be all right.</p><hr><p>本文链接：<a href="http://www.sguotao.top/生活感悟-2018-06-15-三十而立生活不易.html">http://www.sguotao.top/生活感悟-2018-06-15-三十而立生活不易.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三十而立，才真切的感觉到生活的不易，我是一个程序员，一个自以为年轻，熬夜晚点起就可以扛过去的人，一个自以为身体很好，直到有一天发现自己中了大奖的人。&lt;/p&gt;
&lt;p&gt;2017年8月19日，发现自己右肩刺痛，以为是肩周炎加重了，挂朝阳医院门诊，做了腰椎CT和胸部CT，诊断结果腰
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>怎样和领导谈话</title>
    <link href="http://www.sguotao.top/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2017-08-17-%E6%80%8E%E6%A0%B7%E5%92%8C%E9%A2%86%E5%AF%BC%E8%B0%88%E8%AF%9D.html"/>
    <id>http://www.sguotao.top/生活感悟-2017-08-17-怎样和领导谈话.html</id>
    <published>2017-07-25T04:27:04.000Z</published>
    <updated>2017-08-17T02:11:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>与领导相处，只要永远记住一句话：<strong>真理不是争来的。做一个好助手，就要学会经常批评自己，这样，你才能真正的成熟。</strong></p><h2 id="怎样和领导谈话"><a href="#怎样和领导谈话" class="headerlink" title="怎样和领导谈话"></a>怎样和领导谈话</h2><ol><li>领导永远是对的；</li><li>领导最关心的几点作简短、快捷的汇报；</li><li>不要诉苦；</li><li>学会沉默，即使被误解，要学会以分析的眼光看待领导的批评，批评会使你更成熟，处理事情更有分寸，要尽量寻找自身的原因，以自己的缺点来迎合领导的批评，就会换得一颗平淡的心，会避免所有的争执，而且可以使领导跟你一样经常剖析自己，承认自己也可能弄错。</li></ol><p>与领导相处，只要永远记住一句话：真理不是争来的。做一个好助手，就要学会经常批评自己，这样，你才能真正的成熟。谈话是加强沟通、联系上下级关系的一条重要纽带，因此，作为下级的你一定要重视和领导的谈话，把握住自己的分寸。具体地说，应注意以下几个细节：</p><ol><li><p>不妨主动些，作为下属，可以积极主动地与领导交谈，渐渐地消除彼此间可能存在的隔阂，使上级下级关系相处得正常，融洽。当然，这与“巴结”领导不能相提并论，因为工作上的讨论及打招呼是不可能缺少的，这不但能祛除对领导的恐惧感，而且也能使自己的人际关系圆满，工作顺利。</p></li><li><p>在态度上，必须不卑不亢，对领导应当尊重，你应该承认，领导一般有强过你的地方，或者才干超群，或是经验丰富，所以，对领导要做到有礼貌，谦逊。但是，绝不要采取“低三下四”的态度。绝大多数有见识的领导，对那种一味奉承，随声附和的人，是不会予以重视的。在保持独立人格的前提下，你应采取不卑不亢的态度。在必要的场合，你也不必害怕表示自己的不同观点，只要你是从工作出发，摆事实，讲道理，领导一般是会予以考虑的。</p></li><li><p>选择适当的时机，领导一天到晚要考虑的问题很多，你应当根据自己的问题的重要与否，选择适当时机去反映。假如你是为个人琐事就不要在他正埋头处理事务时去打扰他。如果你不知道领导何时有空，不妨先给他写张纸条，写上问题的要求，然后请求与他交谈。或写上你要求面谈的时间，地点，请他先约定。这样，领导便可以安排时间了。</p></li><li><p>事先做好充分的准备，在谈话时，充分了解自己所要说的话的要点，简练，扼要，明确地向领导汇报。如果有些问题是需要请示的，自己心中应有两个以上的方案，而且能向上级分析各方案的利弊，这样有利领导做决断。为此，事先应当周密准备，弄清每个细节，随时可以回答，如果领导同意某一方案，你应尽快将其整理成文字再呈上，以免日后领导又改了主意，造成不必要的麻烦。要先替领导考虑提出问题的可行性。有些人明知客观上不存在解决问题的条件，却一定要去找领导，结果造成了不欢而散的结局。</p></li><li><p>向领导报告一定要有根有据，美国广告大王布鲁贝在他年轻时，他所在公司的经理问他：“印刷厂把纸送来没有？”他回答：“送过来了，共有5000令。”经理问：“你数了吗？”他说：“没有，是看到单上这样写的。”经理冷冷地说：“你不能在此工作了，本公司不能要一个连自己也不能替自己作证明的人来工作。”从此，布鲁贝克得出一个教训：对领导，不要说自己没有把握的事情。</p></li></ol><h2 id="和领导谈话的技巧"><a href="#和领导谈话的技巧" class="headerlink" title="和领导谈话的技巧"></a>和领导谈话的技巧</h2><p>卓越的说话技巧，譬如讨好重要人物、避免麻烦事落到自己身上、处理棘手的事务等等，不仅能让你的工作生涯加倍轻松，更能让你名利双收。牢记以下十个句型，并在适当时刻派上用场，加薪与升职必然离你不远。</p><h3 id="上司传唤时责无旁贷"><a href="#上司传唤时责无旁贷" class="headerlink" title="上司传唤时责无旁贷"></a>上司传唤时责无旁贷</h3><p><strong>句型：我马上处理。</strong><br>冷静、迅速的做出这样的回答，会今上司直觉的认为你是名有效率、听话的好部属；相反，犹豫不决的态度只会惹得责任本就繁重的上司不快。夜里睡不好的时候，还可能迁怒到你头上呢！</p><h3 id="表现出团队精神"><a href="#表现出团队精神" class="headerlink" title="表现出团队精神"></a>表现出团队精神</h3><p><strong>句型：安琪的主意真不错!</strong><br>安琪想出了一条连上司都赞赏的绝妙好计，你恨不得你的脑筋动得比人家快；与其拉长脸孔、暗自不爽，不如偷沾他的光。方法如下：趁著上司听得到的时刻说出本句型。在这个人人都想争著出头的社会里，一个不妒嫉同事的部属，会让上司觉得此人本性纯良、富有团队精神，因而另眼看待。　　</p><h3 id="说服同事帮忙"><a href="#说服同事帮忙" class="headerlink" title="说服同事帮忙"></a>说服同事帮忙</h3><p><strong>句型：这个报告没有你不行啦!。</strong><br>有件棘手的工作，你无法独力完成，非得找个人帮忙不可；于是你找上了那个对这方面工作最拿手的同事。怎麽开口才能让人家心甘情愿的助你一臂之力呢？送高帽、灌迷汤，并保证他日必定回报；而那位好心人为了不负自己在这方面的名声，通常会答应你的请求。不过，将来有功劳的时候别忘了记上人家一笔。</p><h3 id="巧妙闪避你不知道的事"><a href="#巧妙闪避你不知道的事" class="headerlink" title="巧妙闪避你不知道的事"></a>巧妙闪避你不知道的事</h3><p><strong>句型：让我再认真的想一想，三点以前给您答覆好吗？</strong><br>上司问了你某个与业务有关的问题，而你不知该如何做答，千万不可以说「不知道」。本句型不仅暂时为你解危。也让上司认为你在这件事情上头很用心，一时之间竟不知该如何启齿。不过，事後可得做足功课，按时交出你的答覆。</p><h3 id="智退"><a href="#智退" class="headerlink" title="智退"></a>智退</h3><p><strong>句型：这种话好像不大适合在办公室讲喔!</strong><br>如果有男同事的黄腔令你无法忍受，这句话保证让他们闭嘴。男人有时候确实喜欢开黄腔，但你很难判断他们是无心还是有意，这句话可以令无心的人明白，适可而止。如果他还没有闭嘴的意思，即构成了骚扰，你可以向有关人士举发。</p><h3 id="不著痕迹的减轻工作量"><a href="#不著痕迹的减轻工作量" class="headerlink" title="不著痕迹的减轻工作量"></a>不著痕迹的减轻工作量</h3><p><strong>句型：「我了解这件事根重要；我们能不能先查一查手头上的工作，把最重要的排出个优先顺序？」</strong><br>不如当下就推辞。首先，强调你明白这件任务的重要性，然后请求上司的指示，为新任务与原有工作排出优先顺序不著痕迹的让上司知道你的工作量其实很重，若非你不可的话，有些事就得延后处理或转交他人。</p><h3 id="承认疏失但不引起上司不满"><a href="#承认疏失但不引起上司不满" class="headerlink" title="承认疏失但不引起上司不满"></a>承认疏失但不引起上司不满</h3><p><strong>句型：是我一时失察，不过幸好……</strong><br>放错在所难免，但是你陈述过失的方式，却能影响上司心目中对你的看法。勇于承认自己的疏失非常重要，因为推卸责任只会让你看起来就像个讨人厌、软弱无能、不堪重用的人，不过这不表示你就得因此对每个人道歉，诀窍在于别让所有的矛头都指到自己身上，坦承却淡化你的过失，转移众人的焦点。</p><h3 id="面对批评要表现冷静"><a href="#面对批评要表现冷静" class="headerlink" title="面对批评要表现冷静"></a>面对批评要表现冷静</h3><p><strong>句型：谢谢你告诉我，我会仔细考虑你的建议。</strong><br>自己苦心的成果却遭人修正或批评时，的确是一件令人苦恼的事。不需要将不满的情绪写在脸上，但是却应该让批评你工作成果的人知道，你已接收到他传递的信息。不卑不亢的表现才能表现你的风度　　</p><h3 id="以最婉约的方式传递坏消息"><a href="#以最婉约的方式传递坏消息" class="headerlink" title="以最婉约的方式传递坏消息"></a>以最婉约的方式传递坏消息</h3><p><strong>句型：我们似乎碰到一些状况…</strong><br>你刚刚才得知，一件非常重要的案子出了问题；如果立刻冲到上司的办公室里报告这个坏消息，就算不干你的事，也只会让上司质疑你处理危机的能力，弄不好还惹来一顿骂、把气出在你头上。此时，你应该以不带情绪起伏的声调，从容不迫的说出本句型，千万别慌慌张张，也别使用「问题」或「麻烦］这一类的字眼；要让上司觉得事情并非无法解决，而「我们」听起来像是你将与上司站在同一阵线，并肩作战。　　</p><h3 id="恰如其分的讨好"><a href="#恰如其分的讨好" class="headerlink" title="恰如其分的讨好"></a>恰如其分的讨好</h3><p><strong>句型：我很想您对某件事情的看法……</strong><br>许多时候，你与高层要人共处一室，而你不得不说点话以避免冷清尴尬的局面。不过，这也是一个让你能够赢得高层青睐的绝佳时机。但说些什么好呢？每天的例行公事，绝不适合在这个时候被搬出来讲，谈天气嘛，又根本不会让高层对你留下印象。此时，最恰当的莫过一个跟公司前景有关，而又发人深省的话题。问一个大老板关心又熟知的问题，但他滔滔不绝的诉说心得的时候，你不仅获益良多，也会让他对你的求知上进之心刮目相看。</p><h2 id="如何消除与领导谈话时的紧张"><a href="#如何消除与领导谈话时的紧张" class="headerlink" title="如何消除与领导谈话时的紧张"></a>如何消除与领导谈话时的紧张</h2><p>为避免紧张，要淡化交谈的意义，把与领导的交谈视作与常人的交谈完全一样。要有这样的思想：<strong>万一谈不成，也没有什么大不了。在淡化交谈意义的同时，要相信自己有能力、有水平与领导对话，并必定能取得理想的效果。</strong>淡化后果，充满自信，紧张就不会缠绕你。</p><p>单刀直入承认怕：为避免紧张心理的加剧，在你走进办公室见到领导的那一刻，不妨先直截了当地承认：“见到您，我心里非常紧张!”见来者先说怕，许多领导往往会这样说：“怕什么?我是老虎啊?我又不吃人。”有的领导或许会想：难道我平时很严肃，很正经。如此一来，一些领导就会表现出格外的热情和随和，即使你一时仍然紧张，他们也会因你的坦诚而给以谅解。从另一方面来说，自己承认有点怕，并公开说了出来，等于放下了心理包袱，情绪就会慢慢地轻松起来。</p><p>事实通常是这样：你越不承认紧张，心理反而会越来越紧张。</p><p>随身带个小玩艺：心情紧张，这与你和领导的关系生疏有着很大的关系。交谈前，不妨随身带个自己熟悉的、常用的小玩艺，像旅行剪刀、打火机、钥匙串、小型计算器等，以备必要时玩玩，调剂心理。心理学家认为：怯懦或紧张时，摆弄摆弄自己熟悉的东西，可以起到缓解作用。因为这种东西经常和自己在一起，极熟了，会有一种亲切感和可靠的信赖感，无形中会给你一种胆量，还可以分散过于集中的思想，帮助你活跃思维，打开思路。另外，带个小玩艺，在交谈的空隙摆弄一下，还可避免冷场时无事可做而越发紧张的情况。当然，要掌握分寸，一旦紧张消除，小玩艺就要自然放好，不能长玩不息。<br>　　<br>了解兴趣谈兴趣：在与领导交谈前，可先向熟人了解一下他的兴趣和爱好。如果领导喜欢下棋(或书法、或垂钓等)，那么，见面时，就先从这些他感兴趣的话题入手。了解兴趣谈兴趣的目的，是为了找到共同的语言，及时沟通感情和融洽气氛。涉及到感兴趣的话题，领导的话就会多起来，感情也会投入些，态度自然会亲切和平和。几句来去之后，你的心情也许就不会感到紧张了。要注意的是，在谈及感兴趣话题时，一定要实事求是，不要恭维和夸张，如领导的棋艺并不精，你却硬说很高很高，那反而会被他怀疑是吹捧而不予理睬，以致重新造成紧张的气氛。就地取材先闲聊，如领导没有什么特别的兴趣爱好，或者他的兴趣你自己不懂，谈不出内容，那么，不妨采用就地取材闲聊的办法。有交际经验的人总是这样：先说上几句闲话，待彼此有了一定的气氛后再进入正题。为使闲话自然得体，可就地取材。就地取材的内容是很多的：像办公室的陈设、墙上挂着的报纸杂志、近来的天气、领导的衣帽服饰等。如正遇上天气特别冷，就可以天气为材，如桌子上有一只新型的茶杯，可以先观赏一下杯子，然后就谈谈它的特点。先闲聊几句的意义主要在于：</p><p>一是可从中捕捉到领导当时的心情，以及时调整自己的话语；二是可以掩饰和缓解自己心情的紧张；三是可以为进入正题作过渡，起桥梁作用。</p><p>相信领导通人情：有些人不敢与领导交谈，主要是平时跟领导接触不多，不了解其性格，怕领导态度不好，怕领导不通人情。抱着这种心态去交谈，还会不紧张吗?因此，在交谈时，先要相信领导是通人情的，是不会动辄发脾气的。事实上，许多领导干部是喜欢与普通群众接触的，通人情、讲道理、态度好的领导是绝大多数。只要你反映的事、说的话是合情合理的，即使是为了个人，也用不着紧张。有些人怕与领导交谈是因为领导的威望高、名声大，这更是怕得没理。应该晓得，越是威望高名声大的领导，他们的态度和脾气就越好，就越是通人情。</p><p>相信自己能成功：有些人害怕与领导交谈，是由于后果考虑得过多过坏，生怕交谈不成，反而让人留下一个不好的印象，无端惹上一身麻烦。后果考虑过多过坏，心理压力就大了，紧张的心情也就难免。为避免紧张，要淡化交谈的意义，把与领导的交谈视作与常人的交谈完全一样。要有这样的思想：万一谈不成，也没有什么大不了。在淡化交谈意义的同时，要相信自己有能力、有水平与领导对话，并必定能取得理想的效果。淡化后果，充满自信，紧张就不会缠绕你了。</p><hr><p>本文链接：<a href="http://www.sguotao.top/生活感悟-2017-08-17-怎样和领导谈话.html">http://www.sguotao.top/生活感悟-2017-08-17-怎样和领导谈话.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;与领导相处，只要永远记住一句话：&lt;strong&gt;真理不是争来的。做一个好助手，就要学会经常批评自己，这样，你才能真正的成熟。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;怎样和领导谈话&quot;&gt;&lt;a href=&quot;#怎样和领导谈话&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的异步消息处理机制</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2017-06-17-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html"/>
    <id>http://www.sguotao.top/Android进阶-2017-06-17-分析Android中的异步消息处理机制.html</id>
    <published>2017-06-17T02:27:04.000Z</published>
    <updated>2017-08-10T10:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android中已经封装好，供我们直接使用的异步消息处理机制主要包括以下几种:Handler消息循环机制，AsyncTask，HandlerThread和IntentService。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler是Android中引入的一种处理线程中消息循环的机制。每个Hanlder都关联了一个线程，每个线程内部都维护了一个消息队列MessageQueue。在创建一个Handler的时候，该Handler就绑定了当前创建Hanlder的线程。Handler通过发送、处理Message和Runnable对象来关联相对应线程的MessageQueue。总结起来，Handler主要有以下两个作用:</p><ol><li>可以让对应的Message和Runnable在未来的某个时间点进行相应处理；</li><li>自己想要处理的耗时操作放在子线程，让更新UI的操作放在主线程。</li></ol><h3 id="Handler的使用方法"><a href="#Handler的使用方法" class="headerlink" title="Handler的使用方法"></a>Handler的使用方法</h3><h4 id="post-Runnable"><a href="#post-Runnable" class="headerlink" title="post(Runnable)"></a>post(Runnable)</h4><p>先看一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TextView tvContent;</span><br><span class="line">    <span class="comment">//创建mHandler在主线程，mHandler自动绑定主线程</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tvContent = (TextView) <span class="keyword">this</span>.findViewById(R.id.textView);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> DownloadThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Log.i(<span class="string">"scott"</span>, <span class="string">"Download Thread id:"</span> + Thread.currentThread().getId());</span><br><span class="line">                Log.i(<span class="string">"scott"</span>, <span class="string">"start download..."</span>);</span><br><span class="line">                <span class="comment">//执行耗时操作</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                Log.i(<span class="string">"scott"</span>, <span class="string">"download completed..."</span>);</span><br><span class="line"></span><br><span class="line">                Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Log.i(<span class="string">"scott"</span>, <span class="string">"Handler Thread id:"</span> Thread.currentThread().getId());</span><br><span class="line">                        MainActivity.<span class="keyword">this</span>.tvContent.setText(<span class="string">"Download complete!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                mHandler.post(runnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下使用post(Runnable)的步骤:</p><ol><li>创建Handler对象；</li><li>调用Handler的post（Runnable）方法；</li></ol><h4 id="sendMessage-message）"><a href="#sendMessage-message）" class="headerlink" title="sendMessage(message）"></a>sendMessage(message）</h4><p>先看一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_UPDATE_UI = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_UPDATE_UI:</span><br><span class="line">                    tvContent.setText(<span class="string">"Hello Scott!"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView tvContent;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tvContent = (TextView) <span class="keyword">this</span>.findViewById(R.id.textView);</span><br><span class="line"></span><br><span class="line">        Message message = mHandler.obtainMessage();</span><br><span class="line">        message.what = MSG_UPDATE_UI;</span><br><span class="line">        message.obj = <span class="string">"Hello Scott!"</span>;</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下使用Handler发送消息处理消息的步骤:</p><ol><li>创建Handler的对象，重写Handler的handleMessage()方法，根据Message的what来区分消息的种类；</li><li>创建Message对象，通过Message.obtain()或Handler.obtainMessage()来获得一个Message对象；</li><li>设置Message消息种类和消息内容，通过Message.what设置一个自定义的Message的识别码，以便于在Handler的handleMessage方法中根据what识别出不同的Message。消息内容可以通过Message的两个成员变量arg1和arg2来携带两个int数据，也可以通过Message的ob成员变量携带Object类型的数据。</li><li>通过Handler.sendMessage(Message)方法将Message传入Handler中让其在handleMessage中对其进行处理。 </li></ol><h3 id="Handler的机制原理"><a href="#Handler的机制原理" class="headerlink" title="Handler的机制原理"></a>Handler的机制原理</h3><p>Handler消息循环机制中几个比较重要的类:Handler,Looper,Message,MessageQueue。类图关系如下:<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170810150234628931736.png" alt="20170810150234628931736.png"><br>查看Handler的构造方法，在创建Handler时，如果没有显示指定Looper，会通过Looper的myLooper()方法获取Looper对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而Looper的myLooper()方法中获取的Looper对象在Looper的prepare()方法中创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到此完成了Handler与Looper的关联，再看一下MessageQueue，在Handler中的成员变量mQueue实际就是Looper中的mQueue，这一点可以在Handler的构造方法中看出。而Looper的mQueue和mThread在构造方法中完成了初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">       mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">       mThread = Thread.currentThread();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>整个消息循环队列的处理机制，可以用下面一张图来表示:<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170810150234630697981.png" alt="20170810150234630697981.png"><br>由于Handler的post(Runnable)底层实现也是通过sendMessage的方式实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因此图中统一表述为Message的方式，首先Handler通过sendMessage()方法，将消息放入消息队列MessageQueue中，通过Looper的loop方法进行不断的轮训。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">       <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">       <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">       Binder.clearCallingIdentity();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">           <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">               logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                       msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">           <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">               Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               msg.target.dispatchMessage(msg);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                   Trace.traceEnd(traceTag);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">               logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">           <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">           <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">               Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                       + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                       + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                       + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                       + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.recycleUnchecked();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过MessageQueue的next()方法，不断取出队列中的Message，交给Handler的dispatchMessage()方法进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Handler引起的内存泄露问题以及解决办法"><a href="#Handler引起的内存泄露问题以及解决办法" class="headerlink" title="Handler引起的内存泄露问题以及解决办法"></a>Handler引起的内存泄露问题以及解决办法</h3><p>引起内存泄露的原因是:非静态内部类持有外部类的匿名引用，导致外部类无法释放；常见的场景是在Handler的handleMessage()方法中持有了外部Actiivity的引用。</p><p>解决办法:</p><ol><li>将Handler改为静态内部类，Handler内部持有外部Activity的弱引用;</li><li>在退出Ativity时，调用Handler的removeCallback()方法。</li></ol><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask本质上说是一个封装了线程池和Handler的异步框架。</p><h3 id="AsyncTask的使用方法"><a href="#AsyncTask的使用方法" class="headerlink" title="AsyncTask的使用方法"></a>AsyncTask的使用方法</h3><p>在使用AsyncTask时，要先了解AsyncTask的“三个参数和五个方法”。这三个参数是在创建AsyncTask时需要使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Params</span> 表示用于AsyncTask执行任务的参数的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Progress</span> 表示在后台线程处理任务的进度。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Result</span> 表示任务全部完成后所返回的数据类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五个方法分别是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onPreExecute()方法是运行在主线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInBackground</span><span class="params">(Params... params)</span></span>;</span><br></pre></td></tr></table></figure><p>doInBackground()方法运行在工作线程，主要用于执行一些耗时操作，该方法接受Params类型的参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>onPostExecute()方法运行在主线程，doInBackground()执行完成后，会将执行的结果作为参数传递给onPostExecute()方法，参数类型是Result。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>onProgressUpdate()方法运行在主线程，doInBackground()在执行过程中，会将任务执行的进度通过publishProgress()方法，传递到onProgressUpdate()方法，进度值的类型是Progress。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">    onCancelled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>onCancelled()方法运行在主线程。<br>示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by scott on 17/6/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateInfoTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">private</span> ProgressBar mProgressBar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UpdateInfoTask</span><span class="params">(TextView textView, ProgressBar progressBar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.mTextView = textView;</span><br><span class="line">        <span class="keyword">this</span>.mProgressBar = progressBar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != mTextView) &#123;</span><br><span class="line">            mTextView.setText(<span class="string">"开始执行异步线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            publishProgress(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + params[<span class="number">0</span>].intValue() + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != mTextView) &#123;</span><br><span class="line">            mTextView.setText(<span class="string">"异步线程执行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != mProgressBar) &#123;</span><br><span class="line">            mProgressBar.setProgress(values[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AsyncTask的机制原理"><a href="#AsyncTask的机制原理" class="headerlink" title="AsyncTask的机制原理"></a>AsyncTask的机制原理</h3><ol><li>AsyncTask的本质上是一个静态的线程池，AsyncTask派生的子类可以实现不同的异步任务，这些任务都是提交到静态的线程池中执行；</li><li>线程池中的工作线程执行doInBackground(mParams)方法执行异步任务；</li><li>当任务状态改变之后，工作线程会向UI线程发送消息，AsyncTask内部的InternalHandler响应这些消息，并调用相关的回调函数。</li></ol><h3 id="AsyncTask的注意事项"><a href="#AsyncTask的注意事项" class="headerlink" title="AsyncTask的注意事项"></a>AsyncTask的注意事项</h3><ol><li>内存泄露，与Handler类似，当AsyncTask的子类被声明成非静态内部类，当持有外部类的引用时，就有可能会出现内存泄露。</li><li>生命周期(AsyncTask并不会随着Activity的销毁而销毁)，在Activity退出时需要调用AsyncTask的cancel()方法。</li><li>结果丢失，主要与Activity的生命周期有关，如屏幕旋转或由于内存不足导致Activity被回收时，之前创建的AsyncTask会持有被销毁的Activity的引用，此时在AsyncTask的onPostExecute()更新界面可能不会生效。</li><li>并行or串行，在Android1.6之前AsyncTask是串行的，在Android1.6-Android2.3改为并行，在Android2.3之后，又改回串行。可以通过AsyncTask的executeOnExecutor()方法执行并行，虽然并行的效率较高，建议使用串行，保持线程池的稳定。</li></ol><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>通常在Thread中使用Handler大致要经历以下三个过程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Looper threadLooper;</span><br><span class="line">     <span class="keyword">public</span> Handler threadHandler;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>.run();</span><br><span class="line">         <span class="comment">//1.调用Looper.prepare 创建与当前线程绑定的Looper实例</span></span><br><span class="line">         threadLooper.prepare();</span><br><span class="line">         <span class="comment">//2.使用上面创建的Looper生成Handler实例</span></span><br><span class="line">         threadHandler = <span class="keyword">new</span> Handler(threadLooper.myLooper());</span><br><span class="line">         <span class="comment">//3.调用Looper.loop()实现消息循环</span></span><br><span class="line">         threadLooper.loop();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通常开启Thread子线程进行耗时操作，但是多次创建和销毁线程是很耗资源的。为了解决这样的问题，Android系统提供了HandlerThread。HandlerThread实际上是一个带有Looper的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mTid = Process.myTid();</span><br><span class="line">       Looper.prepare();</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           mLooper = Looper.myLooper();</span><br><span class="line">           notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">       Process.setThreadPriority(mPriority);</span><br><span class="line">       onLooperPrepared();</span><br><span class="line">       Looper.loop();</span><br><span class="line">       mTid = -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>查看HandlerThread的源码，会发现HandlerThread对以前在Thread中使用Handler的方式进行了封装,在获取Looper对象时使用了阻塞唤醒机制，保证了获取的Looper对象不会为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(name);</span><br><span class="line">       mPriority = priority;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在创建HandlerThread时，可以设置线程的优先级，线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。</p><h3 id="HandlerThread的特点"><a href="#HandlerThread的特点" class="headerlink" title="HandlerThread的特点"></a>HandlerThread的特点</h3><ol><li>HandlerThread本质上是一个线程类，它继承了Thread；</li><li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li><li>通过获取HandlerThread的Looper对象传递给Handler对象，<strong>可以在HandleMessage方法中执行异步任务</strong>。Handler内部的Looper默认绑定的是UI线程的Looper，通过设置HandlerThread的Looper，Handler就可以处理非UI线程的消息队列中的消息。</li><li>优点是不会有堵塞，减少了对性能的消耗，缺点是不能同时进行多任务的处理，需要等待进行处理，处理效率较低；</li><li>与线程池注重并发不同，HandlerThread是一个串行队列，HandlerThread背后只有一个线程。</li></ol><p>HandlerThread示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        UpdateThread updateThread = <span class="keyword">new</span> UpdateThread(<span class="string">"handler-thread"</span>);</span><br><span class="line">        updateThread.start();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(updateThread.getLooper());</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//耗时操作，不会阻塞主线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UpdateThread</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UpdateThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是继承并处理异步请求的一个类，它本质是就是封装了HandlerThread和Handler异步框架。<br>在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方法和启动传统Service一样，同时，当任务执行完成后，IntentService会自动停止，而不需要我们手动去控制或stopSelf()。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个。总结一下:</p><ol><li>它本质是一种特殊的Service，继承自Service并且本身就是一个抽象类；</li><li>它内部通过HandlerThread和Handler实现异步操作。</li></ol><h3 id="IntentService的使用方法"><a href="#IntentService的使用方法" class="headerlink" title="IntentService的使用方法"></a>IntentService的使用方法</h3><p>创建IntentService时，只需实现onHandleIntent和构造方法，onHandleIntent为异步方法，可以执行耗时操作。参考示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by scott on 17/6/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadImageIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadImageIntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//耗时操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/reference/android/os/Handler.html" target="_blank" rel="noopener">Handler</a><br><a href="https://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="noopener">AsyncTask</a></p><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2017-06-17-分析Android中的异步消息处理机制.html">http://www.sguotao.top/Android进阶-2017-06-17-分析Android中的异步消息处理机制.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android中已经封装好，供我们直接使用的异步消息处理机制主要包括以下几种:Handler消息循环机制，AsyncTask，HandlerThread和IntentService。&lt;/p&gt;
&lt;h2 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; clas
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="Handler" scheme="http://www.sguotao.top/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>分析HTTPS协议</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2017-06-04-%E5%88%86%E6%9E%90HTTPS%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://www.sguotao.top/Android进阶-2017-06-04-分析HTTPS协议.html</id>
    <published>2017-06-04T02:27:04.000Z</published>
    <updated>2017-08-09T03:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><blockquote><p>是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p></blockquote><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170809150224326682630.png" alt="20170809150224326682630.png"><br>Https并不是一个单独的协议，而是对工作在一加密连接（SSL/TLS）上的常规Http协议。通过在TCP和HTTP之间加入TLS（Transport Layer Security）来加密。Https实际就是在TCP层与Http层之间加入了SSL/TLS来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</p><h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p>HTTPS和HTTP的区别主要为以下几点：</p><ol><li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li><li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。由于HTTPS要进行加密处理，所有传输速度比HTTP慢。</li></ol><h2 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h2><p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</p><h3 id="SSL协议的作用"><a href="#SSL协议的作用" class="headerlink" title="SSL协议的作用"></a>SSL协议的作用</h3><ol><li>认证用户和服务器，确保数据发送到正确的客户机和服务器;</li><li>加密数据以防止数据中途被窃取;</li><li>维护数据的完整性，确保数据在传输过程中不被改变。</li></ol><h3 id="SSL协议的工作过程"><a href="#SSL协议的工作过程" class="headerlink" title="SSL协议的工作过程"></a>SSL协议的工作过程</h3><p><strong>服务器认证阶段:</strong></p><ol><li>客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；</li><li>服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；</li><li>客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</li><li>服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</li></ol><p><strong>用户认证阶段:</strong><br>在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p><h2 id="TLS-SSL握手"><a href="#TLS-SSL握手" class="headerlink" title="TLS/SSL握手"></a>TLS/SSL握手</h2><p>SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170809150224484346357.png" alt="20170809150224484346357.png"></p><p>1.客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p><p>2.服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p><p>3.客户利用服务器传过来的信息验证服务器的合法性，<strong>服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。</strong>如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行下一步。</p><p>用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤2中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p><p>如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。</p><p>如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，<strong>具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。</strong>检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p><p>服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p><p>客户端向服务器端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p><p>4.服务器向客户端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p><p>5.SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p><h2 id="Https加密算法相关"><a href="#Https加密算法相关" class="headerlink" title="Https加密算法相关"></a>Https加密算法相关</h2><h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>密钥是一种参数，它是在使用密码算法过程中输入的参数，同一个明文在相同的密码算法和不同的密钥计算下会产生不同的密文。</p><h3 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h3><p>又称共享密钥加密，对称密钥在加密和解密的过程中使用的密钥是相同的，常见的对称加密算法有DES、3DES、AES、RC5、RC6.</p><p>优点是计算速度快，缺点是密钥需要在通讯的两端共享。</p><h3 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h3><p>又称为公开密钥加密。服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公钥可以自由发布，供任何人使用。</p><p>与对称密钥加密相比，非对称加密无需在客户端和服务端之间共享密钥，只要私钥不发给任何用户，即使公钥在网上被截获，也无法被解密，仅有被窃取的公钥是没有任何用处的。</p><h3 id="RSA加密过程"><a href="#RSA加密过程" class="headerlink" title="RSA加密过程"></a>RSA加密过程</h3><p>RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。</p><p>RSA加密过程:</p><ol><li>服务端生成配对的公钥和私钥；</li><li>私钥保存在服务端，公钥发送给客户端；</li><li>客户端使用公钥加密明文传输给服务端；</li><li>服务端使用私钥解密密文得到明文；</li></ol><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>就是互联网通讯中标志通讯各方身份信息的一串数字。数字证书解决的问题，就是保证现在使用的公钥就是真实服务器发送给我们的。</p><p>数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的。</p><h2 id="数字签名和CA"><a href="#数字签名和CA" class="headerlink" title="数字签名和CA"></a>数字签名和CA</h2><p>数据在浏览器和服务器之间传输时，如何保证数据传输是真实服务器发送的而不是被掉包的？同时，如何保证传输的数据没有被人篡改？</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名就是用于验证传输的内容是不是真实服务器发送的数据，发送的数据有没有被篡改过，是非对称加密的一种应用场景，不过他是反过来用私钥加密，通过与之配对的公钥来解密。</p><p>数字签名的过程:</p><ol><li>服务端把报文经过Hash处理后生成摘要信息Digest，摘要信息使用私钥private-key加密之后就生成签名，服务器把签名连同报文一起发送给客户端。</li><li>客户端接收到数据后，把签名提取出来用公钥public-key解密，如果能正常的解密出来Digest2，那么就能确认是对方发送的。</li><li>客户端把报文Text提取出来做同样的Hash处理，得到的摘要信息Digest1，再与之前解密出来的Digest2对比。如果一致，则文本内容没有被修改过。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本传输安全协议</a><br><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" target="_blank" rel="noopener">数字证书</a></p><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2017-06-04-分析HTTPS协议.html">http://www.sguotao.top/Android进阶-2017-06-04-分析HTTPS协议.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Https&quot;&gt;&lt;a href=&quot;#Https&quot; class=&quot;headerlink&quot; title=&quot;Https&quot;&gt;&lt;/a&gt;Https&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="Http" scheme="http://www.sguotao.top/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>分析TCP/IP参考模型</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2017-06-03-%E5%88%86%E6%9E%90TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.html"/>
    <id>http://www.sguotao.top/Android进阶-2017-06-03-分析TCP-IP网络模型.html</id>
    <published>2017-06-03T02:27:04.000Z</published>
    <updated>2017-08-08T08:47:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP/IP模型各个层次分别对应于不同的协议。TCP/IP协议栈是数据通信协议的集合 ，包含许多协议。其协议栈名字来源于其中最主要的两个协议TCP（传输控制协议）和IP（网际协议）。TCP/IP协议栈负责确保网络设备之间能够通信。它是一组规则，规定了信息如何在网络中传输。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017080815021784897401.png" alt="2017080815021784897401.png"></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层功能:</p><ul><li>规定介质类型、接口类型、信令类型；</li><li>规范在终端系统之间激活、维护和关闭物理链路的电气、机械、流程和功能等方面的要求；</li><li>规范电平、数据速率、最大传输距离和物理接头等特征。</li></ul><p>物理层介质：</p><ul><li>同轴电缆（coaxical cable）</li><li>双绞线（twisted pair）</li><li>光纤（fiber）</li><li>无线电波（wireless raido）</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层协议规定了数据链路层帧的封装方式。数据链路层又分为MAC子层和LLC子层:</p><ul><li>MAC子层负责指定数据如何通过物理线路进行传输，并向下与物理层通信，它定义了物理编址、网络拓扑、线路规范、错误通知、按序传递和流量控制等功能。</li><li>LLC子层负责识别协议类型并对数据进行封装以便通过网络进行传输。LLC子层主要执行数据链路层的大部分功能和网络层的部分功能。如帧的收发功能，在发送时，帧由发送的数据加上地址和CRC校验等构成，接收时将帧拆开，执行地址识别、CRC校验，并具有帧顺序控制、差错控制、流量控制等功能。此外，它还执行数据报、虚电路、多路复用等部分网络层的功能。</li></ul><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><p>网络设备的MAC地址是全球唯一的。MAC地址由48个二进制位组成，通常我们用十六进制数字来表示。其中前6位十六进制数字由IEEE统一分配给设备制造商，后6位十六进制数字由厂商自行分配。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>由于以太网采用广播方式发送数据包，效率比较低，也无法区分哪些MAC地址属于同一子网，引入网络层后，能够区分哪些MAC地址属于同一个子网络，使得我们能够区分不同的计算机是否属于同一个子网络，并且在不同的网络之间转发数据包。</p><p>网络层常用协议:</p><ul><li>IP（Internet Protocol）IP为网络层最主要的协议，其功能即为网络层的主要功能，一是提供逻辑编址，二是提供路由功能，三是报文的封装和解封装。ICMP、ARP、RARP协议辅助IP工作。</li><li>ICMP（Internet Control Message Protocol）是一个管理协议并为IP提供信息服务，ICMP消息承载在IP报文中。</li><li>ARP（Address Resolution Protocol）实现IP地址到硬件地址的动态映射，即根据已知的IP地址获得相应的硬件地址。</li><li>RARP（Reverse Address Resolution Protocol）实现硬件地址到IP地址的动态映射，即根据已知的硬件地址获得相应的IP地址。</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>当一个数据包从互联网上发来的时候，怎么确定是网页的内容，还是在线聊天的内容？传输层的功能，实现端口到端口的通信。</p><p>传输层主要功能：</p><ul><li>分段上层数据；</li><li>建立端到端连接；</li><li>将数据从一端主机传送到另一端主机；</li><li>保证数据按序、可靠、正确传输。</li></ul><p>传输层协议主要包含传输控制协议TCP（transfer control protocol）和用户数据报文协议UDP（user datagram protocol）:</p><ul><li>TCP提供面向连接的、可靠的字节流服务。面向连接意味着使用TCP协议作为传输层协议的两个应用之间在相互交换数据之前必须建立一个TCP连接。TCP通过确认、校验、重组等机制为上层应用提供可靠的传输服务。但是TCP连接的建立以及确认、校验等机制都需要耗费大量的工作并且会带来大量的开销。</li><li>UDP提供简单的、面向数据报的服务。UDP不保证可靠性，即不保证报文能够到达目的地。UDP适用于更关注传输效率的应用，如SNMP、Radius等，SNMP监控网络并断续发送告警等消息，如果每次发送少量信息都需要建立TCP连接，无疑会降低传输效率，所以诸如SNMP、Radius等更注重传输效率的应用程序都会选择UDP作为传输层协议。另外，UDP还适用于本身具备可靠性机制的应用层协议。</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层主要功能:</p><ul><li>规定应用程序的数据格式。</li><li>为用户提供接口、处理特定的应用；</li><li>数据加密、解密、压缩、解压缩；</li><li>定义数据表示的标准。</li></ul><p>应用层的协议包括:</p><ul><li>FTP(File TransferProtocol) 文件传输协议。用于传输独立的文件，通常用于交互式用户会话。</li><li>HTTP(HypertextTransfer Protocol)超文本传输协议。 用于传输那些构成万维网上的页面的文件。</li><li>TELNET ：远程终端访问。用于传送具有TELNET控制信息的数据。它提供了与终端设备或终端进程交互的标准方法，支持终端到终端的连接及进程到进程分布式计算的通信。</li><li>SMTP(Simple MessageTransfer Protocol)简单邮件传输协议</li><li>POP3(Post OfficeProtocol)邮局协议用于发送和接收邮件。</li><li>DNS(Domain NameServer)是一个域名服务的协议，提供域名到IP地址的转换，允许对域名资源进行分散管理。</li><li>TFTP(Trivial FileTransfer Protocol)简单文件传输协议。设计用于一般目的的、高吞吐量的文件传输。</li><li>RIP(RoutingInformation Protocol)路由器用来在 IP 网络上交换路由信息的协议。</li><li>SNMP(Simple NetworkManagement Protocol)用于收集网络管理信息，并在网络管理控制台和网络设备（例如路由器、网桥和服务器）之间交换网络管理信息。</li><li>Radius(RemoteAuthentication Dial In User Service)拨号接入远端认证协议完成接入用户的认证、授权、计费功能的协议。</li></ul><h2 id="TCP-IP模型层间数据封装与解析过程"><a href="#TCP-IP模型层间数据封装与解析过程" class="headerlink" title="TCP/IP模型层间数据封装与解析过程"></a>TCP/IP模型层间数据封装与解析过程</h2><p>TCP/IP每一层都让数据得以通过网络进行传输，这些层之间使用PDU（协议数据单元）彼此交换信息，确保网络设备之间能够通信。数据封装的过程如图<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170808150217839042287.png" alt="20170808150217839042287.png"></p><ol><li>传输层数据中加入TCP报头后得到PDU被称为segment（数据段）；</li><li>数据段被传递给网络层，网络层添加IP报头得到的PDU被称为packet（数据包）；</li><li>数据包被传递到数据链路层，封装数据链路层报头得到的PDU被称为frame（数据帧）；</li><li>帧被转换为比特，通过网络介质传输。</li></ol><p>这种协议栈向下传递数据，并添加报头和报尾的过程称为封装，数据被封装并通过网络传输后，接收设备将删除添加的信息，并根据报头中的信息决定如何将数据沿协议栈上传给合适的应用程序，这个过程称为解封装。不同设备的对等层之间依靠封装和解封装来实现相互间的通信。数据解析的过程如图<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170808150217846881527.png" alt="20170808150217846881527.png"></p><h2 id="TCP-IP模型建立连接与断开连接"><a href="#TCP-IP模型建立连接与断开连接" class="headerlink" title="TCP/IP模型建立连接与断开连接"></a>TCP/IP模型建立连接与断开连接</h2><p>TCP/IP模型建立连接与断开连接过程如图<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170808150218203850506.png" alt="20170808150218203850506.png"></p><p> <strong>三次握手过程(建立连接)</strong></p><ol><li>请求端（通常也称为客户端）发送一个SYN段表示客户期望连接服务器端口，初始序列号为a。</li><li>服务器发回序列号为b的SYN段作为响应。同时设置确认序号为客户端的序列号加1（a+1）作为对客户端的SYN报文的确认。</li><li>客户端设置序列号为服务器端的序列号加1（b+1）作为对服务器端SYN报文段的确认。</li></ol><p><strong>四次挥手过程(断开连接)</strong></p><ol><li>请求端（通常也称为客户端）想终止连接则发送一个FIN段，序列号设置为a。</li><li>服务器回应一个确认序号为客户端的序列号加1（a+1）的ACK确认段，作为对客户端的FIN报文的确认。</li><li>服务器端向客户端发送一个FIN终止段（设置序列号为b，确认号为a+1）。</li><li>客户端返回一个确认报文（设置序列号为b+1）作为响应。</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>所提供的服务是用来将主机名和域名转换为IP地址的工作。</p><h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><p>递归:DNS服务器可使用其自身的资源记录信息缓存来应答查询，也可以代表请求客户机来查询或联系其他DNS服务器，以完全解析该名称，并随后将应答返回至客户机。</p><p>迭代:客户机自己也可尝试联系其他的DNS服务器来解析名称。如果客户机这么做，它会使用基于服务器应答的独立和附加的查询。</p><ol><li>在浏览器中输入域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系；</li><li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存</li><li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器；</li><li>如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析。</li><li>本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名（.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。</li><li>如果用的是转发模式，此DNS服务器就会把请求转至上一级DNS服务器，由上一级服务器进行解析。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="http://blog.jobbole.com/91515/" target="_blank" rel="noopener">TCP/IP协议栈及OSI参考模型详解</a><br>2.<a href="http://swiftlet.net/archives/1082" target="_blank" rel="noopener">TCP三次握手和四次挥手协议</a></p><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2017-06-03-分析TCP-IP网络模型.html">http://www.sguotao.top/Android进阶-2017-06-03-分析TCP-IP网络模型.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP/IP模型各个层次分别对应于不同的协议。TCP/IP协议栈是数据通信协议的集合 ，包含许多协议。其协议栈名字来源于其中最主要的两个协议TCP（传输控制协议）和IP（网际协议）。TCP/IP协议栈负责确保网络设备之间能够通信。它是一组规则，规定了信息如何在网络中传输。&lt;
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="Http" scheme="http://www.sguotao.top/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>分析HTTP协议</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2017-06-03-%E5%88%86%E6%9E%90HTTP%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://www.sguotao.top/Android进阶-2017-06-03-分析HTTP协议.html</id>
    <published>2017-06-03T02:27:04.000Z</published>
    <updated>2017-08-08T03:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓协议，是指指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。<br>Http协议，超文本传输协议(Http)是一种通信协议，它允许将超文本标记语言（HTML）文档从web服务器传送到客户端的浏览器。</p></blockquote><p>HTTP协议的最显著的两个特点:</p><ul><li>HTTP是构建于TCP/IP协议之上的协议，默认端口号是80。</li><li>HTTP是无连接无状态的协议。</li></ul><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170808150215936342753.png" alt="20170808150215936342753.png"></p><h3 id="请求行（Request-Line）"><a href="#请求行（Request-Line）" class="headerlink" title="请求行（Request Line）"></a>请求行（Request Line）</h3><p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。其中比较常用的请求方法是GET和POST。</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送。以用google搜索domety为例，Request格式如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span><br><span class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn/"</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line">Accept-Language: zh-cn  </span><br><span class="line">Accept-Encoding: gzip, deflate  </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span><br><span class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn"</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line">Connection: Keep-Alive  </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure><p>可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&amp;”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面的搜索domety为例，如果使用POST方式的话，格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1  </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span><br><span class="line">Referer: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn/"</span>&gt;</span>http://www.google.cn/<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line">Accept-Language: zh-cn  </span><br><span class="line">Accept-Encoding: gzip, deflate  </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span><br><span class="line">Host: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.cn"</span>&gt;</span>www.google.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line">Connection: Keep-Alive  </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r  </span><br><span class="line"></span><br><span class="line">hl=zh-CN&amp;source=hp&amp;q=domety</span><br></pre></td></tr></table></figure><p>可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。POST方式大多用于页面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用GET还是使用POST。</p><h4 id="GET-POST方法的区别"><a href="#GET-POST方法的区别" class="headerlink" title="GET/POST方法的区别"></a>GET/POST方法的区别</h4><ol><li>提交的数据，get提交的数据会在url链接中，以”?”的形式进行分割，post提交数据都放在http请求的body中。</li><li>提交的数据大小是否有限制，get有限制，post没有限制。</li><li>取得变量的值Request.QueryString &amp; Request.Form</li><li>安全问题，get提交方式有安全隐患。</li></ol><h3 id="请求头（Header）"><a href="#请求头（Header）" class="headerlink" title="请求头（Header）"></a>请求头（Header）</h3><p>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p><p><strong>User-Agent</strong>：产生请求的浏览器类型。<br><strong>Accept</strong>：客户端可识别的内容类型列表。<br><strong>Host</strong>：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。</p><h3 id="空行（Blank-Line）"><a href="#空行（Blank-Line）" class="headerlink" title="空行（Blank Line）"></a>空行（Blank Line）</h3><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><h3 id="请求数据（Request-Body）"><a href="#请求数据（Request-Body）" class="headerlink" title="请求数据（Request-Body）"></a>请求数据（Request-Body）</h3><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><p>HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：状态行、响应头(Response Header)和响应正文。<br>状态行由协议版本、数字形式的状态码、及相应的状态描述，各元素之间以空格分隔。</p><p>常见的状态码有如下几种：</p><ul><li>200 OK 客户端请求成功</li><li>301 Moved Permanently 请求永久重定向</li><li>302 Moved Temporarily 请求临时重定向</li><li>304 Not Modified 文件未修改，可以直接使用缓存的文件。</li><li>400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。</li><li>401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li><li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li><li>500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。</li><li>503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li></ul><h2 id="Http协议中容易混淆的知识点"><a href="#Http协议中容易混淆的知识点" class="headerlink" title="Http协议中容易混淆的知识点"></a>Http协议中容易混淆的知识点</h2><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>URI：Uniform Resource Identifier,统一资源标识符，用来唯一的标识一个资源。</p><p>URI的三个组成部分:</p><ol><li>访问资源的命名机制；</li><li>存放资源的主机名；</li><li>资源自身的名称，由路径表示，着重强调资源。</li></ol><p>URL:Uniform Resource Locator，统一资源定位器，它是一种具体的URI，即URL可以标识一个资源，而且还指明了如何locate这个资源。</p><p>URL的三个组成部分：</p><ol><li>协议</li><li>存有该资源的主机IP地址</li><li>主机资源的具体地址；</li></ol><h3 id="http1-1-http1-0的区别"><a href="#http1-1-http1-0的区别" class="headerlink" title="http1.1/http1.0的区别"></a>http1.1/http1.0的区别</h3><ol><li><p>http1.0产生的背景<br>超文本传输协议（HyperText Transfer Protocol）伴随着计算机网络和浏览器的诞生，Http1.0也随之而来，处于计算机网络中的应用层。</p></li><li><p>http1.0所做的优化<br>带宽:现阶段已经解决<br>延迟：<br> 1.浏览器阻塞：浏览器对于同一个域名，同时只能有4个连接；<br> 2.DNS查询：浏览器需要知道目标服务器的IP才能建立连接<br> 3.建立连接: 3次握手</p></li><li><p>http1.1/http1.0的具体区别<br> a. 缓存处理，Http1.1引入了更多的缓存策略；<br> b. 带宽优化及网络连接的使用，Http1.1在请求头中添加了range，可以请求资源的某个部分。<br> c. Host头处理，Http1.1请求消息和响应消息都支持Host的改进，在请求中如果没有Host域会报400错误。<br> d. 长连接，Http1.1支持长连接，减少每次请求都需要建立和关闭连接的消耗。</p></li><li><p>http1.1和http1.0存在的问题<br> a. Http1.0在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间；<br> b. Http1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份；<br> c. Http1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本；<br> d. 虽然Http1.1支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务器带来大量的性能压力。</p></li></ol><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><p>Cookie技术是客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。</p><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。</p><p>Session的工作原理：</p><ol><li>创建Session</li><li>在创建了Session的同时，服务器会为该Session生成唯一的Session id；</li><li>在Session被创建后，就可以调用Session相关的方法在Session中增加内容；</li><li>当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session </li></ol><p>Session和Cookie的区别：</p><ol><li>存放位置不同；Session保存在服务端，Cookie保存在客户端；</li><li>存取方式不同；Session能存取任意类型的数据，Cookie只能保存字符串；</li><li>安全性（隐私策略）不同</li><li>有效期上的不同</li><li>对服务器造成的压力不同</li></ol><h2 id="附录1-HTTP请求报文请求头Header字段说明"><a href="#附录1-HTTP请求报文请求头Header字段说明" class="headerlink" title="附录1 HTTP请求报文请求头Header字段说明"></a>附录1 HTTP请求报文请求头Header字段说明</h2><table><thead><tr><th style="text-align:center">Header字段</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">Accept</td><td style="text-align:center">指定客户端能够接收的内容类型</td><td style="text-align:center">Accept: text/plain, text/html</td></tr><tr><td style="text-align:center">Accept-Charset</td><td style="text-align:center">浏览器可以接受的字符编码集。</td><td style="text-align:center">Accept-Charset: iso-8859-5</td></tr><tr><td style="text-align:center">Accept-Encoding</td><td style="text-align:center">指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><td style="text-align:center">Accept-Encoding: compress, gzip</td></tr><tr><td style="text-align:center">Accept-Language</td><td style="text-align:center">浏览器可接受的语言</td><td style="text-align:center">Accept-Language: en,zh</td></tr><tr><td style="text-align:center">Accept-Ranges</td><td style="text-align:center">可以请求网页实体的一个或者多个子范围字段</td><td style="text-align:center">Accept-Ranges: bytes</td></tr><tr><td style="text-align:center">Authorization</td><td style="text-align:center">HTTP授权的授权证书</td><td style="text-align:center">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">指定请求和响应遵循的缓存机制</td><td style="text-align:center">Cache-Control: no-cache</td></tr><tr><td style="text-align:center">Connection</td><td style="text-align:center">表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><td style="text-align:center">Connection: close</td></tr><tr><td style="text-align:center">Cookie</td><td style="text-align:center">HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><td style="text-align:center">Cookie: $Version=1; Skin=new;</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:center">请求的内容长度</td><td style="text-align:center">Content-Length: 348</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">请求的与实体对应的MIME信息</td><td style="text-align:center">Content-Type: application/x-www-form-urlencoded</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">请求发送的日期和时间</td><td style="text-align:center">Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td style="text-align:center">Expect</td><td style="text-align:center">请求的特定的服务器行为</td><td style="text-align:center">Expect: 100-continue</td></tr><tr><td style="text-align:center">From</td><td style="text-align:center">发出请求的用户的Email</td><td style="text-align:center">From: user@email.com</td></tr><tr><td style="text-align:center">Host</td><td style="text-align:center">指定请求的服务器的域名和端口号</td><td style="text-align:center">Host: www.zcmhi.com</td></tr><tr><td style="text-align:center">If-Match</td><td style="text-align:center">只有请求内容与实体相匹配才有效</td><td style="text-align:center">If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:center">If-Modified-Since</td><td style="text-align:center">如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td><td style="text-align:center">If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td style="text-align:center">If-None-Match</td><td style="text-align:center">如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><td style="text-align:center">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:center">If-Range</td><td style="text-align:center">如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><td style="text-align:center">If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:center">If-Unmodified-Since</td><td style="text-align:center">只在实体在指定时间之后未被修改才请求成功</td><td style="text-align:center">If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td style="text-align:center">Max-Forwards</td><td style="text-align:center">限制信息通过代理和网关传送的时间</td><td style="text-align:center">Max-Forwards: 10</td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">用来包含实现特定的指令</td><td style="text-align:center">Pragma: no-cache</td></tr><tr><td style="text-align:center">Proxy-Authorization</td><td style="text-align:center">连接到代理的授权证书</td><td style="text-align:center">Proxy-Authorization: BasicQWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td style="text-align:center">Range</td><td style="text-align:center">只请求实体的一部分，指定范围</td><td style="text-align:center">Range: bytes=500-999</td></tr><tr><td style="text-align:center">Referer</td><td style="text-align:center">先前网页的地址，当前请求网页紧随其后,即来路</td><td style="text-align:center">Referer: <a href="http://www.zcmhi.com/archives/71.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/71.html</a></td></tr><tr><td style="text-align:center">TE</td><td style="text-align:center">客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><td style="text-align:center">TE: trailers,deflate;q=0.5</td></tr><tr><td style="text-align:center">Upgrade</td><td style="text-align:center">向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><td style="text-align:center">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td style="text-align:center">User-Agent</td><td style="text-align:center">User-Agent的内容包含发出请求的用户信息</td><td style="text-align:center">User-Agent: Mozilla/5.0 (Linux; X11)</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">通知中间网关或代理服务器地址，通信协议</td><td style="text-align:center">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">关于消息实体的警告信息</td><td style="text-align:center">Warn: 199 Miscellaneous warning</td></tr></tbody></table><h2 id="附录2-HTTP响应报文响应头ResponseHeader字段说明"><a href="#附录2-HTTP响应报文响应头ResponseHeader字段说明" class="headerlink" title="附录2 HTTP响应报文响应头ResponseHeader字段说明"></a>附录2 HTTP响应报文响应头ResponseHeader字段说明</h2><table><thead><tr><th style="text-align:center">Header字段</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">Accept-Ranges</td><td style="text-align:center">表明服务器是否支持指定范围请求及哪种类型的分段请求</td><td style="text-align:center">Accept-Ranges: bytes</td></tr><tr><td style="text-align:center">Age</td><td style="text-align:center">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td><td style="text-align:center">Age: 12</td></tr><tr><td style="text-align:center">Allow</td><td style="text-align:center">对某网络资源的有效的请求行为，不允许则返回405</td><td style="text-align:center">Allow: GET, HEAD</td></tr><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">告诉所有的缓存机制是否可以缓存及哪种类型</td><td style="text-align:center">Cache-Control: no-cache</td></tr><tr><td style="text-align:center">Content-Encoding</td><td style="text-align:center">web服务器支持的返回内容压缩编码类型。</td><td style="text-align:center">Content-Encoding: gzip</td></tr><tr><td style="text-align:center">Content-Language</td><td style="text-align:center">响应体的语言</td><td style="text-align:center">Content-Language: en,zh</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:center">响应体的长度</td><td style="text-align:center">Content-Length: 348</td></tr><tr><td style="text-align:center">Content-Location</td><td style="text-align:center">请求资源可替代的备用的另一地址</td><td style="text-align:center">Content-Location: /index.htm</td></tr><tr><td style="text-align:center">Content-MD5</td><td style="text-align:center">返回资源的MD5校验值</td><td style="text-align:center">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td style="text-align:center">Content-Range</td><td style="text-align:center">在整个返回体中本部分的字节位置</td><td style="text-align:center">Content-Range: bytes 21010-47021/47022</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">返回内容的MIME类型</td><td style="text-align:center">Content-Type: text/html; charset=utf-8</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">原始服务器消息发出的时间</td><td style="text-align:center">Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td style="text-align:center">ETag</td><td style="text-align:center">请求变量的实体标签的当前值</td><td style="text-align:center">ETag: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:center">Expires</td><td style="text-align:center">响应过期的日期和时间</td><td style="text-align:center">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:center">请求资源的最后修改时间</td><td style="text-align:center">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr><tr><td style="text-align:center">Location</td><td style="text-align:center">用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td><td style="text-align:center">Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">包括实现特定的指令，它可应用到响应链上的任何接收方</td><td style="text-align:center">Pragma: no-cache</td></tr><tr><td style="text-align:center">Proxy-Authenticate</td><td style="text-align:center">它指出认证方案和可应用到代理的该URL上的参数</td><td style="text-align:center">Proxy-Authenticate: Basic</td></tr><tr><td style="text-align:center">refresh</td><td style="text-align:center">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td><td style="text-align:center">Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td style="text-align:center">Retry-After</td><td style="text-align:center">如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td><td style="text-align:center">Retry-After: 120</td></tr><tr><td style="text-align:center">Server</td><td style="text-align:center">web服务器软件名称</td><td style="text-align:center">Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td style="text-align:center">Set-Cookie</td><td style="text-align:center">设置Http Cookie    Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td></tr><tr><td style="text-align:center">Trailer</td><td style="text-align:center">指出头域在分块传输编码的尾部存在</td><td style="text-align:center">Trailer: Max-Forwards</td></tr><tr><td style="text-align:center">Transfer-Encoding</td><td style="text-align:center">文件传输编码</td><td style="text-align:center">Transfer-Encoding:chunked</td></tr><tr><td style="text-align:center">Vary</td><td style="text-align:center">告诉下游代理是使用缓存响应还是从原始服务器请求</td><td style="text-align:center">Vary: *</td></tr><tr><td style="text-align:center">Via</td><td style="text-align:center">告知代理客户端响应是通过哪里发送的</td><td style="text-align:center">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td style="text-align:center">Warning</td><td style="text-align:center">警告实体可能存在的问题</td><td style="text-align:center">Warning: 199 Miscellaneous warning</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:center">表明客户端请求实体应该使用的授权方案</td><td style="text-align:center">WWW-Authenticate: Basic</td></tr></tbody></table><h2 id="附录3-HTTP响应报文状态码"><a href="#附录3-HTTP响应报文状态码" class="headerlink" title="附录3 HTTP响应报文状态码"></a>附录3 HTTP响应报文状态码</h2><p><strong>1xx:信息</strong></p><style>table th:first-of-type {    width: 150px;}</style><table><thead><tr><th style="text-align:center">消息</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">100 Continue</td><td style="text-align:center">服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td></tr><tr><td style="text-align:center">101 Switching Protocols</td><td style="text-align:center">服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td></tr></tbody></table><p><strong>2xx:成功</strong></p><table><thead><tr><th style="text-align:center">消息</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">200 OK</td><td style="text-align:center">请求成功（其后是对GET和POST请求的应答文档。）</td></tr><tr><td style="text-align:center">201 Created</td><td style="text-align:center">请求被创建完成，同时新的资源被创建。</td></tr><tr><td style="text-align:center">202 Accepted</td><td style="text-align:center">供处理的请求已被接受，但是处理未完成。</td></tr><tr><td style="text-align:center">203 Non-authoritative Information</td><td style="text-align:center">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</td></tr><tr><td style="text-align:center">204 No Content</td><td style="text-align:center">没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td></tr><tr><td style="text-align:center">205 Reset Content</td><td style="text-align:center">没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td></tr><tr><td style="text-align:center">206 Partial Content</td><td style="text-align:center">客户发送了一个带有Range头的GET请求，服务器完成了它。</td></tr></tbody></table><p><strong>3xx:重定向</strong></p><table><thead><tr><th style="text-align:center">消息</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">300 Multiple Choices</td><td style="text-align:center">多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td></tr><tr><td style="text-align:center">301 Moved Permanently</td><td style="text-align:center">所请求的页面已经转移至新的url。</td></tr><tr><td style="text-align:center">302 Found</td><td style="text-align:center">所请求的页面已经临时转移至新的url。</td></tr><tr><td style="text-align:center">303 See Other</td><td style="text-align:center">所请求的页面可在别的url下被找到。</td></tr><tr><td style="text-align:center">304 Not Modified</td><td style="text-align:center">未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td></tr><tr><td style="text-align:center">305 Use Proxy</td><td style="text-align:center">客户请求的文档应该通过Location头所指明的代理服务器提取。</td></tr><tr><td style="text-align:center">306 Unused</td><td style="text-align:center">此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</td></tr><tr><td style="text-align:center">307 Temporary Redirect</td><td style="text-align:center">被请求的页面已经临时移至新的url。</td></tr></tbody></table><p><strong>4xx:客户端错误</strong></p><table><thead><tr><th style="text-align:center">消息</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">400 Bad Request</td><td style="text-align:center">服务器未能理解请求。</td></tr><tr><td style="text-align:center">401 Unauthorized</td><td style="text-align:center">被请求的页面需要用户名和密码。</td></tr><tr><td style="text-align:center">401.1</td><td style="text-align:center">登录失败。</td></tr><tr><td style="text-align:center">401.2</td><td style="text-align:center">服务器配置导致登录失败。</td></tr><tr><td style="text-align:center">401.3</td><td style="text-align:center">由于 ACL 对资源的限制而未获得授权。</td></tr><tr><td style="text-align:center">401.4</td><td style="text-align:center">筛选器授权失败。</td></tr><tr><td style="text-align:center">401.5</td><td style="text-align:center">ISAPI/CGI 应用程序授权失败。</td></tr><tr><td style="text-align:center">401.7</td><td style="text-align:center">访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</td></tr><tr><td style="text-align:center">402 Payment Required</td><td style="text-align:center">此代码尚无法使用。</td></tr><tr><td style="text-align:center">403 Forbidden</td><td style="text-align:center">对被请求页面的访问被禁止。</td></tr><tr><td style="text-align:center">403.1</td><td style="text-align:center">执行访问被禁止。</td></tr><tr><td style="text-align:center">403.2</td><td style="text-align:center">读访问被禁止。</td></tr><tr><td style="text-align:center">403.3</td><td style="text-align:center">写访问被禁止。</td></tr><tr><td style="text-align:center">403.4</td><td style="text-align:center">要求 SSL。</td></tr><tr><td style="text-align:center">403.5</td><td style="text-align:center">要求 SSL 128。</td></tr><tr><td style="text-align:center">403.6</td><td style="text-align:center">IP 地址被拒绝。</td></tr><tr><td style="text-align:center">403.7</td><td style="text-align:center">要求客户端证书。</td></tr><tr><td style="text-align:center">403.8</td><td style="text-align:center">站点访问被拒绝。</td></tr><tr><td style="text-align:center">403.9</td><td style="text-align:center">用户数过多。</td></tr><tr><td style="text-align:center">403.10</td><td style="text-align:center">配置无效。</td></tr><tr><td style="text-align:center">403.11</td><td style="text-align:center">密码更改。</td></tr><tr><td style="text-align:center">403.12</td><td style="text-align:center">拒绝访问映射表。</td></tr><tr><td style="text-align:center">403.13</td><td style="text-align:center">客户端证书被吊销。</td></tr><tr><td style="text-align:center">403.14</td><td style="text-align:center">拒绝目录列表。</td></tr><tr><td style="text-align:center">403.15</td><td style="text-align:center">超出客户端访问许可。</td></tr><tr><td style="text-align:center">403.16</td><td style="text-align:center">客户端证书不受信任或无效。</td></tr><tr><td style="text-align:center">403.17</td><td style="text-align:center">客户端证书已过期或尚未生效。</td></tr><tr><td style="text-align:center">403.18</td><td style="text-align:center">在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</td></tr><tr><td style="text-align:center">403.19</td><td style="text-align:center">不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</td></tr><tr><td style="text-align:center">403.20</td><td style="text-align:center">Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</td></tr><tr><td style="text-align:center">404 Not Found</td><td style="text-align:center">服务器无法找到被请求的页面。</td></tr><tr><td style="text-align:center">404.0</td><td style="text-align:center">（无）–没有找到文件或目录。</td></tr><tr><td style="text-align:center">404.1</td><td style="text-align:center">无法在所请求的端口上访问 Web 站点。</td></tr><tr><td style="text-align:center">404.2</td><td style="text-align:center">Web 服务扩展锁定策略阻止本请求。</td></tr><tr><td style="text-align:center">404.3</td><td style="text-align:center">MIME 映射策略阻止本请求。</td></tr><tr><td style="text-align:center">405 Method Not Allowed</td><td style="text-align:center">请求中指定的方法不被允许。</td></tr><tr><td style="text-align:center">406 Not Acceptable</td><td style="text-align:center">服务器生成的响应无法被客户端所接受。</td></tr><tr><td style="text-align:center">407 Proxy Authentication Required</td><td style="text-align:center">用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td></tr><tr><td style="text-align:center">408 Request Timeout</td><td style="text-align:center">请求超出了服务器的等待时间。</td></tr><tr><td style="text-align:center">409 Conflict</td><td style="text-align:center">由于冲突，请求无法被完成。</td></tr><tr><td style="text-align:center">410 Gone</td><td style="text-align:center">被请求的页面不可用。</td></tr><tr><td style="text-align:center">411 Length Required</td><td style="text-align:center">“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</td></tr><tr><td style="text-align:center">412 Precondition Failed</td><td style="text-align:center">请求中的前提条件被服务器评估为失败。</td></tr><tr><td style="text-align:center">413 Request Entity Too Large</td><td style="text-align:center">由于所请求的实体的太大，服务器不会接受请求。</td></tr><tr><td style="text-align:center">414 Request-url Too Long</td><td style="text-align:center">由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</td></tr><tr><td style="text-align:center">415 Unsupported Media Type</td><td style="text-align:center">由于媒介类型不被支持，服务器不会接受请求。</td></tr><tr><td style="text-align:center">416 Requested Range Not Satisfiable</td><td style="text-align:center">服务器不能满足客户在请求中指定的Range头。</td></tr><tr><td style="text-align:center">417 Expectation Failed</td><td style="text-align:center">执行失败。</td></tr><tr><td style="text-align:center">423</td><td style="text-align:center">锁定的错误。</td></tr></tbody></table><p><strong>5xx:服务端错误</strong></p><table><thead><tr><th style="text-align:center">消息</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">500 Internal Server Error</td><td style="text-align:center">请求未完成。服务器遇到不可预知的情况。</td></tr><tr><td style="text-align:center">500.12</td><td style="text-align:center">应用程序正忙于在 Web 服务器上重新启动。</td></tr><tr><td style="text-align:center">500.13</td><td style="text-align:center">Web 服务器太忙。</td></tr><tr><td style="text-align:center">500.15</td><td style="text-align:center">不允许直接请求 Global.asa。</td></tr><tr><td style="text-align:center">500.16</td><td style="text-align:center">UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。</td></tr><tr><td style="text-align:center">500.18</td><td style="text-align:center">URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。</td></tr><tr><td style="text-align:center">500.100</td><td style="text-align:center">内部 ASP 错误。</td></tr><tr><td style="text-align:center">501 Not Implemented</td><td style="text-align:center">请求未完成。服务器不支持所请求的功能。</td></tr><tr><td style="text-align:center">502 Bad Gateway</td><td style="text-align:center">请求未完成。服务器从上游服务器收到一个无效的响应。</td></tr><tr><td style="text-align:center">502.1</td><td style="text-align:center">CGI 应用程序超时。</td></tr><tr><td style="text-align:center">502.2</td><td style="text-align:center">CGI 应用程序出错。</td></tr><tr><td style="text-align:center">503 Service Unavailable</td><td style="text-align:center">请求未完成。服务器临时过载或当机。</td></tr><tr><td style="text-align:center">504 Gateway Timeout</td><td style="text-align:center">网关超时。</td></tr><tr><td style="text-align:center">505 HTTP Version Not Supported</td><td style="text-align:center">服务器不支持请求中指明的HTTP协议版本。</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html" target="_blank" rel="noopener">HTTP请求报文和HTTP响应报文</a><br><a href="https://baike.baidu.com/item/http" target="_blank" rel="noopener">HTTP百科</a></p><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2017-06-03-分析HTTP协议.html">http://www.sguotao.top/Android进阶-2017-06-03-分析HTTP协议.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;所谓协议，是指指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。&lt;br&gt;Http协议，超文本传输协议(Http)是一种通信协议，它允许将超文本标记语言（HTML）文档从web服务器传送到客户端的浏览器。&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="Http" scheme="http://www.sguotao.top/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>【转】程序员为什么会忧虑自己的未来?</title>
    <link href="http://www.sguotao.top/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2017-06-02-%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BF%A7%E8%99%91%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%AA%E6%9D%A5.html"/>
    <id>http://www.sguotao.top/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html</id>
    <published>2017-06-02T02:22:08.000Z</published>
    <updated>2018-02-24T04:36:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。</p></blockquote><a id="more"></a><p>文章作者:陈驰远，青橙科技CTO，互联网行业的一名老兵，以下是部分摘录。更多讨论，请戳原文。<br>原文链接:<a href="https://juejin.im/post/5930acd6a0bb9f0058af41e5" target="_blank" rel="noopener">https://juejin.im/post/5930acd6a0bb9f0058af41e5</a></p><p>从去年开始，我参加了一些分享交流，也对外发过一些自己对工作所遇问题的思考。不少程序员加我好友咨询问题，几乎每个人问的问题都跟职业规划有关。这提醒了我，其实我自己也一直在思考同样的问题并尝试规划未来。于是想和大家分享一下自己在这方面的感悟。</p><p>本文仅从我自己的角度来剖析对程序员职业规划的看法，并不全面。而下文中提到的程序员群体也泛指在一线具体执行编码任务的程序员，不包含一些高精尖技术岗位的专业技术人才或是已经有自己明确职业规划，已经进阶成功的工程师。</p><h2 id="什么引发了焦虑？"><a href="#什么引发了焦虑？" class="headerlink" title="什么引发了焦虑？"></a>什么引发了焦虑？</h2><p>互联网是一个新兴但高速发展的行业。新兴意味着没有那么多的职场楷模给新人指明方向，也没有一套公认的稳定可复制的职业发展路线。高速发展意味着变革与竞争，大量新人因为行业红利涌入，你无时无刻要跟一群优秀的热血青年同场竞技。</p><p>互联网行业工作强度很大，而中国的互联网从业者更忙。程序员更是战场中的排头兵，身体健康的透支导致很难长期抗战。当你意识到自己跟不上节奏的时候，不管是出于对身体状况的担忧，还是对未来潜在威胁的恐惧，又怎会不感到焦虑呢？而程序员的职业特性加剧了这种焦虑，主要表现在以下几方面：</p><h2 id="程序员职业复利性较低。"><a href="#程序员职业复利性较低。" class="headerlink" title="程序员职业复利性较低。"></a>程序员职业复利性较低。</h2><h3 id="什么叫复利性？"><a href="#什么叫复利性？" class="headerlink" title="什么叫复利性？"></a>什么叫复利性？</h3><p>就如同利息的计算方法一样，在本金相同的情况下，复利获得的利息回报要高于单利，而年期越长，复利效应越高。职业一样有复利效应，一个复利高的职业在职业生涯中后期会展现出越来越高的价值。医生、律师都是复利性很高的职业。而程序员职业复利性较低，主要有两个原因：</p><ul><li><strong>专业性强，通用性差。不同技术种类有着自己的技术栈，共用的只有设计思想、编程范式，基础技术等通用知识。</strong></li><li><strong>在没有明确规划的情况下，大多数程序员日常工作积累的不是通用知识与综合能力，而仅仅是某项技术的熟练度与经验。这是根本原因。</strong><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170602149637117527702.jpg" title="后端技术栈"><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170602149637119625879.jpg" title="前端技术栈">这造成了一个问题——当职业生涯遇到瓶颈时，程序员很难完成一次完美的进阶。让我们分析下最常见的三类方案：</li></ul><ol><li><p><strong>技术职位之间的转岗。</strong>这是最普遍的一种情况，Android转IOS，后端转前端等都在此列。虽然设计原则、编程范式等技术知识是通用的，但作为一线的执行者，技术的熟练度才是影响你工作效率的最大因素，你必须对技术栈非常熟悉才能体现工作的专业度。 转岗往往是无奈之举。</p></li><li><p><strong>技术转产品/运营岗。</strong>很多工程师抱怨产品经理设计的产品有问题，逻辑不严密，用起来很别扭。但让工程师做产品，问题一般会更多。为什么呢？最大的原因在于程序员的思维模式或多或少会受到编程的影响，偏向理性与具象化，缺少了感性的察言观色以及换位思考的能力。设计好一个产品，逻辑严密只是条件之一，但并不是最重要的条件。产品经理需要从用户的行为中挖掘出用户真正的需求，提炼归纳并设计成一个可用的产品。这是大多数程序员很难做好的事情。</p></li><li><p><strong>技术转管理岗。</strong>BAT都有自己的M岗位，高工都可以选择是继续走技术路线还是尝试走管理路线。很多程序员安慰自己，哪天真写不动代码了，那我就做技术经理吧。但我认为管理岗的转变比前面两类都难。管理是一门很深的学问，执行和管理是两回事，需要从根本上改变思维模式。评判一个工程师的好坏可以看工程师的产出，而评判一个管理者的好坏在于整个团队的产出和效率。很多优秀的程序员自己技术能力很强，却很难带领整个团体一起向前进。</p></li></ol><h2 id="程序员职业的壁垒没想象中高，鲁棒性低。"><a href="#程序员职业的壁垒没想象中高，鲁棒性低。" class="headerlink" title="程序员职业的壁垒没想象中高，鲁棒性低。"></a>程序员职业的壁垒没想象中高，鲁棒性低。</h2><p>鲁棒性也指抗变换性，一个好的职业需要有高的鲁棒性。大部分程序员把自己的职业与某项技能绑定。做过编程的都知道，一个高耦合低抽象的编码鲁棒性一定低。互联网行业变化太快，回头看下诺基亚的发展，Windows桌面应用开发，整个行业如同大浪淘沙。随着云平台的崛起，公有化平台的发展，API服务的开放，可以预见从业者的工作效率会大幅提高，同时很多职业可能会再次洗牌：基础运维工程师，DBA，基础算法工程师，安全工程师，图像算法工程师，数据工程师等等都在此列。</p><p>从另外一个角度来说，假设你运气很好，选择了一项长期热门的技术比如Web前端开发。但是因为行业红利太高，无数聪明、努力、上进的热血青年涌入其中。随着社区的发展，在线教育的普及，达到同样熟练度的时间越来越短，而热门互联网技术的发展是以月计，你需要花费大量的时间去学习积累新技术。新人与你的差距会越来越小，你会随时面临被超车的局面。这意味着，很多时候即使你认为自己经验更丰富，能力更强，但你却得不到理想的职位及薪资待遇。</p><h2 id="程序员职业能撬动的价值有限。"><a href="#程序员职业能撬动的价值有限。" class="headerlink" title="程序员职业能撬动的价值有限。"></a>程序员职业能撬动的价值有限。</h2><p>这个概念受启发于《格鲁夫给经理人的第一课》一书。格鲁夫试图定量的分析经理人的产出，于是提出了一个公式：经理人的产出 = 他直接管辖部门的产出 + 他间接影响所及部门的产出。为了定量的分析职业的价值，我也引入了一个公式：产出的价值 = 他自身的产出 + 他直接影响部门的产出 + 他间接影响所及部门的产出</p><p><strong>职业能影响的人越多，创造的价值越高，职业的上限价值也越高。</strong></p><p>互联网行业的供求关系以及价值体系，造成了一个现象：程序员供不应求使其入行薪资高，但是工作五年以上薪资趋向于稳定。对于绝大部分公司的绝大部分职位，当熟练度和经验达到某一个阈值的时候，选择成本是趋同的，自身效率提高所能带动的价值提高已经很有限。正因为如此，从业者在享受了薪资高速增长之后，很难接受薪资增幅趋缓，职业生涯遇到瓶颈引发焦虑。</p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017060214963712208098.jpg" title="[薪资待遇]"><h2 id="我的规划是什么？"><a href="#我的规划是什么？" class="headerlink" title="我的规划是什么？"></a>我的规划是什么？</h2><p>分析了这么多，我最想表达的意思是：所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。</p><p>首先我会分析自己的特点，这是建立与他人的差异性和自己独特标签的关键所在，也是最值得加强的地方。我最大的特点是什么？<br><strong>有野心。</strong>我不想选择一种得过且过的生活，而会选择一个产出价值更高的事情来做，影响更多的人，创造更高的价值。<br><strong>会沟通。</strong>我沟通能力不错，既可以对外谈合作，又可以对内做管理。这会是我相对一般技术型程序员一个很大的不同。<br><strong>专业强。</strong>在专业技能层面我有较深的认识与理解，虽然谈不上顶尖，但我知道怎么运用自己的知识能力找到最适合现状的方法解决几乎所有日常问题。技术积累永远是我最核心的竞争力。</p><p>知道自己特点之后，我会以此为基础来增强自己的不可替代性。不可替代性不仅仅只是基于个人的能力，还有这几点是需要日常注意积累的：<br><strong>健康的身体。</strong>在经历过一次生病后，我更加意识到拥有一个健康的身体才是最重要的。积极健身可是我们青橙员工的必备素质。<br><strong>思想与格局的高度。</strong>思想的高度并不是一朝一夕就能拔高的，而是在经历了来自工作与生活的各种挑战之后，静下心来反思总结，从而慢慢积累并提升。<br><strong>人脉与影响力。</strong>乐于记录和分享自己的工作感悟。抓住向其他人学习的机会，比如参加一些会议或交流，不管是同行业还是其他行业的，都是很有必要的。人脉和影响力的积累与格局的高度也是相辅相成的，与某些方面比自己优秀的人交流往往会收获满满。<br><strong>当我有了明确的方向并且每天都能看到自己进步的时候，就会对未来充满憧憬。</strong>我给自己未来的定位是做一名解决者。何谓解决者？面对未知或已知的问题，知道如何分析本质原因，制定并实施解决方案。附加打油诗一首：</p><blockquote><p>文能设计定需求，武可写码做架构。<br>进做招商引融资，退做大V占风口。<br>产品体验包上线，还要招人带节奏。</p></blockquote><hr><p>本文链接：<a href="http://www.sguotao.top/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html">http://www.sguotao.top/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.top/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【RN笔记】ReactNative Flex整理</title>
    <link href="http://www.sguotao.top/ReactNative-2017-05-17-rn-flex.html"/>
    <id>http://www.sguotao.top/ReactNative-2017-05-17-rn-flex.html</id>
    <published>2017-05-17T02:27:04.000Z</published>
    <updated>2017-06-08T10:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex容器属性</h2><ul><li><p><strong>flex-direction 属性决定主轴的方向（即项目的排列方向）。</strong></p><pre><code>row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。</code></pre></li><li><p><strong>flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</strong></p><pre><code>nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。</code></pre></li><li><p><strong>flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</strong></p></li><li><p><strong>justify-content 属性定义了项目在主轴上的对齐方式。</strong></p><pre><code>flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</code></pre></li><li><p><strong>align-items 属性定义项目在交叉轴上如何对齐。</strong></p><pre><code>flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</code></pre></li><li><p><strong>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</strong></p><pre><code>flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。</code></pre></li></ul><h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h2><ul><li><p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p></li><li><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p></li><li><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p></li><li><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p></li><li><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></li><li><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p></li></ul><hr><p>本文链接：<a href="http://www.sguotao.top/ReactNative-2017-05-17-rn-flex.html">http://www.sguotao.top/ReactNative-2017-05-17-rn-flex.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flex容器属性&quot;&gt;&lt;a href=&quot;#Flex容器属性&quot; class=&quot;headerlink&quot; title=&quot;Flex容器属性&quot;&gt;&lt;/a&gt;Flex容器属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;flex-direction 属性决定主轴的方向（即项目的
      
    
    </summary>
    
      <category term="ReactNative" scheme="http://www.sguotao.top/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://www.sguotao.top/tags/ReactNative/"/>
    
      <category term="Flex" scheme="http://www.sguotao.top/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】人民的名义</title>
    <link href="http://www.sguotao.top/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2017-05-04-%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89.html"/>
    <id>http://www.sguotao.top/读书笔记-2017-05-04-人民的名义.html</id>
    <published>2017-05-04T04:00:00.000Z</published>
    <updated>2018-06-15T07:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>车窗外，严酷的冬季让广袤大地褪尽了五彩缤纷，裸露出素朴的本色，宛如卸妆后的母亲。<br>北风凛冽，裹挟着原野上的残草败叶，不时地扑打着路面。<br>然而冷峻的荒漠中，不也孕育着春天的希望吗？<br><a id="more"></a></p></blockquote><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017060914970149358704.png" alt="2017060914970149358704.png"><br>酣畅淋漓的读完了整本书，热播的电视剧也进入了收官，如何评价书中的人物？我想，不同的人，会因为个人经历的不同，看问题的角度不同，人生观、世界观和价值观不同，对同一个人物，会做出完全不同的评价。</p><blockquote><p>摘自公众号：闲人笔潭</p></blockquote><p>这部剧播出至今，不仅收视率火热，关于剧情、人物的讨论更是一浪高过一浪。而且有意思的地方在于，舆论的反转。</p><p>正义精明的检察官变成了何不食肉糜的既得利益者；<br>祁同伟从一个腐败官员变成了一个“寒门难出贵子”的悲情人物；<br>达康书记从一个有能力有抱负的政治家变成了伪君子。<br>而与之相对应的，是孙连城、高育良、沙瑞金甚至陈岩石评价的反转。</p><p>公众话题的有趣之处就在于：<strong>面对同一个问题，不同人会因为个人经历的不同、三观的不同、立场的不同与角度的不同发表出截然不同的评价。</strong></p><p>替祁同伟打抱不平，是因为祁同伟的悲情遭遇让诸多还在奋斗以及奋斗失败的人们心生共鸣。甚至不少人反对“阶级固化”更胜于反腐：<strong>腐败损失的是人民的经济利益，阶级固化是近乎堵死了寒门子弟上升的渠道与奋斗的动力。</strong></p><p>觉得侯亮平夫妇、陆亦可他们“何不食肉糜”的，也再正常不过。这个世界确实是分层的，但在你心里，可以不分。可钟小艾一句“摆得正自己的位置”，不知让多少人感受到了这种分层，以及优越感。</p><p>觉得李达康横行霸道的，是因为谁都不愿意身边有个这样一个聪明、有能力却“不粘锅”的人，“先生如万年青草，可以傲霜雪而不可充栋梁”大家都知道这个人好，但都想离他远点。</p><p>而大家讨论着，甚至吵得面红耳赤，当真是为了这么几个角色么？<strong>其实大多都是在讲自己的价值观，寻求价值认同啊</strong>。</p><p>价值观源自于出身、经历、读书思考，是每个人自身的精神之源，这样的动力才让我们每一个人都在为自己深有感触的地方发声。我们理解某些悲剧的时候也在潜意识的担心这些悲剧会不会在自己身上上演，我们控诉某些不公的时候更加感触得到这些不公就在自己的生活中，讨论的是剧情，共鸣的是每个人的经历。所以窃以为，大家最关注的、最感同身受的问题，恐怕也是当下社会存在的最显著的问题。</p><p>没错，就是阶级固化。中国是一个伪装成世界的国家，沿海是高楼大厦的现代社会，西部是还在等待扶贫的山区；南部的商业意识已发展数十年，深入人心，东北的人情关系更世代未变，根深蒂固；北上广的孩子们在排歌剧话剧的时候河南河北的学生还在“只要学不死，就往死里学”的标语下挑灯夜读。虽然在同一片土地上，却是不同的世界。</p><p>阶级固化所给人带来的就是像祁同伟那样“品学兼优的学生会主席，主动参加缉毒，身中三枪的英雄也被权力任意支配”的恐惧与无力感；还有钟小艾的“只要再努力一下就好了”的“何不食肉糜”般的轻描淡写。但是更会有人认为贪腐了就是贪腐了，没有任何贪腐的理由。这种撕裂的观点可能就是大家不同的经历：有些人苦于成才无门，有些人则受难于贪官污吏，正是这些不同的角度才有了前些天对“达康书记”的赞誉与这些天对“祁厅长”遭遇的同情，以及对这部剧的各种评判。</p><p>祁同伟是一个可惜可叹的悲剧，其实剧中哪一位有血有肉的人物不是呢？农民出身一分钱不敢花的赵德汉、善于谋划学识渊博的教授书记高育良、爷爷闹革命出身能熟练背出《共产党宣言》的刘新建。他们都曾拼搏奋斗，也都有了一般人很难拥有的学识、能力，他们最终也都贪污腐化了。有个人的原因，也有制度的原因。</p><p>想起几年前的“民国热”，当时还在热心科普民国的种种“真相”，想让向往民国的朋友们知道那是一个路有冻死骨的乱世，可应者渺渺。后来才被一句话点醒：“除了年轻学生，谁会真想去民国，连个手机都没有，只不过都是对现实有些不满罢了。”就如同文艺复兴从来就不是想回到希腊。</p><p>评《人民的名义》也不是真的想过天下大同，每个人都是圣人。<strong>这些激烈争吵，只是希望我们的价值观能得到更多的认同，希望社会能往更好的一点发展。当人们“一切向钱看”，而没有了价值信仰和精神寄托时，社会的稳定与繁荣就很难持续。当收入不高和升迁无望的政府官员面对诱惑而没有抵抗力时，就很难指望可以一劳永逸地使干部队伍保持廉洁。当某地的政治平衡和权力格局需要借助外力才能打破时，该地政治生态系统的自我修复功能就值得警惕。讨论《人民的名义》时，大概讨论的，可能都是自己的人生吧。</strong></p><hr><p>本文链接：<a href="http://www.sguotao.top/读书笔记-2017-05-04-人民的名义.html">http://www.sguotao.top/读书笔记-2017-05-04-人民的名义.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;车窗外，严酷的冬季让广袤大地褪尽了五彩缤纷，裸露出素朴的本色，宛如卸妆后的母亲。&lt;br&gt;北风凛冽，裹挟着原野上的残草败叶，不时地扑打着路面。&lt;br&gt;然而冷峻的荒漠中，不也孕育着春天的希望吗？&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书写作" scheme="http://www.sguotao.top/tags/%E8%AF%BB%E4%B9%A6%E5%86%99%E4%BD%9C/"/>
    
      <category term="人民的名义" scheme="http://www.sguotao.top/tags/%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的Property Animation</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2016-05-20-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Property-Animation.html"/>
    <id>http://www.sguotao.top/Android进阶-2016-05-20-分析Android中的Property-Animation.html</id>
    <published>2017-05-02T02:27:04.000Z</published>
    <updated>2017-07-13T10:04:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。<br><a href="/Android进阶-2016-05-18-android-view-animation.html">Android动画分析一 View Animation</a><br><a href="/Android进阶-2016-05-19-android-drawable-animation.html">Android动画分析二 Drawable Animation</a><br>在这一篇中，将对Android3.0之后出现的属性动画(Property Animation)进行整理。既然已经有了View Animation和Drawable Animation了，为什么还要引入Property Animation呢？</p><blockquote><p>1.使用动画场景的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么View动画就不能再帮我们忙了，也就是说View动画在功能和可扩展方面都有相当大的局限性。</p><p>2.Property Animation是改变对象的属性，不仅仅是对view本身做操作。传统的View动画只是改变view的显示效果，并不改变view的属性。郭霖介绍了一个比较形象的例子🌰，比如说，现在屏幕的左上角有一个按钮，然后我们通过View动画将它移动到了屏幕的右下角，点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过View动画将这个按钮绘制到了屏幕的右下角而已。属性动画的实现机制是通过对目标对象进行赋值并修改其属性来实现的，那么之前所说的按钮显示的问题也就不复存在了，如果我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。</p></blockquote><h2 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h2><p>Property Animation是Android3.0(API11)之后引入的动画，属性动画的引入，极大的地丰富了Android的动画体系，与传统的View动画和Drawable动画还是存在一些差别，在使用的过程中需要留意：</p><p>1.传统动画的xml文件存放在res/anim/目录下，而属性动画的xml文件存放在res/animator/目录下，虽然animator有着anim的前缀，但这是两个完全不同的目录。由于存放目录的不同，因此在代码中引用的方式也会有所差别，传统动画可以通过R.anim.filename获得动画的引用，属性通过则通过R.animator.filename获得动画的引用。</p><p>2.属性动画常用的Java类与传统动画Java类很相似，比如属性动画集AnimatorSet和传统动画集AnimationSet，在使用时注意区别，可以简化记忆“后缀是mator的是属性动画，后缀是mation的是传统动画”。属性动画中，常用的类，可以简单的用下面的类图进行概括。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170607149683875928772.png" alt="20170607149683875928772.png"><br>属性动画也支持xml标签的使用方式，Android API提供了三种类型的标签，分别是&lt;animator&gt;、&lt;objectAnimator&gt;、&lt;set&gt;每个标签都有对应的Java实现类。</p><h3 id="lt-animator-gt-ValueAnimator"><a href="#lt-animator-gt-ValueAnimator" class="headerlink" title="&lt;animator&gt;-ValueAnimator"></a>&lt;animator&gt;-ValueAnimator</h3><blockquote><p>ValueAnimator是整个属性动画机制当中最核心的一个类，属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，通过Handler来完成动画的绘制以确保属性的变化发生在UI线程，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。</p></blockquote><p>&lt;animator&gt;标签对应的Java实现类正是ValueAnimator类，&lt;animator&gt;包括以下属性：</p><table><thead><tr><th style="text-align:center">XML Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">android:duration</td><td style="text-align:center">动画从开始到结束持续的时长，单位为毫秒</td></tr><tr><td style="text-align:center">android:startOffset</td><td style="text-align:center">设置动画执行之前的等待时长，单位为毫秒</td></tr><tr><td style="text-align:center">android:repeatCount</td><td style="text-align:center">设置动画重复执行的次数，默认为0，不重复；可设为-1或infinite，表示无限重复</td></tr><tr><td style="text-align:center">android:repeatMode</td><td style="text-align:center">设置动画重复执行的模式，RESTART(默认值) 动画重复执行时从起点开始，REVERSE动画会反方向执行</td></tr><tr><td style="text-align:center">android:interpolator</td><td style="text-align:center">设置动画的插值器,若不设置，默认使用 AccelerateDecelerateInterpolator</td></tr><tr><td style="text-align:center">android:valueFrom</td><td style="text-align:center">动画开始的值，可以为int值、float值或color值</td></tr><tr><td style="text-align:center">android:valueTo</td><td style="text-align:center">动画结束的值，可以为int值、float值或color值</td></tr><tr><td style="text-align:center">android:valueType</td><td style="text-align:center">动画值类型，floatType(默认值) 指定动画值，即以上两个value属性的值为浮点型,intType 指定动画值，即以上两个value属性的值为整型,若为color值，则无需设置该属性</td></tr></tbody></table><p>同样的，属性动画也支持代码和资源文件两种创建方式。当使用资源文件时，需要通过AnimatorInflater中的loadAnimator()方法，将资源文件进行加载，得到Animator对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);  </span><br><span class="line">animator.setTarget(view);  </span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></p><p>资源文件定义方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:valueFrom=&quot;1&quot;</span><br><span class="line">    android:valueTo=&quot;0&quot;</span><br><span class="line">    android:valueType=&quot;floatType&quot;</span><br><span class="line">    android:repeatCount=&quot;1&quot;</span><br><span class="line">    android:repeatMode=&quot;reverse&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>代码的实现方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator valueAnimator = ValueAnimator.ofFloat(1f, 0f);</span><br><span class="line">valueAnimator.setDuration(1000);</span><br><span class="line">valueAnimator.setRepeatCount(1);</span><br><span class="line">valueAnimator.setRepeatMode(ValueAnimator.REVERSE);</span><br><span class="line">valueAnimator.start();</span><br></pre></td></tr></table></figure></p><h3 id="lt-objectAnimator-gt-ObjectAnimator"><a href="#lt-objectAnimator-gt-ObjectAnimator" class="headerlink" title="&lt;objectAnimator&gt;-ObjectAnimator"></a>&lt;objectAnimator&gt;-ObjectAnimator</h3><blockquote><p>&lt;objectAnimator&gt;标签对应的Java实现类是ObjectAnimator，相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。ObjectAnimator是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。</p></blockquote><p>由于ObjectAnimation继承ValueAnimator，所以&lt;objectAnimator&gt;除了&lt;animator&gt;的属性外，还包括自身特有的属性：</p><table><thead><tr><th style="text-align:center">XML Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">android:propertyName</td><td style="text-align:center">目标对象的属性名，要求目标对象必须提供该属性的setter方法，如果动画的时候没有初始值，还需要提供getter方法</td></tr></tbody></table><p>xml资源文件创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;1000&quot;</span><br><span class="line">    android:valueTo=&quot;200&quot;</span><br><span class="line">    android:valueType=&quot;floatType&quot;</span><br><span class="line">    android:propertyName=&quot;y&quot;</span><br><span class="line">    android:repeatCount=&quot;1&quot;</span><br><span class="line">    android:repeatMode=&quot;reverse&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>代码创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(view,&quot;alpha&quot;,0f,1f)</span><br><span class="line">            .setDuration(3000)</span><br><span class="line">            .start();</span><br></pre></td></tr></table></figure></p><p>ObjectAnimator提供了对View属性的设置，因为采用了反射的方式，所以要求View中要有该属性的setter和getter方法。当然，为了对View更方便的设置属性动画，Android系统也提供了View的一些属性和相应的setter和getter方法：</p><table><thead><tr><th style="text-align:center">XML Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">alpha</td><td style="text-align:center">透明度，默认为1，表示不透明，0表示完全透明</td></tr><tr><td style="text-align:center">pivotX 和 pivotY</td><td style="text-align:center">缩放动画固定点坐标</td></tr><tr><td style="text-align:center">scaleX 和 scaleY</td><td style="text-align:center">水平方向和垂直方向的缩放比例</td></tr><tr><td style="text-align:center">rotation、rotationX 和 rotationY</td><td style="text-align:center">基于固定点(pivotX,pivotY)做旋转,rotation是旋转度数,rotationX是水平旋转度数,rotationY是竖直旋转度数</td></tr><tr><td style="text-align:center">translationX 和 translationY</td><td style="text-align:center">水平方向移动距离和竖直方向移动距离</td></tr><tr><td style="text-align:center">x 和 y</td><td style="text-align:center">View在父容器内左上角的坐标</td></tr></tbody></table><p>通过对上面这些属性的操作，就可以完成传统View动画实现的效果。上面的示例代码中，实现了对一个属性的修改，如果对多个属性进行修改，该如何操纵呢？<br>PropertyValuesHolder可以实现对一组属性或多组属性的持有，可以同时设置多个属性，通过ofPropertyValuesHolder()方法，设置到对应的动画view上，这样局完成了动画过程中，多个属性的修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PropertyValuesHolder pValue1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f, 1f);</span><br><span class="line">PropertyValuesHolder pValue2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 0f, 1f);</span><br><span class="line">PropertyValuesHolder pValue3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 0f, 1f);</span><br><span class="line">ObjectAnimator.ofPropertyValuesHolder(view, pValue1, pValue2, pValue3).setDuration(3000).start();</span><br></pre></td></tr></table></figure><p>PropertyValuesHolder类提供了多个of开头的方法，以实现不同数据类型属性的设置，其中有一组方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</span><br><span class="line">public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values)</span><br><span class="line">static PropertyValuesHolder ofKeyframes(String propertyName, Keyframes keyframes)</span><br><span class="line">static PropertyValuesHolder ofKeyframes(Property property, Keyframes keyframes)</span><br></pre></td></tr></table></figure></p><p>在这组方法中，用到了Keyframe和Keyframes两个类，那么这两个类是做什么用的？Keyframe，关键帧，该类型对象由一个time/value对组成，定义了指定时间点的指定值。Keyframe是一个抽象类，在该类中定义了三个实现类ObjectKeyframe，IntKeyframe，FloatKeyframe用来保存Object、Int、Float类型的value。Keyframes是一个接口，KeyframeSet是它的实现类，KeyframeSet可以认为是关键帧Keyframe的辅助类，在KeyframeSet中维护着一个Keyframe类型的list。在API 23以后，可以在xml文件中使用PropertyValuesHolder。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">                android:duration=&quot;1000&quot;</span><br><span class="line">                android:repeatCount=&quot;1&quot;</span><br><span class="line">                android:repeatMode=&quot;reverse&quot;&gt;</span><br><span class="line">    &lt;propertyValuesHolder android:propertyName=&quot;x&quot; android:valueTo=&quot;400&quot;/&gt;</span><br><span class="line">    &lt;propertyValuesHolder android:propertyName=&quot;y&quot; android:valueTo=&quot;200&quot;/&gt;</span><br><span class="line">&lt;/objectAnimator&gt;</span><br></pre></td></tr></table></figure></p><p>在API16(Android4.1)中，新添加了TimeAnimator类，这个类它并不能直接实现动画效果，这个类有一个TimeListener接口，TimeListener会返回动画持续的时间，与上次调用的间隔时间。</p><h3 id="lt-set-gt-AnimatorSet"><a href="#lt-set-gt-AnimatorSet" class="headerlink" title="&lt;set&gt;-AnimatorSet"></a>&lt;set&gt;-AnimatorSet</h3><p>属性动画也可以实现多个动画的组合效果，对应AnimatorSet类。由于&lt;set&gt;实现动画组合的标签，所以它有一个设定动画顺序的属性:</p><table><thead><tr><th style="text-align:center">XML Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">android:ordering</td><td style="text-align:center">设置动画的时序关系，together(默认值) 动画同时执行，sequentially 动画按顺序执行</td></tr></tbody></table><p>当使用组合动画时，既有同时执行，又有顺序执行时，可以通过&lt;set&gt;标签的嵌套来实现。<br>在AnimatorSet内部中定义了一个Builder类，下面几个方法的返回类型都是该Builder类，这样我们在使用这几个方法设定多个动画播放顺序的时候，可以直接通过链式的方式，简化代码，这几个比较常用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 将现有动画插入到传入的动画之后执行</span><br><span class="line">    * @param anim</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public AnimatorSet.Builder after(Animator anim)</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 将现有动画延迟指定毫秒后执行</span><br><span class="line">    * @param delay</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public AnimatorSet.Builder after(long delay)</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 将现有动画插入到传入的动画之前执行</span><br><span class="line">    * @param anim</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public AnimatorSet.Builder before(Animator anim)</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 将现有动画和传入的动画同时执行</span><br><span class="line">    * @param anim</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public AnimatorSet.Builder with(Animator anim)</span><br></pre></td></tr></table></figure></p><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>属性动画也提供了一下监听器Listener，实现对属性动画状态的监测，通过回调方法实现业务逻辑。在Animator类中定义了两个接口，分别是AnimatorListener和AnimatorPauseListener，使用时通过addListener()和addPauseListener()进行监听器的添加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">valueAnimator.addListener(new Animator.AnimatorListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationStart(Animator animation) &#123;</span><br><span class="line">                //动画开始时调用</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                //动画结束时调用</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationCancel(Animator animation) &#123;</span><br><span class="line">                //动画被取消时调用</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationRepeat(Animator animation) &#123;</span><br><span class="line">                //动画重复执行时调用</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>由于Animator是ValueAnimator的父类，ObjectAnimator又继承ValueAnimator，因此ValueAnimator和ObjectAnimator都可以对这两个监听器进行添加。注意的是AnimatorPauseListener需要API Level 19。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">valueAnimator.addPauseListener(new Animator.AnimatorPauseListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationPause(Animator animation) &#123;</span><br><span class="line">                //动画暂停时调用</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationResume(Animator animation) &#123;</span><br><span class="line">                //动画恢复时调用</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>系统提供了AnimatorListenerAdapter抽象类实现了这两个接口，这样只需要重写需要的方法，而不必每个方法都重写了。在ValueAnimator中还添加接口AnimatorUpdateListener，可以实现对动画更新操作的监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">                // 动画更新时调用</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><blockquote><p>在API17(Android3.1)中引入，属性动画的机制已经不是再针对于View而进行设计的了，而是一种不断地对值进行操作的机制，它可以将值赋值到指定对象的指定属性上。但是，在绝大多数情况下，我相信大家主要都还是对View进行动画操作的。Android开发团队也是意识到了这一点，没有为View的动画操作提供一种更加便捷的用法确实是有点太不人性化了，于是在Android 3.1系统当中补充了ViewPropertyAnimator这个机制。</p><ol><li>整个ViewPropertyAnimator的功能都是建立在View类新增的animate()方法之上的，这个方法会创建并返回一个ViewPropertyAnimator的实例，之后的调用的所有方法，设置的所有属性都是通过这个实例完成的。</li><li>大家注意到，在使用ViewPropertyAnimator时，我们自始至终没有调用过start()方法，这是因为新的接口中使用了隐式启动动画的功能，只要我们将动画定义完成之后，动画就会自动启动。并且这个机制对于组合动画也同样有效，只要我们不断地连缀新的方法，那么动画就不会立刻执行，等到所有在ViewPropertyAnimator上设置的方法都执行完毕后，动画就会自动启动。当然如果不想使用这一默认机制的话，我们也可以显式地调用start()方法来启动动画。</li><li>ViewPropertyAnimator的所有接口都是使用连缀的语法来设计的，每个方法的返回值都是它自身的实例，因此调用完一个方法之后可以直接连缀调用它的另一个方法，这样把所有的功能都串接起来，我们甚至可以仅通过一行代码就完成任意复杂度的动画功能。</li></ol></blockquote><h3 id="TypeEvaluator-估值器"><a href="#TypeEvaluator-估值器" class="headerlink" title="TypeEvaluator(估值器)"></a>TypeEvaluator(估值器)</h3><blockquote><p>简单来说，就是告诉动画系统如何从初始值过度到结束值。与Interpolator区别是，Interpolator主要是用来控制动画的播放速率。</p></blockquote><p>在TypeEvaluator接口中定义了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public T evaluate(float fraction, T startValue, T endValue);</span><br></pre></td></tr></table></figure></p><p>evaluate()方法当中传入了三个参数，第一个参数fraction用于表示动画的完成度，我们应该根据它来计算当前动画的值应该是多少，第二第三个参数分别表示动画的初始值和结束值。系统提供了7个实现类方便我们使用，分别是ArgbEvaluator、FloatArrayEvaluator、FloatEvaluator、IntArrayEvaluator、IntEvaluator、PointFEvaluator和RectEvaluator。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="noopener">Property Animation</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43536355" target="_blank" rel="noopener">Android属性动画完全解析(上)，初识属性动画的基本用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43816093" target="_blank" rel="noopener">Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/44171115" target="_blank" rel="noopener">Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法</a></p><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2016-05-20-分析Android中的Property-Animation.html">http://www.sguotao.top/Android进阶-2016-05-20-分析Android中的Property-Animation.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。&lt;br&gt;&lt;a href=&quot;/Android进阶-2016-05-18-android-vi
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="动画" scheme="http://www.sguotao.top/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="代码库" scheme="http://www.sguotao.top/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的内存泄露</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2017-03-24-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html"/>
    <id>http://www.sguotao.top/Android进阶-2017-03-24-分析Android中的内存泄露.html</id>
    <published>2017-03-24T02:27:04.000Z</published>
    <updated>2017-07-11T12:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存泄露与内存溢出"><a href="#内存泄露与内存溢出" class="headerlink" title="内存泄露与内存溢出"></a>内存泄露与内存溢出</h2><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露(Memory Leak)是指无用对象（不再使用的对象）持续占有内存，或者无用对象的内存得不到及时释放，从而造成内存空间得不到有效的利用。在Java中，内存泄露的原因，通常是长生命周期的对象，持有短生命周期对象的引用。在《深入理解Java虚拟机》中的解释是，当无用对象一直被有用对象引用，导致无用对象可达，JVM无法对无用对象完成回收。从而造成内存泄露。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170327149058275225194.png" alt="内存泄露"></p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出(Out of Memory)是指程序在运行过程中，无法申请到足够的的内存导致的一种错误。内存泄露是会导致内存溢出，但不是导致内存溢出的唯一原因。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170327149058290012605.png" alt="20170327149058290012605.png"></p><h2 id="Java中的内存泄露"><a href="#Java中的内存泄露" class="headerlink" title="Java中的内存泄露"></a>Java中的内存泄露</h2><h3 id="Java-内存分配"><a href="#Java-内存分配" class="headerlink" title="Java 内存分配"></a>Java 内存分配</h3><p>Java中的内存分配主要分三块，静态存储区，栈区和堆区。</p><ul><li>静态存储区，编译时分配，存在于程序的整个运行期间，主要用于存放静态数据和常量。</li><li>栈区，在方法执行时，用于存放方法内部的局部变量，方法结束后，内存释放。</li><li>堆区，通常用来存放new出来的对象，由JVM进行回收处理。</li></ul><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170329149077275371348.png" alt="20170329149077275371348.png"><br>从JDK1.2开始，Java将对象的引用分为了强引用、软引用、弱引用和虚引用。</p><ul><li>强引用(Strong Reference),平时使用最多的一种引用，<strong>如果一个对象的引用方式是强引用，垃圾回收器不会对该对象进行回收，即使出现了内存空间不足的情况，JVM会抛出Out of Memory,也不会对强引用的对象进行回收。</strong></li><li>软引用(Soft Reference),在对象的引用强度上若于强引用，对于弱引用的对象，<strong>当内存不足时，JVM会回收软引用对象，释放内存空间</strong>。通常情况下，缓存的创建，适合使用软引用的方式。</li><li>弱引用(Weak Reference),在对象的引用强度上，弱于软引用，相对于强引用对象的不可回收，弱引用的对象，不存在这种情况，<strong>在垃圾回收器工作时，不论内存空间是否充足，都会对弱引用的对象进行回收。</strong>弱引用的作用，主要在于解决强引用对象之前的耦合关系，如在集合类中，任何Java对象都可以作为键来使用，当一个键值对被放入到集合中，集合对象本身就对这些键和值产生引用，如果是强引用，只要集合对象本身存在，其中包含的键和值就不会被回收，当集合包含的键和值越来越多时，最后会消耗掉JVM中的全部内存。</li><li>虚引用(Phantom Reference)，使用的情况并不多见，主要用来实现比较清晰的内存控制，这对于内存有限的移动设备是很有意义的。<strong>虚引用用来跟踪对象被垃圾回收器回收的活动</strong>，虚引用和软引用，弱引用的一个明显的区别是，虚引用必须和引用队列联合使用，通过检查引用队列中的内容，可以判断一个对象是否即将被回收。</li></ul><p>一个对象的引用类型有多个，怎么判断？<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170329149077630884381.png" alt="20170329149077630884381.png"><br>判定规则如下：</p><ul><li>单条引用链上的可达性，以最弱的一个引用类型来决定；</li><li>多条引用链上的可达性，以最强的一个引用类型来决定；</li></ul><p>我们假设上图中，1和3为强引用，5为软引用，7为弱引用。对于对象5的引用类型，在路径1–5中，5为软引用类型，依据规则1，对象5为软引用类型。在路径3–7中，7为弱引用类型，所以对象5为弱引用类型。依据规则2，多条引用链上的可达性，以最强的一个引用类型决定，因此，对象5的引用类型为软引用类型。</p><h2 id="内存泄露检测工具"><a href="#内存泄露检测工具" class="headerlink" title="内存泄露检测工具"></a>内存泄露检测工具</h2><h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><p>Memory Monitors是AndroidStudio自带的一个性能检测工具，主要包含以下几个功能：</p><ul><li>实时查看app的内存使用情况；</li><li>能够比较直观的了解到app的运行卡顿是否跟GC的频繁操作有关；</li><li>能够了解到app的crash是否跟内存溢出有关；</li><li>能够发现内存抖动(在短时间内分配大量内存，频繁的引起GC操作)</li></ul><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170401149101636441749.png" alt="20170401149101636441749.png"></p><h3 id="DDMS-Dump"><a href="#DDMS-Dump" class="headerlink" title="DDMS Dump"></a>DDMS Dump</h3><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017040114910150822979.png" alt="2017040114910150822979.png"><br><strong>什么是Java Heap Dump？</strong>首先需要搞明白什么是Java Heap，Java Heap是分配给实例类和数组对象运行数据区，所有Java线程在运行期间共享heap中的数据，Java Heap Dump相当于在应用运行时，某个时间点进行一次快照，在AndroidStudio中，快照会被保存为.hprof类型的文件，保存在captures目录中。</p><p>分析.hprof文件，我们可以将.hprof视图分成A、B、C三个部分，在A部分中，可以看到app的整个堆内存信息，显示了在堆内存中的所有的java类。</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Total Count</td><td style="text-align:center">内存中，当前Java类的实例数量</td></tr><tr><td style="text-align:center">Heap Count</td><td style="text-align:center">堆内存中，当前Java类的实例数量</td></tr><tr><td style="text-align:center">Size of</td><td style="text-align:center">当前Java类每个实例对象需要占用内存的物理大小</td></tr><tr><td style="text-align:center">Shallow Size</td><td style="text-align:center">当前Java实例对象占有的内存大小</td></tr><tr><td style="text-align:center">Retained Size</td><td style="text-align:center">释放当前Java实例对象后，节省的内存大小</td></tr></tbody></table><p>当选中A区域中的某个Java类，可以在B区域中看到选中Java类的所有实例对象。</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Depth</td><td style="text-align:center">当前对象的深度</td></tr><tr><td style="text-align:center">Shallow Size</td><td style="text-align:center">当前对象占有的内存大小</td></tr><tr><td style="text-align:center">Dominating Size</td><td style="text-align:center">当前对象可支配的内存大小</td></tr></tbody></table><p>在B中看到选中Java类的所有实例对象的同时，在C区域能够看到哪些对象引用了该对象。</p><p><strong>什么是Allocation Tracker？</strong>Allocation Tracker主要用来追踪内存分配信息，Start Allocation Tracking 相当于在程序运行时，某个时间节点，对内存分配信息进行一次快照，生成的快照文件被保存为.alloc类型，保存在captures目录中。Allocation Tracker 也可以在Devices Monitor中启动，在Devices Monitor中使用时，需要设备有Root权限。</p><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT(Eclipse Memory Analyzer)是一个堆转储文件分析工具，在Monitor的快照文件(.hprof)，需要转换成MAT可以打开的标准.hprof文件，使用Mat工具打开转换后的.hprof文件，会生成一个内存消耗整体状况的报告，从饼状图中，可以比较直观地看到哪些对象占用了多少的内存空间。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170419149258510813625.png" alt="20170419149258510813625.png"><br>这里介绍一下，MAT给我们提供的几个分析的维度。</p><ul><li>Histogram，在该视图中可以清晰的看出内存中对象的数量，及所占用内存空间的大小。</li><li>Dominator Tree:在该视图中，可以在线程的角度观察到哪些对象占用内存空间。</li><li>Top Consumers:从包，对象等角度，显示内存的占用情况，能够比较直观的找出占用内存比较多的对象。</li><li>Leak Suspects:分析内存泄露的情况，生成一份报表，给出一些problem的建议。</li></ul><p>下面介绍一些常用的操作，视图中支持正则表达式筛选，可以过滤出我们比较关心的对象，可以以列表或者树形的结构显示出来，其中：</p><ul><li>with incoming references:过滤出那些类引用了当前选中的类；</li><li>with outcoming references:过滤出当前选中类引用了哪些类；</li></ul><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017042014926559112895.png" alt="2017042014926559112895.png"></p><p>垃圾回收器会对虚拟机的内存空间，即堆空间中已经存在的对象进行识别，如果对象正在被引用，那么称其为存活对象，如果对象不在被引用，则为垃圾回收器回收的对象，这部分对象占用的内存空间可以被回收。</p><p>在垃圾回收机制中有一组元素被称为根元素集合，它们是一组被虚拟机直接引用的对象。堆空间中的每个对象都是由一个根元素为起点被层层调用的。所以，一个对象如果被一个存活的根元素所引用，就会被认为是存活对象，不能被回收。这时，可以通过分析一个对象到根元素的引用路径来分析该对象为什么不能够被顺利回收。</p><p>当选中某个对象，通过Merge Shortest Paths to GC Root的操作，可以显示对象之间的排除了软引用，弱引用和虚引用的引用关系，这样我们看到的就是被选中对象是否还存在强引用，通过分析 ，能够直接找到内存没有释放的原因。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170420149269042589662.png" alt="20170420149269042589662.png"></p><h2 id="开发中常见内存泄露的场景"><a href="#开发中常见内存泄露的场景" class="headerlink" title="开发中常见内存泄露的场景"></a>开发中常见内存泄露的场景</h2><h3 id="1-Context对象使用不当；"><a href="#1-Context对象使用不当；" class="headerlink" title="1.Context对象使用不当；"></a>1.Context对象使用不当；</h3><p>在Android中经常使用的单例模式，如果使用不当，会出现内存泄露，泄露的主要原因是因为，单例模式中的静态成员变量的生命周期与应用的生命周期一样长。比较常见的场景是，经常在一些工具类中使用单例模式，如xxManager,xxHelper，xxUtils,这些工具类中需要使用Context,由于Activity是间接继承Context，当Activity退出时，单例对象中持有了它的引用，导致Activity回收失败，从而出现内存泄露。处理方式是使用Application,由于Application的生命周期贯穿整个应用，所以当这些工具类需要使用到Context时，使用getApplication()或者getApplicationContext()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    public class Util &#123;</span><br><span class="line">        private Context mContext;</span><br><span class="line">        private static Util sInstance;</span><br><span class="line"></span><br><span class="line">        private Util(Context context) &#123;</span><br><span class="line">            this.mContext = context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static Util getInstance(Context context) &#123;</span><br><span class="line">            if (sInstance == null) &#123;</span><br><span class="line">//                sInstance = new Util(context);</span><br><span class="line">                sInstance = new Util(context.getApplicationContext());</span><br><span class="line">            &#125;</span><br><span class="line">            return sInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-内部类使用不当"><a href="#2-内部类使用不当" class="headerlink" title="2.内部类使用不当"></a>2.内部类使用不当</h3><p>当使用非静态的内部类时，如果出现内部类持有外部类的引用，就会出现内存泄露，优化方法，可以使用静态的内部类，这样内部类就不在持有外部类的引用，不会影响GC对于外部类的回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态成员变量</span><br><span class="line">     */</span><br><span class="line">    public static InnerClass innerClass = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_my);</span><br><span class="line"></span><br><span class="line">        innerClass = new InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class InnerClass &#123;</span><br><span class="line"></span><br><span class="line">        public void doSomeThing() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Handler的异步消息通信"><a href="#3-Handler的异步消息通信" class="headerlink" title="3.Handler的异步消息通信"></a>3.Handler的异步消息通信</h3><p>在使用Handler时出现内存泄露的主要原因是Handler的生命周期与Activity的生命周期不一致，当应用启动时，创建UI主线程Looper对象，Looper实现了简单的消息队列，主线程Looper对象存在整个应用的生命周期中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class HandlerActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private final Handler mHandler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mHandler.sendMessageDelayed(Message.obtain(), 10*000);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在Actiivity中使用Handler时，就可能会产生内存泄露，究其根本原因，是我们使用的非静态内部类(或者匿名内部类)默认隐性持有外部类的引用，静态内部类不会持有外部类的引用。在Activity结束时，由于Message是延迟消息，会在主线程的消息队列中，该消息持有Activity中的Handler的引用，Handler默认持有Activity的引用，直至该消息被处理完。此时导致Activity对象无法被回收，就会出现内存泄露。优化方法，可以使用静态内部类继承Handler对象，或者在Activity的onDestory()方法中，调用mHandler.removeCallbacksAndMessages(null);</p><h3 id="4-Bitmap使用不当"><a href="#4-Bitmap使用不当" class="headerlink" title="4.Bitmap使用不当"></a>4.Bitmap使用不当</h3><p>使用Bitmap如果回收不及时，也会出现内存泄露。原因在于Bitmap类没有对外创建对象的构造方法，获得Bitmap对象只能通过BitmapFactory中的各种静态方法，生成Bitmap对象是通过JNI调用底层c来实现的。所以，当我们获取一个Bitmap对象时，其对应的内存中包含两部分内容，一部分是Java，一部分是c,Java部分的内存可以通过GC进行回收，但是c部分的内存GC是不会进行自动回收的，所以，我们在使用Bitmap对象时，需要调用recycle()来主动释放c部分的内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否已经回收</span><br><span class="line">if(bitmap != null &amp;&amp; !bitmap.isRecycled())&#123; </span><br><span class="line">        // 回收并且置为null</span><br><span class="line">        bitmap.recycle(); </span><br><span class="line">        bitmap = null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-资源性对象没有及时关闭"><a href="#5-资源性对象没有及时关闭" class="headerlink" title="5.资源性对象没有及时关闭"></a>5.资源性对象没有及时关闭</h3><p>当我们使用一些资源性对象时，如果没有做关闭操作，也会出现内存泄露，常见的资源性对象包括(Cursor、ContentProvider、File、Stream)等。还有一类如EventBus、BroadCastReceiver在注册后，为了避免重复注册，需要在退出时及时的销毁。</p><h3 id="6-集合列表相关"><a href="#6-集合列表相关" class="headerlink" title="6.集合列表相关"></a>6.集合列表相关</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。</p><h3 id="7-Native中存在内存泄露"><a href="#7-Native中存在内存泄露" class="headerlink" title="7.Native中存在内存泄露"></a>7.Native中存在内存泄露</h3><p>由于Native层的代码多用c或c++来实现，GC无法对这部分内存进行会后处理，这时可能会出现内存泄露，这时候就需要c工程师帮助分析，如Malloc的内存是否做了free处理，指针使用完成后，是否进行了置空处理等等。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://www.jianshu.com/p/e97ed5d8a403" target="_blank" rel="noopener">科普：内存泄漏与内存溢出</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank" rel="noopener">Java的内存泄漏</a></li><li><a href="https://segmentfault.com/a/1190000006852540" target="_blank" rel="noopener">Android 内存泄露总结</a></li><li><a href="https://segmentfault.com/a/1190000003910496" target="_blank" rel="noopener">Java四种引用类型</a></li><li><a href="http://blog.csdn.net/itomge/article/details/48719527" target="_blank" rel="noopener">MAT使用教程</a></li></ol><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2017-03-24-分析Android中的内存泄露.html">http://www.sguotao.top/Android进阶-2017-03-24-分析Android中的内存泄露.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存泄露与内存溢出&quot;&gt;&lt;a href=&quot;#内存泄露与内存溢出&quot; class=&quot;headerlink&quot; title=&quot;内存泄露与内存溢出&quot;&gt;&lt;/a&gt;内存泄露与内存溢出&lt;/h2&gt;&lt;h3 id=&quot;内存泄露&quot;&gt;&lt;a href=&quot;#内存泄露&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="内存泄露" scheme="http://www.sguotao.top/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="MAT" scheme="http://www.sguotao.top/tags/MAT/"/>
    
  </entry>
  
  <entry>
    <title>【RN笔记】ReactNative样式整理</title>
    <link href="http://www.sguotao.top/ReactNative-2017-04-25-rn-css.html"/>
    <id>http://www.sguotao.top/ReactNative-2017-04-25-rn-css.html</id>
    <published>2017-03-24T02:27:04.000Z</published>
    <updated>2017-07-13T10:13:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。</p><h2 id="引入样式的几种方法"><a href="#引入样式的几种方法" class="headerlink" title="引入样式的几种方法"></a>引入样式的几种方法</h2><p>常见的引用样式的几种方法，包括内嵌方式，外联方式和混合方式，还可以把样式定义在单独的文件中，通过import引用。</p><h3 id="1-内嵌方式"><a href="#1-内嵌方式" class="headerlink" title="1. 内嵌方式"></a>1. 内嵌方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default class appProject extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                marginTop:200,</span><br><span class="line">                marginLeft:5,</span><br><span class="line">                marginRight:5,</span><br><span class="line">                height:84,</span><br><span class="line">                flexDirection:&apos;row&apos;,</span><br><span class="line">                backgroundColor:&apos;#FF0067&apos;,</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-外联方式"><a href="#2-外联方式" class="headerlink" title="2. 外联方式"></a>2. 外联方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Styles = StyleSheet.create(&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        marginTop:200,</span><br><span class="line">        marginLeft:5,</span><br><span class="line">        marginRight:5,</span><br><span class="line">        height:84,</span><br><span class="line">        flexDirection:&apos;row&apos;,</span><br><span class="line">        backgroundColor:&apos;#FF0067&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-混合方式"><a href="#3-混合方式" class="headerlink" title="3. 混合方式"></a>3. 混合方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default class appProject extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            //外层容器</span><br><span class="line">            &lt;View style=&#123;[Styles.container,Styles.bg,&#123;color:&apos;red&apos;&#125;]&#125;&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-import引用"><a href="#4-import引用" class="headerlink" title="4.import引用"></a>4.import引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import &#123;</span><br><span class="line">    StyleSheet,</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        marginTop:200,</span><br><span class="line">        marginLeft:5,</span><br><span class="line">        marginRight:5,</span><br><span class="line">        height:84,</span><br><span class="line">        flexDirection:&apos;row&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    bg:&#123;</span><br><span class="line">        backgroundColor:&apos;#FF0067&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">module.exports = styles;</span><br></pre></td></tr></table></figure><p>通过import进行引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import styles from &apos;./styles/style&apos;;</span><br></pre></td></tr></table></figure></p><h2 id="常见的属性及说明"><a href="#常见的属性及说明" class="headerlink" title="常见的属性及说明"></a>常见的属性及说明</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">backgroundColor</td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 background-color 属性</td></tr></tbody></table><h3 id="2-宽高尺寸"><a href="#2-宽高尺寸" class="headerlink" title="2.宽高尺寸"></a>2.宽高尺寸</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">width</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 width 属性</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 height 属性</td></tr></tbody></table><h3 id="3-外边距相关-margin"><a href="#3-外边距相关-margin" class="headerlink" title="3.外边距相关(margin)"></a>3.外边距相关(margin)</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">margin</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白</td></tr><tr><td style="text-align:center">marginHorizontal</td><td style="text-align:center">number</td><td style="text-align:center">CSS中没有对应的属性，相当于同时设置marginRight和marginLeft</td></tr><tr><td style="text-align:center">marginVertical</td><td style="text-align:center">number</td><td style="text-align:center">CSS中没有对应的属性，相当于同时设置marginTop和marginBottom</td></tr><tr><td style="text-align:center">marginTop</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 margin-top 属性</td></tr><tr><td style="text-align:center">marginRight</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 margin-right 属性</td></tr><tr><td style="text-align:center">marginBottom</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 margin-bottom 属性</td></tr><tr><td style="text-align:center">marginLeft</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 margin-left 属性</td></tr></tbody></table><h3 id="4-内边距相关-padding"><a href="#4-内边距相关-padding" class="headerlink" title="4.内边距相关(padding)"></a>4.内边距相关(padding)</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">padding</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白</td></tr><tr><td style="text-align:center">paddingHorizontal</td><td style="text-align:center">number</td><td style="text-align:center">CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft</td></tr><tr><td style="text-align:center">paddingVertical</td><td style="text-align:center">number</td><td style="text-align:center">CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom</td></tr><tr><td style="text-align:center">paddingTop</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 padding-top 属性</td></tr><tr><td style="text-align:center">paddingRight</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 padding-right 属性</td></tr><tr><td style="text-align:center">paddingBottom</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 padding-bottom 属性</td></tr><tr><td style="text-align:center">paddingLeft</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 padding-left 属性</td></tr></tbody></table><h3 id="5-边框相关-border"><a href="#5-边框相关-border" class="headerlink" title="5.边框相关(border)"></a>5.边框相关(border)</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">borderStyle</td><td style="text-align:center">solid, dotted, dashed</td><td style="text-align:center">对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性</td></tr><tr><td style="text-align:center">borderWidth</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-width 属性</td></tr><tr><td style="text-align:center">borderTopWidth</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-top-width 属性</td></tr><tr><td style="text-align:center">borderRightWidth</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-right-width 属性</td></tr><tr><td style="text-align:center">borderBottomWidth</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-bottom-width 属性</td></tr><tr><td style="text-align:center">borderLeftWidth</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-left-width 属性</td></tr><tr><td style="text-align:center">borderColor</td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 border-color 属性</td></tr><tr><td style="text-align:center">borderTopColor</td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 border-top-color 属性</td></tr><tr><td style="text-align:center">borderRightColor</td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 border-right-color 属性</td></tr><tr><td style="text-align:center">borderBottomColor</td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 border-bottom-color 属性</td></tr><tr><td style="text-align:center">borderLeftColor</td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 border-left-color 属性</td></tr><tr><td style="text-align:center">borderRadius</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-radius 属性</td></tr><tr><td style="text-align:center">borderTopLeftRadius</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-top-left-radius 属性</td></tr><tr><td style="text-align:center">borderTopRightRadius</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-top-right-radius 属性</td></tr><tr><td style="text-align:center">borderBottomLeftRadius</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-bottom-left-radius 属性</td></tr><tr><td style="text-align:center">borderBottomRightRadius</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 border-bottom-right-radius 属性</td></tr></tbody></table><h3 id="6-位置相关-position"><a href="#6-位置相关-position" class="headerlink" title="6.位置相关(position)"></a>6.位置相关(position)</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">position</td><td style="text-align:center">absolute, relative</td><td style="text-align:center">对应 CSS 中的 position 属性，但阉割了 static, fixed 取值</td></tr><tr><td style="text-align:center">top</td><td style="text-align:center">number&gt;</td><td style="text-align:center">对应 CSS 中的 top 属性</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 right 属性</td></tr><tr><td style="text-align:center">bottom</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 bottom 属性</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 left 属性</td></tr></tbody></table><h3 id="7-文本相关-Text"><a href="#7-文本相关-Text" class="headerlink" title="7.文本相关(Text)"></a>7.文本相关(Text)</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">color</td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 color 属性</td></tr><tr><td style="text-align:center">fontFamily</td><td style="text-align:center">string</td><td style="text-align:center">对应 CSS 中的 font-family 属性</td></tr><tr><td style="text-align:center">fontSize</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 font-size 属性</td></tr><tr><td style="text-align:center">fontStyle</td><td style="text-align:center">normal, italic</td><td style="text-align:center">对应 CSS 中的 font-style 属性，但阉割了 oblique 取值</td></tr><tr><td style="text-align:center">fontWeight</td><td style="text-align:center">normal, bold 100~900</td><td style="text-align:center">对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值</td></tr><tr><td style="text-align:center">lineHeight</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 line-height 属性</td></tr><tr><td style="text-align:center">textAlign</td><td style="text-align:center">auto, left, right, center, justifyiOS</td><td style="text-align:center">对应 CSS 中的 text-align 属性，增加了 auto 取值</td></tr><tr><td style="text-align:center">textAlignVertical<sup>Android</sup></td><td style="text-align:center">auto, top, bottom, center</td><td style="text-align:center">对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub 等值</td></tr><tr><td style="text-align:center">textShadowColor</td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 text-shadow 属性中的颜色定义</td></tr><tr><td style="text-align:center">textShadowOffset</td><td style="text-align:center">{width: number, height: number}</td><td style="text-align:center">对应 CSS 中的 text-shadow 属性中的阴影偏移定义</td></tr><tr><td style="text-align:center">textShadowRadius</td><td style="text-align:center">number</td><td style="text-align:center">在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义</td></tr><tr><td style="text-align:center">letterSpacing<sup>iOS</sup></td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 letter-spacing 属性，但取值不同</td></tr><tr><td style="text-align:center">textDecorationColor<sup>iOS</sup></td><td style="text-align:center">color</td><td style="text-align:center">对应 CSS 中的 text-decoration-color 属性</td></tr><tr><td style="text-align:center">textDecorationLine<sup>iOS</sup></td><td style="text-align:center">none, underline, line-through, underline line-through</td><td style="text-align:center">对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值</td></tr><tr><td style="text-align:center">textDecorationStyle<sup>iOS</sup></td><td style="text-align:center">solid, double, dotted, dashed</td><td style="text-align:center">对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值</td></tr><tr><td style="text-align:center">writingDirection<sup>iOS</sup></td><td style="text-align:center">auto, ltr, rtl</td><td style="text-align:center">对应 CSS 中的 direction 属性，增加了 auto 取值</td></tr></tbody></table><h3 id="8-弹性布局相关-Flex"><a href="#8-弹性布局相关-Flex" class="headerlink" title="8.弹性布局相关(Flex)"></a>8.弹性布局相关(Flex)</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">flex</td><td style="text-align:center">number</td><td style="text-align:center">对应 CSS 中的 flex 属性</td></tr><tr><td style="text-align:center">flexDirection</td><td style="text-align:center">row, column</td><td style="text-align:center">对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值</td></tr><tr><td style="text-align:center">flexWrap</td><td style="text-align:center">wrap, nowrap</td><td style="text-align:center">对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值</td></tr><tr><td style="text-align:center">justifyContent</td><td style="text-align:center">flex-start, flex-end, center, space-between, space-around</td><td style="text-align:center">对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。</td></tr><tr><td style="text-align:center">alignItems</td><td style="text-align:center">flex-start, flex-end, center, stretch</td><td style="text-align:center">对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。</td></tr><tr><td style="text-align:center">alignSelf</td><td style="text-align:center">auto, flex-start, flex-end, center, stretch</td><td style="text-align:center">对应 CSS 中的 align-self 属性，但阉割了 baseline 取值</td></tr></tbody></table><h3 id="9-转换相关-transform"><a href="#9-转换相关-transform" class="headerlink" title="9.转换相关(transform)"></a>9.转换相关(transform)</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">transform</td><td style="text-align:center">[{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}]</td><td style="text-align:center">对应 CSS 中的 transform 属性</td></tr><tr><td style="text-align:center">transformMatrix</td><td style="text-align:center">TransformMatrixPropType</td><td style="text-align:center">类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数</td></tr><tr><td style="text-align:center">backfaceVisibility</td><td style="text-align:center">visible, hidden</td><td style="text-align:center">对应 CSS 中的 backface-visibility 属性</td></tr></tbody></table><h3 id="10-图片相关"><a href="#10-图片相关" class="headerlink" title="10.图片相关"></a>10.图片相关</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">resizeMode</td><td style="text-align:center">cover, contain, stretch</td><td style="text-align:center">contain是指无论如何图片都包含在指定区域内，假设设置的宽度高度比图片大，则图片居中显示，否则，图片等比缩小显示</td></tr><tr><td style="text-align:center">overflow</td><td style="text-align:center">visible, hidden</td><td style="text-align:center">超出部分是否显示，hidden为隐藏</td></tr><tr><td style="text-align:center">tintColor</td><td style="text-align:center">number</td><td style="text-align:center">着色，rgb字符串类型</td></tr><tr><td style="text-align:center">opacity</td><td style="text-align:center">number</td><td style="text-align:center">透明度</td></tr></tbody></table><h3 id="11-图像变换"><a href="#11-图像变换" class="headerlink" title="11.图像变换"></a>11.图像变换</h3><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">取值</th><th style="text-align:center">对应css属性</th></tr></thead><tbody><tr><td style="text-align:center">rotation</td><td style="text-align:center">–</td><td style="text-align:center">旋转</td></tr><tr><td style="text-align:center">scaleX</td><td style="text-align:center">–</td><td style="text-align:center">水平方向缩放</td></tr><tr><td style="text-align:center">scaleY</td><td style="text-align:center">–</td><td style="text-align:center">垂直方向缩放</td></tr><tr><td style="text-align:center">translateX</td><td style="text-align:center">–</td><td style="text-align:center">水平方向平移</td></tr><tr><td style="text-align:center">translateY</td><td style="text-align:center">–</td><td style="text-align:center">水平方向平移</td></tr></tbody></table><hr><p>本文链接：<a href="http://www.sguotao.top/ReactNative-2017-04-25-rn-css.html">http://www.sguotao.top/ReactNative-2017-04-25-rn-css.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。&lt;/p&gt;
&lt;h2 id=&quot;引入样式的几种方法&quot;&gt;&lt;a href=&quot;#引入样式的几种方法&quot; class=&quot;headerlink&quot; title=&quot;引入样式的几种方法&quot;&gt;&lt;/a&gt;引入样式
      
    
    </summary>
    
      <category term="ReactNative" scheme="http://www.sguotao.top/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://www.sguotao.top/tags/ReactNative/"/>
    
      <category term="CSS" scheme="http://www.sguotao.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>分析Android中的动态加载机制</title>
    <link href="http://www.sguotao.top/Android%E8%BF%9B%E9%98%B6-2017-03-17-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"/>
    <id>http://www.sguotao.top/Android进阶-2017-03-17-分析Android中的动态加载机制.html</id>
    <published>2017-03-17T02:27:04.000Z</published>
    <updated>2017-08-08T03:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java的类加载机制ClassLoader"><a href="#Java的类加载机制ClassLoader" class="headerlink" title="Java的类加载机制ClassLoader"></a>Java的类加载机制ClassLoader</h2><p>我们编写的java代码，最终会编译成.class字节码的形式，一个完整的Java程序，通常会由若干个.class文件组成，在程序运行时，通过该程序的入口函数来调用系统的各个功能，但是程序启动时，并不会一次性将.class文件加载到内存中，根据程序的需要，通过Java的类加载机制来动态加载.class文件，ClassLoader就是来实现.class文件的动态加载的。</p><h2 id="Java中各类加载器的关系"><a href="#Java中各类加载器的关系" class="headerlink" title="Java中各类加载器的关系"></a>Java中各类加载器的关系</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974200061820.png" alt="20170317148974200061820.png"><br>Java默认会提供三个类加载器，分别为BootStrapClassLoader,ExtClassLoader和AppClassLoader;</p><ul><li>BootStrapLoader，启动类加载器，是Java类加载层次中最顶层的类加载器，由c代码编写，负责加载JDK中的核心类库（包括JRE classes目录下的.class文件，libs目录下的jar文件）。可以使用System.getProperty(“sun.boot.class.path”)来显示BootStrapLoader加载的jar和.class文件；</li><li>ExtClassLoader,扩展类加载器，负责加载Java的扩展类库，默认加载/jre/lib/ext目录下的所有jar和.class文件。可以通过可以使用System.getProperty(“java.ext.dirs”)来显示ExtClassLoader加载的jar和.class文件；</li><li>AppClassLoader,系统类加载器，负责加载classpath目录下所有的jar和class文件。</li></ul><h2 id="Java类加载的实现过程"><a href="#Java类加载的实现过程" class="headerlink" title="Java类加载的实现过程"></a>Java类加载的实现过程</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974217438657.jpg" alt="20170317148974217438657.jpg"></p><ul><li>执行程序代码，找到JRE所在目录；</li><li>找到jvm.dll(Windows)或者libjvm.so(Linux);</li><li>启动JVM，并进行初始化工作</li><li>创建BootStrapClassLoader;</li><li>BootStrapClassLoader会加载ExtClassLoader，并设定ExtClassLoader的parent为BootStrapClassLoader;</li><li>BootStrapClassLoader会加载AppClassLoader,并设定AppClassLoader的parent为ExtClassLoader;</li></ul><p>当AppClassLoader开始加载xxx.class时，类加载器会现将加载的任务交给其parent来完成，如果parent找不到，则自己负责加载。所以在加载xxx.class时的顺序是，BootstrapClassLoader –&gt; ExtClassLoader –&gt; AppClassLoader，如果都找不到，则抛出ClassNotFoundException。这就是非常有名的双亲委托模型。</p><p>使用双亲委托模型，有效地解决了.class字节码重复加载的问题，当parent已经加载类某各类的.class字节码时，子类就没有必要再重新进行加载。举个例子，来说明一下双亲委托模型。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974220124844.png" alt="20170317148974220124844.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 取得SomeClass的Class实例</span><br><span class="line">   Class c = Class.forName(&quot;SomeClass&quot;);</span><br><span class="line">   // 取得ClassLoader</span><br><span class="line">   ClassLoader loader = c.getClassLoader();</span><br><span class="line">   System.out.println(loader);</span><br><span class="line">   // 取得父ClassLoader</span><br><span class="line">   System.out.println(loader.getParent());</span><br><span class="line">   // 再取得父ClassLoader</span><br><span class="line">   System.out.println(loader.getParent().getParent());</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher\$AppClassLoader@19821f</span><br><span class="line">sun.misc.Launcher\$ExtClassLoader@addbf1</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>由于SomeClass是自定义的一个Java类，通常会java.class.path中产生字节码，首先AppClassLoader会将加载的任务交给其parent,ExtClassLaoder,ExtClassLoader将加载任务交给其parent，BootStrapClassLoader,由于BootStrapLoader在其目录(sun.boot.class.path)下没有找到该类的字节码，所以由ExtClassLoader来加载，ExtClassLoader在其目录(java.ext.dirs)也没有发现SomeClass的字节码，交给AppClassLoader进行加载，AppClassLoader在(java.class.path)中找到，并进行加载。</p><p>加载SomeClass的ClassLoader是AppClassLoader,其parent是ExtClassLoader,<br>而ExtClassLoader的parent是null，这是因为BootStrapClassLoader是由c代码编写的，在JVM中并没有对应的实例对象，所以显示为null。</p><h2 id="Dalvik与JVM"><a href="#Dalvik与JVM" class="headerlink" title="Dalvik与JVM"></a>Dalvik与JVM</h2><p>在Java中，把一些Java类编译成.class文件，通过ClassLoader进行加载，但是在Android上边，情况有所不同，主要的原因在于Android中使用的虚拟机是Dalvik。Android中的Dalvik和Java中的JVM都是将对应的Java类加载到内存中运行。不同的是JVM加载的是.class字节码文件，或是通过defineClass方式产生class，进行加载。Dalvik加载的是.dex文件，.dex文件是Android对.class文件进行了优化，更加适合内存和处理器有限的系统。</p><ul><li>Dalvik是基于寄存器的，而JVM是基于栈的。</li><li>Dalvik运行dex文件，而JVM运行java字节码</li><li>自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。</li></ul><p>很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。2014年6月25日,Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。ART,即Android Runtime。ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time,JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time)。这样的话，应用的启动(首次)和执行都会变得更加快速。</p><h2 id="DexClassLoader与PathClassLoader"><a href="#DexClassLoader与PathClassLoader" class="headerlink" title="DexClassLoader与PathClassLoader"></a>DexClassLoader与PathClassLoader</h2><p>在使用Java虚拟机时，我们经常自定义继承自ClassLoader的类加载器。然后通过defineClass方法来从一个二进制流中加载Class。而在Android中我们无法这么使用，Android中ClassLoader的defineClass方法具体是调用VMClassLoader的defineClass本地静态方法。而这个本地方法什么都没做，只是抛出了一个“UnsupportedOperationException”异常。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"can't load this type of class file"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>既然在Dalvik虚拟机里，ClassLoader不好用，那么Android官方为了解决这个问题，帮我们从ClassLoader中派生出了两个类：DexClassLoader和PathClassLoader。先来看一下DexClassLoader和PahtClassLoader的继承关系。</p><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170322149015010153287.png" alt="20170322149015010153287.png"></p><h3 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h3><p>DexClassLoader可以加载jar,apk,dex,可以从SD卡进行加载，可以实现dex的动态加载与更新，DexClassLoader要有一个app私有且可写的目录来存储经过优化的.odex文件。构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexPath .dex文件路径,多个文件路径使用':'分隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> optimizedDirectory .dex文件优化后生成的.odex文件的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> librarySearchPath 动态库路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 双亲委派模式,指定父类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h3><p>PathClassLoader只能加载已经安装的apk文件。Android系统默认使用的类加载器。构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexPath .dex文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> librarySearchPath 本地库路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent 双亲委派模式,指定父类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DexClassLoader与PathClassLoader的比较"><a href="#DexClassLoader与PathClassLoader的比较" class="headerlink" title="DexClassLoader与PathClassLoader的比较"></a>DexClassLoader与PathClassLoader的比较</h3><p>通过两个类加载构造函数的对比发现，区别在于DexClassLoader构造函数中的参数optimizedDirectory。Google官方文档中给出optimizedDirectory的说明是，用来存储经过优化后的.odex文件的路径。optimizedDirectory必须是一个内部存储路径，DexClassLoader可以通过构造函数指定optimizedDirectory，所以DexClassLoader可以实现动态加载，外部的.jar/.dex文件，优化后会存在在optimizedDirectory目录中。PathClassLoader由于没有指定该路径，所以只能加载内部的，已经安装的apk中的.odex文件。</p><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170322149015373793574.png" alt="20170322149015373793574.png"></p><p>整个类加载过程可以简单描述为上面的时序图。ClassLoader在加载过程中，通过loadClass方法，调用BaseDexClassLoader中重载的findClass方法，该方法会遍历DexPathList列表。DexPathList的创建过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.originalPath = dexPath;</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>optimizedDirectory用来缓存优化过的.odex文件，在DexClassLoader中可以通过构造函数进行制定，在PathClassLoader中，optimizedDirectory为null，会直接使用系统中已经安装的apk文件的.odex目录。DexPathList完整的创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                       String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</span><br><span class="line">                                             File optimizedDirectory) &#123;</span><br><span class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            ZipFile zip = <span class="keyword">null</span>;</span><br><span class="line">            DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">            String name = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</span><br><span class="line">                || name.endsWith(ZIP_SUFFIX)) &#123;</span><br><span class="line">                zip = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">            &#125;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                elements.add(<span class="keyword">new</span> Element(file, zip, dex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Converts a dex/jar file path and an output directory to an</span></span><br><span class="line"><span class="comment">     * output file path for an associated optimized dex file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">optimizedPathFor</span><span class="params">(File path,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">        String fileName = path.getName();</span><br><span class="line">        <span class="keyword">if</span> (!fileName.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastDot = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastDot &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                fileName += DEX_SUFFIX;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(lastDot + <span class="number">4</span>);</span><br><span class="line">                sb.append(fileName, <span class="number">0</span>, lastDot);</span><br><span class="line">                sb.append(DEX_SUFFIX);</span><br><span class="line">                fileName = sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        File result = <span class="keyword">new</span> File(optimizedDirectory, fileName);</span><br><span class="line">        <span class="keyword">return</span> result.getPath();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="http://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener">深入分析Java ClassLoader原理</a><br>2.<a href="http://blog.csdn.net/irelandken/article/details/7048817" target="_blank" rel="noopener">分析BootstrapClassLoader/ExtClassLoader/AppClassLoader的加载路径 及”父委托机制”</a><br>3.<a href="https://openhome.cc/Gossip/JavaEssence/ClassLoader.html" target="_blank" rel="noopener">簡介類別載入器</a><br>4.<a href="http://www.infoq.com/cn/articles/android-in-depth-dalvik" target="_blank" rel="noopener">Java虚拟机Dalvik</a><br>5<a href="http://www.jianshu.com/p/669fc4858194" target="_blank" rel="noopener">Android动态加载——DexClassloader分析</a></p><hr><p>本文链接：<a href="http://www.sguotao.top/Android进阶-2017-03-17-分析Android中的动态加载机制.html">http://www.sguotao.top/Android进阶-2017-03-17-分析Android中的动态加载机制.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java的类加载机制ClassLoader&quot;&gt;&lt;a href=&quot;#Java的类加载机制ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;Java的类加载机制ClassLoader&quot;&gt;&lt;/a&gt;Java的类加载机制ClassLoader&lt;/
      
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.top/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.top/tags/Android/"/>
    
      <category term="JVM" scheme="http://www.sguotao.top/tags/JVM/"/>
    
      <category term="插件框架" scheme="http://www.sguotao.top/tags/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ClassLoader" scheme="http://www.sguotao.top/tags/ClassLoader/"/>
    
  </entry>
  
</feed>
