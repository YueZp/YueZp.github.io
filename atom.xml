<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sguotao.com/"/>
  <updated>2017-06-02T10:40:10.000Z</updated>
  <id>http://www.sguotao.com/</id>
  
  <author>
    <name>Scott</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【转】程序员为什么会忧虑自己的未来?</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2017-06-02-%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BF%A7%E8%99%91%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%AA%E6%9D%A5.html"/>
    <id>http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html</id>
    <published>2017-06-02T02:22:08.000Z</published>
    <updated>2017-06-02T10:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。</p>
</blockquote>
<a id="more"></a>
<p>文章作者:陈驰远，青橙科技CTO，互联网行业的一名老兵，以下是部分摘录。更多讨论，请戳原文。<br>原文链接:<a href="https://juejin.im/post/5930acd6a0bb9f0058af41e5" target="_blank" rel="external">https://juejin.im/post/5930acd6a0bb9f0058af41e5</a></p>
<p>从去年开始，我参加了一些分享交流，也对外发过一些自己对工作所遇问题的思考。不少程序员加我好友咨询问题，几乎每个人问的问题都跟职业规划有关。这提醒了我，其实我自己也一直在思考同样的问题并尝试规划未来。于是想和大家分享一下自己在这方面的感悟。</p>
<p>本文仅从我自己的角度来剖析对程序员职业规划的看法，并不全面。而下文中提到的程序员群体也泛指在一线具体执行编码任务的程序员，不包含一些高精尖技术岗位的专业技术人才或是已经有自己明确职业规划，已经进阶成功的工程师。</p>
<h2 id="什么引发了焦虑？"><a href="#什么引发了焦虑？" class="headerlink" title="什么引发了焦虑？"></a>什么引发了焦虑？</h2><p>互联网是一个新兴但高速发展的行业。新兴意味着没有那么多的职场楷模给新人指明方向，也没有一套公认的稳定可复制的职业发展路线。高速发展意味着变革与竞争，大量新人因为行业红利涌入，你无时无刻要跟一群优秀的热血青年同场竞技。</p>
<p>互联网行业工作强度很大，而中国的互联网从业者更忙。程序员更是战场中的排头兵，身体健康的透支导致很难长期抗战。当你意识到自己跟不上节奏的时候，不管是出于对身体状况的担忧，还是对未来潜在威胁的恐惧，又怎会不感到焦虑呢？而程序员的职业特性加剧了这种焦虑，主要表现在以下几方面：</p>
<h2 id="程序员职业复利性较低。"><a href="#程序员职业复利性较低。" class="headerlink" title="程序员职业复利性较低。"></a>程序员职业复利性较低。</h2><h3 id="什么叫复利性？"><a href="#什么叫复利性？" class="headerlink" title="什么叫复利性？"></a>什么叫复利性？</h3><p>就如同利息的计算方法一样，在本金相同的情况下，复利获得的利息回报要高于单利，而年期越长，复利效应越高。职业一样有复利效应，一个复利高的职业在职业生涯中后期会展现出越来越高的价值。医生、律师都是复利性很高的职业。而程序员职业复利性较低，主要有两个原因：</p>
<ul>
<li><strong>专业性强，通用性差。不同技术种类有着自己的技术栈，共用的只有设计思想、编程范式，基础技术等通用知识。</strong></li>
<li><strong>在没有明确规划的情况下，大多数程序员日常工作积累的不是通用知识与综合能力，而仅仅是某项技术的熟练度与经验。这是根本原因。</strong><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170602149637117527702.jpg" title="后端技术栈">
<img src="http://7u2np3.com1.z0.glb.clouddn.com/20170602149637119625879.jpg" title="前端技术栈">
这造成了一个问题——当职业生涯遇到瓶颈时，程序员很难完成一次完美的进阶。让我们分析下最常见的三类方案：</li>
</ul>
<ol>
<li><p><strong>技术职位之间的转岗。</strong>这是最普遍的一种情况，Android转IOS，后端转前端等都在此列。虽然设计原则、编程范式等技术知识是通用的，但作为一线的执行者，技术的熟练度才是影响你工作效率的最大因素，你必须对技术栈非常熟悉才能体现工作的专业度。 转岗往往是无奈之举。</p>
</li>
<li><p><strong>技术转产品/运营岗。</strong>很多工程师抱怨产品经理设计的产品有问题，逻辑不严密，用起来很别扭。但让工程师做产品，问题一般会更多。为什么呢？最大的原因在于程序员的思维模式或多或少会受到编程的影响，偏向理性与具象化，缺少了感性的察言观色以及换位思考的能力。设计好一个产品，逻辑严密只是条件之一，但并不是最重要的条件。产品经理需要从用户的行为中挖掘出用户真正的需求，提炼归纳并设计成一个可用的产品。这是大多数程序员很难做好的事情。</p>
</li>
<li><p><strong>技术转管理岗。</strong>BAT都有自己的M岗位，高工都可以选择是继续走技术路线还是尝试走管理路线。很多程序员安慰自己，哪天真写不动代码了，那我就做技术经理吧。但我认为管理岗的转变比前面两类都难。管理是一门很深的学问，执行和管理是两回事，需要从根本上改变思维模式。评判一个工程师的好坏可以看工程师的产出，而评判一个管理者的好坏在于整个团队的产出和效率。很多优秀的程序员自己技术能力很强，却很难带领整个团体一起向前进。</p>
</li>
</ol>
<h2 id="程序员职业的壁垒没想象中高，鲁棒性低。"><a href="#程序员职业的壁垒没想象中高，鲁棒性低。" class="headerlink" title="程序员职业的壁垒没想象中高，鲁棒性低。"></a>程序员职业的壁垒没想象中高，鲁棒性低。</h2><p>鲁棒性也指抗变换性，一个好的职业需要有高的鲁棒性。大部分程序员把自己的职业与某项技能绑定。做过编程的都知道，一个高耦合低抽象的编码鲁棒性一定低。互联网行业变化太快，回头看下诺基亚的发展，Windows桌面应用开发，整个行业如同大浪淘沙。随着云平台的崛起，公有化平台的发展，API服务的开放，可以预见从业者的工作效率会大幅提高，同时很多职业可能会再次洗牌：基础运维工程师，DBA，基础算法工程师，安全工程师，图像算法工程师，数据工程师等等都在此列。</p>
<p>从另外一个角度来说，假设你运气很好，选择了一项长期热门的技术比如Web前端开发。但是因为行业红利太高，无数聪明、努力、上进的热血青年涌入其中。随着社区的发展，在线教育的普及，达到同样熟练度的时间越来越短，而热门互联网技术的发展是以月计，你需要花费大量的时间去学习积累新技术。新人与你的差距会越来越小，你会随时面临被超车的局面。这意味着，很多时候即使你认为自己经验更丰富，能力更强，但你却得不到理想的职位及薪资待遇。</p>
<h2 id="程序员职业能撬动的价值有限。"><a href="#程序员职业能撬动的价值有限。" class="headerlink" title="程序员职业能撬动的价值有限。"></a>程序员职业能撬动的价值有限。</h2><p>这个概念受启发于《格鲁夫给经理人的第一课》一书。格鲁夫试图定量的分析经理人的产出，于是提出了一个公式：经理人的产出 = 他直接管辖部门的产出 + 他间接影响所及部门的产出。为了定量的分析职业的价值，我也引入了一个公式：产出的价值 = 他自身的产出 + 他直接影响部门的产出 + 他间接影响所及部门的产出</p>
<p><strong>职业能影响的人越多，创造的价值越高，职业的上限价值也越高。</strong></p>
<p>互联网行业的供求关系以及价值体系，造成了一个现象：程序员供不应求使其入行薪资高，但是工作五年以上薪资趋向于稳定。对于绝大部分公司的绝大部分职位，当熟练度和经验达到某一个阈值的时候，选择成本是趋同的，自身效率提高所能带动的价值提高已经很有限。正因为如此，从业者在享受了薪资高速增长之后，很难接受薪资增幅趋缓，职业生涯遇到瓶颈引发焦虑。</p>
<img src="http://7u2np3.com1.z0.glb.clouddn.com/2017060214963712208098.jpg" title="[薪资待遇]">
<h2 id="我的规划是什么？"><a href="#我的规划是什么？" class="headerlink" title="我的规划是什么？"></a>我的规划是什么？</h2><p>分析了这么多，我最想表达的意思是：所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。</p>
<p>首先我会分析自己的特点，这是建立与他人的差异性和自己独特标签的关键所在，也是最值得加强的地方。我最大的特点是什么？<br><strong>有野心。</strong>我不想选择一种得过且过的生活，而会选择一个产出价值更高的事情来做，影响更多的人，创造更高的价值。<br><strong>会沟通。</strong>我沟通能力不错，既可以对外谈合作，又可以对内做管理。这会是我相对一般技术型程序员一个很大的不同。<br><strong>专业强。</strong>在专业技能层面我有较深的认识与理解，虽然谈不上顶尖，但我知道怎么运用自己的知识能力找到最适合现状的方法解决几乎所有日常问题。技术积累永远是我最核心的竞争力。</p>
<p>知道自己特点之后，我会以此为基础来增强自己的不可替代性。不可替代性不仅仅只是基于个人的能力，还有这几点是需要日常注意积累的：<br><strong>健康的身体。</strong>在经历过一次生病后，我更加意识到拥有一个健康的身体才是最重要的。积极健身可是我们青橙员工的必备素质。<br><strong>思想与格局的高度。</strong>思想的高度并不是一朝一夕就能拔高的，而是在经历了来自工作与生活的各种挑战之后，静下心来反思总结，从而慢慢积累并提升。<br><strong>人脉与影响力。</strong>乐于记录和分享自己的工作感悟。抓住向其他人学习的机会，比如参加一些会议或交流，不管是同行业还是其他行业的，都是很有必要的。人脉和影响力的积累与格局的高度也是相辅相成的，与某些方面比自己优秀的人交流往往会收获满满。<br><strong>当我有了明确的方向并且每天都能看到自己进步的时候，就会对未来充满憧憬。</strong>我给自己未来的定位是做一名解决者。何谓解决者？面对未知或已知的问题，知道如何分析本质原因，制定并实施解决方案。附加打油诗一首：</p>
<blockquote>
<p>文能设计定需求，武可写码做架构。<br>进做招商引融资，退做大V占风口。<br>产品体验包上线，还要招人带节奏。</p>
</blockquote>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html">http://www.sguotao.com/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】ReactNative Flex整理</title>
    <link href="http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html"/>
    <id>http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html</id>
    <published>2017-05-17T02:27:04.000Z</published>
    <updated>2017-06-02T10:39:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flex容器属性"><a href="#Flex容器属性" class="headerlink" title="Flex容器属性"></a>Flex容器属性</h2><ul>
<li><p><strong>flex-direction 属性决定主轴的方向（即项目的排列方向）。</strong></p>
<pre><code>row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿。
column-reverse：主轴为垂直方向，起点在下沿。
</code></pre></li>
<li><p><strong>flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</strong></p>
<pre><code>nowrap（默认）：不换行。
wrap：换行，第一行在上方。
wrap-reverse：换行，第一行在下方。
</code></pre></li>
<li><p><strong>flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</strong></p>
</li>
<li><p><strong>justify-content 属性定义了项目在主轴上的对齐方式。</strong></p>
<pre><code>flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，项目之间的间隔都相等。
space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
</code></pre></li>
<li><p><strong>align-items 属性定义项目在交叉轴上如何对齐。</strong></p>
<pre><code>flex-start：交叉轴的起点对齐。
flex-end：交叉轴的终点对齐。
center：交叉轴的中点对齐。
baseline: 项目的第一行文字的基线对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
</code></pre></li>
<li><p><strong>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</strong></p>
<pre><code>flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。
</code></pre></li>
</ul>
<h2 id="Flex项目属性"><a href="#Flex项目属性" class="headerlink" title="Flex项目属性"></a>Flex项目属性</h2><ul>
<li><p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
</li>
<li><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
</li>
<li><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
</li>
<li><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
</li>
<li><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
</li>
<li><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
</li>
</ul>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html">http://www.sguotao.com/ReactNative-2017-05-17-rn-flex.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flex容器属性&quot;&gt;&lt;a href=&quot;#Flex容器属性&quot; class=&quot;headerlink&quot; title=&quot;Flex容器属性&quot;&gt;&lt;/a&gt;Flex容器属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;flex-direction 属性决定主轴的方向（即项目的
    
    </summary>
    
      <category term="ReactNative" scheme="http://www.sguotao.com/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://www.sguotao.com/tags/ReactNative/"/>
    
      <category term="Flex" scheme="http://www.sguotao.com/tags/Flex/"/>
    
  </entry>
  
  <entry>
    <title>Android动画分析三 Property Animation</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-05-20-android-property-animation.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-05-20-android-property-animation.html</id>
    <published>2017-05-02T02:27:04.000Z</published>
    <updated>2017-06-07T12:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。<br><a href="/Android进阶-2016-05-18-android-view-animation.html">Android动画分析一 View Animation</a><br><a href="/Android进阶-2016-05-19-android-drawable-animation.html">Android动画分析二 Drawable Animation</a><br>在这一篇中，将对Android3.0之后出现的属性动画(Property Animation)进行整理。既然已经有了View Animation和Drawable Animation了，为什么还要引入Property Animation呢？</p>
<blockquote>
<p>1.使用动画场景的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么View动画就不能再帮我们忙了，也就是说View动画在功能和可扩展方面都有相当大的局限性。</p>
<p>2.Property Animation是改变对象的属性，不仅仅是对view本身做操作。传统的View动画只是改变view的显示效果，并不改变view的属性。郭霖介绍了一个比较形象的例子🌰，比如说，现在屏幕的左上角有一个按钮，然后我们通过View动画将它移动到了屏幕的右下角，点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过View动画将这个按钮绘制到了屏幕的右下角而已。属性动画的实现机制是通过对目标对象进行赋值并修改其属性来实现的，那么之前所说的按钮显示的问题也就不复存在了，如果我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。</p>
</blockquote>
<h2 id="Property-Animation"><a href="#Property-Animation" class="headerlink" title="Property Animation"></a>Property Animation</h2><p>Property Animation是Android3.0(API11)之后引入的动画，属性动画的引入，极大的地丰富了Android的动画体系，与传统的View动画和Drawable动画还是存在一些差别，在使用的过程中需要留意：</p>
<p>1.传统动画的xml文件存放在res/anim/目录下，而属性动画的xml文件存放在res/animator/目录下，虽然animator有着anim的前缀，但这是两个完全不同的目录。由于存放目录的不同，因此在代码中引用的方式也会有所差别，传统动画可以通过R.anim.filename获得动画的引用，属性通过则通过R.animator.filename获得动画的引用。</p>
<p>2.属性动画常用的Java类与传统动画Java类很相似，比如属性动画集AnimatorSet和传统动画集AnimationSet，在使用时注意区别，可以简化记忆“后缀是mator的是属性动画，后缀是mation的是传统动画”。属性动画中，常用的类，可以简单的用下面的类图进行概括。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170607149683875928772.png" alt="20170607149683875928772.png"><br>属性动画也支持xml标签的使用方式，Android API提供了三种类型的标签，分别是&lt;animator&gt;、&lt;objectAnimator&gt;、&lt;set&gt;每个标签都有对应的Java实现类。</p>
<h3 id="lt-animator-gt-ValueAnimator"><a href="#lt-animator-gt-ValueAnimator" class="headerlink" title="&lt;animator&gt;-ValueAnimator"></a>&lt;animator&gt;-ValueAnimator</h3><blockquote>
<p>ValueAnimator是整个属性动画机制当中最核心的一个类，属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，通过Handler来完成动画的绘制以确保属性的变化发生在UI线程，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。</p>
</blockquote>
<p>&lt;animator&gt;标签对应的Java实现类正是ValueAnimator类，&lt;animator&gt;包括以下属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:duration</td>
<td style="text-align:center">动画从开始到结束持续的时长，单位为毫秒</td>
</tr>
<tr>
<td style="text-align:center">android:startOffset</td>
<td style="text-align:center">设置动画执行之前的等待时长，单位为毫秒</td>
</tr>
<tr>
<td style="text-align:center">android:repeatCount</td>
<td style="text-align:center">设置动画重复执行的次数，默认为0，不重复；可设为-1或infinite，表示无限重复</td>
</tr>
<tr>
<td style="text-align:center">android:repeatMode</td>
<td style="text-align:center">设置动画重复执行的模式，RESTART(默认值) 动画重复执行时从起点开始，REVERSE动画会反方向执行</td>
</tr>
<tr>
<td style="text-align:center">android:interpolator</td>
<td style="text-align:center">设置动画的插值器,若不设置，默认使用 AccelerateDecelerateInterpolator</td>
</tr>
<tr>
<td style="text-align:center">android:valueFrom</td>
<td style="text-align:center">动画开始的值，可以为int值、float值或color值</td>
</tr>
<tr>
<td style="text-align:center">android:valueTo</td>
<td style="text-align:center">动画结束的值，可以为int值、float值或color值</td>
</tr>
<tr>
<td style="text-align:center">android:valueType</td>
<td style="text-align:center">动画值类型，floatType(默认值) 指定动画值，即以上两个value属性的值为浮点型,intType 指定动画值，即以上两个value属性的值为整型,若为color值，则无需设置该属性</td>
</tr>
</tbody>
</table>
<p>同样的，属性动画也支持代码和资源文件两种创建方式。当使用资源文件时，需要通过AnimatorInflater中的loadAnimator()方法，将资源文件进行加载，得到Animator对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file);  </div><div class="line">animator.setTarget(view);  </div><div class="line">animator.start();</div></pre></td></tr></table></figure></p>
<p>资源文件定义方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;1000&quot;</div><div class="line">    android:valueFrom=&quot;1&quot;</div><div class="line">    android:valueTo=&quot;0&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>代码的实现方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ValueAnimator valueAnimator = ValueAnimator.ofFloat(1f, 0f);</div><div class="line">valueAnimator.setDuration(1000);</div><div class="line">valueAnimator.setRepeatCount(1);</div><div class="line">valueAnimator.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">valueAnimator.start();</div></pre></td></tr></table></figure></p>
<h3 id="lt-objectAnimator-gt-ObjectAnimator"><a href="#lt-objectAnimator-gt-ObjectAnimator" class="headerlink" title="&lt;objectAnimator&gt;-ObjectAnimator"></a>&lt;objectAnimator&gt;-ObjectAnimator</h3><blockquote>
<p>&lt;objectAnimator&gt;标签对应的Java实现类是ObjectAnimator，相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。ObjectAnimator是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。</p>
</blockquote>
<p>由于ObjectAnimation继承ValueAnimator，所以&lt;objectAnimator&gt;除了&lt;animator&gt;的属性外，还包括自身特有的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:propertyName</td>
<td style="text-align:center">目标对象的属性名，要求目标对象必须提供该属性的setter方法，如果动画的时候没有初始值，还需要提供getter方法</td>
</tr>
</tbody>
</table>
<p>xml资源文件创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:duration=&quot;1000&quot;</div><div class="line">    android:valueTo=&quot;200&quot;</div><div class="line">    android:valueType=&quot;floatType&quot;</div><div class="line">    android:propertyName=&quot;y&quot;</div><div class="line">    android:repeatCount=&quot;1&quot;</div><div class="line">    android:repeatMode=&quot;reverse&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>代码创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator.ofFloat(view,&quot;alpha&quot;,0f,1f)</div><div class="line">            .setDuration(3000)</div><div class="line">            .start();</div></pre></td></tr></table></figure></p>
<p>ObjectAnimator提供了对View属性的设置，因为采用了反射的方式，所以要求View中要有该属性的setter和getter方法。当然，为了对View更方便的设置属性动画，Android系统也提供了View的一些属性和相应的setter和getter方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">alpha</td>
<td style="text-align:center">透明度，默认为1，表示不透明，0表示完全透明</td>
</tr>
<tr>
<td style="text-align:center">pivotX 和 pivotY</td>
<td style="text-align:center">缩放动画固定点坐标</td>
</tr>
<tr>
<td style="text-align:center">scaleX 和 scaleY</td>
<td style="text-align:center">水平方向和垂直方向的缩放比例</td>
</tr>
<tr>
<td style="text-align:center">rotation、rotationX 和 rotationY</td>
<td style="text-align:center">基于固定点(pivotX,pivotY)做旋转,rotation是旋转度数,rotationX是水平旋转度数,rotationY是竖直旋转度数</td>
</tr>
<tr>
<td style="text-align:center">translationX 和 translationY</td>
<td style="text-align:center">水平方向移动距离和竖直方向移动距离</td>
</tr>
<tr>
<td style="text-align:center">x 和 y</td>
<td style="text-align:center">View在父容器内左上角的坐标</td>
</tr>
</tbody>
</table>
<p>通过对上面这些属性的操作，就可以完成传统View动画实现的效果。上面的示例代码中，实现了对一个属性的修改，如果对多个属性进行修改，该如何操纵呢？<br>PropertyValuesHolder可以实现对一组属性或多组属性的持有，可以同时设置多个属性，通过ofPropertyValuesHolder()方法，设置到对应的动画view上，这样局完成了动画过程中，多个属性的修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PropertyValuesHolder pValue1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f, 1f);</div><div class="line">PropertyValuesHolder pValue2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 0f, 1f);</div><div class="line">PropertyValuesHolder pValue3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 0f, 1f);</div><div class="line">ObjectAnimator.ofPropertyValuesHolder(view, pValue1, pValue2, pValue3).setDuration(3000).start();</div></pre></td></tr></table></figure>
<p>PropertyValuesHolder类提供了多个of开头的方法，以实现不同数据类型属性的设置，其中有一组方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</div><div class="line">public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values)</div><div class="line">static PropertyValuesHolder ofKeyframes(String propertyName, Keyframes keyframes)</div><div class="line">static PropertyValuesHolder ofKeyframes(Property property, Keyframes keyframes)</div></pre></td></tr></table></figure></p>
<p>在这组方法中，用到了Keyframe和Keyframes两个类，那么这两个类是做什么用的？Keyframe，关键帧，该类型对象由一个time/value对组成，定义了指定时间点的指定值。Keyframe是一个抽象类，在该类中定义了三个实现类ObjectKeyframe，IntKeyframe，FloatKeyframe用来保存Object、Int、Float类型的value。Keyframes是一个接口，KeyframeSet是它的实现类，KeyframeSet可以认为是关键帧Keyframe的辅助类，在KeyframeSet中维护着一个Keyframe类型的list。在API 23以后，可以在xml文件中使用PropertyValuesHolder。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">                android:duration=&quot;1000&quot;</div><div class="line">                android:repeatCount=&quot;1&quot;</div><div class="line">                android:repeatMode=&quot;reverse&quot;&gt;</div><div class="line">    &lt;propertyValuesHolder android:propertyName=&quot;x&quot; android:valueTo=&quot;400&quot;/&gt;</div><div class="line">    &lt;propertyValuesHolder android:propertyName=&quot;y&quot; android:valueTo=&quot;200&quot;/&gt;</div><div class="line">&lt;/objectAnimator&gt;</div></pre></td></tr></table></figure></p>
<p>在API16(Android4.1)中，新添加了TimeAnimator类，这个类它并不能直接实现动画效果，这个类有一个TimeListener接口，TimeListener会返回动画持续的时间，与上次调用的间隔时间。</p>
<h3 id="lt-set-gt-AnimatorSet"><a href="#lt-set-gt-AnimatorSet" class="headerlink" title="&lt;set&gt;-AnimatorSet"></a>&lt;set&gt;-AnimatorSet</h3><p>属性动画也可以实现多个动画的组合效果，对应AnimatorSet类。由于&lt;set&gt;实现动画组合的标签，所以它有一个设定动画顺序的属性:</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:ordering</td>
<td style="text-align:center">设置动画的时序关系，together(默认值) 动画同时执行，sequentially 动画按顺序执行</td>
</tr>
</tbody>
</table>
<p>当使用组合动画时，既有同时执行，又有顺序执行时，可以通过&lt;set&gt;标签的嵌套来实现。<br>在AnimatorSet内部中定义了一个Builder类，下面几个方法的返回类型都是该Builder类，这样我们在使用这几个方法设定多个动画播放顺序的时候，可以直接通过链式的方式，简化代码，这几个比较常用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 将现有动画插入到传入的动画之后执行</div><div class="line">    * @param anim</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public AnimatorSet.Builder after(Animator anim)</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 将现有动画延迟指定毫秒后执行</div><div class="line">    * @param delay</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public AnimatorSet.Builder after(long delay)</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 将现有动画插入到传入的动画之前执行</div><div class="line">    * @param anim</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public AnimatorSet.Builder before(Animator anim)</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 将现有动画和传入的动画同时执行</div><div class="line">    * @param anim</div><div class="line">    * @return</div><div class="line">    */</div><div class="line">   public AnimatorSet.Builder with(Animator anim)</div></pre></td></tr></table></figure></p>
<h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>属性动画也提供了一下监听器Listener，实现对属性动画状态的监测，通过回调方法实现业务逻辑。在Animator类中定义了两个接口，分别是AnimatorListener和AnimatorPauseListener，使用时通过addListener()和addPauseListener()进行监听器的添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">valueAnimator.addListener(new Animator.AnimatorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationStart(Animator animation) &#123;</div><div class="line">                //动画开始时调用</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAnimationEnd(Animator animation) &#123;</div><div class="line">                //动画结束时调用</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAnimationCancel(Animator animation) &#123;</div><div class="line">                //动画被取消时调用</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAnimationRepeat(Animator animation) &#123;</div><div class="line">                //动画重复执行时调用</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>由于Animator是ValueAnimator的父类，ObjectAnimator又继承ValueAnimator，因此ValueAnimator和ObjectAnimator都可以对这两个监听器进行添加。注意的是AnimatorPauseListener需要API Level 19。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">valueAnimator.addPauseListener(new Animator.AnimatorPauseListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationPause(Animator animation) &#123;</div><div class="line">                //动画暂停时调用</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onAnimationResume(Animator animation) &#123;</div><div class="line">                //动画恢复时调用</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>系统提供了AnimatorListenerAdapter抽象类实现了这两个接口，这样只需要重写需要的方法，而不必每个方法都重写了。在ValueAnimator中还添加接口AnimatorUpdateListener，可以实现对动画更新操作的监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                // 动画更新时调用</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><blockquote>
<p>在API17(Android3.1)中引入，属性动画的机制已经不是再针对于View而进行设计的了，而是一种不断地对值进行操作的机制，它可以将值赋值到指定对象的指定属性上。但是，在绝大多数情况下，我相信大家主要都还是对View进行动画操作的。Android开发团队也是意识到了这一点，没有为View的动画操作提供一种更加便捷的用法确实是有点太不人性化了，于是在Android 3.1系统当中补充了ViewPropertyAnimator这个机制。</p>
<ol>
<li>整个ViewPropertyAnimator的功能都是建立在View类新增的animate()方法之上的，这个方法会创建并返回一个ViewPropertyAnimator的实例，之后的调用的所有方法，设置的所有属性都是通过这个实例完成的。</li>
<li>大家注意到，在使用ViewPropertyAnimator时，我们自始至终没有调用过start()方法，这是因为新的接口中使用了隐式启动动画的功能，只要我们将动画定义完成之后，动画就会自动启动。并且这个机制对于组合动画也同样有效，只要我们不断地连缀新的方法，那么动画就不会立刻执行，等到所有在ViewPropertyAnimator上设置的方法都执行完毕后，动画就会自动启动。当然如果不想使用这一默认机制的话，我们也可以显式地调用start()方法来启动动画。</li>
<li>ViewPropertyAnimator的所有接口都是使用连缀的语法来设计的，每个方法的返回值都是它自身的实例，因此调用完一个方法之后可以直接连缀调用它的另一个方法，这样把所有的功能都串接起来，我们甚至可以仅通过一行代码就完成任意复杂度的动画功能。</li>
</ol>
</blockquote>
<h3 id="TypeEvaluator-估值器"><a href="#TypeEvaluator-估值器" class="headerlink" title="TypeEvaluator(估值器)"></a>TypeEvaluator(估值器)</h3><blockquote>
<p>简单来说，就是告诉动画系统如何从初始值过度到结束值。与Interpolator区别是，Interpolator主要是用来控制动画的播放速率。</p>
</blockquote>
<p>在TypeEvaluator接口中定义了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public T evaluate(float fraction, T startValue, T endValue);</div></pre></td></tr></table></figure></p>
<p>evaluate()方法当中传入了三个参数，第一个参数fraction用于表示动画的完成度，我们应该根据它来计算当前动画的值应该是多少，第二第三个参数分别表示动画的初始值和结束值。系统提供了7个实现类方便我们使用，分别是ArgbEvaluator、FloatArrayEvaluator、FloatEvaluator、IntArrayEvaluator、IntEvaluator、PointFEvaluator和RectEvaluator。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="external">Property Animation</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43536355" target="_blank" rel="external">Android属性动画完全解析(上)，初识属性动画的基本用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43816093" target="_blank" rel="external">Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/44171115" target="_blank" rel="external">Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-05-20-android-property-animation.html">http://www.sguotao.com/Android进阶-2016-05-20-android-property-animation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。&lt;br&gt;&lt;a href=&quot;/Android进阶-2016-05-18-android-vi
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="动画" scheme="http://www.sguotao.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="代码库" scheme="http://www.sguotao.com/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】ReactNative样式整理</title>
    <link href="http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html"/>
    <id>http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html</id>
    <published>2017-03-24T02:27:04.000Z</published>
    <updated>2017-06-02T10:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。</p>
<h2 id="引入样式的几种方法"><a href="#引入样式的几种方法" class="headerlink" title="引入样式的几种方法"></a>引入样式的几种方法</h2><p>常见的引用样式的几种方法，包括内嵌方式，外联方式和混合方式，还可以把样式定义在单独的文件中，通过import引用。</p>
<h3 id="1-内嵌方式"><a href="#1-内嵌方式" class="headerlink" title="1. 内嵌方式"></a>1. 内嵌方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">export default class appProject extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;</div><div class="line">                &#123;</div><div class="line">                marginTop:200,</div><div class="line">                marginLeft:5,</div><div class="line">                marginRight:5,</div><div class="line">                height:84,</div><div class="line">                flexDirection:&apos;row&apos;,</div><div class="line">                backgroundColor:&apos;#FF0067&apos;,</div><div class="line">                &#125;</div><div class="line">                &#125;&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-外联方式"><a href="#2-外联方式" class="headerlink" title="2. 外联方式"></a>2. 外联方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const Styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        marginTop:200,</div><div class="line">        marginLeft:5,</div><div class="line">        marginRight:5,</div><div class="line">        height:84,</div><div class="line">        flexDirection:&apos;row&apos;,</div><div class="line">        backgroundColor:&apos;#FF0067&apos;,</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="3-混合方式"><a href="#3-混合方式" class="headerlink" title="3. 混合方式"></a>3. 混合方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">export default class appProject extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            //外层容器</div><div class="line">            &lt;View style=&#123;[Styles.container,Styles.bg,&#123;color:&apos;red&apos;&#125;]&#125;&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-import引用"><a href="#4-import引用" class="headerlink" title="4.import引用"></a>4.import引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;</div><div class="line">import &#123;</div><div class="line">    StyleSheet,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">    container: &#123;</div><div class="line">        marginTop:200,</div><div class="line">        marginLeft:5,</div><div class="line">        marginRight:5,</div><div class="line">        height:84,</div><div class="line">        flexDirection:&apos;row&apos;,</div><div class="line">    &#125;,</div><div class="line">    bg:&#123;</div><div class="line">        backgroundColor:&apos;#FF0067&apos;,</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">module.exports = styles;</div></pre></td></tr></table></figure>
<p>通过import进行引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import styles from &apos;./styles/style&apos;;</div></pre></td></tr></table></figure></p>
<h2 id="常见的属性及说明"><a href="#常见的属性及说明" class="headerlink" title="常见的属性及说明"></a>常见的属性及说明</h2><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">backgroundColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 background-color 属性</td>
</tr>
</tbody>
</table>
<h3 id="2-宽高尺寸"><a href="#2-宽高尺寸" class="headerlink" title="2.宽高尺寸"></a>2.宽高尺寸</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">width</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 width 属性</td>
</tr>
<tr>
<td style="text-align:center">height</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 height 属性</td>
</tr>
</tbody>
</table>
<h3 id="3-外边距相关-margin"><a href="#3-外边距相关-margin" class="headerlink" title="3.外边距相关(margin)"></a>3.外边距相关(margin)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">margin</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白</td>
</tr>
<tr>
<td style="text-align:center">marginHorizontal</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置marginRight和marginLeft</td>
</tr>
<tr>
<td style="text-align:center">marginVertical</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置marginTop和marginBottom</td>
</tr>
<tr>
<td style="text-align:center">marginTop</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-top 属性</td>
</tr>
<tr>
<td style="text-align:center">marginRight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-right 属性</td>
</tr>
<tr>
<td style="text-align:center">marginBottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">marginLeft</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 margin-left 属性</td>
</tr>
</tbody>
</table>
<h3 id="4-内边距相关-padding"><a href="#4-内边距相关-padding" class="headerlink" title="4.内边距相关(padding)"></a>4.内边距相关(padding)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">padding</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白</td>
</tr>
<tr>
<td style="text-align:center">paddingHorizontal</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft</td>
</tr>
<tr>
<td style="text-align:center">paddingVertical</td>
<td style="text-align:center">number</td>
<td style="text-align:center">CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom</td>
</tr>
<tr>
<td style="text-align:center">paddingTop</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-top 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingRight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-right 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingBottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">paddingLeft</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 padding-left 属性</td>
</tr>
</tbody>
</table>
<h3 id="5-边框相关-border"><a href="#5-边框相关-border" class="headerlink" title="5.边框相关(border)"></a>5.边框相关(border)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">borderStyle</td>
<td style="text-align:center">solid, dotted, dashed</td>
<td style="text-align:center">对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性</td>
</tr>
<tr>
<td style="text-align:center">borderWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRightWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-right-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderLeftWidth</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-left-width 属性</td>
</tr>
<tr>
<td style="text-align:center">borderColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-top-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRightColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-right-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderLeftColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 border-left-color 属性</td>
</tr>
<tr>
<td style="text-align:center">borderRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopLeftRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-left-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderTopRightRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-top-right-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomLeftRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-left-radius 属性</td>
</tr>
<tr>
<td style="text-align:center">borderBottomRightRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 border-bottom-right-radius 属性</td>
</tr>
</tbody>
</table>
<h3 id="6-位置相关-position"><a href="#6-位置相关-position" class="headerlink" title="6.位置相关(position)"></a>6.位置相关(position)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">position</td>
<td style="text-align:center">absolute, relative</td>
<td style="text-align:center">对应 CSS 中的 position 属性，但阉割了 static, fixed 取值</td>
</tr>
<tr>
<td style="text-align:center">top</td>
<td style="text-align:center">number&gt;</td>
<td style="text-align:center">对应 CSS 中的 top 属性</td>
</tr>
<tr>
<td style="text-align:center">right</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 right 属性</td>
</tr>
<tr>
<td style="text-align:center">bottom</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 bottom 属性</td>
</tr>
<tr>
<td style="text-align:center">left</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 left 属性</td>
</tr>
</tbody>
</table>
<h3 id="7-文本相关-Text"><a href="#7-文本相关-Text" class="headerlink" title="7.文本相关(Text)"></a>7.文本相关(Text)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 color 属性</td>
</tr>
<tr>
<td style="text-align:center">fontFamily</td>
<td style="text-align:center">string</td>
<td style="text-align:center">对应 CSS 中的 font-family 属性</td>
</tr>
<tr>
<td style="text-align:center">fontSize</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 font-size 属性</td>
</tr>
<tr>
<td style="text-align:center">fontStyle</td>
<td style="text-align:center">normal, italic</td>
<td style="text-align:center">对应 CSS 中的 font-style 属性，但阉割了 oblique 取值</td>
</tr>
<tr>
<td style="text-align:center">fontWeight</td>
<td style="text-align:center">normal, bold 100~900</td>
<td style="text-align:center">对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值</td>
</tr>
<tr>
<td style="text-align:center">lineHeight</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 line-height 属性</td>
</tr>
<tr>
<td style="text-align:center">textAlign</td>
<td style="text-align:center">auto, left, right, center, justifyiOS</td>
<td style="text-align:center">对应 CSS 中的 text-align 属性，增加了 auto 取值</td>
</tr>
<tr>
<td style="text-align:center">textAlignVertical<sup>Android</sup></td>
<td style="text-align:center">auto, top, bottom, center</td>
<td style="text-align:center">对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub 等值</td>
</tr>
<tr>
<td style="text-align:center">textShadowColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 text-shadow 属性中的颜色定义</td>
</tr>
<tr>
<td style="text-align:center">textShadowOffset</td>
<td style="text-align:center">{width: number, height: number}</td>
<td style="text-align:center">对应 CSS 中的 text-shadow 属性中的阴影偏移定义</td>
</tr>
<tr>
<td style="text-align:center">textShadowRadius</td>
<td style="text-align:center">number</td>
<td style="text-align:center">在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义</td>
</tr>
<tr>
<td style="text-align:center">letterSpacing<sup>iOS</sup></td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 letter-spacing 属性，但取值不同</td>
</tr>
<tr>
<td style="text-align:center">textDecorationColor<sup>iOS</sup></td>
<td style="text-align:center">color</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-color 属性</td>
</tr>
<tr>
<td style="text-align:center">textDecorationLine<sup>iOS</sup></td>
<td style="text-align:center">none, underline, line-through, underline line-through</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值</td>
</tr>
<tr>
<td style="text-align:center">textDecorationStyle<sup>iOS</sup></td>
<td style="text-align:center">solid, double, dotted, dashed</td>
<td style="text-align:center">对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值</td>
</tr>
<tr>
<td style="text-align:center">writingDirection<sup>iOS</sup></td>
<td style="text-align:center">auto, ltr, rtl</td>
<td style="text-align:center">对应 CSS 中的 direction 属性，增加了 auto 取值</td>
</tr>
</tbody>
</table>
<h3 id="8-弹性布局相关-Flex"><a href="#8-弹性布局相关-Flex" class="headerlink" title="8.弹性布局相关(Flex)"></a>8.弹性布局相关(Flex)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flex</td>
<td style="text-align:center">number</td>
<td style="text-align:center">对应 CSS 中的 flex 属性</td>
</tr>
<tr>
<td style="text-align:center">flexDirection</td>
<td style="text-align:center">row, column</td>
<td style="text-align:center">对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值</td>
</tr>
<tr>
<td style="text-align:center">flexWrap</td>
<td style="text-align:center">wrap, nowrap</td>
<td style="text-align:center">对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值</td>
</tr>
<tr>
<td style="text-align:center">justifyContent</td>
<td style="text-align:center">flex-start, flex-end, center, space-between, space-around</td>
<td style="text-align:center">对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。</td>
</tr>
<tr>
<td style="text-align:center">alignItems</td>
<td style="text-align:center">flex-start, flex-end, center, stretch</td>
<td style="text-align:center">对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。</td>
</tr>
<tr>
<td style="text-align:center">alignSelf</td>
<td style="text-align:center">auto, flex-start, flex-end, center, stretch</td>
<td style="text-align:center">对应 CSS 中的 align-self 属性，但阉割了 baseline 取值</td>
</tr>
</tbody>
</table>
<h3 id="9-转换相关-transform"><a href="#9-转换相关-transform" class="headerlink" title="9.转换相关(transform)"></a>9.转换相关(transform)</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">transform</td>
<td style="text-align:center">[{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}]</td>
<td style="text-align:center">对应 CSS 中的 transform 属性</td>
</tr>
<tr>
<td style="text-align:center">transformMatrix</td>
<td style="text-align:center">TransformMatrixPropType</td>
<td style="text-align:center">类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数</td>
</tr>
<tr>
<td style="text-align:center">backfaceVisibility</td>
<td style="text-align:center">visible, hidden</td>
<td style="text-align:center">对应 CSS 中的 backface-visibility 属性</td>
</tr>
</tbody>
</table>
<h3 id="10-图片相关"><a href="#10-图片相关" class="headerlink" title="10.图片相关"></a>10.图片相关</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">resizeMode</td>
<td style="text-align:center">cover, contain, stretch</td>
<td style="text-align:center">contain是指无论如何图片都包含在指定区域内，假设设置的宽度高度比图片大，则图片居中显示，否则，图片等比缩小显示</td>
</tr>
<tr>
<td style="text-align:center">overflow</td>
<td style="text-align:center">visible, hidden</td>
<td style="text-align:center">超出部分是否显示，hidden为隐藏</td>
</tr>
<tr>
<td style="text-align:center">tintColor</td>
<td style="text-align:center">number</td>
<td style="text-align:center">着色，rgb字符串类型</td>
</tr>
<tr>
<td style="text-align:center">opacity</td>
<td style="text-align:center">number</td>
<td style="text-align:center">透明度</td>
</tr>
</tbody>
</table>
<h3 id="11-图像变换"><a href="#11-图像变换" class="headerlink" title="11.图像变换"></a>11.图像变换</h3><table>
<thead>
<tr>
<th style="text-align:center">属性名称</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">对应css属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">rotation</td>
<td style="text-align:center">–</td>
<td style="text-align:center">旋转</td>
</tr>
<tr>
<td style="text-align:center">scaleX</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向缩放</td>
</tr>
<tr>
<td style="text-align:center">scaleY</td>
<td style="text-align:center">–</td>
<td style="text-align:center">垂直方向缩放</td>
</tr>
<tr>
<td style="text-align:center">translateX</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向平移</td>
</tr>
<tr>
<td style="text-align:center">translateY</td>
<td style="text-align:center">–</td>
<td style="text-align:center">水平方向平移</td>
</tr>
</tbody>
</table>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html">http://www.sguotao.com/ReactNative-2017-04-25-rn-css.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。&lt;/p&gt;
&lt;h2 id=&quot;引入样式的几种方法&quot;&gt;&lt;a href=&quot;#引入样式的几种方法&quot; class=&quot;headerlink&quot; title=&quot;引入样式的几种方法&quot;&gt;&lt;/a&gt;引入样式
    
    </summary>
    
      <category term="ReactNative" scheme="http://www.sguotao.com/categories/ReactNative/"/>
    
    
      <category term="ReactNative" scheme="http://www.sguotao.com/tags/ReactNative/"/>
    
      <category term="CSS" scheme="http://www.sguotao.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Android内存泄露</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2017-03-24-android-memory-leak.html"/>
    <id>http://www.sguotao.com/Android进阶-2017-03-24-android-memory-leak.html</id>
    <published>2017-03-24T02:27:04.000Z</published>
    <updated>2017-06-02T10:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存泄露与内存溢出"><a href="#内存泄露与内存溢出" class="headerlink" title="内存泄露与内存溢出"></a>内存泄露与内存溢出</h2><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露(Memory Leak)是指无用对象（不再使用的对象）持续占有内存，或者无用对象的内存得不到及时释放，从而造成内存空间得不到有效的利用。在Java中，内存泄露的原因，通常是长生命周期的对象，持有短生命周期对象的引用。在《深入理解Java虚拟机》中的解释是，当无用对象一直被有用对象引用，导致无用对象可达，JVM无法对无用对象完成回收。从而造成内存泄露。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170327149058275225194.png" alt="内存泄露"></p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出(Out of Memory)是指程序在运行过程中，无法申请到足够的的内存导致的一种错误。内存泄露是会导致内存溢出，但不是导致内存溢出的唯一原因。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170327149058290012605.png" alt="20170327149058290012605.png"></p>
<h2 id="Java中的内存泄露"><a href="#Java中的内存泄露" class="headerlink" title="Java中的内存泄露"></a>Java中的内存泄露</h2><h3 id="Java-内存分配"><a href="#Java-内存分配" class="headerlink" title="Java 内存分配"></a>Java 内存分配</h3><p>Java中的内存分配主要分三块，静态存储区，栈区和堆区。</p>
<ul>
<li>静态存储区，编译时分配，存在于程序的整个运行期间，主要用于存放静态数据和常量。</li>
<li>栈区，在方法执行时，用于存放方法内部的局部变量，方法结束后，内存释放。</li>
<li>堆区，通常用来存放new出来的对象，由JVM进行回收处理。</li>
</ul>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170329149077275371348.png" alt="20170329149077275371348.png"><br>从JDK1.2开始，Java将对象的引用分为了强引用、软引用、弱引用和虚引用。</p>
<ul>
<li>强引用(Strong Reference),平时使用最多的一种引用，<strong>如果一个对象的引用方式是强引用，垃圾回收器不会对该对象进行回收，即使出现了内存空间不足的情况，JVM会抛出Out of Memory,也不会对强引用的对象进行回收。</strong></li>
<li>软引用(Soft Reference),在对象的引用强度上若于强引用，对于弱引用的对象，<strong>当内存不足时，JVM会回收软引用对象，释放内存空间</strong>。通常情况下，缓存的创建，适合使用软引用的方式。</li>
<li>弱引用(Weak Reference),在对象的引用强度上，弱于软引用，相对于强引用对象的不可回收，弱引用的对象，不存在这种情况，<strong>在垃圾回收器工作时，不论内存空间是否充足，都会对弱引用的对象进行回收。</strong>弱引用的作用，主要在于解决强引用对象之前的耦合关系，如在集合类中，任何Java对象都可以作为键来使用，当一个键值对被放入到集合中，集合对象本身就对这些键和值产生引用，如果是强引用，只要集合对象本身存在，其中包含的键和值就不会被回收，当集合包含的键和值越来越多时，最后会消耗掉JVM中的全部内存。</li>
<li>虚引用(Phantom Reference)，使用的情况并不多见，主要用来实现比较清晰的内存控制，这对于内存有限的移动设备是很有意义的。<strong>虚引用用来跟踪对象被垃圾回收器回收的活动</strong>，虚引用和软引用，弱引用的一个明显的区别是，虚引用必须和引用队列联合使用，通过检查引用队列中的内容，可以判断一个对象是否即将被回收。</li>
</ul>
<p>一个对象的引用类型有多个，怎么判断？<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170329149077630884381.png" alt="20170329149077630884381.png"><br>判定规则如下：</p>
<ul>
<li>单条引用链上的可达性，以最弱的一个引用类型来决定；</li>
<li>多条引用链上的可达性，以最强的一个引用类型来决定；</li>
</ul>
<p>我们假设上图中，1和3为强引用，5为软引用，7为弱引用。对于对象5的引用类型，在路径1–5中，5为软引用类型，依据规则1，对象5为软引用类型。在路径3–7中，7为弱引用类型，所以对象5为弱引用类型。依据规则2，多条引用链上的可达性，以最强的一个引用类型决定，因此，对象5的引用类型为软引用类型。</p>
<h2 id="内存泄露检测工具"><a href="#内存泄露检测工具" class="headerlink" title="内存泄露检测工具"></a>内存泄露检测工具</h2><h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><p>Memory Monitors是AndroidStudio自带的一个性能检测工具，主要包含以下几个功能：</p>
<ul>
<li>实时查看app的内存使用情况；</li>
<li>能够比较直观的了解到app的运行卡顿是否跟GC的频繁操作有关；</li>
<li>能够了解到app的crash是否跟内存溢出有关；</li>
<li>能够发现内存抖动(在短时间内分配大量内存，频繁的引起GC操作)</li>
</ul>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170401149101636441749.png" alt="20170401149101636441749.png"></p>
<h3 id="DDMS-Dump"><a href="#DDMS-Dump" class="headerlink" title="DDMS Dump"></a>DDMS Dump</h3><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017040114910150822979.png" alt="2017040114910150822979.png"><br><strong>什么是Java Heap Dump？</strong>首先需要搞明白什么是Java Heap，Java Heap是分配给实例类和数组对象运行数据区，所有Java线程在运行期间共享heap中的数据，Java Heap Dump相当于在应用运行时，某个时间点进行一次快照，在AndroidStudio中，快照会被保存为.hprof类型的文件，保存在captures目录中。</p>
<p>分析.hprof文件，我们可以将.hprof视图分成A、B、C三个部分，在A部分中，可以看到app的整个堆内存信息，显示了在堆内存中的所有的java类。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Total Count</td>
<td style="text-align:center">内存中，当前Java类的实例数量</td>
</tr>
<tr>
<td style="text-align:center">Heap Count</td>
<td style="text-align:center">堆内存中，当前Java类的实例数量</td>
</tr>
<tr>
<td style="text-align:center">Size of</td>
<td style="text-align:center">当前Java类每个实例对象需要占用内存的物理大小</td>
</tr>
<tr>
<td style="text-align:center">Shallow Size</td>
<td style="text-align:center">当前Java实例对象占有的内存大小</td>
</tr>
<tr>
<td style="text-align:center">Retained Size</td>
<td style="text-align:center">释放当前Java实例对象后，节省的内存大小</td>
</tr>
</tbody>
</table>
<p>当选中A区域中的某个Java类，可以在B区域中看到选中Java类的所有实例对象。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Depth</td>
<td style="text-align:center">当前对象的深度</td>
</tr>
<tr>
<td style="text-align:center">Shallow Size</td>
<td style="text-align:center">当前对象占有的内存大小</td>
</tr>
<tr>
<td style="text-align:center">Dominating Size</td>
<td style="text-align:center">当前对象可支配的内存大小</td>
</tr>
</tbody>
</table>
<p>在B中看到选中Java类的所有实例对象的同时，在C区域能够看到哪些对象引用了该对象。</p>
<p><strong>什么是Allocation Tracker？</strong>Allocation Tracker主要用来追踪内存分配信息，Start Allocation Tracking 相当于在程序运行时，某个时间节点，对内存分配信息进行一次快照，生成的快照文件被保存为.alloc类型，保存在captures目录中。Allocation Tracker 也可以在Devices Monitor中启动，在Devices Monitor中使用时，需要设备有Root权限。</p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT(Eclipse Memory Analyzer)是一个堆转储文件分析工具，在Monitor的快照文件(.hprof)，需要转换成MAT可以打开的标准.hprof文件，使用Mat工具打开转换后的.hprof文件，会生成一个内存消耗整体状况的报告，从饼状图中，可以比较直观地看到哪些对象占用了多少的内存空间。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170419149258510813625.png" alt="20170419149258510813625.png"><br>这里介绍一下，MAT给我们提供的几个分析的维度。</p>
<ul>
<li>Histogram，在该视图中可以清晰的看出内存中对象的数量，及所占用内存空间的大小。</li>
<li>Dominator Tree:在该视图中，可以在线程的角度观察到哪些对象占用内存空间。</li>
<li>Top Consumers:从包，对象等角度，显示内存的占用情况，能够比较直观的找出占用内存比较多的对象。</li>
<li>Leak Suspects:分析内存泄露的情况，生成一份报表，给出一些problem的建议。</li>
</ul>
<p>下面介绍一些常用的操作，视图中支持正则表达式筛选，可以过滤出我们比较关心的对象，可以以列表或者树形的结构显示出来，其中：</p>
<ul>
<li>with incoming references:过滤出那些类引用了当前选中的类；</li>
<li>with outcoming references:过滤出当前选中类引用了哪些类；</li>
</ul>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/2017042014926559112895.png" alt="2017042014926559112895.png"></p>
<p>垃圾回收器会对虚拟机的内存空间，即堆空间中已经存在的对象进行识别，如果对象正在被引用，那么称其为存活对象，如果对象不在被引用，则为垃圾回收器回收的对象，这部分对象占用的内存空间可以被回收。</p>
<p>在垃圾回收机制中有一组元素被称为根元素集合，它们是一组被虚拟机直接引用的对象。堆空间中的每个对象都是由一个根元素为起点被层层调用的。所以，一个对象如果被一个存活的根元素所引用，就会被认为是存活对象，不能被回收。这时，可以通过分析一个对象到根元素的引用路径来分析该对象为什么不能够被顺利回收。</p>
<p>当选中某个对象，通过Merge Shortest Paths to GC Root的操作，可以显示对象之间的排除了软引用，弱引用和虚引用的引用关系，这样我们看到的就是被选中对象是否还存在强引用，通过分析 ，能够直接找到内存没有释放的原因。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170420149269042589662.png" alt="20170420149269042589662.png"></p>
<h2 id="开发中常见内存泄露的场景"><a href="#开发中常见内存泄露的场景" class="headerlink" title="开发中常见内存泄露的场景"></a>开发中常见内存泄露的场景</h2><h3 id="1-Context对象使用不当；"><a href="#1-Context对象使用不当；" class="headerlink" title="1.Context对象使用不当；"></a>1.Context对象使用不当；</h3><p>在Android中经常使用的单例模式，如果使用不当，会出现内存泄露，泄露的主要原因是因为，单例模式中的静态成员变量的生命周期与应用的生命周期一样长。比较常见的场景是，经常在一些工具类中使用单例模式，如xxManager,xxHelper，xxUtils,这些工具类中需要使用Context,由于Activity是间接继承Context，当Activity退出时，单例对象中持有了它的引用，导致Activity回收失败，从而出现内存泄露。处理方式是使用Application,由于Application的生命周期贯穿整个应用，所以当这些工具类需要使用到Context时，使用getApplication()或者getApplicationContext()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">    public class Util &#123;</div><div class="line">        private Context mContext;</div><div class="line">        private static Util sInstance;</div><div class="line"></div><div class="line">        private Util(Context context) &#123;</div><div class="line">            this.mContext = context;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public static Util getInstance(Context context) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">//                sInstance = new Util(context);</div><div class="line">                sInstance = new Util(context.getApplicationContext());</div><div class="line">            &#125;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2-内部类使用不当"><a href="#2-内部类使用不当" class="headerlink" title="2.内部类使用不当"></a>2.内部类使用不当</h3><p>当使用非静态的内部类时，如果出现内部类持有外部类的引用，就会出现内存泄露，优化方法，可以使用静态的内部类，这样内部类就不在持有外部类的引用，不会影响GC对于外部类的回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 静态成员变量</div><div class="line">     */</div><div class="line">    public static InnerClass innerClass = null;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_my);</div><div class="line"></div><div class="line">        innerClass = new InnerClass();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class InnerClass &#123;</div><div class="line"></div><div class="line">        public void doSomeThing() &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Handler的异步消息通信"><a href="#3-Handler的异步消息通信" class="headerlink" title="3.Handler的异步消息通信"></a>3.Handler的异步消息通信</h3><p>在使用Handler时出现内存泄露的主要原因是Handler的生命周期与Activity的生命周期不一致，当应用启动时，创建UI主线程Looper对象，Looper实现了简单的消息队列，主线程Looper对象存在整个应用的生命周期中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class HandlerActivity extends Activity &#123;</div><div class="line"></div><div class="line">    private final Handler mHandler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            // ...</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mHandler.sendMessageDelayed(Message.obtain(), 10*000);</div><div class="line">        finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当在Actiivity中使用Handler时，就可能会产生内存泄露，究其根本原因，是我们使用的非静态内部类(或者匿名内部类)默认隐性持有外部类的引用，静态内部类不会持有外部类的引用。在Activity结束时，由于Message是延迟消息，会在主线程的消息队列中，该消息持有Activity中的Handler的引用，Handler默认持有Activity的引用，直至该消息被处理完。此时导致Activity对象无法被回收，就会出现内存泄露。优化方法，可以使用静态内部类继承Handler对象，或者在Activity的onDestory()方法中，调用mHandler.removeCallbacksAndMessages(null);</p>
<h3 id="4-Bitmap使用不当"><a href="#4-Bitmap使用不当" class="headerlink" title="4.Bitmap使用不当"></a>4.Bitmap使用不当</h3><p>使用Bitmap如果回收不及时，也会出现内存泄露。原因在于Bitmap类没有对外创建对象的构造方法，获得Bitmap对象只能通过BitmapFactory中的各种静态方法，生成Bitmap对象是通过JNI调用底层c来实现的。所以，当我们获取一个Bitmap对象时，其对应的内存中包含两部分内容，一部分是Java，一部分是c,Java部分的内存可以通过GC进行回收，但是c部分的内存GC是不会进行自动回收的，所以，我们在使用Bitmap对象时，需要调用recycle()来主动释放c部分的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 判断是否已经回收</div><div class="line">if(bitmap != null &amp;&amp; !bitmap.isRecycled())&#123; </div><div class="line">        // 回收并且置为null</div><div class="line">        bitmap.recycle(); </div><div class="line">        bitmap = null; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-资源性对象没有及时关闭"><a href="#5-资源性对象没有及时关闭" class="headerlink" title="5.资源性对象没有及时关闭"></a>5.资源性对象没有及时关闭</h3><p>当我们使用一些资源性对象时，如果没有做关闭操作，也会出现内存泄露，常见的资源性对象包括(Cursor、ContentProvider、File、Stream)等。还有一类如EventBus、BroadCastReceiver在注册后，为了避免重复注册，需要在退出时及时的销毁。</p>
<h3 id="6-集合列表相关"><a href="#6-集合列表相关" class="headerlink" title="6.集合列表相关"></a>6.集合列表相关</h3><p>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。</p>
<h3 id="7-Native中存在内存泄露"><a href="#7-Native中存在内存泄露" class="headerlink" title="7.Native中存在内存泄露"></a>7.Native中存在内存泄露</h3><p>由于Native层的代码多用c或c++来实现，GC无法对这部分内存进行会后处理，这时可能会出现内存泄露，这时候就需要c工程师帮助分析，如Malloc的内存是否做了free处理，指针使用完成后，是否进行了置空处理等等。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="http://www.jianshu.com/p/e97ed5d8a403" target="_blank" rel="external">科普：内存泄漏与内存溢出</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank" rel="external">Java的内存泄漏</a></li>
<li><a href="https://segmentfault.com/a/1190000006852540" target="_blank" rel="external">Android 内存泄露总结</a></li>
<li><a href="https://segmentfault.com/a/1190000003910496" target="_blank" rel="external">Java四种引用类型</a></li>
<li><a href="http://blog.csdn.net/itomge/article/details/48719527" target="_blank" rel="external">MAT使用教程</a></li>
</ol>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2017-03-24-android-memory-leak.html">http://www.sguotao.com/Android进阶-2017-03-24-android-memory-leak.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存泄露与内存溢出&quot;&gt;&lt;a href=&quot;#内存泄露与内存溢出&quot; class=&quot;headerlink&quot; title=&quot;内存泄露与内存溢出&quot;&gt;&lt;/a&gt;内存泄露与内存溢出&lt;/h2&gt;&lt;h3 id=&quot;内存泄露&quot;&gt;&lt;a href=&quot;#内存泄露&quot; class=&quot;headerli
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="内存泄露" scheme="http://www.sguotao.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="MAT" scheme="http://www.sguotao.com/tags/MAT/"/>
    
  </entry>
  
  <entry>
    <title>Android动态加载机制</title>
    <link href="http://www.sguotao.com/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6-2017-03-17-classloader.html"/>
    <id>http://www.sguotao.com/插件框架-2017-03-17-classloader.html</id>
    <published>2017-03-17T02:27:04.000Z</published>
    <updated>2017-06-02T10:39:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java的类加载机制ClassLoader"><a href="#Java的类加载机制ClassLoader" class="headerlink" title="Java的类加载机制ClassLoader"></a>Java的类加载机制ClassLoader</h2><p>我们编写的java代码，最终会编译成.class字节码的形式，一个完整的Java程序，通常会由若干个.class文件组成，在程序运行时，通过该程序的入口函数来调用系统的各个功能，但是程序启动时，并不会一次性将.class文件加载到内存中，根据程序的需要，通过Java的类加载机制来动态加载.class文件，ClassLoader就是来实现.class文件的动态加载的。</p>
<h2 id="Java中各类加载器的关系"><a href="#Java中各类加载器的关系" class="headerlink" title="Java中各类加载器的关系"></a>Java中各类加载器的关系</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974200061820.png" alt="20170317148974200061820.png"><br>Java默认会提供三个类加载器，分别为BootStrapClassLoader,ExtClassLoader和AppClassLoader;</p>
<ul>
<li>BootStrapLoader，启动类加载器，是Java类加载层次中最顶层的类加载器，由c代码编写，负责加载JDK中的核心类库（包括JRE classes目录下的.class文件，libs目录下的jar文件）。可以使用System.getProperty(“sun.boot.class.path”)来显示BootStrapLoader加载的jar和.class文件；</li>
<li>ExtClassLoader,扩展类加载器，负责加载Java的扩展类库，默认加载/jre/lib/ext目录下的所有jar和.class文件。可以通过可以使用System.getProperty(“java.ext.dirs”)来显示ExtClassLoader加载的jar和.class文件；</li>
<li>AppClassLoader,系统类加载器，负责加载classpath目录下所有的jar和class文件。</li>
</ul>
<h2 id="Java类加载的实现过程"><a href="#Java类加载的实现过程" class="headerlink" title="Java类加载的实现过程"></a>Java类加载的实现过程</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974217438657.jpg" alt="20170317148974217438657.jpg"></p>
<ul>
<li>执行程序代码，找到JRE所在目录；</li>
<li>找到jvm.dll(Windows)或者libjvm.so(Linux);</li>
<li>启动JVM，并进行初始化工作</li>
<li>创建BootStrapClassLoader;</li>
<li>BootStrapClassLoader会加载ExtClassLoader，并设定ExtClassLoader的parent为BootStrapClassLoader;</li>
<li>BootStrapClassLoader会加载AppClassLoader,并设定AppClassLoader的parent为ExtClassLoader;</li>
</ul>
<p>当AppClassLoader开始加载xxx.class时，类加载器会现将加载的任务交给其parent来完成，如果parent找不到，则自己负责加载。所以在加载xxx.class时的顺序是，BootstrapClassLoader –&gt; ExtClassLoader –&gt; AppClassLoader，如果都找不到，则抛出ClassNotFoundException。这就是非常有名的双亲委托模型。</p>
<p>使用双亲委托模型，有效地解决了.class字节码重复加载的问题，当parent已经加载类某各类的.class字节码时，子类就没有必要再重新进行加载。举个例子，来说明一下双亲委托模型。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170317148974220124844.png" alt="20170317148974220124844.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 取得SomeClass的Class实例</div><div class="line">   Class c = Class.forName(&quot;SomeClass&quot;);</div><div class="line">   // 取得ClassLoader</div><div class="line">   ClassLoader loader = c.getClassLoader();</div><div class="line">   System.out.println(loader);</div><div class="line">   // 取得父ClassLoader</div><div class="line">   System.out.println(loader.getParent());</div><div class="line">   // 再取得父ClassLoader</div><div class="line">   System.out.println(loader.getParent().getParent());</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher\$AppClassLoader@19821f</div><div class="line">sun.misc.Launcher\$ExtClassLoader@addbf1</div><div class="line">null</div></pre></td></tr></table></figure>
<p>由于SomeClass是自定义的一个Java类，通常会java.class.path中产生字节码，首先AppClassLoader会将加载的任务交给其parent,ExtClassLaoder,ExtClassLoader将加载任务交给其parent，BootStrapClassLoader,由于BootStrapLoader在其目录(sun.boot.class.path)下没有找到该类的字节码，所以由ExtClassLoader来加载，ExtClassLoader在其目录(java.ext.dirs)也没有发现SomeClass的字节码，交给AppClassLoader进行加载，AppClassLoader在(java.class.path)中找到，并进行加载。</p>
<p>加载SomeClass的ClassLoader是AppClassLoader,其parent是ExtClassLoader,<br>而ExtClassLoader的parent是null，这是因为BootStrapClassLoader是由c代码编写的，在JVM中并没有对应的实例对象，所以显示为null。</p>
<h2 id="Dalvik与JVM"><a href="#Dalvik与JVM" class="headerlink" title="Dalvik与JVM"></a>Dalvik与JVM</h2><p>在Java中，把一些Java类编译成.class文件，通过ClassLoader进行加载，但是在Android上边，情况有所不同，主要的原因在于Android中使用的虚拟机是Dalvik。Android中的Dalvik和Java中的JVM都是将对应的Java类加载到内存中运行。不同的是JVM加载的是.class字节码文件，或是通过defineClass方式产生class，进行加载。Dalvik加载的是.dex文件，.dex文件是Android对.class文件进行了优化，更加适合内存和处理器有限的系统。</p>
<ul>
<li>Dalvik是基于寄存器的，而JVM是基于栈的。</li>
<li>Dalvik运行dex文件，而JVM运行java字节码</li>
<li>自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。</li>
</ul>
<p>很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。2014年6月25日,Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。ART,即Android Runtime。ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time,JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time)。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<h2 id="DexClassLoader与PathClassLoader"><a href="#DexClassLoader与PathClassLoader" class="headerlink" title="DexClassLoader与PathClassLoader"></a>DexClassLoader与PathClassLoader</h2><p>在使用Java虚拟机时，我们经常自定义继承自ClassLoader的类加载器。然后通过defineClass方法来从一个二进制流中加载Class。而在Android中我们无法这么使用，Android中ClassLoader的defineClass方法具体是调用VMClassLoader的defineClass本地静态方法。而这个本地方法什么都没做，只是抛出了一个“UnsupportedOperationException”异常。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</div><div class="line">        <span class="keyword">throws</span> ClassFormatError</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"can't load this type of class file"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>既然在Dalvik虚拟机里，ClassLoader不好用，那么Android官方为了解决这个问题，帮我们从ClassLoader中派生出了两个类：DexClassLoader和PathClassLoader。先来看一下DexClassLoader和PahtClassLoader的继承关系。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170322149015010153287.png" alt="20170322149015010153287.png"></p>
<h3 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h3><p>DexClassLoader可以加载jar,apk,dex,可以从SD卡进行加载，可以实现dex的动态加载与更新，DexClassLoader要有一个app私有且可写的目录来存储经过优化的.odex文件。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *</div><div class="line">		 * <span class="doctag">@param</span> dexPath .dex文件路径,多个文件路径使用':'分隔</div><div class="line">		 * <span class="doctag">@param</span> optimizedDirectory .dex文件优化后生成的.odex文件的路径</div><div class="line">		 * <span class="doctag">@param</span> librarySearchPath 动态库路径</div><div class="line">		 * <span class="doctag">@param</span> parent 双亲委派模式,指定父类加载器</div><div class="line">		 */</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h3><p>PathClassLoader只能加载已经安装的apk文件。Android系统默认使用的类加载器。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *</div><div class="line">		 * <span class="doctag">@param</span> dexPath .dex文件路径</div><div class="line">		 * <span class="doctag">@param</span> librarySearchPath 本地库路径</div><div class="line">		 * <span class="doctag">@param</span> parent 双亲委派模式,指定父类加载器</div><div class="line">		 */</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="DexClassLoader与PathClassLoader的比较"><a href="#DexClassLoader与PathClassLoader的比较" class="headerlink" title="DexClassLoader与PathClassLoader的比较"></a>DexClassLoader与PathClassLoader的比较</h3><p>通过两个类加载构造函数的对比发现，区别在于DexClassLoader构造函数中的参数optimizedDirectory。Google官方文档中给出optimizedDirectory的说明是，用来存储经过优化后的.odex文件的路径。optimizedDirectory必须是一个内部存储路径，DexClassLoader可以通过构造函数指定optimizedDirectory，所以DexClassLoader可以实现动态加载，外部的.jar/.dex文件，优化后会存在在optimizedDirectory目录中。PathClassLoader由于没有指定该路径，所以只能加载内部的，已经安装的apk中的.odex文件。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170322149015373793574.png" alt="20170322149015373793574.png"></p>
<p>整个类加载过程可以简单描述为上面的时序图。ClassLoader在加载过程中，通过loadClass方法，调用BaseDexClassLoader中重载的findClass方法，该方法会遍历DexPathList列表。DexPathList的创建过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></div><div class="line">                              String libraryPath, ClassLoader parent) &#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">        <span class="keyword">this</span>.originalPath = dexPath;</div><div class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>optimizedDirectory用来缓存优化过的.odex文件，在DexClassLoader中可以通过构造函数进行制定，在PathClassLoader中，optimizedDirectory为null，会直接使用系统中已经安装的apk文件的.odex目录。DexPathList完整的创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></div><div class="line">                       String libraryPath, File optimizedDirectory) &#123;</div><div class="line">        ……</div><div class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</div><div class="line">                                             File optimizedDirectory) &#123;</div><div class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</div><div class="line">        <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">            ZipFile zip = <span class="keyword">null</span>;</div><div class="line">            DexFile dex = <span class="keyword">null</span>;</div><div class="line">            String name = file.getName();</div><div class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</div><div class="line">                dex = loadDexFile(file, optimizedDirectory);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</div><div class="line">                || name.endsWith(ZIP_SUFFIX)) &#123;</div><div class="line">                zip = <span class="keyword">new</span> ZipFile(file);</div><div class="line">            &#125;</div><div class="line">            ……</div><div class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</div><div class="line">                elements.add(<span class="keyword">new</span> Element(file, zip, dex));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException &#123;</div><div class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</div><div class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Converts a dex/jar file path and an output directory to an</div><div class="line">     * output file path for an associated optimized dex file.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">optimizedPathFor</span><span class="params">(File path,</span></span></div><div class="line">                                           File optimizedDirectory) &#123;</div><div class="line">        String fileName = path.getName();</div><div class="line">        <span class="keyword">if</span> (!fileName.endsWith(DEX_SUFFIX)) &#123;</div><div class="line">            <span class="keyword">int</span> lastDot = fileName.lastIndexOf(<span class="string">"."</span>);</div><div class="line">            <span class="keyword">if</span> (lastDot &lt; <span class="number">0</span>) &#123;</div><div class="line">                fileName += DEX_SUFFIX;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(lastDot + <span class="number">4</span>);</div><div class="line">                sb.append(fileName, <span class="number">0</span>, lastDot);</div><div class="line">                sb.append(DEX_SUFFIX);</div><div class="line">                fileName = sb.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        File result = <span class="keyword">new</span> File(optimizedDirectory, fileName);</div><div class="line">        <span class="keyword">return</span> result.getPath();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="http://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="external">深入分析Java ClassLoader原理</a><br>2.<a href="http://blog.csdn.net/irelandken/article/details/7048817" target="_blank" rel="external">分析BootstrapClassLoader/ExtClassLoader/AppClassLoader的加载路径 及”父委托机制”</a><br>3.<a href="https://openhome.cc/Gossip/JavaEssence/ClassLoader.html" target="_blank" rel="external">簡介類別載入器</a><br>4.<a href="http://www.infoq.com/cn/articles/android-in-depth-dalvik" target="_blank" rel="external">Java虚拟机Dalvik</a><br>5<a href="http://www.jianshu.com/p/669fc4858194" target="_blank" rel="external">Android动态加载——DexClassloader分析</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/插件框架-2017-03-17-classloader.html">http://www.sguotao.com/插件框架-2017-03-17-classloader.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java的类加载机制ClassLoader&quot;&gt;&lt;a href=&quot;#Java的类加载机制ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;Java的类加载机制ClassLoader&quot;&gt;&lt;/a&gt;Java的类加载机制ClassLoader&lt;/
    
    </summary>
    
      <category term="插件框架" scheme="http://www.sguotao.com/categories/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="JVM" scheme="http://www.sguotao.com/tags/JVM/"/>
    
      <category term="插件框架" scheme="http://www.sguotao.com/tags/%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ClassLoader" scheme="http://www.sguotao.com/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>怎样才能让别人觉得与你合作愉快</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2016-08-17-pleasure-working-with-you.html"/>
    <id>http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html</id>
    <published>2016-08-17T09:00:00.000Z</published>
    <updated>2017-06-02T10:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章作者：咪喵<br>文章来源： TalentGuide </p>
</blockquote>
<p>为什么有的人，明明事情做得不少，却永远没人说他好？有的人，不管做什么都得到周围人众口一词的称赞？</p>
<p>真的是因为两个人做的事差很多吗？也许是。<br>也许，只是一些小习惯改变了他们的口碑。</p>
<h2 id="1-收到请回答"><a href="#1-收到请回答" class="headerlink" title="1. 收到请回答"></a>1. 收到请回答</h2><p>一些人，交给他的事情永远没下文。你不知道他收到了没有，是不是正在做，已经做到了什么进展，啥时候能交付。即使这件事他已经做完了，不去问，他也永远不会告诉你。</p>
<ol>
<li>收到任务，请告诉对方“我收到了。”</li>
<li>需要时间消化，请告诉对方“我看一下，晚点（给出具体时间段更佳）给你答复。”</li>
<li>事情有进展时，及时周知相关人等最新进度。</li>
<li>事情完成时，通知相关方，并感谢在其中给过帮助的人。</li>
</ol>
<p>做到这些，不需要很多时间，却会让与你合作的人感到轻松愉快。</p>
<h2 id="2-要做就别抱怨"><a href="#2-要做就别抱怨" class="headerlink" title="2. 要做就别抱怨"></a>2. 要做就别抱怨</h2><p>有的人，接受任务时永远不情不愿，嘴里没完没了地抱怨，最后虽仍然接下了任务，却留下了难以合作的印象。</p>
<p>如果别人的行为确实给自己带来了麻烦或是有为难之处，可以清晰告知对方自己难做的原因，说清楚希望对方如何改进，并告知这样的改进会给双方带来什么好处。</p>
<p>比如对方总给你扔急活，你为了这个急活不得不加班加点，到处求人。正确的做法是<strong>告诉对方这件事有哪些环节，分别需要多长时间，以后请提早多少天告知，以便更好的完成。这次帮忙加急，下不为例</strong>。这样对方能理解你这次加急赶完是帮了他忙，而不会抱怨每次给你事情都推三阻四还完成得不好。</p>
<h2 id="3-推进事情要推到有进展才算数"><a href="#3-推进事情要推到有进展才算数" class="headerlink" title="3. 推进事情要推到有进展才算数"></a>3. 推进事情要推到有进展才算数</h2><p>有些人，推进一件事的方法是：每隔一段时间，发封不痛不痒的邮件，抄送所有人，摆个样子跟进一下，也不在乎对方是否给了结果。仿佛在说“你看，我推过了，是对方不给做，推不动不关我事哦。出了问题责任是他是他还是他。”</p>
<p>如果是自家孩子病了，有哪位家长会说“我给医生发邮件了，他没回我，所以病治不了了。”显然，孩子生病时家长都是心急火燎的，医生不在会找护士，找主管，找院长，找媒体。用尽一切可用的渠道，一切可用的方法，直到医生给孩子看病为止。</p>
<p>当说一件事情推不动时，扪心自问自己真的做到了像家长为生病的孩子找医生那样努力吗？真的已经用尽了一切可用的力量，找尽了一切可找的人去推动这件事吗？</p>
<p>装模作样推一推是没有意义的，一定要推到这件事有实质进展为止。<strong>实质进展是对方给排期、给解决方案、给具体处理这件事的人</strong>。如果什么都没拿到，那根本不算推进过一件事。</p>
<h2 id="4-做不到早说"><a href="#4-做不到早说" class="headerlink" title="4. 做不到早说"></a>4. 做不到早说</h2><p>有的人，交给他的事情，不问永远没问题，一问全是问题。拖过了截止期做不到，罗列出一堆原因，都是ABCDE的问题，与他无关。</p>
<p>OK，就算ABCDE的问题确实与他无关，为什么不能在发现有这些问题时及时反馈呢？自己解决不了的问题，及时反馈并暴露，让有能力解决的人去解决，是靠谱最重要的表现之一。</p>
<p>又有人说，我要是暴露了这些问题得罪了别人怎么办？请问不暴露这些问题，任由时间资源浪费，事情最终没做到，就谁都不得罪了吗？<strong>作为一个团队，成事是最重要的。暴露问题是为了解决问题，而不是为了挑事，关键是把握分寸</strong>。</p>
<p>还有人说，跟别人没关系，就是堆给我的活太多了，我做不完怎么办？如果是这种情况，更要尽早反馈了。或许你花了大量时间在一件优先级比较低的事情上，导致最重要的事情没有做完。结果把自己累得半死，还谁都不满意。<strong>发现自己做不完，就要第一时间跟相关方确认优先级，力保最重要的事情能够及时完成。如果被插入了其他优先级更高的事，也要尽快知会事情被推迟的相关方</strong>。</p>
<h2 id="5-功劳是大家的"><a href="#5-功劳是大家的" class="headerlink" title="5. 功劳是大家的"></a>5. 功劳是大家的</h2><p>有些人，干活的时候一天八回地狂催别人。活干完了，人没影了，汇报工作成果时只字不提其他人，仿佛活全是他自己一人干的。这样的人，执行力再好，下次再找人干活时，也难得到别人心甘情愿的帮忙。</p>
<p><strong>无论别人是帮了多小的忙，在事情结束后也要表示感谢</strong>。道谢要不嫌隆重，能当面谢的尽量当面去谢，能单独打电话谢的就不要讲其他事情时顺便谢，发邮件表示感谢的话尽量抄送对方老板详细说明感谢的事由。这些事情并不费劲，却会让别人更愿意帮助你。</p>
<h2 id="6-别吐槽，给解决方案"><a href="#6-别吐槽，给解决方案" class="headerlink" title="6. 别吐槽，给解决方案"></a>6. 别吐槽，给解决方案</h2><p>有的人，你一找他解决问题，就开启吐槽模式，内容全是“我有多辛苦多不容易，能做的我都做了，这些问题全是因为balabala……”</p>
<p>每当这时我都好想告诉对方“亲，没有人关心你的心路历程。”我不关心你有多辛苦多不容易你做了多少事情，为什么别人就是没按照你设定的剧本做。我只知道现在有一个问题，我找你只想知道“怎样解决这个问题”。</p>
<p><strong>当有一个问题时，请直奔主题，给解决方案</strong>。</p>
<h2 id="7-敢作敢当"><a href="#7-敢作敢当" class="headerlink" title="7. 敢作敢当"></a>7. 敢作敢当</h2><p>当事情搞砸时，最次的做法是想尽办法推卸责任，最好的做法是<strong>诚恳道歉，评估影响范围，想尽办法用最快速度修正错误，弥补损失</strong>。</p>
<p>不要耍滑头，得意于自己把责任都推出去了，推卸得越成功，实际越失败。不要怕承担，勇于承担责任的人，别人才敢赋予你更大的责任。</p>
<h2 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h2><p>做到上面这些条，说难不难，说易也不易。说白了，就是要多操些心，多费些力。</p>
<p>有的人说一份工作而已，干嘛把自己搞这么累。我就做好自己这部分，别人的事我不管，跟我没关系，只要出事了别怪我头上就行。当然，若真这么想，没什么不行的，您高兴就好。只是请不要再抱怨为什么自己怀才不遇，升职加薪总是比别人慢。多劳多得，很公平，不是么？</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html">http://www.sguotao.com/生活感悟-2016-08-17-pleasure-working-with-you.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章作者：咪喵&lt;br&gt;文章来源： TalentGuide &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么有的人，明明事情做得不少，却永远没人说他好？有的人，不管做什么都得到周围人众口一词的称赞？&lt;/p&gt;
&lt;p&gt;真的是因为两个人做的事差很多吗？也
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android动画分析二 Drawable Animation</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-05-19-android-drawable-animation.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-05-19-android-drawable-animation.html</id>
    <published>2016-05-19T02:27:04.000Z</published>
    <updated>2017-06-07T09:23:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中对Android传统动画中的View动画进行了一些整理，<a href="/Android%E8%BF%9B%E9%98%B6-2016-05-18-android-view-animation.html">Android动画分析一 View Animation</a> 在这一篇中，将对Android传统动画中的Drawable动画进行整理。什么是Drawable动画，Drawable动画是将一些列的Drawable资源一个接一个的播放，从而产生动画的效果，可以理解为是Frame Animation。</p>
<h2 id="Drawable-Animation"><a href="#Drawable-Animation" class="headerlink" title="Drawable Animation"></a>Drawable Animation</h2><p>这里介绍实现Drawable Animation的两种方式，一种是使用&lt;animation-list&gt;标签，一种是使用AnimationDrawable对象。</p>
<h3 id="Drawable动画的示例"><a href="#Drawable动画的示例" class="headerlink" title="Drawable动画的示例"></a>Drawable动画的示例</h3><p>在res/drawable目录下定义一个动画文件(<strong>注:不是res/anim目录</strong>)，文件的根节点是&lt;animation-list&gt;其中android:oneshot属性当值为true时,动画只执行一次，当值为false时，动画重复执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:oneshot=&quot;false&quot;&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/upgrade_notification01&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/upgrade_notification02&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/upgrade_notification03&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/upgrade_notification04&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/upgrade_notification05&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/upgrade_notification06&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">&lt;/animation-list&gt;</div></pre></td></tr></table></figure></p>
<p>在Activity中处理的逻辑:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ImageView imageView;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_test_view_animation);</div><div class="line"></div><div class="line">        imageView = (ImageView) this.findViewById(R.id.imageView);</div><div class="line">        Button mButton = (Button) this.findViewById(R.id.button);</div><div class="line"></div><div class="line">        mButton.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                AnimationDrawable drawableAnim = (AnimationDrawable) imageView.getBackground();</div><div class="line">                if (drawableAnim.isRunning()) &#123;</div><div class="line">                    drawableAnim.stop();</div><div class="line">                &#125; else &#123;</div><div class="line">                    drawableAnim.start();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Drawable动画显示效果"><a href="#Drawable动画显示效果" class="headerlink" title="Drawable动画显示效果"></a>Drawable动画显示效果</h3><p>实现一个下载提示的动画:<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170531149619977711659.gif" alt="20170531149619977711659.gif"></p>
<h3 id="一点引申"><a href="#一点引申" class="headerlink" title="一点引申"></a>一点引申</h3><p>在实现Drawable动画过程中,做一点引申:</p>
<ol>
<li>定义的xml动画文件根元素是&lt;animation-list&gt;，存放在res/drawable目录，如果放在其他目录，会出现警告，但不影响正常的编译。</li>
<li>AnimationDrawable的start()方法不能够在Activity的onCreate()调用，因为这个时候，AnimationDrawable可能还没有绑定到Window上，如果想实现进入Activity后直接播放动画，可以在onWindowFocusChanged()方法里面调用，因为这个方法是在window已经获取到焦点之后回调的，可以保证已经绑定结束。</li>
<li>在ImageView设置动画时，需要区分&lt;ImageView&gt;的src属性和background属性，在这个示例中，如果使用src属性，会出现NPE异常。出现异常的原因与src属性的绘制时机有关。background属性是view的属性，Android系统提供的所有控件都有该属性，在View的onDraw之前，就已经被绘制。而src属性是ImageView的特有属性，在ImageView的onDraw()方法中才会被绘制。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/guide/topics/graphics/drawable-animation.html" target="_blank" rel="external">drawable-animation</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-05-19-android-drawable-animation.html">http://www.sguotao.com/Android进阶-2016-05-19-android-drawable-animation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中对Android传统动画中的View动画进行了一些整理，&lt;a href=&quot;/Android%E8%BF%9B%E9%98%B6-2016-05-18-android-view-animation.html&quot;&gt;Android动画分析一 View Animation&lt;
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="动画" scheme="http://www.sguotao.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="代码库" scheme="http://www.sguotao.com/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Android动画分析一 View Animation</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2016-05-18-android-view-animation.html"/>
    <id>http://www.sguotao.com/Android进阶-2016-05-18-android-view-animation.html</id>
    <published>2016-05-18T02:27:04.000Z</published>
    <updated>2017-06-02T10:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行Android动画内容整理的时候，发现Android的动画有很多，如官方文档中直接给出的有Property Animation、View Animation、Drawable Animation，还有平时接触比较多的帧动画（Frame Animation）和补间动画（Tweened Animation）等，这些概念需要进行一下梳理。</p>
<p>Android的动画可以分为两类，传统动画和Android3.0之后出现的属性动画(Property Animation)，其中传统动画又包括帧动画(Frame Animation)和补间动画(Tweened Animation)，帧动画的工作原理，类似于动画片，将一个完成的动画拆分为一张张的图片，然后连起来进行播放；补间动画是对View进行的一系列操作，包括淡入淡出(Alpha)，缩放(Scale)，旋转(Rotate)和平移(Translate)。Drawable Animation是将一些列的Drawable资源一个接一个的播放，从而产生动画的效果，可以理解为是Frame Animation。类似的，View Animation可以理解为是Tweened Animation。用一张图来说明一下这几种动画之间的关系。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170518149509230136976.png" alt="20170518149509230136976.png"></p>
<h2 id="View-Animation"><a href="#View-Animation" class="headerlink" title="View Animation"></a>View Animation</h2><p>View Animation视图动画，只能作用在View上，完成一些基本的动画，淡入淡出，缩放，旋转和平移，以及这些基本动画的组合。视图动画的实现方式有两种，通常在res/anim目录下定义一个xml文件，xml的根元素可以是&lt;alpha&gt;、&lt;scale&gt;、&lt;rotate&gt;、&lt;translate&gt;及&lt;set&gt;。在&lt;set&gt;中定义了一个动画集，包括四种基本动画，也可以包括一个子&lt;set&gt;。另外一种方式，直接使用这些标签对应的Java类，也可以实现相同的效果。View Animation的类图如下所示。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170523149554073223859.png" alt="20170523149554073223859.png"><br>在介绍几种基本动画之前，先介绍一下动画的一些共有属性，四种基本动画除了继承了这些基本属性外，还有一些自身的属性，这些特有属性的介绍，会在每类动画介绍中做详细的说明。这些共有属性包括：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:detachWallpaper</td>
<td style="text-align:center">设置是否在壁纸上运行，只对设置了壁纸背景的窗口动画(window animation)有效。设为true，则动画只在窗口运行，壁纸背景保持不变</td>
</tr>
<tr>
<td style="text-align:center">android:duration</td>
<td style="text-align:center">动画从开始到结束持续的时长，单位为毫秒</td>
</tr>
<tr>
<td style="text-align:center">android:fillAfter</td>
<td style="text-align:center">设置为true时，动画执行完后，View会停留在动画的最后一帧；默认为false；如果是动画集，需在&lt;set&gt;标签中设置该属性才有效</td>
</tr>
<tr>
<td style="text-align:center">android:fillBefore</td>
<td style="text-align:center">设置为true时，动画执行完后，View回到动画执行前的状态，默认即为true</td>
</tr>
<tr>
<td style="text-align:center">android:fillEnabled</td>
<td style="text-align:center">设置为true时，android:fillBefore的值才有效，否则android:fillBefore会被忽略</td>
</tr>
<tr>
<td style="text-align:center">android:interpolator</td>
<td style="text-align:center">设置动画速率的变化，比如加速、减速、匀速等，需要指定Interpolator资源</td>
</tr>
<tr>
<td style="text-align:center">android:repeatCount</td>
<td style="text-align:center">设置动画重复执行的次数，默认为0，即不重复；可设为-1或infinite，表示无限重复</td>
</tr>
<tr>
<td style="text-align:center">android:repeatMode</td>
<td style="text-align:center">设置动画重复执行的模式，可设为以下两个值其中之一：restart 动画重复执行时从起点开始，默认为该值;reverse 动画会反方向执行</td>
</tr>
<tr>
<td style="text-align:center">android:startOffset</td>
<td style="text-align:center">设置动画执行之前的等待时长，毫秒为单位；重复执行时，每次执行前同样也会等待一段时间</td>
</tr>
<tr>
<td style="text-align:center">android:zAdjustment</td>
<td style="text-align:center">表示被设置动画的内容在动画运行时在Z轴上的位置，取值为以下三个值之一：normal 默认值，保持内容在Z轴上的位置不变;top 保持在Z周最上层;bottom 保持在Z轴最下层</td>
</tr>
</tbody>
</table>
<h2 id="lt-alpha-gt-淡入淡出"><a href="#lt-alpha-gt-淡入淡出" class="headerlink" title="&lt;alpha&gt;(淡入淡出)"></a>&lt;alpha&gt;(淡入淡出)</h2><p>&lt;alpha&gt;可以实现淡入淡出的渐变效果。</p>
<h3 id="alpha动画属性"><a href="#alpha动画属性" class="headerlink" title="alpha动画属性"></a>alpha动画属性</h3><p>对应AlphaAnimation，alpha动画有两个特有的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">android:fromAlpha</td>
<td style="text-align:center">动画开始时的透明度，0.0为全透明，1.0为不透明，默认为1.0</td>
</tr>
<tr>
<td style="text-align:center">android:toAlpha</td>
<td style="text-align:center">动画结束时的透明度，0.0为全透明，1.0为不透明，默认为1.0</td>
</tr>
</tbody>
</table>
<h3 id="alpha动画构造方法"><a href="#alpha动画构造方法" class="headerlink" title="alpha动画构造方法"></a>alpha动画构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 需要在res中定义属性集(不常使用）</div><div class="line"> * @param context 上下文</div><div class="line"> * @param attrs 属性集</div><div class="line"> */</div><div class="line">public AlphaAnimation(Context context, AttributeSet attrs)</div><div class="line"></div><div class="line">/**</div><div class="line"> * 在构造法方法中指定动画开始和结束时的透明度(常用方法)</div><div class="line"> * @param fromAlpha 动画开始时的透明度</div><div class="line"> * @param toAlpha 动画结束时的透明度</div><div class="line"> */</div><div class="line">public AlphaAnimation(float fromAlpha, float toAlpha)</div></pre></td></tr></table></figure>
<h3 id="alpha动画示例"><a href="#alpha动画示例" class="headerlink" title="alpha动画示例"></a>alpha动画示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final ImageView imageView = (ImageView) this.findViewById(R.id.imageView);</div><div class="line">Button mButton = (Button) this.findViewById(R.id.button);</div><div class="line"></div><div class="line">final AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f,1.0f);</div><div class="line">alphaAnimation.setDuration(3000);</div><div class="line"></div><div class="line">mButton.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        imageView.startAnimation(alphaAnimation);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170523149551118671554.gif" alt="20170523149551118671554.gif"></p>
<h2 id="lt-scale-gt-缩放"><a href="#lt-scale-gt-缩放" class="headerlink" title="&lt;scale&gt;(缩放)"></a>&lt;scale&gt;(缩放)</h2><p>&lt;scale&gt;可以实现缩放的效果。</p>
<h3 id="scale动画属性"><a href="#scale动画属性" class="headerlink" title="scale动画属性"></a>scale动画属性</h3><p>对应ScaleAnimation，scale动画有以下的特有属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fromX</td>
<td style="text-align:center">动画开始时X坐标上的缩放尺寸，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大</td>
</tr>
<tr>
<td style="text-align:center">toX</td>
<td style="text-align:center">动画结束时X坐标上的缩放尺寸，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大</td>
</tr>
<tr>
<td style="text-align:center">fromY</td>
<td style="text-align:center">动画开始时Y坐标上的缩放尺寸，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大</td>
</tr>
<tr>
<td style="text-align:center">toY</td>
<td style="text-align:center">动画结束时Y坐标上的缩放尺寸，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大</td>
</tr>
<tr>
<td style="text-align:center">pivotX</td>
<td style="text-align:center">缩放动画相对的固定点X坐标</td>
</tr>
<tr>
<td style="text-align:center">pivotY</td>
<td style="text-align:center">缩放动画相对的固定点Y坐标</td>
</tr>
<tr>
<td style="text-align:center">pivotXType</td>
<td style="text-align:center">缩放动画相对的固定点X坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT</td>
</tr>
<tr>
<td style="text-align:center">pivotXValue</td>
<td style="text-align:center">缩放动画相对的固定点X坐标的位置，与pivotXType相关</td>
</tr>
<tr>
<td style="text-align:center">pivotYType</td>
<td style="text-align:center">缩放动画相对的固定点Y坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT</td>
</tr>
<tr>
<td style="text-align:center">pivotYValue</td>
<td style="text-align:center">缩放动画相对的固定点Y坐标的位置，与pivotYType相关</td>
</tr>
</tbody>
</table>
<h3 id="scale动画构造方法"><a href="#scale动画构造方法" class="headerlink" title="scale动画构造方法"></a>scale动画构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 自定义动画时需要重写的方法</div><div class="line"> * @param context 上下文</div><div class="line"> * @param attrs 属性集</div><div class="line"> */</div><div class="line">public ScaleAnimation(Context context, AttributeSet attrs)</div><div class="line"></div><div class="line">/**</div><div class="line"> *</div><div class="line"> * @param fromX 动画开始时X坐标上的缩放尺寸</div><div class="line"> * @param toX 动画结束时X坐标上的缩放尺寸</div><div class="line"> * @param fromY 动画开始时Y坐标上的缩放尺寸</div><div class="line"> * @param toY 动画结束时Y坐标上的缩放尺寸</div><div class="line"> */</div><div class="line">public ScaleAnimation(float fromX, float toX, float fromY, float toY)</div><div class="line"></div><div class="line">/**</div><div class="line"> * 指定一个固定点,进行动画,固定点的坐标是(pivotX,pivotY)</div><div class="line"> * 第二个构造方法默认固定点的坐标是(0,0),即动画view的的左上角</div><div class="line"> * </div><div class="line"> * @param fromX 动画开始时X坐标上的缩放尺寸</div><div class="line"> * @param toX 动画结束时X坐标上的缩放尺寸</div><div class="line"> * @param fromY 动画开始时Y坐标上的缩放尺寸</div><div class="line"> * @param toY 动画结束时Y坐标上的缩放尺寸</div><div class="line"> * @param pivotX 固定点的X坐标坐标,取值为0时表示动画view的左边沿</div><div class="line"> * @param pivotY 固定点的Y坐标坐标,取值为0时表示动画view的上边沿</div><div class="line"> */</div><div class="line">public ScaleAnimation(float fromX, float toX, float fromY, float toY,</div><div class="line">                      float pivotX, float pivotY)</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过pivotXType,pivotXValue,pivotYType和pivotYValue确定一个固定点进行动画</div><div class="line"> * 第三个构造方法中,固定点默认的位置类型(pivotXType、pivotYType)为 Animation.ABSOLUTE</div><div class="line"> * </div><div class="line"> * @param fromX 动画开始时X坐标上的缩放尺寸</div><div class="line"> * @param toX 动画结束时X坐标上的缩放尺寸</div><div class="line"> * @param fromY 动画开始时Y坐标上的缩放尺寸</div><div class="line"> * @param toY 动画结束时Y坐标上的缩放尺寸</div><div class="line"> * @param pivotXType 固定点X坐标位置的类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.)</div><div class="line"> * @param pivotXValue 固定点X坐标坐标,位置与pivotXType有关</div><div class="line"> * @param pivotYType 固定点Y坐标位置的类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.)</div><div class="line"> * @param pivotYValue 固定点Y坐标坐标,位置与pivotYType有关</div><div class="line"> */</div><div class="line">public ScaleAnimation(float fromX, float toX, float fromY, float toY,</div><div class="line">                      int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)</div></pre></td></tr></table></figure>
<p>这里有必要对这几个构造方法进行一些说明：</p>
<ol>
<li>第二个构造方法public ScaleAnimation(float fromX, float toX, float fromY, float toY)固定点的默认坐标是(0,0)，即要发生动画view的左上角，通过该构造方法创建的缩放动画，都是相对于该固定点进行的。</li>
<li>第三个构造方法public ScaleAnimation(float fromX, float toX, float fromY, float toY,float pivotX, float pivotY)固定点的坐标可以指定为(pivotX,pivotY),即相对于发生动画view的左上角距离(pivotX,pivotY)的位置，通过该构造方法创建的缩放动画,都是相对这个指定的点进行的。</li>
<li>第四个构造方法public ScaleAnimation(float fromX, float toX, float fromY, float toY,int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)对固定点位置的确定有了更多的方式，固定点位置的确定主要与pivotXType, pivotXValue, pivotYType, pivotYValue这四个值有关。通常pivotXType和pivotYType的值都指定为同一种类型。</li>
</ol>
<ul>
<li>当pivotXType和pivotYType为Animation. ABSOLUTE时，与第三个构造方法效果相同，即第三个构造方法默认的pivotXType和pivotYType为Animation. ABSOLUTE。</li>
<li>当pivotXType和pivotYType为Animation.RELATIVE_TO_SELF，固定点的位置相对于动画view，固定点的坐标为(width*pivotXValue,height*pivotYValue),其中width为动画view的宽，height为动画view的高。</li>
<li>当pivotXType和pivotYType为Animation.RELATIVE_TO_PARENT，固定点的位置相对于动画view的父容器view，固定点的坐标为(parentWidth*pivotXValue,parentHeight*pivotYValue),其中parentWidth为父容器view的宽，parentHeight为父容器的高。</li>
</ul>
<h3 id="scale动画示例"><a href="#scale动画示例" class="headerlink" title="scale动画示例"></a>scale动画示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//固定点位置相对于imageview,固定点坐标为imageview的中心</div><div class="line">        final ScaleAnimation scaleAnimation = new ScaleAnimation(0.5f, 1.0f, 0.5f, 1.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">        scaleAnimation.setDuration(3000);</div><div class="line">        scaleAnimation.setFillAfter(true);//动画结束时,保持结束的位置不变</div><div class="line">        mButton.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line">                imageView.startAnimation(scaleAnimation);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170523149553277096247.gif" alt="20170523149553277096247.gif"></p>
<h2 id="lt-rotate-gt-旋转"><a href="#lt-rotate-gt-旋转" class="headerlink" title="&lt;rotate&gt;(旋转)"></a>&lt;rotate&gt;(旋转)</h2><p>&lt;rotate&gt;可以实现旋转的效果。</p>
<h3 id="rotate动画属性"><a href="#rotate动画属性" class="headerlink" title="rotate动画属性"></a>rotate动画属性</h3><p>对应RotateAnimation，rotate动画有以下的特有属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fromDegrees</td>
<td style="text-align:center">旋转开始的角度，旋转角度从0到360</td>
</tr>
<tr>
<td style="text-align:center">toDegrees</td>
<td style="text-align:center">旋转结束的角度，旋转角度从0到360</td>
</tr>
<tr>
<td style="text-align:center">pivotX</td>
<td style="text-align:center">旋转中心相对的X坐标</td>
</tr>
<tr>
<td style="text-align:center">pivotY</td>
<td style="text-align:center">旋转中心相对的Y坐标</td>
</tr>
<tr>
<td style="text-align:center">pivotXType</td>
<td style="text-align:center">旋转动画中心X坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT</td>
</tr>
<tr>
<td style="text-align:center">pivotXValue</td>
<td style="text-align:center">旋转动画中心X坐标的位置，与pivotXType相关</td>
</tr>
<tr>
<td style="text-align:center">pivotYType</td>
<td style="text-align:center">旋转动画中心Y坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT</td>
</tr>
<tr>
<td style="text-align:center">pivotYValue</td>
<td style="text-align:center">旋转动画中心Y坐标的位置，与pivotYType相关</td>
</tr>
</tbody>
</table>
<h3 id="rotate动画构造方法"><a href="#rotate动画构造方法" class="headerlink" title="rotate动画构造方法"></a>rotate动画构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * </div><div class="line"> * @param context</div><div class="line"> * @param attrs</div><div class="line"> */</div><div class="line">public RotateAnimation(Context context, AttributeSet attrs)</div><div class="line"></div><div class="line">/**</div><div class="line"> * 旋转中心的位置(0,0)</div><div class="line"> * @param fromDegrees 旋转动画开始角度</div><div class="line"> * @param toDegrees 旋转动画结束角度</div><div class="line"> */</div><div class="line">public RotateAnimation(float fromDegrees, float toDegrees)</div><div class="line"></div><div class="line">/**</div><div class="line"> * 旋转中心相对(0,0)的位置(pivotX,pivotY)</div><div class="line"> * @param fromDegrees 旋转动画开始角度</div><div class="line"> * @param toDegrees 旋转动画结束角度</div><div class="line"> * @param pivotX 旋转中心x坐标</div><div class="line"> * @param pivotY 旋转中心y坐标</div><div class="line"> */</div><div class="line">public RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过pivotXType,pivotXValue,pivotYType和pivotYValue确定旋转中心</div><div class="line"> * @param fromDegrees 旋转动画开始角度</div><div class="line"> * @param toDegrees 旋转动画结束角度</div><div class="line"> * @param pivotXType 旋转动画中心x坐标位置类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.)</div><div class="line"> * @param pivotXValue 旋转动画中心x坐标的位置,与pivotXType相关</div><div class="line"> * @param pivotYType 旋转中心y坐标位置类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.)</div><div class="line"> * @param pivotYValue 旋转动画中心y坐标的位置,与pivotYType相关</div><div class="line"> */</div><div class="line">public RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,</div><div class="line">                       int pivotYType, float pivotYValue)</div></pre></td></tr></table></figure>
<h3 id="rotate动画示例"><a href="#rotate动画示例" class="headerlink" title="rotate动画示例"></a>rotate动画示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final ImageView imageView = (ImageView) this.findViewById(R.id.imageView);</div><div class="line">Button mButton = (Button) this.findViewById(R.id.button);</div><div class="line"></div><div class="line">final RotateAnimation rotateAnimation = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">rotateAnimation.setDuration(3000);</div><div class="line">rotateAnimation.setFillAfter(true);//动画结束时,保持结束的位置不变</div><div class="line">mButton.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        imageView.startAnimation(rotateAnimation);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170523149553531557978.gif" alt="20170523149553531557978.gif"></p>
<h2 id="lt-translate-gt-平移"><a href="#lt-translate-gt-平移" class="headerlink" title="&lt;translate&gt;(平移)"></a>&lt;translate&gt;(平移)</h2><p>&lt;translate&gt;可以实现平移的动画效果。</p>
<h3 id="translate动画属性"><a href="#translate动画属性" class="headerlink" title="translate动画属性"></a>translate动画属性</h3><p>对应TranslateAnimation，translate动画有以下特有的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">XML Attribute</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fromXDelta</td>
<td style="text-align:center">平移动画开始点X坐标</td>
</tr>
<tr>
<td style="text-align:center">toXDelta</td>
<td style="text-align:center">平移动画结束点X坐标</td>
</tr>
<tr>
<td style="text-align:center">fromYDelta</td>
<td style="text-align:center">平移动画开始点Y坐标</td>
</tr>
<tr>
<td style="text-align:center">toYDelta</td>
<td style="text-align:center">平移动画结束点Y坐标</td>
</tr>
<tr>
<td style="text-align:center">fromXType</td>
<td style="text-align:center">平移动画开始点X坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT</td>
</tr>
<tr>
<td style="text-align:center">fromXValue</td>
<td style="text-align:center">平移动画开始点X坐标位置，与fromXType有关</td>
</tr>
<tr>
<td style="text-align:center">toXType</td>
<td style="text-align:center">平移动画结束点X坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT</td>
</tr>
<tr>
<td style="text-align:center">toXValue</td>
<td style="text-align:center">平移动画结束点X坐标位置，与toXType有关</td>
</tr>
<tr>
<td style="text-align:center">fromYType</td>
<td style="text-align:center">平移动画开始点Y坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT</td>
</tr>
<tr>
<td style="text-align:center">fromYValue</td>
<td style="text-align:center">平移动画开始点坐标位置，与fromYType有关</td>
</tr>
<tr>
<td style="text-align:center">toYType</td>
<td style="text-align:center">平移动画结束点Y坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT</td>
</tr>
<tr>
<td style="text-align:center">toYValue</td>
<td style="text-align:center">平移动画结束点坐标位置，与toYType有关</td>
</tr>
</tbody>
</table>
<h3 id="translate动画构造方法"><a href="#translate动画构造方法" class="headerlink" title="translate动画构造方法"></a>translate动画构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * </div><div class="line"> * @param context 上下文</div><div class="line"> * @param attrs 属性集</div><div class="line"> */</div><div class="line">public TranslateAnimation(Context context, AttributeSet attrs)</div><div class="line"></div><div class="line">/**</div><div class="line"> * 平移动画的起点位置和结束位置坐标都是相对于(0,0)即动画view的左上角.</div><div class="line"> * @param fromXDelta </div><div class="line"> * @param toXDelta</div><div class="line"> * @param fromYDelta</div><div class="line"> * @param toYDelta</div><div class="line"> */</div><div class="line">public TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过构造参数确定平移动画的起始位置和结束位置的坐标</div><div class="line"> * </div><div class="line"> * @param fromXType 开始点x坐标位置类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.)</div><div class="line"> * @param fromXValue 开始点x坐标位置,与fromXType有关</div><div class="line"> * @param toXType 结束点x坐标类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.)</div><div class="line"> * @param toXValue 结束点x坐标位置,与toXType有关</div><div class="line"> * @param fromYType 开始点y坐标类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.)</div><div class="line"> * @param fromYValue 开始点y坐标位置,与fromYType有关</div><div class="line"> * @param toYType 结束点y坐标类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.)</div><div class="line"> * @param toYValue 结束点y坐标类型,与toYType有关</div><div class="line"> */</div><div class="line">public TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue,</div><div class="line">                          int fromYType, float fromYValue, int toYType, float toYValue)</div></pre></td></tr></table></figure>
<h3 id="translate动画示例"><a href="#translate动画示例" class="headerlink" title="translate动画示例"></a>translate动画示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">final TranslateAnimation translateAnimation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 1.0f,</div><div class="line">    Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 1.0f);</div><div class="line">translateAnimation.setDuration(3000);</div><div class="line">translateAnimation.setFillAfter(true);//动画结束时,保持结束的位置不变</div><div class="line">mButton.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        imageView.startAnimation(translateAnimation);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170523149553593494120.gif" alt="20170523149553593494120.gif"></p>
<h2 id="lt-set-gt-动画集"><a href="#lt-set-gt-动画集" class="headerlink" title="&lt;set&gt;动画集"></a>&lt;set&gt;动画集</h2><p>&lt;set&gt;是一系列动画的集合，对应AnimationSet,可以实现一些动画的组合。在AnimationSet的构造方法中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Constructor to use when building an AnimationSet from code</div><div class="line">    * </div><div class="line">    * @param shareInterpolator Pass true if all of the animations in this set</div><div class="line">    *        should use the interpolator associated with this AnimationSet.</div><div class="line">    *        Pass false if each animation should use its own interpolator.</div><div class="line">    */</div><div class="line">   public AnimationSet(boolean shareInterpolator) &#123;</div><div class="line">       setFlag(PROPERTY_SHARE_INTERPOLATOR_MASK, shareInterpolator);</div><div class="line">       init();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>当使用代码方式创建动画集时，需要使用到这个构造方法，构造方法需要一个boolean值，当为true时，动画集中的动画使用animationSet的插值器，当为false时，使用每个动画自己的插值器。这里有一个问题，什么是插值器？</p>
<h3 id="Interpolator"><a href="#Interpolator" class="headerlink" title="Interpolator"></a>Interpolator</h3><p>在Android API 11以前，插值器是Interpolator的直接翻译过来的名称，在Android API 11以后，加入了TimeInterpolator接口。什么是插值器？插值器定义了动画的运行轨迹，如加速和减速等。粗略统计了一下，Android API中关于插值器的接口，抽象类和实现类大概有16个，为了清晰的理解这些接口和类的关系，先抛出一张类图。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170527149586916399293.png" alt="20170527149586916399293.png"><br>这么多的实现类，每个插值器实现类的作用是什么？区别又是什么？在TimeInterpolator接口中声明了一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Maps a value representing the elapsed fraction of an animation to a value that represents</div><div class="line">     * the interpolated fraction. This interpolated value is then multiplied by the change in</div><div class="line">     * value of an animation to derive the animated value at the current elapsed animation time.</div><div class="line">     *</div><div class="line">     * @param input A value between 0 and 1.0 indicating our current point</div><div class="line">     *        in the animation where 0 represents the start and 1.0 represents</div><div class="line">     *        the end</div><div class="line">     * @return The interpolation value. This value can be more than 1.0 for</div><div class="line">     *         interpolators which overshoot their targets, or less than 0 for</div><div class="line">     *         interpolators that undershoot their targets.</div><div class="line">     */</div><div class="line">    float getInterpolation(float input);</div></pre></td></tr></table></figure></p>
<p>该函数将当前动画运行的点input映射到一个插值函数中。不同的插值器实现类，对应这不同的插值函数。比如在插值器AccelerateInterpolator中，对应的插值函数是一个抛物线。抛物线的斜率跟mFactor参数有关，mFactor的值越大，抛物线的曲率越大。对应的动画效果是开始阶段动画比较慢，此后会越来越快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public float getInterpolation(float input) &#123;</div><div class="line">        if (mFactor == 1.0f) &#123;</div><div class="line">            return input * input;</div><div class="line">        &#125; else &#123;</div><div class="line">            return (float)Math.pow(input, mDoubleFactor);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对一些插值器的效果进行一个简单的描述，具体的运动效果，与对应的插值函数有关。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/20170527149587798346557.png" alt="20170527149587798346557.png"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="external">prop-animation</a><br><a href="https://developer.android.com/guide/topics/graphics/view-animation.html" target="_blank" rel="external">view animation</a><br><a href="https://developer.android.com/guide/topics/graphics/drawable-animation.html" target="_blank" rel="external">drawable-animation</a><br><a href="https://developer.android.com/reference/android/view/animation/Animation.html" target="_blank" rel="external">Animation</a><br><a href="https://developer.android.com/reference/android/view/animation/AlphaAnimation.html" target="_blank" rel="external">AlphaAnimation</a><br><a href="https://developer.android.com/reference/android/view/animation/RotateAnimation.html" target="_blank" rel="external">RotateAnimation</a><br><a href="https://developer.android.com/reference/android/view/animation/ScaleAnimation.html" target="_blank" rel="external">ScaleAnimation</a><br><a href="https://developer.android.com/reference/android/view/animation/TranslateAnimation.html" target="_blank" rel="external">TranslateAnimation</a><br><a href="https://developer.android.com/reference/android/view/animation/AnimationSet.html" target="_blank" rel="external">AnimationSet</a><br><a href="https://my.oschina.net/banxi/blog/135633" target="_blank" rel="external">android动画（一）Interpolator</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2016-05-18-android-view-animation.html">http://www.sguotao.com/Android进阶-2016-05-18-android-view-animation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行Android动画内容整理的时候，发现Android的动画有很多，如官方文档中直接给出的有Property Animation、View Animation、Drawable Animation，还有平时接触比较多的帧动画（Frame Animation）和补间动画（
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="动画" scheme="http://www.sguotao.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="代码库" scheme="http://www.sguotao.com/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>和光同尘，静水流深</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2016-05-09-getdown-to-my-work.html"/>
    <id>http://www.sguotao.com/生活感悟-2016-05-09-getdown-to-my-work.html</id>
    <published>2016-05-08T09:00:00.000Z</published>
    <updated>2017-06-02T10:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>北京时间，2016年5月1日，完成了自己人生中一件非常重要的事情，我结婚了，当自己去看婚礼视频的时候，那因紧张而僵硬的表情，在大方自如的媳妇面前，感觉是那么的不协调，我对自己说，我是多么的幸运，能遇到这样的女孩，同时，我也感到一份支撑，一种依靠。2016，我不再单打独斗了。</p>
<p>总想快速从结婚的喜悦中调整到繁忙的工作中来，2016年，对于公司也是非常重要的一年，能成为其中的一员，见证公司和自己的成长，我想着本身也是一种缘分，希望自己能在2016年剩下的日子里，看到自己持续的成长。</p>
<p>今天看到一篇博客，其中的一些文字，让自己感触很深：</p>
<ol>
<li>好奇心比雄心走得更远：很多人对未来空有满腔的雄心壮志，往往不如对技术要有一份好奇心，一份探索欲，再加上一份执着的人。</li>
<li>要有open的心态：曾经的我也只是把自己的所思所得都放入自己的云笔记，很少整理，这其实不利于技术发展，有空应该多整理自己零散的知识点，觉得不错的点可以拿出来写成博客，那是对能力的又一层提升。另外，在低头做技术的同时，还应该有空抬头看世界，不能闭门造车。</li>
<li>天道酬勤：学历只能代表过去，能力代表现在，潜力代表未来！ 你不把自己逼一把，你压根不知道自己有多优秀，只要努力去学习，去挖掘潜力，进而提升自我技术修为，未来不再是梦！共勉之！</li>
</ol>
<p>解决问题的方式：遇到问题，一定要先尝试自己解决，解决不了再请教他人。这是对自己的一个锻炼，也是对他人的一个尊重，可以有多种途径自行搜索：</p>
<ol>
<li>百度一下，很多时候还是能有所帮助的，不要过分强调google，完全抛弃百度，毕竟中文看起来比较快；</li>
<li>先中文关键词google一下；再英文关键词google一下；</li>
<li>stackoverflow.com、知乎等技术问答网站内直接搜索；</li>
<li>查看官方文档；</li>
<li>如果有源码，尝试直接看源码，看能否解决；</li>
<li>有空可以多逛逛github，多看看Google官方文档，多关注社区，定会收获不少；</li>
</ol>
<p>当然，最最重要的是<strong>能静得下心，持之以恒地专研技术</strong>。</p>
<p>以前，自己总是用“和光同尘，静水流深”来勉励自己，现在更加觉着这句话的重要。浮躁是在自己这个年纪，甚至是现在这个社会，比较普遍的现象。希望自己不要眼高手低，脚踏实地的走好现在的路，低调做人，高调做事。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2016-05-09-getdown-to-my-work.html">http://www.sguotao.com/生活感悟-2016-05-09-getdown-to-my-work.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;北京时间，2016年5月1日，完成了自己人生中一件非常重要的事情，我结婚了，当自己去看婚礼视频的时候，那因紧张而僵硬的表情，在大方自如的媳妇面前，感觉是那么的不协调，我对自己说，我是多么的幸运，能遇到这样的女孩，同时，我也感到一份支撑，一种依靠。2016，我不再单打独斗了。
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】解忧杂货店</title>
    <link href="http://www.sguotao.com/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-02-20-%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97.html"/>
    <id>http://www.sguotao.com/读书笔记-2016-02-20-解忧杂货店.html</id>
    <published>2016-02-20T04:00:00.000Z</published>
    <updated>2017-06-08T10:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>真的要到很久之后，才会明白，每一个选择只要努力过，都是正确的选择。</p>
</blockquote>
<a id="more"></a>
<p>几个看似独立的故事，互相都存在羁绊，让人觉着这是发生在小镇里一个个普普通通的故事，但正式因为平凡，才有撼动人心的力量。</p>
<h2 id="回答在牛奶箱里"><a href="#回答在牛奶箱里" class="headerlink" title="回答在牛奶箱里"></a>回答在牛奶箱里</h2><p>深爱的男友身患绝症，年轻的女孩在爱情和梦想间徘徊。</p>
<blockquote>
<p>有一天，我对他说：<br>“我比任何人都爱你，想要永远和你在一起，如果我放弃比赛就能让你好起来，我会毫不犹豫地放弃。但如果不是这样，我希望坚持我对梦想。因为一直以来追寻着梦想，我才活出了自我，而你喜欢的也正是这样的我。我没有一刻忘记过你，但请让我去追逐梦想吧。”<br>听完这番话，病床上的他流下泪来。他对我说：<br>“我早就在等你这句话了。看到你为了我而烦恼，我很难过。让深爱的人放弃梦想，这比死还让我痛苦。即使分隔两地，我们的心也会永远在一起。你不要有任何顾虑，我希望你无怨无悔地去追寻梦想。”</p>
</blockquote>
<p>年轻女孩找到了阅读自己地图的方法，从那天起，她不再迷茫，重新投身到训练中，因为她明白，陪伴在他身边并不是照顾他的唯一方式。深爱的男友还是离开了人世，但女孩从他临终时满足的表情，和那句“谢谢你带给我的梦想”，得到了更有价值的东西。</p>
<h2 id="深夜的口琴声"><a href="#深夜的口琴声" class="headerlink" title="深夜的口琴声"></a>深夜的口琴声</h2><p>克郎为了音乐梦想离家漂泊，却在现实中寸步难行。</p>
<blockquote>
<p>你对音乐的执着追求，绝不是白白付出。<br>我相信，将会有人因为你的歌而得到救赎。你创作的音乐也必将流传下去。<br>请你始终坚信这一点，坚信到生命最后一刻。</p>
</blockquote>
<p>当克朗扛着少年在火力奔跑，他自己也不知道往哪儿跑，红光与黑暗，同时将他包围。在他生命最后一刻，仍要坚持相信。这里我看到的不是为了梦想的执着坚持，打动我的反而是父亲的支持。我们焦虑，是因为我们找不到问题的答案，徘徊在是与非的选择上，其实，每一个选择只要努力过，都是正确的选择。</p>
<h2 id="在思域车上等到天亮"><a href="#在思域车上等到天亮" class="headerlink" title="在思域车上等到天亮"></a>在思域车上等到天亮</h2><p>绿河怀了有妇之夫的孩子，为应该生下来还是堕胎而纠结。</p>
<blockquote>
<p>虽然至今为止的道路绝非一片坦途，但想到正因为活着才有机会感受到痛楚，我就成功克服了种种恐惧。</p>
</blockquote>
<h2 id="听着披头士默祷"><a href="#听着披头士默祷" class="headerlink" title="听着披头士默祷"></a>听着披头士默祷</h2><p>少年浩介面临家庭巨变，挣扎在亲情与未来的迷茫中。<br>人与人之间情断义绝，并不需要什么具体的理由。就算表面上有，也很可能只是心离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。</p>
<blockquote>
<p>关于家人，除了积极向上的旅行，家人应该尽可能在一起。因为反感、厌倦等理由而离开，不是家人应有的姿态。<br>无论现在多么不开心，你要相信，明天会比今天更好。</p>
</blockquote>
<h2 id="来自天上的祈祷"><a href="#来自天上的祈祷" class="headerlink" title="来自天上的祈祷"></a>来自天上的祈祷</h2><blockquote>
<p>如果把来找我咨询的人比喻成迷途的羔羊，通常他们手上都有地图，却没有去看，或是不知道自己目前的位置。但我相信你不属于这两种情况。你的地图是一张白纸，所以即使想决定目的地，也不知道路在哪里。地图是一张白纸，这当然很伤脑筋。任何人都会不知所措。可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事啊。我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。</p>
</blockquote>
<p>这是浪矢杂货店最后的一封回信，不知道是不是初为人父的关系，看到这里，想到了四个月大，能冲我咿咿呀呀的女儿，我想，上面似乎也是我想对女儿说的话。就像希拉里说的一样“我第一次成为你的母亲，你第一次成为我的女儿，让我们彼此关照，共同成长”。如果将来的某一天，女儿也像小说中的人物，在人生的十字路口，不知道该何去何从时，我能否像浪矢杂货店的爷爷一样，告诉她看地图的方式。我多想告诉她，要到很久之后，你就会明白，每一个选择只要努力过，都是正确的选择。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/读书笔记-2016-02-20-解忧杂货店.html">http://www.sguotao.com/读书笔记-2016-02-20-解忧杂货店.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;真的要到很久之后，才会明白，每一个选择只要努力过，都是正确的选择。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.sguotao.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://www.sguotao.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="解忧杂货店" scheme="http://www.sguotao.com/tags/%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97/"/>
    
  </entry>
  
  <entry>
    <title>【RxJava】一 RxJava是什么</title>
    <link href="http://www.sguotao.com/RxJava-2016-01-25.html"/>
    <id>http://www.sguotao.com/RxJava-2016-01-25.html</id>
    <published>2016-01-25T02:27:04.000Z</published>
    <updated>2017-06-02T10:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-RxJava是什么？"><a href="#1-RxJava是什么？" class="headerlink" title="1.RxJava是什么？"></a>1.RxJava是什么？</h2><p>GitHub官方给出的解释：</p>
<blockquote>
<p>RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.</p>
</blockquote>
<p>即一个运行在JVM上的库，通过一个<strong>可观测的序列</strong>，组成的<strong>异步的</strong>、<strong>基于事件的</strong>程序。</p>
<h2 id="2-为什么要使用RxJava"><a href="#2-为什么要使用RxJava" class="headerlink" title="2.为什么要使用RxJava?"></a>2.为什么要使用RxJava?</h2><p>在平时的开发中，当遇到如进行访问网络请求，数据库的查询操作，文件读写操作等耗时操作时，都会放在子线程中来进行。<br>让复杂的业务逻辑，回归简单和清晰。</p>
<p>Rx模式以及优点<br>1，使用观察者模式；<br>    创建：Rx可以方便的创建事件流和数据流；<br>    组合：Rx使用查询式的操作符组合和变换数据流；<br>    监听：Rx可以订阅任何可观察数据流并执行操作；<br>2，简化代码<br>    函数式风格:对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态；<br>    简化代码:Rx的操作符通常可以将复杂的难题简化成为很少的几行代码；<br>    异步错误处理:传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制；<br>    轻松使用并发:Rx的Observerables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题。</p>
<h2 id="3-怎样使用RxJava"><a href="#3-怎样使用RxJava" class="headerlink" title="3.怎样使用RxJava?"></a>3.怎样使用RxJava?</h2><p>响应式编程<br>    Rx提供了一系列的操作符，你可以使用它们来过滤（filter）、选择（select）、变换（transform)、<br>    结合（combine)和组合（compose)多个Observable，这些操作符让执行和复合变得非常高效。</p>
<pre><code>你可以把Observable当做Iterable的推送方式的等价物，使用Iterable,消费者从生产者哪里获取数据，
线程阻塞直至数据准备好。使用Observable，在数据准备好时，生产者将数据推送给消费者。数据可以同步
或异步的到达，这种方式更灵活。
</code></pre><p>RxAndroid响应式开发</p>
<p>1，Rx是响应式编程的意思，本质是观察者模式，是以观察者（Observer）和订阅者（Subscriber)为基础的异步响应方式。<br>2，在Android编程时，经常会使用后台线程，那么就可以使用这种方式，目前的异步编程方式都会导致一些问题，如：</p>
<p>Asynctasks can easily lead to memory leaks.<br>CursorLoaders with a ContentProvider require a large amount of configuration and boilerplate code to setup.<br>Services are intentded for longer running background tasks and not fast-finishing operations,such as making<br>a network call or loading content from a database.<br>访问网络接口调用返回数据，尤其在使用接口回调时，处理数据比较麻烦。</p>
<p>创建观察者<br>    在异步模型中创建观察者；<br>    定义一个方法，它完成某些任务，然后从异步调用中返回一个值，这个方法时观察者的一部分。<br>    将这个异步调用本身定义为一个Observable<br>    观察者通过订阅（Subscribe)操作关联到那个Observable；<br>    继续业务逻辑，等方法返回时，Observable会发射结果，观察者的方法会开始处理结果或结果集；</p>
<p>RxJava的观察者模式<br>    观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，<br>    需要在B变化的一瞬间做出反应。</p>
<pre><code>RxJava有四个基本概念：
    Observable（可观察者,即被观察者）
    Observer（观察者）
    subscribe（订阅）
    事件

Observable和Observer通过subscribe()方法实现订阅关系，从而Observerable可以在需要的时候发出事件来通知Observer。
</code></pre><p>RxJava基本实现<br>    1.创建Observer<br>        Observer即观察者，它决定事件触发的时候将有怎样的行为。RxJava中的Observer接口实现方式：<br>    2.创建Observable<br>        Observable即被观察者，它决定什么时候触发事件以及触发怎样的事件。RxJava使用create()方法<br>        来创建一个Observable，并为它定义事件触发规则；<br>    3.Subscribe(订阅)<br>        创建了Observable和Observer之后，再用subscribe()方法将它们联结起来，整条链子就可以工作了。</p>
<h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">https://github.com/ReactiveX/RxJava</a></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/RxJava-2016-01-25.html">http://www.sguotao.com/RxJava-2016-01-25.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-RxJava是什么？&quot;&gt;&lt;a href=&quot;#1-RxJava是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.RxJava是什么？&quot;&gt;&lt;/a&gt;1.RxJava是什么？&lt;/h2&gt;&lt;p&gt;GitHub官方给出的解释：&lt;/p&gt;
&lt;blockquote
    
    </summary>
    
      <category term="RxJava" scheme="http://www.sguotao.com/categories/RxJava/"/>
    
    
      <category term="RxJava" scheme="http://www.sguotao.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>听了好多道理，却还是做不好工作</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2015-12-30-executive-ability.html"/>
    <id>http://www.sguotao.com/生活感悟-2015-12-30-executive-ability.html</id>
    <published>2015-12-30T13:18:59.000Z</published>
    <updated>2017-06-02T10:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章来源：微信公众号</p>
</blockquote>
<p>海尔的企业文化内刊上，刊着一张员工砸冰箱的黑白照片。这件事发生在1985年，海尔公司涣散不堪，只能长期靠借钱维持工厂运营。砸冰箱事件源于一封举报信，用户反映海尔的电冰箱有质量问题。经检查，这类不合格的冰箱还有76台，张瑞敏当即决定把冰箱全部砸掉，并由生产者自己动手。</p>
<p>至此，“具备责任心、做好每一个细节”的理念深深刻在每一个员工心里。海尔的管理精髓之一是：日事日毕，日清日高。强调高效的执行力，把每天的工作做完、做好。在此理念下，海尔从一个濒临倒闭的小厂，蜕变为享誉国内外的大集团。执行力的力量功不可没。</p>
<p>我的老大Ella在创业前，曾在腾讯干过几年，当时工作中他们提得最多的一个词，就是<strong>“执行力”</strong>。这个习惯让她在以后的创业中受益匪浅。<br>Ella曾问过阿里高管：论人才储备，阿里18罗汉，占据各部高层，为什么他们有那么多人可用？</p>
<p>对方回答：平凡人做非凡事。企业偏爱执行力强的平凡人，愿意帮助这样的员工成长。执行力对职业发展的重要性可见一斑。再有想法不去执行，也是空谈。那么，执行力具体指的是什么？从概念上讲，它包含三个方面：完成任务的意愿、完成任务的能力、完成任务的程度。我用三个小故事来分别解释这三个方面：</p>
<ol>
<li><p>我有个朋友，一直口口声声说暗恋一名女孩儿，却从来没有展开追求。他并不是不知道怎么追女孩，在给别人建议时，他头头是道。<br>“你每天给她买早餐，悄悄放在桌上，坚持三个月，肯定成！”<br>“你为什么不这样做？”<br>“不行不行，现在还不是时候，我再等等吧。”<br>等着等着，然后就没有然后了。女孩跟别人好了。心中思绪涌动，但不愿付诸行动。<br><strong>此乃缺乏执行的意愿。</strong></p>
</li>
<li><p>一群老鼠开会，研究怎样才能躲避猫的袭击。有老鼠提议说：不如在猫脖子上挂一个铃铛，猫一靠近，我们就能听到然后逃跑了。大家纷纷赞同这是个好点子，鼠老大决定就这么办！那么问题来了，谁去挂这个铃铛呢？所有老鼠都低着头，谁也不愿意接这个任务，做就等于死。直到鼠老大去世，这个决定依然没有被实施。<br><strong>究其原因，是老鼠们根本不具备执行它的能力。</strong></p>
</li>
<li><p>闺蜜梅梅一个月前定下减肥计划——每天坚持跑步半小时。一个月来，她一天也没落下，但减肥大业毫无成效，这让我很困惑。在陪她跑了一次之后，我彻底明白其中原因：半小时时间里，有10分钟她在做准备工作，10分钟在停下来喝水休息，剩下10分钟才是真正运动的时间。<br><strong>执行程度低，看似完成了目标，实则收效甚微。</strong></p>
</li>
</ol>
<p>以上三个故事，都是缺乏执行力的表现。在职场中，因为多次没有完成工作任务而被解雇的例子比比皆是，相信你也碰到或耳闻过。而执行力强的那些人，总是晋升最快的一类。你可能要问了：道理我都懂，可为什么执行起来这么困难呢？</p>
<p>Lagou将执行力不足的原因总结为三点：</p>
<ul>
<li>目标定得太离谱；</li>
<li>想得多却做得少；</li>
<li>拖延后潦草收场；</li>
</ul>
<p>为了摆脱“听了很多道理，却依然做不好工作”的困扰，Lagou 针对原因对症下药，精心准备了10条既有用、又易操作的小技巧，来助你提高执行力，使职场之路更加顺畅。</p>
<h2 id="1-明确目标"><a href="#1-明确目标" class="headerlink" title="1.明确目标"></a>1.明确目标</h2><p>很多时候你会发现，决定好了的事情，执行起来却非常困难，这通常是目标设定不清晰导致的。目标超过个人能力、目标过大、周期过长、不能分解、指向不明、不掌握资源等等，都会导致目标难以执行。在设定目标的时候，首先要去判定目标的明确性，这时候，我们可以用到著名的“SMART原则”，来衡量已定目标的明确与否。“SMART原则”是：</p>
<ul>
<li>目标必须是具体的(Specific);</li>
<li>目标必须是可以衡量的(Measurable);</li>
<li>目标必须是可以达到的(Attainable);</li>
<li>目标必须和其他目标具有相关性(Relevant);</li>
<li>目标必须具有明确的截止期限(Time-based)。</li>
</ul>
<p>例如：你接到一项任务，做一款H5，旨在通过H5实现用户的转化，促使他们去注册你公司的APP。你把这项任务的目标设定为——尽最大可能做出一款能够刷爆朋友圈的H5，实现用户的高效转化——这会让你在实施这项任务时感到茫然。</p>
<p>运用SMART原则，此项目标的设定应为：在两周的时间内（明确期限），做一款H5，实现1万的用户转化（具体目标、可衡量）。在设定这个量的时候，应当考虑渠道数和粉丝数，并参考以往的推广案例里，它们的转化率是多少。如果推广渠道的粉丝总数才5万，你设定1万的转化量，那几乎是不切实际的。</p>
<h2 id="2-将目标分解成多个小目标"><a href="#2-将目标分解成多个小目标" class="headerlink" title="2.将目标分解成多个小目标"></a>2.将目标分解成多个小目标</h2><p>目标过大、周期过长的任务，会让人不知从何下手。在处理一项庞杂的事务时，很容易出现本末倒置、战线延长的现象。成功hold住大目标的秘诀在于，将之分解为一个个小目标，安排好时间，逐一攻破。目标分解的经典案例是一个关于马拉松的故事：1984年东京国际马拉松邀请赛中，一个名不见经传的山本田一出人意料地夺得冠军，他的技巧在于把路程分解成几个小目标：银行、大树、红房子。他说：“比赛开始后，我就以百米冲刺的速度奋力向第一个目标冲去，到达第一个目标后，我同样的速度冲向第二个目标— —40多公里的路程就被我分解成这么几个小目标轻松地跑完了。”</p>
<h2 id="3-设定奖励机制"><a href="#3-设定奖励机制" class="headerlink" title="3.设定奖励机制"></a>3.设定奖励机制</h2><p>为自己完成目标设定一个奖励，会让你更有动力去做这件事。比如在你面临一项棘手的任务时，告诉自己如果完成了，就可以去买一个你心仪已久的东西，这会让你更有动力去朝目标努力。同样，可以将奖励机制细分在每个小目标里。每完成一个部分，给自己一个小小的奖励，既能减轻困难感，又能让你更有动力去完成下一个目标。</p>
<h2 id="4-寻找执行后果的吸引力"><a href="#4-寻找执行后果的吸引力" class="headerlink" title="4.寻找执行后果的吸引力"></a>4.寻找执行后果的吸引力</h2><p>在执行任务之前，先去考量完成目标能给你带来的好处。这里的好处可能是：得到领导的肯定、同事的赞许、职位晋升的可能、金钱收入、经验值增长……这样，你的行动就有了一个具有吸引力的目的地，吸引你主动向前，提高执行力。</p>
<h2 id="5-寻找同伴"><a href="#5-寻找同伴" class="headerlink" title="5.寻找同伴"></a>5.寻找同伴</h2><p>行为是具有传染性的。试想，如果你与他人共同完成一项任务，当你看到别人已经行动了，你好意思待着不动么？同伴的参与会督促你尽快执行任务，在“自己不能做得比别人差”的心理作用下，让你的执行效果更加地好。</p>
<h2 id="6-在公共场合公开进度-寻求监督"><a href="#6-在公共场合公开进度-寻求监督" class="headerlink" title="6.在公共场合公开进度,寻求监督"></a>6.在公共场合公开进度,寻求监督</h2><p>很多时候，面子是促进一个人完成目标的重要因素。把你要做的事写在公开场合，让朋友监督，说出去的话，泼出去的水，在众目睽睽之下，为了不丢脸，硬着头皮熬夜也要把这件事做完。</p>
<h2 id="7-五分钟打扫房间法则"><a href="#7-五分钟打扫房间法则" class="headerlink" title="7.五分钟打扫房间法则"></a>7.五分钟打扫房间法则</h2><p>告诉自己只花5分钟去打扫一下房间，看起来很快很简单的样子。事实上，一旦你开始打扫，你就很可能不会在5分钟之后真的停止打扫。打扫后的改观让你得到了成就感，并且想要一鼓作气打扫完毕。在这种观念下，想要再拖延一段时间在开始的想法，就被攻破了。</p>
<h2 id="8-设定一个你难以承受的惩罚措施"><a href="#8-设定一个你难以承受的惩罚措施" class="headerlink" title="8.设定一个你难以承受的惩罚措施"></a>8.设定一个你难以承受的惩罚措施</h2><p>为自己设定一个完不成目标就必须接受的惩罚措施，而且，这个惩罚必须是你很难承受的。比如，在你经济紧张的情况下，告诉朋友，如果自己没有达到目标，就给他一千块钱，并立下字据。如果输了那一千，你很可能接下来的日子会十分拮据，避免不受到惩罚，会迫使你提高执行力。</p>
<p>《为学》里曾说到：</p>
<blockquote>
<p>“自恃其聪与敏而不学者，自败者也；不自限其昏与庸而力学不卷者，自力者也。”</p>
</blockquote>
<p>智力有高低，思想有深浅，但如果不付诸行动去执行，一切都是无用的。在职业成长过程中，执行力才是最好的催促剂。就如老大Ella所说的：“甩开膀子干，赢过一切造作。每一个人，无论今天是什么起点，一切皆有可能。”</p>
<p>新的一年马上要来了，开始行动吧!!</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2015-12-30-executive-ability.html">http://www.sguotao.com/生活感悟-2015-12-30-executive-ability.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章来源：微信公众号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;海尔的企业文化内刊上，刊着一张员工砸冰箱的黑白照片。这件事发生在1985年，海尔公司涣散不堪，只能长期靠借钱维持工厂运营。砸冰箱事件源于一封举报信，用户反映海尔的电冰箱有质量问题。经检
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello 2015</title>
    <link href="http://www.sguotao.com/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2015-01-21-my-2014.html"/>
    <id>http://www.sguotao.com/生活感悟-2015-01-21-my-2014.html</id>
    <published>2015-01-01T04:00:00.000Z</published>
    <updated>2017-06-02T10:17:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>都说开通博客，要写篇文章纪念一下，借此感谢Github，Jekyll,MarkDown,感谢像闫肃,黄玄这样的爱分享的童鞋，2014年对我来说，是很重要的一年，认识了很多人，失去了很多人，总得来说，成长了很多，借此写一篇，纪念我逝去的2014。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>2014年，换了工作，离开了PBI，离开了原来熟悉的环境，离开了熟悉的同事，告别了朝九晚五熟悉的生活节奏，当然也搬离了住了2年的海淀，一切都像当年，从学校出来，搬到海淀的情景。时光荏苒，场景再现，不变的是自己，变了的是身边的人。</p>
<p>以前都是在Android源码的环境下，编译代码，调试应用，曾经一度以为自己对很多知识已经足够了解了，可是突然到了一个更大的平台，你才发现，突来的状况，还是会让你措手不及，所以，当你以为自己很牛了，那是因为你见识的还不够多，在更大的🐂面前，你还是攻击力只有5的渣儿渣儿。</p>
<p>来到了Letv，一切都要从零开始，昨天的已经成为过去，对于未来，还需要今天的积攒，未来还有很长的路要走。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>2014年，研究生进入了第二年，习惯了没有休息日的节奏，突然闲下来，还会有些不适应。在读研之前，没有认真的想过，自己为什么要读，可能是因为曾经考研未果的不甘吧。如果说，读研的收获是为了见识的更多，学到的更多，那我最大的收获，就是认识了很多小伙伴，是他们让我改变了很多，让我发现自己很多性格上的缺点，从而去弥补不足。</p>
<p>2014年，顺利的通过了开题报告，接下来就安心的准备毕业答辩了，在准备的过程中，把工作中内容和答辩的内容结合起来，深入的去了解移动流媒体的内容，相信在未来的工作中，会有很大的帮助。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>2014年，去了江西的三清山，当时还没想到，那竟然是最后一次和同事们一起出去玩，好在当时还没有这种离别的情绪，不然也不会玩的这么尽兴。2015年了，衷心的祝森涛，田田，尚喆，赵哥，晶晶…一切都好。</p>
<p>2014年，去了筹划了已久的西藏，认识了能歌善舞的ZuoZuo，特别会聊天的DiDi，还有原原，感谢徐老师拍的照片和视频，本想写一篇日记记录一下来着，看来只能把这事儿推到2015了，很感慨，为什么人们都说你们变黑了，唯独说我变白了呢？</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>那时我们有梦，<br>关于青春，关于爱情，<br>关于穿于世界的旅行。</p>
</blockquote>
<p>2014年，错过了一些人，有些是因为客观的原因，更多的是因为自己。杰伦结婚了，我们的青春岁月也结束了；科比，阿伦最后一年征战NBA，以后再想看他们打球，只能去翻看以前的视频了，从来没想过他们离开的日子，他们就老了。以后再做错事儿，再也不能拿自己年轻当借口了，遇到合适的人，不能再错过了。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/生活感悟-2015-01-21-my-2014.html">http://www.sguotao.com/生活感悟-2015-01-21-my-2014.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;p&gt;都说开通博客，要写篇文章纪念一下，借此感谢Github，Jekyll,MarkDown,感谢像闫肃,黄玄这样的爱分享的童鞋，2014年对我来
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.sguotao.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活" scheme="http://www.sguotao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Activity Task栈及启动模式</title>
    <link href="http://www.sguotao.com/Android%E8%BF%9B%E9%98%B6-2013-11-11-activity-task-affinity.html"/>
    <id>http://www.sguotao.com/Android进阶-2013-11-11-activity-task-affinity.html</id>
    <published>2013-11-11T02:27:04.000Z</published>
    <updated>2017-06-02T10:37:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android中，一个activity可以激活另一个activity（可能属于另一个应用程序）。若新的被激活的activity属于另一个应用程序，则那个activity会运行在那个应用程序的进程中，但是从用户的角度来看，好像就是属于本应用程序一样。</p>
<p>Android是通过将之前的activity组件和新被激活的activity组件放入同一个任务栈来实现这个功能的。从用户的角度看，一个任务栈就代表了“一个应用程序”。它实际上是一个栈，里面放着一组被排列好的相关的activity组件。位于栈底的activity（根activity）就是开启这个任务栈的activity组件，一般情况下，就是应用程序的主界面。而位于栈顶的activity组件即代表当前被激活的activity组件（可接收用户行为的activity）。</p>
<h2 id="什么是任务栈"><a href="#什么是任务栈" class="headerlink" title="什么是任务栈"></a>什么是任务栈</h2><p>任务栈中包含了activity组件的对象，且任务栈中可以包含某一个activity组件类型的多个实例对象。在任务栈中的activity组件不能被重排序，只能被压栈和弹栈。</p>
<p>任务栈不是某个类型，也不是某一个元素，它是一组activity组件的组织形式。所以没有办法在不影响任务栈中的activity组件的情况下，单独设置任务栈的参数。<strong>根activity的参数既是整个任务栈的参数，它会影响任务栈中的所有activity组件。</strong></p>
<p>当某个应用程序在前后台切换的时候，实际上就是代表这个应用程序的一个任务栈在前后台切换。刚刚描述的行为是activity和任务栈的默认行为，但也有办法在很多方面对它进行修改：</p>
<ul>
<li>方法1：在发送的请求（即Intent对象）中设置一些标记。</li>
<li>方法2：在manifest文件中，对接收请求（即Intent对象）的activity组件设置一些属性。</li>
</ul>
<p>所以在请求者和接收者中都可以进行控制。在Intent对象中主要的标志有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FLAG_ACTIVITY_NEW_TASK  </div><div class="line">FLAG_ACTIVITY_CLEAR_TOP  </div><div class="line">FLAG_ACTIVITY_RESET_TASK_IF_NEEDED  </div><div class="line">FLAG_ACTIVITY_SINGLE_TOP</div></pre></td></tr></table></figure></p>
<p>在<activity>标签中，主要的属性有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">taskAffinity   </div><div class="line">launchMode   </div><div class="line">allowTaskReparenting   </div><div class="line">clearTaskOnLaunch   </div><div class="line">alwaysRetainTaskState   </div><div class="line">finishOnTaskLaunch</div></pre></td></tr></table></figure></activity></p>
<p>接下来的内容就会讲解一些Intent标志和<activity>标签属性的作用和用法。</activity></p>
<h2 id="亲缘关系和新的任务"><a href="#亲缘关系和新的任务" class="headerlink" title="亲缘关系和新的任务"></a>亲缘关系和新的任务</h2><p>默认情况下，一个应用程序中的activity组件彼此之间是亲属关系――也就是说它们属于同一个任务栈。但是我们可以通过设置某个<activity>标签的taskAffinity属性来为这个activity组件设置亲属关系。在不同的应用程序中定义的activity组件可以共用同一个亲属关系，或者在同一个的应用程序中定义的activity组件可以使用不同的亲属关系。亲属关系会在两种情况下发挥作用：</activity></p>
<ul>
<li>1）负责激活activity组件的Intent对象中包含了FLAG_ACTIVITY_NEW_TASK标志。 </li>
<li>2）被激活的activity组件的allowTaskReparenting属性被设置为“true”。</li>
</ul>
<p><strong>关于FLAG_ACTIVITY_NEW_TASK标志量</strong><br>默认情况下，一个被激活的新activity会和负责激活它的那个activity组件存在于同一个任务栈中。但是若负责激活的Intent对象包含了FLAG_ACTIVITY_NEW_TASK标志，则系统会为存放那个即被激活的新activity寻找一个新的任务栈。此时，若已经存在了相同亲属关系的任务栈，则系统会直接将这个即被激活的新activity放入到这个任务栈中；否则系统会开始一个新的任务栈。</p>
<p><strong>关于allowTaskReparenting属性</strong><br>若一个activity组件的allowTaskReparenting被置为“true”，则当与这个activity有相同的亲属关系的任务栈被切换到前台的时候，这个activity会从当前存在的任务栈中移动到与其有相同的亲属关系的任务栈中。<strong>若从用户的角度来看，一个.apk文件包含了一个以上的“应用程序”，那你可能要为那些activity组件指定不同的亲属关系。</strong></p>
<h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p><activity>标签的launchMode属性可以设置为四种不同的模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">“standard”（默认模式）  </div><div class="line">    “singleTop”  </div><div class="line">    “singleTask”  </div><div class="line">    “singleInstance”</div></pre></td></tr></table></figure></activity></p>
<p>这几种模式的区别体现以下四点上：</p>
<ul>
<li><p>1)当这个activity被激活的时候，会放入哪个任务栈。<br>对于“standard”和“singleTop”模式，这个新被激活的activity会放入和之前的activity相同的任务栈中――除非如前所述，Intent对象包含FLAG_ACTIVITY_NEW_TASK标志。但“singleTask”和“singleInstance”模式则表示这个新被激活的activity不会放入已经存在的任务栈中，它会重新开启一个任务栈，并作为这个新的任务栈的根activity。</p>
</li>
<li><p>2)是否可以存在这个activity类型的多个实例。<br>对于“standard”和“singleTop”模式，可以有多个实例，并且这些实例可以属于不同的任务栈，每个任务栈也可以包含有这个activity类型的多个实例。<br>但“singleTask”和“singleInstance”模式则表示至多只可以存在这个activity类型的一个实例。又因为有第一点必须是根activity的限制，所以这意味着在同一时间，在手机上绝不会存在多于一个的由这个activity启动的任务栈。</p>
</li>
<li><p>3)包含此activity的任务栈是否可以包含其它的activity。<br>“singleInstance”模式表示包含此activity的任务栈不可以包含其它的activity。若此activity启动了另一个activity组件，那么无论那个activity组件的启动模式是什么或是Intent对象中是否包含了FLAG_ACTIVITY_NEW_TASK标志，它都会被放入另外的任务栈。在其它方面“singleInstance”模式和“singleTask”模式是一样的。<br>其余三种启动模式则允许包含此activity的任务栈包含其它的activity。 </p>
</li>
<li><p>4)每一个activity实例处理一个intent<br>对于默认的“standard”模式，每当响应一个Intent对象，都会创建一个这种activity类型的新的实例。即每一个activity实例处理一个intent。对于“singleTop”模式，只有当这个activity的实例当前处于任务栈的栈顶位置，则它会被重复利用来处理新到达的intent对象。否则就和“standard”模式的行为一样。正如第二点所说的，“singleTask”和“singleInstance”模式表示只能有一个实例，所以这个唯一的实例需要处理所有新到达的intent对象。又由于“singleInstance”模式的activity实例总是位于任务栈的栈顶，所以这样做很正常。但对于“singleTask”模式的acitvity，在其上面可能存在其它的activity组件，所以它的位置并不是栈顶，在这种情况下，intent对象会被丢弃。（虽然会被丢弃，但是这个intent对象会使这个任务栈切换到前台）</p>
</li>
</ul>
<p><strong>如果一个新到达的intent对象是被一个已经存在的activity组件来处理的，那么这个activity的onNewIntent(android.content.Intent)方法会被系统调用。</strong><br><strong>注意：若为了处理一个新到达的intent对象而创建了一个activity实例，则用户按下“BACK”键就会退到之前的那个activity。但若这个新到达的intent对象是由一个已经存在的activity组件来处理的，那么用户按下“BACK” 键就不会回退到处理这个新intent对象之前的状态了。</strong></p>
<h2 id="清理任务栈"><a href="#清理任务栈" class="headerlink" title="清理任务栈"></a>清理任务栈</h2><p>如果一个任务栈在很长的一段时间都被用户保持在后台的，那么系统就会将这个任务栈中除了根activity以外的其它所有activity全部清除掉。从这之后，当用户再将任务栈切换到前台，则只能显示根activity了。以上说的是默认模式，可以通过<activity>标签的一些属性来更改：</activity></p>
<ul>
<li><p>1）alwaysRetainTaskState属性<br>如果将根activity的alwaysRetainTaskState属性设置为“true”，则即便一个任务栈在很长的一段时间都被用户保持在后台的，系统也不会对这个任务栈进行清理。</p>
</li>
<li><p>2）clearTaskOnLaunch属性<br>如果将根activity的clearTaskOnLaunch属性设置为“true”，那么只有这个任务栈切换到了后台，那么系统就会将这个任务栈中除了根activity以外的其它所有activity全部清除掉。即和alwaysRetainTaskState的行为完全相反。 </p>
</li>
<li><p>3) finishOnTaskLaunch属性<br>这个属性的行为类似于clearTaskOnLaunch，但是此属性作用于单个的activity对象，而不是整个任务栈。当这个任务栈切换到了后台，这个属性可以使任务栈清理包括根activity在内的任何activity对象。</p>
</li>
</ul>
<p>这里也有另一种方法来使activity对象从任务栈中被移除。若Intent对象包含FLAG_ACTIVITY_CLEAR_TOP标志，并且在目标任务栈中已经存在了用于处理这个Intent对象的activity类型的一个实例，那么在任务栈中这个实例之上的所有activity实例会被移除。从而用于处理这个Intent对象的activity类型的那个实例会位于任务栈的栈顶，并用来处理那个Intent对象。若那个匹合的activity类型的启动模式是“standard”，则这个已经存在于任务栈中的匹合的activity类型的实例也会被移除，并且一个新的此类型activity的实例被创建并压栈来处理这个Intent对象。</p>
<p><strong>FLAG_ACTIVITY_CLEAR_TOP这个标志经常和FLAG_ACTIVITY_NEW_TASK标志结合使用，这样结合使用的意思是在另一个任务栈中定位已经存在的匹合的activity类型的实例，并且让此实例位于栈顶。 </strong></p>
<h2 id="启动任务栈"><a href="#启动任务栈" class="headerlink" title="启动任务栈"></a>启动任务栈</h2><p>通过将一个activity类型的intent-filter的动作设置为“android.intent.action.MAIN”，类别设置为“android.intent.category.LAUNCHER”可以使这个activity实例称为一个任务栈的入口。拥有这种类型的intent-filter的activity类型的图标和名字也会显示在application launcher中。</p>
<p>第二个能力是很重要的：用户必须能够使一个任务栈切换到后台，也可以随时将其切换到前台。出于这个原因，使activity在启动时新开任务栈的启动模式（即“singleTask”和“singleInstance”模式）只应该被利用在拥有拥有“android.intent.action.MAIN”动作和“android.intent.category.LAUNCHER”类别的intent-filter的activity类型上。</p>
<p>类似的限制同样体现在FLAG_ACTIVITY_NEW_TASK标志上。如果这个标志使一个activity开始了一个新的任务栈，并且用户点击“HOME”键将其切换到了后台，则必须有某种方式使用户可以重新将那个任务栈切换到前台。一些实例（比如通知管理器），总是在外部的任务栈中开启一个activity，而不是其自身的任务栈，所以它们总是将FLAG_ACTIVITY_NEW_TASK标志放入Intent对象中，并将Intent对象传入startActivity()方法中。</p>
<p>对于在某些情况下，你不希望用户能够返回到某一个activity，那么可以通过设置<activity>标签的“finishOnTaskLaunch”属性为“true”来实现。</activity></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android进阶-2013-11-11-activity-task-affinity.html">http://www.sguotao.com/Android进阶-2013-11-11-activity-task-affinity.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android中，一个activity可以激活另一个activity（可能属于另一个应用程序）。若新的被激活的activity属于另一个应用程序，则那个activity会运行在那个应用程序的进程中，但是从用户的角度来看，好像就是属于本应用程序一样。&lt;/p&gt;
&lt;p&gt;Andr
    
    </summary>
    
      <category term="Android进阶" scheme="http://www.sguotao.com/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://www.sguotao.com/tags/Activity/"/>
    
      <category term="启动模式" scheme="http://www.sguotao.com/tags/%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 设置全屏显示</title>
    <link href="http://www.sguotao.com/Android%E5%9F%BA%E7%A1%80-2012-08-15-android%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E6%98%BE%E7%A4%BA.html"/>
    <id>http://www.sguotao.com/Android基础-2012-08-15-android设置全屏显示.html</id>
    <published>2012-08-15T02:27:04.000Z</published>
    <updated>2017-06-02T10:37:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android中实现全屏显示的两种方式:</p>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>在AndroidManifest.xml文件中通过设置Application或Activity的android:theme属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">            android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;</div><div class="line">            android:name=&quot;.TestViewAnimation&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</div><div class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div></pre></td></tr></table></figure></p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>在Activity的onCreate()方法中进行设置(<strong>两行代码还必须写在setContentView()前面。</strong>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">          /*set it to be no title*/</div><div class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</div><div class="line">        /*set it to be full screen*/</div><div class="line">        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);</div><div class="line">        setContentView(R.layout.activity_test_view_animation);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="方式三-补充"><a href="#方式三-补充" class="headerlink" title="方式三(补充)"></a>方式三(补充)</h2><p>在AppCompatActivity设置全屏，情况有些特殊。发现当Activity继承AppCompatActivity时，以上两种方法会出现Crash和无法编译的情况。这时需要我们创建一个style样式，并在AndroidManifest.xml文件中需要全屏显示的Activity使用该样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;theme_fullscreen&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</div><div class="line">    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</div><div class="line">    &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;</div><div class="line">    &lt;item name=&quot;android:windowActionBar&quot;&gt;false&lt;/item&gt;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android基础-2012-08-15-android设置全屏显示.html">http://www.sguotao.com/Android基础-2012-08-15-android设置全屏显示.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android中实现全屏显示的两种方式:&lt;/p&gt;
&lt;h2 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式一&lt;/h2&gt;&lt;p&gt;在AndroidManifest.xml文件中通过设置Application
    
    </summary>
    
      <category term="Android基础" scheme="http://www.sguotao.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="代码库" scheme="http://www.sguotao.com/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Android基础16 传感器</title>
    <link href="http://www.sguotao.com/Android%E5%9F%BA%E7%A1%80-2011-08-14-android-basic-16.html"/>
    <id>http://www.sguotao.com/Android基础-2011-08-14-android-basic-16.html</id>
    <published>2011-08-14T02:27:04.000Z</published>
    <updated>2017-06-02T10:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-传感器"><a href="#1-传感器" class="headerlink" title="1. 传感器"></a>1. 传感器</h2><p>传感器类型：方向、加速度(重力)、光线、磁场、距离(临近性)、温度等。 </p>
<table>
<thead>
<tr>
<th>方向传感器</th>
<th style="text-align:center">Sensor.TYPE_ORIENTATION</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>加速度(重力)传感器 | Sensor.TYPE_ACCELEROMETER<br>光线传感器 | Sensor.TYPE_LIGHT<br>磁场传感器 | Sensor.TYPE_MAGNETIC_FIELD<br>距离(临近性)传感器 | Sensor.TYPE_PROXIMITY<br>温度传感器 | Sensor.TYPE_TEMPERATURE</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//获取某种类型的感应器</div><div class="line">Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);</div><div class="line">//注册监听，获取传感器变化值</div><div class="line">sensorManager.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_GAME);</div></pre></td></tr></table></figure>
<p>上面第三个参数为采样率：最快、游戏、普通、用户界面。当应用程序请求特定的采样率时，其实只是对传感器子系统的一个建议，不保证特定的采样率可用。</p>
<table>
<thead>
<tr>
<th>最快</th>
<th style="text-align:center">SensorManager.SENSOR_DELAY_FASTEST</th>
<th style="text-align:center">最低延迟，一般不是特别敏感的处理不推荐使用，该种模式可能造成手机电力大量消耗，由于传递的为原始数据，算法不处理好将会影响游戏逻辑和UI的性能。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p> 游戏 | SensorManager.SENSOR_DELAY_GAME | 游戏延迟，一般绝大多数的实时性较高的游戏都使用该级别。<br>普通 | SensorManager.SENSOR_DELAY_NORMAL | 标准延迟，对于一般的益智类或EASY级别的游戏可以使用，但过低的采样率可能对一些赛车类游戏有跳帧现象。<br>用户界面 | SensorManager.SENSOR_DELAY_UI | 一般对于屏幕方向自动旋转使用，相对节省电能和逻辑处理，一般游戏开发中我们不使用。</p>
<p>下面介绍如何获取加速度(重力)传感器和方向传感器的测量值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">	private TextView accelerometer;</div><div class="line">	private TextView orientation;</div><div class="line">	private SensorManager sensorManager;</div><div class="line">	</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.main);</div><div class="line">        //①获取感应器管理器</div><div class="line">        sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);</div><div class="line">        accelerometer = (TextView) findViewById(R.id.accelerometer);  </div><div class="line">        orientation = (TextView) findViewById(R.id.orientation);  </div><div class="line">    &#125;</div><div class="line">		@Override</div><div class="line">		protected void onResume() &#123;</div><div class="line">		//②获取重力加速度传感器</div><div class="line">		Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);</div><div class="line">		//③注册监听器</div><div class="line">	 	sensorManager.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_GAME);	</div><div class="line">		Sensor sensor1 = sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);//获取方向传感器</div><div class="line">		sensorManager.registerListener(listener, sensor1, SensorManager.SENSOR_DELAY_GAME);	</div><div class="line">		super.onResume();</div><div class="line">	&#125; </div><div class="line">    @Override</div><div class="line">	protected void onPause() &#123;</div><div class="line">		//④注消所有传感器监听</div><div class="line">    	sensorManager.unregisterListener(listener); </div><div class="line">		super.onPause();</div><div class="line">	&#125;</div><div class="line">	private SensorEventListener listener = new SensorEventListener() &#123;		</div><div class="line">		@Override</div><div class="line">		public void onSensorChanged(SensorEvent event) &#123;//当传感器的值发生变化			</div><div class="line">			float x = event.values[SensorManager.DATA_X];      </div><div class="line">        	float y = event.values[SensorManager.DATA_Y];      </div><div class="line">		    float z = event.values[SensorManager.DATA_Z];  </div><div class="line">		switch (event.sensor.getType()) &#123;</div><div class="line">			case Sensor.TYPE_ACCELEROMETER:</div><div class="line">				accelerometer.setText(&quot;Accelerometer Sensor: &quot; + x + &quot;, &quot; + y + &quot;, &quot; + z); </div><div class="line">				break;</div><div class="line">			case Sensor.TYPE_ORIENTATION:</div><div class="line">				orientation.setText(&quot;Orientation Sensor: &quot; + x + &quot;, &quot; + y + &quot;, &quot; + z); </div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;		</div><div class="line">		@Override</div><div class="line">		public void onAccuracyChanged(Sensor sensor, int accuracy) &#123;//当传感器的精度变化时	</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法orientation.setText(x，y，z);参数的含义</strong></p>
<ol>
<li>x该值表示方位，0代表北（North）；90代表东（East）；180代表南（South）；270代表西（West）如果x值正好是这4个值之一，并且手机是水平放置，手机的顶部对准的方向就是该值代表的方向。</li>
<li>y值表示倾斜度，或手机翘起的程度。当手机绕着X轴倾斜时该值发生变化。y值的取值范围是-180≤y值 ≤180。</li>
<li>z值来测量桌子等物体的倾斜度。<br>z值表示手机沿着Y轴的滚动角度。表示手机沿着Y轴的滚动角度。取值范围是-90≤z值≤90。假设将手机屏幕朝上水平放在桌面上，这时如果桌面是平的，z值应为0。将手机左侧逐渐抬起时，z值逐渐变小，直到手机垂直于桌面放置，这时z值是-90。将手机右侧逐渐抬起时，z值逐渐增大，    直到手机垂直于桌面放置，这时z值是90。在垂直位置时继续向右或向左滚动，z值会继续在-90至90之间变化。</li>
</ol>
<p>假设将手机屏幕朝上水平放在桌子上，这时如果桌子是完全水平的，y值应该是0（由于很少有桌子是绝对水平的，因此，该值很可能不为0，但一般都是-5和5之间的某个值）。这时从手机顶部开始抬起，直到将手机沿X轴旋转180度（屏幕向下水平放在桌面上）。在这个旋转过程中，y值会在0到-180之间变化，也就是说，从手机顶部抬起时，y的值会逐渐变小，直到等于-180。如果从手机底部开始抬起，直到将手机沿X轴旋转180度，这时y值会在0到180之间变化。也就是y值会逐渐增大，直到等于180。可以利用y值和使用方向传感器（案例：指南针）</p>
<h2 id="2-NinePatch图片"><a href="#2-NinePatch图片" class="headerlink" title="2. NinePatch图片"></a>2. NinePatch图片</h2><p><img src="http://obovytgzz.bkt.clouddn.com/9patch1.png" alt="图片1"><br>NinePatch是一种很有用的PNG图片格式，它可以在特定区域随文字大小进行缩放。如下：</p>
<p>从上图可以看到，背景图片的中间区域会随着文字的大小进行缩放。背景图片是一张NinePatch图片。 NinePatch图片可以使用android自带的draw9patch工具来制作，该工具在SDK安装路径的tools目录下。执行该工具，然后点击“File”-&gt;“open 9-path”打开一张用于制作NinePatch图片的原来图片。在画布的上方和左方的边上画线指定缩放区域，勾选“Show patches”可显示画定的区域，绿色为固定大小区域，红色为缩放区域，文字会摆放在红色区域。制作完后，点击“File” “save 9-path”保存图片，draw9patch工具会自动为图片加上*.9.png后缀。</p>
<p>把制作好的图片拷贝进项目的res/drawable目录，然后编写代码。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;TextView android:layout_width=&quot;wrap_content&quot; </div><div class="line">    android:layout_height=&quot;wrap_content&quot;</div><div class="line">    android:text=&quot;退出&quot; android:textColor=&quot;#330000&quot;</div><div class="line">    android:background=&quot;@drawable/button&quot;/&gt;</div></pre></td></tr></table></figure>
<p><img src="http://obovytgzz.bkt.clouddn.com/9patch2.png" alt="图片2"></p>
<h2 id="3-触摸事件"><a href="#3-触摸事件" class="headerlink" title="3. 触摸事件"></a>3. 触摸事件</h2><h3 id="3-1-拖拽"><a href="#3-1-拖拽" class="headerlink" title="3.1 拖拽"></a>3.1 拖拽</h3><p>XML配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;ImageView  </div><div class="line">		android:id=&quot;@+id/img&quot;</div><div class="line">	    android:layout_width=&quot;wrap_content&quot; </div><div class="line">	    android:layout_height=&quot;wrap_content&quot; </div><div class="line">	    android:scaleType=&quot;matrix&quot;</div><div class="line">	    android:src=&quot;@drawable/bb2&quot;   /&gt;</div></pre></td></tr></table></figure>
<p>Java代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ImageView imageView = (ImageView) findViewById(R.id.img);</div><div class="line">imageView.setOnTouchListener(new MyListener());</div><div class="line">private final class MyListener implements OnTouchListener &#123;</div><div class="line">		private float x;	</div><div class="line">		private float y;</div><div class="line">		private Matrix startMatrix = new Matrix();</div><div class="line">		private Matrix matrix = new Matrix();</div><div class="line">		public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">			switch (event.getAction()) &#123;</div><div class="line">				case MotionEvent.ACTION_DOWN:</div><div class="line">					x = event.getX();</div><div class="line">					y = event.getY();</div><div class="line">					startMatrix.set(imageView.getImageMatrix());</div><div class="line">					break;</div><div class="line">				case MotionEvent.ACTION_MOVE:</div><div class="line">					matrix.set(startMatrix);</div><div class="line">					matrix.postTranslate(event.getX() - x, event.getY() - y);</div><div class="line">					break;</div><div class="line">			&#125;</div><div class="line">			imageView.setImageMatrix(matrix);</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-多点触控"><a href="#3-2-多点触控" class="headerlink" title="3.2 多点触控"></a>3.2 多点触控</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">private final class MyListener implements OnTouchListener &#123;</div><div class="line">		private float x;</div><div class="line">		private float y;</div><div class="line">		private Matrix matrix = new Matrix();</div><div class="line">		private Matrix startMatrix = new Matrix();</div><div class="line">		private int type;</div><div class="line">		private float startDis;</div><div class="line">		private PointF point;</div><div class="line">		public boolean onTouch(View v, MotionEvent event) &#123;</div><div class="line">			System.out.println(event.getAction());</div><div class="line">			switch (event.getAction()) &#123;</div><div class="line">				case MotionEvent.ACTION_DOWN:</div><div class="line">					type = 1;</div><div class="line">					x = event.getX();</div><div class="line">					y = event.getY();</div><div class="line">					startMatrix.set(imageView.getImageMatrix());</div><div class="line">					break;</div><div class="line">				case MotionEvent.ACTION_MOVE:</div><div class="line">					matrix.set(startMatrix);</div><div class="line">					if (type == 1)</div><div class="line">						matrix.postTranslate(event.getX() - x, event.getY() - y);</div><div class="line">					else &#123;</div><div class="line">						float scale = getDis(event) / startDis;</div><div class="line">						matrix.postScale(scale, scale, point.x, point.y);</div><div class="line">					&#125;</div><div class="line">					break;</div><div class="line">				case MotionEvent.ACTION_POINTER_DOWN:</div><div class="line">					type = 2;</div><div class="line">					startMatrix.set(imageView.getImageMatrix());</div><div class="line">					startDis = getDis(event);</div><div class="line">					point = getPoint(event);</div><div class="line">					break;</div><div class="line">			&#125;</div><div class="line">			imageView.setImageMatrix(matrix);</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	private float getDis(MotionEvent event) &#123;</div><div class="line">		float a = event.getX(1) - event.getX(0);</div><div class="line">		float b = event.getY(1) - event.getY(0);</div><div class="line">		return (float) Math.sqrt(a * a + b * b);</div><div class="line">	&#125;</div><div class="line">	private PointF getPoint(MotionEvent event) &#123;</div><div class="line">		float x = (event.getX(0) + event.getX(1)) / 2;</div><div class="line">		float y = (event.getY(0) + event.getY(1)) / 2;</div><div class="line">		return new PointF(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-读取SIM卡"><a href="#4-读取SIM卡" class="headerlink" title="4. 读取SIM卡"></a>4. 读取SIM卡</h2><p>文档位置：<br>android-sdk-windows\platforms\android-8\sources\ContactsProvider\src\com\android\providers\contacts\ CallLogProvider.java</p>
<h3 id="4-1-判断SIM卡属于那个运营商"><a href="#4-1-判断SIM卡属于那个运营商" class="headerlink" title="4.1 判断SIM卡属于那个运营商"></a>4.1 判断SIM卡属于那个运营商</h3><p>SIM卡的IMSI码是SIM卡唯一标识：IMSI 国际移动用户识别码（IMSI：International Mobile Subscriber Identification Number）是区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息。IMSI由MCC、MNC、MSIN组成，其中MCC为移动国家号码，由3位数字组成，唯一地识别移动客户所属的国家，我国为460；MNC为网络id，由2位数字组成，用于识别移动客户所归属的移动网络，中国移动为00，中国联通为01,中国电信为03；MSIN为移动客户识别码，采用等长11位数字构成。唯一地识别国内GSM.移动通信网中移动客户。所以要区分是移动还是联通，只需取得SIM卡中的MNC字段即可。<br>需要权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;</div></pre></td></tr></table></figure>
<p>Java代码实现：<br>第一种方法:获取手机的IMSI码,并判断是中国移动\中国联通\中国电信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">TelephonyManager telManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);</div><div class="line">        String imsi = telManager.getSubscriberId();</div><div class="line"> if(imsi!=null)&#123;</div><div class="line">//因为移动网络编号46000下的IMSI已经用完,所以虚拟了一个46002编号，134/159号段使用了此编号</div><div class="line">        if(imsi.startsWith(&quot;46000&quot;) || imsi.startsWith(&quot;46002&quot;))&#123;  //中国移动</div><div class="line">        &#125;else if(imsi.startsWith(&quot;46001&quot;))&#123; //中国联通        </div><div class="line">        &#125;else if(imsi.startsWith(&quot;46003&quot;))&#123; //中国电信</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TelephonyManager telManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);</div><div class="line">        String operator = telManager.getSimOperator();</div><div class="line"> if(operator!=null)&#123;</div><div class="line">        if(operator.equals(&quot;46000&quot;) || operator.equals(&quot;46002&quot;))&#123;  //中国移动</div><div class="line">        &#125;else if(operator.equals(&quot;46001&quot;))&#123;//中国联通</div><div class="line">        &#125;else if(operator.equals(&quot;46003&quot;))&#123;//中国电信</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-2-从SIM卡中获取联系人信息"><a href="#4-2-从SIM卡中获取联系人信息" class="headerlink" title="4.2 从SIM卡中获取联系人信息"></a>4.2 从SIM卡中获取联系人信息</h3><p>Android系统内部通过Contentprovider对外共享Sim卡存放的联系人等信息，你可以通过操作Contentprovider来实现Sim卡信息的添删改查操作。 需要权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;</div></pre></td></tr></table></figure>
<p>Java代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(&quot;content://icc/adn&quot;);</div><div class="line">		Cursor c = getContentResolver().query(uri, null, null, null, null);</div><div class="line">		while (c.moveToNext())</div><div class="line">			System.out.println(c.getString(c.getColumnIndex(&quot;name&quot;)) + &quot;: &quot; </div><div class="line">        + c.getString(c.getColumnIndex(&quot;number&quot;)));</div></pre></td></tr></table></figure>
<h3 id="4-3-删除呼叫记录"><a href="#4-3-删除呼叫记录" class="headerlink" title="4.3 删除呼叫记录"></a>4.3 删除呼叫记录</h3><p>需要权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot; /&gt;</div></pre></td></tr></table></figure>
<p>负责存放呼叫记录的内容提供者源码在ContactsProvider项目下：</p>
<ol>
<li>源码路径：com\android\providers\contacts\CallLogProvider.java</li>
<li>使用到的数据库在：/data/data/com.android.providers.contacts/databases/contacts2.db</li>
<li>表名:calls</li>
</ol>
<p><strong>呼叫记录有三种类型</strong></p>
<ol>
<li>来电：CallLog.Calls.INCOMING_TYPE （常量值：1）</li>
<li>外拔：CallLog.Calls.OUTGOING_TYPE（常量值：2）</li>
<li>未接：CallLog.Calls.MISSED_TYPE（常量值：3）</li>
</ol>
<p>删除指定号码的来电或未接呼叫记录：Java代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">IncomingCallLogContentObserver observer = new IncomingCallLogContentObserver(new Handler());</div><div class="line">observer.setNumber(&quot;5554&quot;);</div><div class="line">getContentResolver().registerContentObserver(CallLog.Calls.CONTENT_URI, true, observer);</div><div class="line">private class IncomingCallLogContentObserver extends ContentObserver &#123;</div><div class="line">        private String number;</div><div class="line">        public IncomingCallLogContentObserver(Handler handler)&#123;    	 </div><div class="line">      	  super(handler);      	 </div><div class="line">        &#125;</div><div class="line">        public void setNumber(String number)&#123;</div><div class="line">        	 this.number = number;</div><div class="line">        &#125;</div><div class="line">        public void onChange(boolean paramBoolean)&#123;</div><div class="line">        	ContentResolver contentResolver = getContentResolver();</div><div class="line">        	if(number!=null)&#123;              </div><div class="line">              Uri localUri = CallLog.Calls.CONTENT_URI;</div><div class="line"> Cursor cursor = contentResolver.query(localUri, new String[]&#123;&quot;_id&quot;&#125;, &quot;number=? AND (type=1 OR type=3)&quot;, </div><div class="line">              		new String[]&#123;number&#125;, &quot;_id desc limit 1&quot;);</div><div class="line">              if(cursor.moveToFirst())&#123;</div><div class="line">  	            contentResolver.delete(localUri, &quot;_id=?&quot;, new String[]&#123;cursor.getString(0)&#125;);</div><div class="line">              &#125;</div><div class="line">              cursor.close();</div><div class="line">        	&#125;</div><div class="line">            contentResolver.unregisterContentObserver(this);</div><div class="line">        &#125;｝</div></pre></td></tr></table></figure>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android基础-2011-08-14-android-basic-16.html">http://www.sguotao.com/Android基础-2011-08-14-android-basic-16.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-传感器&quot;&gt;&lt;a href=&quot;#1-传感器&quot; class=&quot;headerlink&quot; title=&quot;1. 传感器&quot;&gt;&lt;/a&gt;1. 传感器&lt;/h2&gt;&lt;p&gt;传感器类型：方向、加速度(重力)、光线、磁场、距离(临近性)、温度等。 &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
    
    </summary>
    
      <category term="Android基础" scheme="http://www.sguotao.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="传感器" scheme="http://www.sguotao.com/tags/%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android基础15 动画特效</title>
    <link href="http://www.sguotao.com/Android%E5%9F%BA%E7%A1%80-2011-08-13-android-basic-15.html"/>
    <id>http://www.sguotao.com/Android基础-2011-08-13-android-basic-15.html</id>
    <published>2011-08-13T02:27:04.000Z</published>
    <updated>2017-06-02T10:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Tween动画"><a href="#1-Tween动画" class="headerlink" title="1. Tween动画"></a>1. Tween动画</h2><p>将某个组件以渐变的方式实现透明、缩放、移动、旋转等动画效果。<br><img src="http://obovytgzz.bkt.clouddn.com/anni1.png" alt="图片1"></p>
<p>详见文档android-sdk-windows/docs/guide/topics/resources/animation-resource.html</p>
<h2 id="2-Frame动画"><a href="#2-Frame动画" class="headerlink" title="2. Frame动画"></a>2. Frame动画</h2><p>通过多个画面连续播放实现动画效果，开发步骤：</p>
<ul>
<li>把准备好的图片放进项目res/ drawable下。</li>
<li>在项目的res目录下创建文件夹anim，然后在anim文件夹下面定义动画XML文件，文件名称        可以自定义。当然也可以采用编码方式定义动画效果（使用AnimationDrawable类）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">android:oneshot=&quot;false&quot;&gt;</div><div class="line">&lt;item android:drawable=&quot;@drawable/girl_1&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">&lt;item android:drawable=&quot;@drawable/girl_2&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">&lt;item android:drawable=&quot;@drawable/girl_3&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">&lt;/animation-list&gt;</div></pre></td></tr></table></figure>
<ul>
<li>为View控件绑定动画效果。调用代表动画的AnimationDrawable的start()方法开始动画。<br>详见文档 android-sdk-windows/docs/guide/topics/resources/animation-resource.html</li>
</ul>
<h2 id="3-使用动画切换Activity"><a href="#3-使用动画切换Activity" class="headerlink" title="3. 使用动画切换Activity"></a>3. 使用动画切换Activity</h2><p>在startActivity()方法调用之后调用<br>overridePendingTransition(int enterAnim, int exitAnim)方法<br>enterAnim 进入的动画资源id<br>exitAnim 退出的动画    资源id</p>
<h2 id="4-使用动画翻页"><a href="#4-使用动画翻页" class="headerlink" title="4. 使用动画翻页"></a>4. 使用动画翻页</h2><p>XML配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;ViewFlipper</div><div class="line">	android:id=&quot;@+id/viewFlipper&quot;</div><div class="line">	android:layout_width=&quot;fill_parent&quot;</div><div class="line">	android:layout_height=&quot;fill_parent&quot;&gt;</div><div class="line">   	&lt;ImageView</div><div class="line">	    android:layout_width=&quot;wrap_content&quot;</div><div class="line">	    android:layout_height=&quot;wrap_content&quot;</div><div class="line">   		android:src=&quot;@drawable/bb2&quot;/&gt;</div><div class="line">   	&lt;ImageView</div><div class="line">	    android:layout_width=&quot;wrap_content&quot;</div><div class="line">	    android:layout_height=&quot;wrap_content&quot;</div><div class="line">   		android:src=&quot;@drawable/bb3&quot;/&gt;</div><div class="line">&lt;/ViewFlipper&gt;</div></pre></td></tr></table></figure>
<p>Java代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">	ViewFlipper viewFlipper = (ViewFlipper) findViewById(R.id.viewFlipper);</div><div class="line">	switch (event.getAction()) &#123;</div><div class="line">		case MotionEvent.ACTION_DOWN:</div><div class="line">			start = event.getX();</div><div class="line">			break;</div><div class="line">		case MotionEvent.ACTION_UP:</div><div class="line">			float end = event.getX();</div><div class="line">			if (end &gt; start) &#123;</div><div class="line">				viewFlipper.setInAnimation(this, R.anim.previous_enter);</div><div class="line">				viewFlipper.setOutAnimation(this, R.anim.previous_exit);</div><div class="line">				viewFlipper.showPrevious();</div><div class="line">			&#125; else if (end &lt; start) &#123;</div><div class="line">				viewFlipper.setInAnimation(this, R.anim.next_enter);</div><div class="line">				viewFlipper.setOutAnimation(this, R.anim.next_exit);</div><div class="line">				viewFlipper.showNext();</div><div class="line">			&#125;</div><div class="line">			break;</div><div class="line">	&#125;</div><div class="line">	return super.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-动画练习"><a href="#5-动画练习" class="headerlink" title="5. 动画练习"></a>5. 动画练习</h2><h3 id="5-1-本例要实现对ImageView对象进行渐变尺寸缩放动画效果"><a href="#5-1-本例要实现对ImageView对象进行渐变尺寸缩放动画效果" class="headerlink" title="5.1 本例要实现对ImageView对象进行渐变尺寸缩放动画效果"></a>5.1 本例要实现对ImageView对象进行渐变尺寸缩放动画效果</h3><ul>
<li>在项目的res目录下创建文件夹anim，然后在anim文件夹下面定义动画XML文件,文件名称可以自定义，如：scale.xml，内容如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line"> &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; </div><div class="line">    &lt;scale android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; </div><div class="line">        android:fromXScale=&quot;0.0&quot; </div><div class="line">        android:fromYScale=&quot;0.0&quot;  </div><div class="line">        android:toXScale=&quot;5&quot; </div><div class="line">        android:toYScale=&quot;5&quot; </div><div class="line">        android:pivotX=&quot;50%&quot; </div><div class="line">        android:pivotY=&quot;50%&quot; </div><div class="line">        android:fillAfter=&quot;false&quot; </div><div class="line">        android:duration=&quot;5000&quot;  /&gt; </div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
<p>动画的进度使用interpolator控制，android提供了几个Interpolator 子类，实现了不同的速度曲线，如LinearInterpolator实现了匀速效果、Accelerateinterpolator实现了加速效果、DecelerateInterpolator实现了减速效果等。还可以定义自己的Interpolator子类，实现抛物线、自由落体等物理效果。</p>
<p>fromXScale（浮点型） 属性为动画起始时X坐标上的缩放尺寸<br>fromYScale（浮点型） 属性为动画起始时Y坐标上的缩放尺寸<br>toXScale（浮点型）   属性为动画结束时X坐标上的缩放尺寸<br>toYScale（浮点型）   属性为动画结束时Y坐标上的缩放尺寸</p>
<p>说明: 以上四种属性值<br>0.0表示收缩到没有<br>1.0表示正常无缩放<br>值小于1.0表示收缩<br>值大于1.0表示放大<br>pivotX（浮点型）     属性为动画相对于物件的X坐标的开始位置<br>pivotY（浮点型）     属性为动画相对于物件的Y坐标的开始位置 </p>
<p>说明:<br>以上两个属性值 从0%-100%中取值<br>50%为物件的X或Y方向坐标上的中点位置<br>duration（长整型）属性为动画持续时间 。说明:   时间以毫秒为单位<br>fillAfter（布尔型）属性当设置为true，该动画转化在动画结束后被应用</p>
<ul>
<li>在layout文件添加&lt;ImageView&gt;节点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;horizontal&quot;</div><div class="line">    android:layout_width=&quot;fill_parent&quot;</div><div class="line">    android:layout_height=&quot;fill_parent&quot;&gt;</div><div class="line">&lt;ImageView</div><div class="line">   android:layout_width=&quot;wrap_content&quot;</div><div class="line">   android:layout_height=&quot;wrap_content&quot;</div><div class="line">   android:src=&quot;@drawable/icon&quot;</div><div class="line">   android:id=&quot;@+id/imageView&quot; /&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>说明：除了可以对&lt;ImageView&gt;实现动画效果，其实也可以对其他View实现动画效果，如：&lt;TextView&gt;</p>
<ul>
<li>在Activity里对ImageView使用前面定义好的动画效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class AnimationActivity extends Activity &#123;</div><div class="line">	@Override</div><div class="line">	public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.main);</div><div class="line">		ImageView imageView = (ImageView)this.findViewById(R.id.imageView);</div><div class="line">		//加载动画XML文件,生成动画指令</div><div class="line">		Animation animation = AnimationUtils.loadAnimation(this, R.anim.scale);</div><div class="line">		//开始执行动画</div><div class="line">		imageView.startAnimation(animation);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>备注：上面采用的是xml文件定义动画效果，作为代替，也可以采用编码方式实现。下面采用编码方式实现上述例子同样的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class AnimationActivity extends Activity &#123;</div><div class="line">	@Override	</div><div class="line">	public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.main);</div><div class="line">		ImageView imageView = (ImageView)this.findViewById(R.id.imageView);</div><div class="line">		ScaleAnimation animation = new ScaleAnimation(0.0f, 5f, 0.0f, 5f, </div><div class="line">		Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">		animation.setDuration(5000); //设置持续时间5秒</div><div class="line">		imageView.startAnimation(animation);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-2-其他动画效果定义例子"><a href="#5-2-其他动画效果定义例子" class="headerlink" title="5.2 其他动画效果定义例子"></a>5.2 其他动画效果定义例子</h3><ul>
<li>渐变透明度动画效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">	&lt;alpha</div><div class="line">		android:fromAlpha=&quot;0.1&quot;	</div><div class="line">		android:toAlpha=&quot;1.0&quot;</div><div class="line">		android:duration=&quot;3000&quot;/&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
<p>编码实现透明度动画效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class AnimationActivity extends Activity &#123;</div><div class="line">	@Override</div><div class="line">	public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.main);</div><div class="line">		ImageView imageView = (ImageView)this.findViewById(R.id.imageView);</div><div class="line">		AlphaAnimation animation = new AlphaAnimation(0.1, 1.0); </div><div class="line">		animation.setDuration(5000); //设置持续时间5秒</div><div class="line">		imageView.startAnimation(animation);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>画面位置移动动画效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">&lt;translate</div><div class="line">android:repeatCount=&quot;2&quot;</div><div class="line">android:fromXDelta=&quot;0&quot;</div><div class="line">android:fromYDelta=&quot;0&quot;</div><div class="line">android:toXDelta=&quot;120&quot;</div><div class="line">android:toYDelta=&quot;120&quot;</div><div class="line">android:duration=&quot;3000&quot;/&gt;</div><div class="line">&lt;!-- fromXDelta fromYDelta 为动画起始时 X和Y坐标上的位置</div><div class="line">toXDelta toYDelta为动画结束起始时  X和Y坐标上的位置 --&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
<p>编码实现位置移动动画效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class AnimationActivity extends Activity &#123;</div><div class="line">	@Override</div><div class="line">	public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.main);</div><div class="line">		ImageView imageView = (ImageView)this.findViewById(R.id.imageView);</div><div class="line">		TranslateAnimation animation = new TranslateAnimation(0, 120, 0, 120); </div><div class="line">		animation.setDuration(5000); //设置持续时间5秒</div><div class="line">		imageView.startAnimation(animation);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>画面旋转动画效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">&lt;rotate</div><div class="line">android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;</div><div class="line">android:repeatCount=&quot;2&quot;</div><div class="line">android:fromDegrees=&quot;0&quot;</div><div class="line">android:toDegrees=&quot;+360&quot;</div><div class="line">android:pivotX=&quot;50%&quot;</div><div class="line">android:pivotY=&quot;50%&quot;</div><div class="line">android:duration=&quot;3000&quot;/&gt;</div><div class="line">&lt;!-- </div><div class="line">repeatCount 重复次数</div><div class="line">fromDegrees为动画起始时物件的角度:</div><div class="line">当角度为负数——表示逆时针旋转</div><div class="line">当角度为正数——表示顺时针旋转</div><div class="line">(负数fromDegrees——toDegrees正数:顺时针旋转)</div><div class="line">(负数fromDegrees——toDegrees负数:逆时针旋转)</div><div class="line">(正数fromDegrees——toDegrees正数:顺时针旋转)</div><div class="line">(正数fromDegrees——toDegrees负数:逆时针旋转)</div><div class="line">toDegrees属性为动画结束时物件旋转的角度 可以大于360度</div><div class="line">pivotX,pivotY  为动画相对于物件的X、Y坐标的开始位置。说明：以上两个属性值 从0%-100%中取值,50%为物件的X或Y方向坐标上的中点位置</div><div class="line"> --&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
<p>编码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RotateAnimation animation = new RotateAnimation(0, -90, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);</div><div class="line">animation.setDuration(500);</div><div class="line">imageView.startAnimation(animation);</div></pre></td></tr></table></figure>
<ul>
<li>Frame动画例子<br>a)    把准备好的图片放进项目res/ drawable下。图片有：girl_1.gif, girl_2.gif, girl_3.gif<br>b)    在项目的res目录下创建文件夹anim，然后在anim文件夹下面定义动画XML文件，文件名称可以自定义,如：frame.xml。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:oneshot=&quot;false&quot;&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/girl_1&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/girl_2&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/girl_3&quot; android:duration=&quot;200&quot; /&gt;</div><div class="line">&lt;/animation-list&gt;</div></pre></td></tr></table></figure>
<p>上面的XML就定义了一个Frame动画，其包含3帧动画，3帧动画中分别应用了drawable中的3张图片：girl_1.gif, girl_2.gif, girl_3.gif，每帧动画持续200毫秒。android:oneshot属性如果为true，表示动画只播放一次停止在最后一帧上，如果设置为false表示动画循环播放。</p>
<p>c)    为View控件绑定动画效果，调用代表动画的AnimationDrawable的start()方法开始动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FrameActivity extends Activity &#123;</div><div class="line">	private AnimationDrawable animationDrawable;</div><div class="line">	@Override</div><div class="line">	public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.main);</div><div class="line">		ImageView imageView = (ImageView)this.findViewById(R.id.imageView);</div><div class="line">		imageView.setBackgroundResource(R.anim.frame);</div><div class="line">		animationDrawable = (AnimationDrawable) imageView.getBackground();</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">		  if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;//按下</div><div class="line">			  animationDrawable.start();</div><div class="line">			  return true;</div><div class="line">		  &#125;</div><div class="line">		  return super.onTouchEvent(event);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一点需要强调的是：启动Frame动画的代码animationDrawable.start();不能应用在OnCreate()方法中，因为在OnCreate()中 AnimationDrawable还没有完全的与ImageView绑定。在OnCreate()中启动动画，只能看到第一张图片。这里在触摸事件中实现的。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android基础-2011-08-13-android-basic-15.html">http://www.sguotao.com/Android基础-2011-08-13-android-basic-15.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Tween动画&quot;&gt;&lt;a href=&quot;#1-Tween动画&quot; class=&quot;headerlink&quot; title=&quot;1. Tween动画&quot;&gt;&lt;/a&gt;1. Tween动画&lt;/h2&gt;&lt;p&gt;将某个组件以渐变的方式实现透明、缩放、移动、旋转等动画效果。&lt;br&gt;&lt;img s
    
    </summary>
    
      <category term="Android基础" scheme="http://www.sguotao.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="UI" scheme="http://www.sguotao.com/tags/UI/"/>
    
      <category term="动画" scheme="http://www.sguotao.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android基础14 样式与主题</title>
    <link href="http://www.sguotao.com/Android%E5%9F%BA%E7%A1%80-2011-08-12-android-basic-14.html"/>
    <id>http://www.sguotao.com/Android基础-2011-08-12-android-basic-14.html</id>
    <published>2011-08-12T02:27:04.000Z</published>
    <updated>2017-06-02T10:37:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-样式-style"><a href="#1-样式-style" class="headerlink" title="1. 样式(style)"></a>1. 样式(style)</h2><p>android中的样式和CSS样式作用相似，都是用于为界面元素定义显示风格，它是一个包含一个或者多个view控件属性的集合。如：需要定义字体的颜色和大小。在CSS中是这样定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">    .ncist&#123;COLOR:#0000CC;font-size:18px;&#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>可以像这样使用上面的css样式：<div class="ncist">华北科技</div>，在Android中可以这样定义样式：在res/values/styles.xml文件中添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;style name=“ncist”&gt; &lt;!-- 为样式定义一个全局唯一的名字--&gt;</div><div class="line">     &lt;item name=“android:textSize”&gt;18px&lt;/item&gt; &lt;!-- name属性的值为使用了该样式的View控件的属性 --&gt;</div><div class="line">     &lt;item name=&quot;android:textColor&quot;&gt;#0000CC&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>在layout文件中可以像下面这样使用上面的android样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; ....&gt;</div><div class="line">    &lt;TextView style=&quot;@style/ncist&quot;</div><div class="line">        .....  /&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>&lt;style&gt;元素中有一个parent属性。这个属性可以让当前样式继承一个父样式，并且具有父样式的值。当然，如果父样式的值不符合你的需求，你也可以对它进行修改，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">    &lt;style name=&quot;ncist&quot;&gt;</div><div class="line">        &lt;item name=&quot;android:textSize&quot;&gt;18px&lt;/item&gt; &lt;!-- name属性为样式要用在的View控件持有的属性 --&gt;</div><div class="line">        &lt;item name=&quot;android:textColor&quot;&gt;#0000CC&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">    &lt;style name=&quot;subncist&quot; parent=&quot;@style/ncist&quot;&gt;</div><div class="line">        &lt;item name=&quot;android:textColor&quot;&gt;#FF0000&lt;/item&gt;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p><strong>继承样式有两种定义方式</strong></p>
<ol>
<li>继承样式，在&lt;style&gt;标签中配置属性parent</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;style2&quot; parent=&quot;@style/style1&quot;&gt;</div><div class="line">			&lt;item name=&quot;android:textColor&quot;&gt;#FF0000&lt;/item&gt;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<ol>
<li>继承样式，在name中引用其他样式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;style2.style3&quot;&gt;</div><div class="line">			&lt;item name=&quot;android:textSize&quot;&gt;30sp&lt;/item&gt;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<p><strong>使用样式</strong><br>在layout文件的标签中配置style属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Button  	style=&quot;@style/style2.style3&quot;</div><div class="line">	    		android:text=&quot;这是一个按钮&quot;/&gt;</div></pre></td></tr></table></figure>
<h2 id="2-主题-theme"><a href="#2-主题-theme" class="headerlink" title="2. 主题(theme)"></a>2. 主题(theme)</h2><p>android中主题也是用于为应用定义显示风格，它的定义和样式的定义相同，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;resources&gt;</div><div class="line">&lt;style name=“ncistTheme&quot;&gt;</div><div class="line">	&lt;item name=“android:windowNoTitle”&gt;true&lt;/item&gt; &lt;!– 没标题 </div><div class="line">	&lt;item name=“android:windowFullscreen”&gt;?android:windowNoTitle&lt;/item&gt; &lt;!– 全屏显示 </div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<p>上面“?android:windowNoTitle”中的问号用于引用在当前主题中定义过的资源的值。下面代码显示在AndroidManifest.xml中如何为应用设置上面定义的主题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;application android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot;</div><div class="line">     android:theme=&quot;@style/ncistTheme&quot;&gt;</div><div class="line">   ......</div><div class="line">&lt;/application&gt;</div></pre></td></tr></table></figure>
<p>除了可以在AndroidManifest.xml中设置主题，同样也可以在代码中设置主题，如下：<br>setTheme(R.style.ncistTheme);</p>
<h2 id="3-样式与主题的区别"><a href="#3-样式与主题的区别" class="headerlink" title="3. 样式与主题的区别"></a>3. 样式与主题的区别</h2><p>尽管在定义上，样式和主题基本相同，但是它们使用的地方不同。</p>
<ol>
<li>样式用在单独的View，如：EditText、TextView等；</li>
<li>主题通过AndroidManifest.xml中的&lt;application&gt;和&lt;activity&gt;用在整个应用或者某个 Activity，主题对整个应用或某个Activity进行全局性影响。</li>
<li>如果一个应用使用了主题，同时应用下的view也使用了样式，那么当主题和样式属性发生冲突时，样式的优先级高于主题。</li>
</ol>
<p>另外android系统也定义了一些主题，例如：<br>&lt;activity android:theme=“@android:style/Theme.Dialog”&gt;，该主题可以让Activity看起来像一个对话框，还有透明主题：@android:style/Theme.Translucent 。如果需要查阅这些主题，可以在文档的referenceandroid–&gt;R.style 中查看。</p>
<p><strong>注意：如果使用android内置的样式，IDE自动提示的“_”要替换成“.”</strong></p>
<h2 id="4-国际化与屏幕适配"><a href="#4-国际化与屏幕适配" class="headerlink" title="4. 国际化与屏幕适配"></a>4. 国际化与屏幕适配</h2><h3 id="4-1-国际化"><a href="#4-1-国际化" class="headerlink" title="4.1 国际化"></a>4.1 国际化</h3><p><img src="http://obovytgzz.bkt.clouddn.com/i18n1.png" alt="图片1"><br>在values和drawable文件夹后加上语言以及地区名，程序中需要国际化的部分使用资源ID<br>values-en-rUS ；values-zh-rCN；values-zh-rTW</p>
<p><strong>匹配规则</strong></p>
<ol>
<li>在匹配资源时先会找语言、地区完全匹配的</li>
<li>如果没有地区匹配的，则查找语言匹配的<br>如果没有语言匹配的则找默认values</li>
</ol>
<h3 id="4-2-屏幕适配"><a href="#4-2-屏幕适配" class="headerlink" title="4.2 屏幕适配"></a>4.2 屏幕适配</h3><p><img src="http://obovytgzz.bkt.clouddn.com/i18n2.png" alt="图片2"><br>在layout文件夹后加上分辨率，系统会根据屏幕尺寸自动选择，注意分辨率中的乘号是“x”不是“*”，并且大的数字在“x”之前，否则编译无法通过；如果没有匹配的分辨率会找默认layout文件夹。</p>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android基础-2011-08-12-android-basic-14.html">http://www.sguotao.com/Android基础-2011-08-12-android-basic-14.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-样式-style&quot;&gt;&lt;a href=&quot;#1-样式-style&quot; class=&quot;headerlink&quot; title=&quot;1. 样式(style)&quot;&gt;&lt;/a&gt;1. 样式(style)&lt;/h2&gt;&lt;p&gt;android中的样式和CSS样式作用相似，都是用于为界面元素定义显
    
    </summary>
    
      <category term="Android基础" scheme="http://www.sguotao.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="UI" scheme="http://www.sguotao.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Android基础13 常用UI（下）</title>
    <link href="http://www.sguotao.com/Android%E5%9F%BA%E7%A1%80-2011-08-11-android-basic-13.html"/>
    <id>http://www.sguotao.com/Android基础-2011-08-11-android-basic-13.html</id>
    <published>2011-08-11T02:27:04.000Z</published>
    <updated>2017-06-02T10:37:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-菜单-Menu"><a href="#1-菜单-Menu" class="headerlink" title="1.菜单(Menu)"></a>1.菜单(Menu)</h2><h3 id="1-1-普通menu"><a href="#1-1-普通menu" class="headerlink" title="1.1 普通menu"></a>1.1 普通menu</h3><p><img src="http://obovytgzz.bkt.clouddn.com/menu1.png" alt="图片1"></p>
<ol>
<li>重写Activity的onCreateOptionsMenu(Menu menu)方法，该方法用于创建选项菜单，在用户按下手机的“Menu”按钮时就会显示创建好的菜单，在onCreateOptionsMenu(Menu menu)方法内部可以调用Menu.add()方法实现菜单的添加。</li>
<li>重写Activity的onMenuItemSelected()方法，该方法用于处理菜单被选择事件</li>
<li>通过手机上提供的“MENU”按钮可以打开菜单，如果希望通过代码打开菜单，可以调用Activity的openOptionsMenu()方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class MenuActivity extends Activity &#123;</div><div class="line">private static final String TAG = &quot;MenuActivity&quot;;</div><div class="line">private static final int MENU_ADD = Menu.FIRST;</div><div class="line">private static final int MENU_UPDATE = Menu.FIRST + 1;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.menu); </div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public boolean onCreateOptionsMenu(Menu menu) &#123;</div><div class="line">		menu.add(Menu.NONE, MENU_ADD, Menu.NONE, &quot;添加&quot;);  </div><div class="line">		menu.add(Menu.NONE, MENU_UPDATE, Menu.NONE, &quot;更新&quot;);</div><div class="line">		return super.onCreateOptionsMenu(menu); &#125;</div><div class="line">    @Override</div><div class="line">    public boolean onMenuItemSelected(int featureId, MenuItem item) &#123;</div><div class="line">		switch (item.getItemId()) &#123;</div><div class="line">	  	case MENU_ADD:</div><div class="line">	       Log.i(TAG, &quot;add was selected&quot;);</div><div class="line">	       return true;</div><div class="line">	  case MENU_UPDATE:</div><div class="line">	       Log.i(TAG, &quot;update was selected&quot;);</div><div class="line">	       return true;</div><div class="line">	  default:</div><div class="line">              return super.onMenuItemSelected(featureId, item);</div><div class="line">&#125; &#125;	&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2-SubMenu"><a href="#1-2-SubMenu" class="headerlink" title="1.2 SubMenu"></a>1.2 SubMenu</h3><ol>
<li>添加子菜单<br>调用menu对象的addSubMenu(final CharSequence title)，该方法返回一个SubMenu对象</li>
<li>添加子菜单的菜单项<br>调用SubMenu对象的add(CharSequence title) 方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public boolean onCreateOptionsMenu(Menu menu) &#123;</div><div class="line">        menu.add(0, 1, 1, &quot;苹果&quot;);</div><div class="line">        menu.add(0, 2, 2, &quot;香蕉&quot;);</div><div class="line">        SubMenu subMenu = menu.addSubMenu(1, 100, 100, &quot;桃子&quot;);</div><div class="line">        subMenu.add(2, 101, 101, &quot;大桃子&quot;);</div><div class="line">        subMenu.add(2, 102, 102, &quot;小桃子&quot;);</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="1-3-Context-Menu"><a href="#1-3-Context-Menu" class="headerlink" title="1.3 Context Menu"></a>1.3 Context Menu</h3><p>类似于电脑上的右键，长按某个View之后弹出来的菜单。首先在main.xml里定义若干个按钮。首先要注册一下，在onCreate方法里，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.main);</div><div class="line">        b1 = (Button) findViewById(R.id.b1);</div><div class="line">        b2 = (Button) findViewById(R.id.b2);</div><div class="line">        registerForContextMenu(b1);</div><div class="line">        registerForContextMenu(b2);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后覆盖onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Override</div><div class="line">    public void onCreateContextMenu(ContextMenu menu, View v,</div><div class="line">            ContextMenuInfo menuInfo) &#123;</div><div class="line">        if(v==b1)&#123;</div><div class="line">            menu.setHeaderTitle(&quot;这是1&quot;);</div><div class="line">            menu.add(200, 200, 200, &quot;Context Menu 1&quot;);</div><div class="line">            menu.add(200, 201, 201, &quot;Context Menu 2&quot;);</div><div class="line">        &#125;</div><div class="line">        else if(v==b2)&#123;</div><div class="line">            menu.setHeaderTitle(&quot;这是2&quot;);</div><div class="line">            menu.add(300, 300, 300, &quot;C 1&quot;);</div><div class="line">            menu.add(300, 301, 301, &quot;C 2&quot;);</div><div class="line">        &#125;</div><div class="line">        super.onCreateContextMenu(menu, v, menuInfo);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="1-4-动态Menu"><a href="#1-4-动态Menu" class="headerlink" title="1.4 动态Menu"></a>1.4 动态Menu</h3><p><img src="http://obovytgzz.bkt.clouddn.com/menu2.png" alt="图片2"><br>动态菜单就是根据不同的界面有不同的菜单。下面的代码实现这样的功能：当主界面的某个TextView的值是“M“和“N”时，弹出不同的菜单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean onPrepareOptionsMenu(Menu menu) &#123;</div><div class="line">        String currentText = tv1.getText().toString();</div><div class="line">        if(&quot;M&quot;.equals(currentText))&#123;</div><div class="line">            menu.clear();//先清掉菜单</div><div class="line">            MenuItem item = menu.add(0, 400, 401, &quot;to N&quot;);//可以通过点击这个菜单项来改变tv1的值这样(变成N)就可以测试了</div><div class="line">            item.setIcon(android.R.drawable.alert_dark_frame);//android自带的图标</div><div class="line">        &#125;</div><div class="line">        if(&quot;N&quot;.equals(currentText))&#123;</div><div class="line">            menu.clear();//先清掉菜单</div><div class="line">            MenuItem item = menu.add(0, 401, 402, &quot;to M&quot;);//可以通过点击这个菜单项来改变tv1的值这样(变成M)就可以测试了</div><div class="line">            item.setIcon(android.R.drawable.alert_light_frame);</div><div class="line">        &#125;</div><div class="line">        menu.add(0, 402, 403, &quot;Now is &quot; + currentText);//现在共有两个菜单子项</div><div class="line">        return super.onPrepareOptionsMenu(menu);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="1-5-用xml文件方式创建Menu"><a href="#1-5-用xml文件方式创建Menu" class="headerlink" title="1.5 用xml文件方式创建Menu"></a>1.5 用xml文件方式创建Menu</h3><p>之前都是用代码的方法创建Menu,用xml配置文件也可以相当方便地制作菜单。<br>要res/目录下建一个文件夹，名为menu，下面建一个xml文件，名为menu_xml_file.xml，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">&lt;group android:id=&quot;@+id/grout_main&quot;&gt;</div><div class="line">    &lt;item android:id=&quot;@+id/menu_1&quot;</div><div class="line">                android:title=&quot;This 1&quot;/&gt;</div><div class="line">    &lt;item android:id=&quot;@+id/menu_2&quot; </div><div class="line">            android:title=&quot;This 2&quot; /&gt; </div><div class="line">&lt;/group&gt;</div><div class="line">&lt;/menu&gt;</div></pre></td></tr></table></figure>
<p>在Activity中覆盖onCreateOptionsMenu(Menu menu)方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean onCreateOptionsMenu(Menu menu) &#123;</div><div class="line">        MenuInflater inflater = getMenuInflater();</div><div class="line">        inflater.inflate(R.menu.menu_xml_file, menu);</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其他的都和在Activity中制作菜单一样。</p>
<h2 id="2-手势识别-GestureOverlayView"><a href="#2-手势识别-GestureOverlayView" class="headerlink" title="2. 手势识别(GestureOverlayView)"></a>2. 手势识别(GestureOverlayView)</h2><p><img src="http://obovytgzz.bkt.clouddn.com/menu3.png" alt="图片3"></p>
<ol>
<li>建立手势库<br>使用SDK自带例子GestureBuilder建立手势库（位置：android-sdk-windows\samples\android-8\GestureBuilder）。使用GestureBuilder之前，你需要恢复其到开发环境，然后进行编绎并部署到手机上。此时，就可以使用GestureBuilder建立手势库，生成的手势库文件在SCDard上，默认文件名称为：gestures</li>
<li>在应用中加载手势库文件，然后开发手势识别代码。<br>把手势库文件gestures文件拷贝到项目的res/raw目录下。然后在布局文件中添加用于手势绘制的View：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;android.gesture.GestureOverlayView</div><div class="line">		android:id=&quot;@+id/gov&quot;</div><div class="line">		android:layout_width=&quot;fill_parent&quot;</div><div class="line">		android:layout_height=&quot;fill_parent&quot;</div><div class="line">		android:gestureStrokeType=&quot;multiple&quot;/&gt;</div></pre></td></tr></table></figure>
<ol>
<li>为View添加手势监听事件：gestureOverlayView.addOnGesturePerformedListener();</li>
<li>得到手势库：mLibrary = GestureLibraries.fromRawResource(this, R.raw.gestures);</li>
<li>加载手势库：mLibrary.load();</li>
</ol>
<p>大多数情况下，手势都是通过一笔完成。然而有一些特别的需求就需要通过多个笔画来实现，这时可以使用gestureStrokeType属性进行设置：android:gestureStrokeType=”multiple”</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">    private GestureOverlayView gestureOverlayView;</div><div class="line">    private GestureLibrary mLibrary;</div><div class="line">    private boolean state;</div><div class="line">    private EditText addressText;</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.main);</div><div class="line">        addressText = (EditText)this.findViewById(R.id.address);</div><div class="line">        gestureOverlayView = (GestureOverlayView)this.findViewById(R.id.gestures);</div><div class="line">        //当用户完成一次Gesture绘制后，系统将自动调用Listener对象的onGesturePerformed()方法</div><div class="line">        gestureOverlayView.addOnGesturePerformedListener(new GestureListener());</div><div class="line">        mLibrary = GestureLibraries.fromRawResource(this, R.raw.gestures);</div><div class="line">        state = mLibrary.load();//加载手势库</div><div class="line">    &#125;</div><div class="line">    private final class GestureListener implements GestureOverlayView.OnGesturePerformedListener&#123;</div><div class="line">		@Override</div><div class="line">		public void onGesturePerformed(GestureOverlayView overlay, Gesture gesture) &#123;</div><div class="line">			if(state)&#123;</div><div class="line">				List&lt;Prediction&gt; predictions = mLibrary.recognize(gesture);</div><div class="line">				//从手势库中查询匹配的内容，匹配的结果可能包括多个相似的结果，匹配度高的结果放在最前面</div><div class="line">				if(!predictions.isEmpty())&#123;</div><div class="line">					Prediction prediction = predictions.get(0);</div><div class="line">					//prediction的score属性代表了与手势的相似程度name代表手势对应的名称</div><div class="line">					if(prediction.score &gt; 1)&#123;</div><div class="line">						addressText.setText(prediction.name);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;    </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-编码实现软件界面"><a href="#3-编码实现软件界面" class="headerlink" title="3. 编码实现软件界面"></a>3. 编码实现软件界面</h2><p>Android除了可以使用xml实现软件界面，还可以通过编码方式实现软件的界面，而且在某种情况下只能采用编码方式实现软件的界面，例如：软件运行时需要根据运算结果决定显示某些内容。如果不是必须，建议使用xml，因为这样可以使应用遵守mvc设计模式，具有良好的软件分层结构。下面代码实现了如HelloWorld项目一样的软件界面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity &#123;</div><div class="line">	public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        LinearLayout linearLayout = new LinearLayout(this);</div><div class="line">        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(</div><div class="line">        	ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT);</div><div class="line">        TextView textView = new TextView(this);</div><div class="line">        textView.setText(R.string.hello);</div><div class="line">        textView.setId(34);</div><div class="line">        LinearLayout.LayoutParams textParams = new LinearLayout.LayoutParams(</div><div class="line">        	ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">        linearLayout.addView(textView, textParams);</div><div class="line">        setContentView(linearLayout, layoutParams);       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-网页视图-WebView"><a href="#4-网页视图-WebView" class="headerlink" title="4. 网页视图(WebView)"></a>4. 网页视图(WebView)</h2><p>因为android软件开发分工目前还没有细化，程序员往往需要负责软件界面的开发，虽然软件的界面图片已经由美工设计好了，但如果使用layout技术把软件做成如图片所示的界面确实很困难，而且也比较耗时。Android通过WebView实现了JS代码与Java代码互相通信的功能，使的android软件的界面开发也可以采用HTML网页技术，这样，广大网页美工可以参与进android软件的界面开发工作，从而让程序员从中解脱出来。</p>
<p>XML配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;WebView</div><div class="line">android:id=&quot;@+id/webView&quot;</div><div class="line">android:layout_width=&quot;fill_parent&quot; </div><div class="line">android:layout_height=&quot;fill_parent&quot;	/&gt;</div></pre></td></tr></table></figure>
<p>在项目的assets目录放入index.html文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</div><div class="line">&lt;html&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</div><div class="line">		&lt;title&gt;Insert title here&lt;/title&gt;</div><div class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">			function show(jsondata)&#123;</div><div class="line">			        var jsonobjs = eval(jsondata);</div><div class="line">			        var table = document.getElementById(&quot;personTable&quot;);</div><div class="line">			        for(var y=0; y&lt;jsonobjs.length; y++)&#123;</div><div class="line">				        var tr = table.insertRow(table.rows.length); </div><div class="line">				        var td1 = tr.insertCell(0);</div><div class="line">				        var td2 = tr.insertCell(1);</div><div class="line">				        td2.align = &quot;center&quot;;</div><div class="line">				        var td3 = tr.insertCell(2);</div><div class="line">				        td3.align = &quot;center&quot;;</div><div class="line">				        td1.innerHTML = jsonobjs[y].name; </div><div class="line">				        td2.innerHTML = jsonobjs[y].amount; </div><div class="line">				        td3.innerHTML = &quot;&lt;a href=&apos;javascript:contact.call(\&quot;&quot;+ jsonobjs[y].phone+ &quot;\&quot;)&apos;&gt;&quot;+ jsonobjs[y].phone+ &quot;&lt;/a&gt;&quot;; </div><div class="line">					&#125;</div><div class="line">			&#125;</div><div class="line">		&lt;/script&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body onload=&quot;javascript:contact.showcontacts()&quot;&gt;</div><div class="line">	   &lt;table border=&quot;0&quot; width=&quot;100%&quot; id=&quot;personTable&quot; cellspacing=&quot;0&quot;&gt;</div><div class="line">			&lt;tr&gt;</div><div class="line">				&lt;td width=&quot;30%&quot;&gt;姓名&lt;/td&gt;</div><div class="line">				&lt;td width=&quot;30%&quot; align=&quot;center&quot;&gt;存款&lt;/td&gt;</div><div class="line">				&lt;td align=&quot;center&quot;&gt;电话&lt;/td&gt;</div><div class="line">			&lt;/tr&gt;</div><div class="line">		&lt;/table&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class HtmlActivity extends Activity &#123;</div><div class="line">private WebView webView;</div><div class="line">private Handler handler = new Handler();</div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.main);</div><div class="line">        webView = (WebView)this.findViewById(R.id.webView);</div><div class="line">        webView.getSettings().setJavaScriptEnabled(true);</div><div class="line">        webView.getSettings().setSaveFormData(false);</div><div class="line">        webView.getSettings().setSavePassword(false);</div><div class="line">        webView.getSettings().setSupportZoom(false);</div><div class="line">        webView.addJavascriptInterface(new NcistJavaScript(), “ncist”);</div><div class="line">		//addJavascriptInterface方法中要绑定的Java对象</div><div class="line">        webView.setWebChromeClient(new NcistWebClient());</div><div class="line">        webView.loadUrl(&quot;file:///android_asset/index.html&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private final class NcistJavaScript&#123;</div><div class="line">    	public void personlist()&#123;</div><div class="line">    	    webview.loadUrl(&quot;javascript:contactlist(&apos;&quot;+ getPersonJson() + &quot;&apos;)&quot;); </div><div class="line">		&#125;</div><div class="line">    	public void call(final String phone)&#123;</div><div class="line">	    startActivity(new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:&quot;+ phone)));</div><div class="line">    	&#125;</div><div class="line">		public static String getPersonJson() &#123;//生成json字符串</div><div class="line">	   try &#123;</div><div class="line">		JSONObject jsonObject = new JSONObject();</div><div class="line">		jsonObject.put(&quot;id&quot;, 56);</div><div class="line">		jsonObject.put(&quot;name&quot;, &quot;老张&quot;);</div><div class="line">		jsonObject.put(&quot;phone&quot;, &quot;5556&quot;);    	</div><div class="line">		JSONObject jsonObject2 = new JSONObject();</div><div class="line">		jsonObject2.put(&quot;id&quot;, 89);</div><div class="line">		jsonObject2.put(&quot;name&quot;, &quot;老方&quot;);</div><div class="line">		jsonObject2.put(&quot;phone&quot;, &quot;5558&quot;);    	</div><div class="line">		JSONArray jsonArray = new JSONArray();</div><div class="line">		jsonArray.put(jsonObject);</div><div class="line">		jsonArray.put(jsonObject2);    	</div><div class="line">		return jsonArray.toString();</div><div class="line">	     &#125; catch (JSONException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	     &#125;</div><div class="line">	   return &quot;&quot;;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    private final class NcistWebClient extends WebChromeClient&#123;</div><div class="line">    	@Override</div><div class="line">	public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123;</div><div class="line">    	new AlertDialog.Builder(HtmlActivity.this) </div><div class="line">	.setTitle(&quot;提示信息&quot;)       </div><div class="line">	.setMessage(message)           </div><div class="line">	.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener()&#123;</div><div class="line">	    	public void onClick(DialogInterface dialoginterface, int i)&#123;&#125;</div><div class="line">	&#125;).show();</div><div class="line">	return true;</div><div class="line">	&#125; &#125;&#125;</div></pre></td></tr></table></figure>
<hr>
<p>本文链接：<a href="http://www.sguotao.com/Android基础-2011-08-11-android-basic-13.html">http://www.sguotao.com/Android基础-2011-08-11-android-basic-13.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-菜单-Menu&quot;&gt;&lt;a href=&quot;#1-菜单-Menu&quot; class=&quot;headerlink&quot; title=&quot;1.菜单(Menu)&quot;&gt;&lt;/a&gt;1.菜单(Menu)&lt;/h2&gt;&lt;h3 id=&quot;1-1-普通menu&quot;&gt;&lt;a href=&quot;#1-1-普通menu&quot; c
    
    </summary>
    
      <category term="Android基础" scheme="http://www.sguotao.com/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Android" scheme="http://www.sguotao.com/tags/Android/"/>
    
      <category term="UI" scheme="http://www.sguotao.com/tags/UI/"/>
    
  </entry>
  
</feed>
