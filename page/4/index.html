<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Scott-小白" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="和光同尘,静水流深">
<meta property="og:type" content="website">
<meta property="og:title" content="Scott-小白">
<meta property="og:url" content="http://www.sguotao.com/page/4/index.html">
<meta property="og:site_name" content="Scott-小白">
<meta property="og:description" content="和光同尘,静水流深">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scott-小白">
<meta name="twitter:description" content="和光同尘,静水流深">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.sguotao.com/page/4/"/>





  <title>Scott-小白</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?760edc77a59a2329550e2d68c6400d9b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Scott-小白</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2011/06/Android基础-2011-06-01-android-basic-1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2011/06/Android基础-2011-06-01-android-basic-1.html" itemprop="url">
                  Android基础1 Android项目的结构
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2011-06-01T00:00:00+08:00">
                2011-06-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2011/06/Android基础-2011-06-01-android-basic-1.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2011/06/Android基础-2011-06-01-android-basic-1.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2011/06/Android基础-2011-06-01-android-basic-1.html" class="leancloud_visitors" data-flag-title="Android基础1 Android项目的结构">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Android系统架构图"><a href="#1-Android系统架构图" class="headerlink" title="1. Android系统架构图"></a>1. Android系统架构图</h2><p>学习Android内容，总是无法绕过Android系统架构图，这张图，在以后Android开发的过程中，总是离不开它。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-06-01%20%E4%B8%8A%E5%8D%8810.26.51.png" alt=""></p>
<h2 id="2-Davlik-VM和JVM的区别"><a href="#2-Davlik-VM和JVM的区别" class="headerlink" title="2. Davlik VM和JVM的区别"></a>2. Davlik VM和JVM的区别</h2><p>Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-06-01%20%E4%B8%8A%E5%8D%8810.28.40.png" alt=""></p>
<h3 id="2-1-Dalvik-和标准-Java-虚拟机-JVM-的首要差别"><a href="#2-1-Dalvik-和标准-Java-虚拟机-JVM-的首要差别" class="headerlink" title="2.1 Dalvik 和标准 Java 虚拟机(JVM)的首要差别"></a>2.1 Dalvik 和标准 Java 虚拟机(JVM)的首要差别</h3><p>Dalvik 基于寄存器，而 JVM 基于栈。基于寄存器的虚拟机对于更大的程序来说，在它们编译的时候，花费的时间更短。 JVM字节码中，局部变量会被放入局部变量表中，继而被压入堆栈供操作码进行运算，当然JVM也可以只使用堆栈而不显式地将局部变量存入变量表中。Dalvik字节码中，局部变量会被赋给65536个可用的寄存器中的任何一个，Dalvik指令直接操作这些寄存器，而不是访问堆栈中的元素。</p>
<h3 id="2-2-Dalvik-和-Java-字节码的区别"><a href="#2-2-Dalvik-和-Java-字节码的区别" class="headerlink" title="2.2 Dalvik 和 Java 字节码的区别"></a>2.2 Dalvik 和 Java 字节码的区别</h3><p>VM字节码由.class文件组成，每个文件一个class。JVM在运行的时候为每一个类装载字节码。相反的，Dalvik程序只包含一个.dex文件，这个文件包含了程序中所有的类。Java编译器创建了JVM字节码之后，Dalvik的dx编译器删除.class文件，重新把它们编译成Dalvik字节码，然后把它们写进一个.dex文件中。这个过程包括翻译、重构、解释程序的基本元素（常量池、类定义、数据段）。常量池描述了所有的常量，包括引用、方法名、数值常量等。类定义包括了访问标志、类名等基本信息。数据段中包含各种被VM执行的函数代码以及类和函数的相关信息（例如DVM所需要的寄存器数量、局部变量表、操作数堆栈大小），还有实例变量。</p>
<h3 id="2-3-Dalvik-和-Java-SDK的SDK不同及运行环境的区别"><a href="#2-3-Dalvik-和-Java-SDK的SDK不同及运行环境的区别" class="headerlink" title="2.3 Dalvik 和 Java SDK的SDK不同及运行环境的区别 　 　"></a>2.3 Dalvik 和 Java SDK的SDK不同及运行环境的区别 　 　</h3><p>Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p>
<p>Dalvik虚拟机在android2.2之后使用JIT （Just-In-Time）技术，与传统JVM的JIT并不完全相同，Dalvik虚拟机有自己的 bytecode，并非使用 Java bytecode。</p>
<p>还有以下几点：</p>
<ol>
<li>Dalvik主要是完成对象生命周期管理，堆栈管理，线程管理，安全和异常管理，以及垃圾回收等等重要功能。 　　</li>
<li>Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。 　　</li>
<li>不同于Java虚拟机运行java字节码，Dalvik虚拟机运行的是其专有的文件格式Dex。 　　</li>
<li>dex文件格式可以减少整体文件尺寸，提高I/O操作的类查找速度。 　　</li>
<li>odex是为了在运行过程中进一步提高性能，对dex文件的进一步优化。 　　</li>
<li>所有的Android应用的线程都对应一个Linux线程，虚拟机因而可以更多的依赖操作系统的线程调度和管理机制。 　　</li>
<li>有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化、库的加载、预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的速度提供给系统。对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域。</li>
</ol>
<h2 id="3-常用Android设备的屏幕分辨率"><a href="#3-常用Android设备的屏幕分辨率" class="headerlink" title="3. 常用Android设备的屏幕分辨率"></a>3. 常用Android设备的屏幕分辨率</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-06-01%20%E4%B8%8A%E5%8D%8811.20.21.png" alt=""></p>
<h2 id="4-安装和卸载应用"><a href="#4-安装和卸载应用" class="headerlink" title="4. 安装和卸载应用"></a>4. 安装和卸载应用</h2><p><strong>adb安装</strong><br>打开cmd命令行 – 进入SDK根目录下tools文件夹，abd install apk文件绝对路径<br>例如：adb install D:\Ncist\Program\android\01_HelloWorld\bin\01_HelloWorld.apk</p>
<p><strong>adb卸载</strong><br>adb uninstall 包名<br>例如：adb uninstall cn.ncist.helloworld</p>
<h2 id="5-Android项目的目录结构"><a href="#5-Android项目的目录结构" class="headerlink" title="5. Android项目的目录结构"></a>5. Android项目的目录结构</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-06-01%20%E4%B8%8B%E5%8D%882.22.14.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/12/Java-IO流-2010-12-03-io-4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/12/Java-IO流-2010-12-03-io-4.html" itemprop="url">
                  Java IO流 File类
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-12-03T00:00:00+08:00">
                2010-12-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/12/Java-IO流-2010-12-03-io-4.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/12/Java-IO流-2010-12-03-io-4.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/12/Java-IO流-2010-12-03-io-4.html" class="leancloud_visitors" data-flag-title="Java IO流 File类">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：</p>
<p><a href="http://sguotao.com/2010/11/30/io-1/" target="_blank" rel="external">Java IO流 1 IO流的介绍</a> <br><br><a href="http://sguotao.com/2010/12/01/io-2/" target="_blank" rel="external">Java IO流 2 字符流 </a><br><br><a href="http://sguotao.com/2010/12/02/io-3/" target="_blank" rel="external">Java IO流 3 字节流 </a><br><br><a href="http://sguotao.com/2010/12/03/io-4/" target="_blank" rel="external">Java IO流 4 File类 </a><br><br><a href="http://sguotao.com/2012/11/21/io-5/" target="_blank" rel="external">Java IO流 5 序列流</a></p>
<h2 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h2><p>该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。 可以通过对象的思想来操作文件以及文件夹。<br><strong>1.构造函数</strong><br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
File(String filename)//将一个字符串路径(相对或者绝对)封装成File对象，该路径是可存在的，也可以是不存在。 
File(String parent,String child); 
File(File parent,String child); 
</pre>

<p><strong>2.特别的字段：separator:跨平台的目录分隔符</strong>。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
  File file = new File("c:"+File.separator+"abc"+File.separator+"a.txt"); 
 </pre>

<p><strong>3.常见方法</strong><br>1)    创建：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
boolean createNewFile()throws IOException//创建文件，如果被创建的文件已经存在，则不创建。 
boolean mkdir()// 创建文件夹。 
boolean mkdirs()//创建多级文件夹。 
</pre>

<p>2)    删除：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
boolean delete()//可用于删除文件或者文件夹。 
注意：**对于文件夹只能删除不带内容的空文件夹，对于带有内容的文件夹，不可以直接删除，必须要从里往外删除**。 
void deleteOnExit()//删除动作交给系统完成。无论是否反生异常，系统在退出时执行删除动作。 
</pre>

<p>3)    判断：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
boolean canExecute()
boolean canWrite()
boolean canRead()
boolean exists()//判断文件或者文件夹是否存在。 
boolean isFile()//判断File对象中封装的是否是文件。 
boolean isDirectory()//判断File对象中封装的是否是文件夹。 
boolean isHidden()//判断文件或者文件夹是否隐藏。在获取硬盘文件或者文件夹时，对于系统目录中的文件，java是无法访问的，所以在遍历，可以避免遍历隐藏文件。 
</pre>

<p>4)    获取：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
getName()//获取文件或者文件夹的名称。 
getPath()//File对象中封装的路径是什么，获取的就是什么。 
getAbsolutePath()//无论File对象中封装的路径是什么，获取的都是绝对路径。 
getParent()//获取File对象封装文件或者文件夹的父目录。 
注意：**如果封装的是相对路径，那么返回的是null.**
long length()//获取文件大小。 
long lastModified()//获取文件或者文件最后一次修改的时间。 
static File[] listRoots()//获取的是被系统中有效的盘符。 
String[] list()//获取指定目录下当前的文件以及文件夹名称。 
String[] list(Filenamefilter)//可以根据指定的过滤器，过滤后的文件及文件夹名称。 
File[] listFiles()//获取指定目录下的文件以及文件夹对象。 
</pre>

<p>5)    重命名：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
renameTo(File): 
File f1 = new File("c:\\a.txt"); 
File f2 = new File("c:\\b.txt"); 
f1.renameTo(f2);//将c盘下的a.txt文件改名为b.txt文件。 
</pre>

<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><p>其实就是在使用一个功能过程中，又对该功能有需求。就出现了函数自身调用自身。<br>注意：</p>
<ul>
<li><strong>一定要限定条件，否则内存溢出</strong>。 </li>
<li><strong>使用递归时，调用次数不要过多，否则也会出现内存溢出</strong>。 </li>
</ul>
<p>需求：<br>想要列出指定目录下的文件以及文件夹中的文件(子文件)。列出指定目录下的当前的文件或者文件夹。<br>想要列出当前目录下的文件夹中的文件，其实就是在重新使用该功能  。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
    public void listDir(File dir,int level)    { 
      System.out.println(getLevel(level)+dir.getName()); 
      level++; 
      File[] files = dir.listFiles(); 
      for(int x =0; x<files.length; x++)="" {="" if(files[x].isdirecotry())="" 如果遍历到的是目录。="" listdir(files[x],level);="" 那么就行该功能的重复使用递归。="" else="" system.out.println(getlevel(level)+files[x].getname());="" }="" <="" pre="">

<p>想要对列出的目录有一些层次关系。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
    public String getLevel(int level) { 
      StringBuilder sb = new StringBuilder(); 
      sb.append("|--"); 
      for(int x=0; x<level; x++)="" {="" sb.insert(0,"|="" ");="" }="" return="" sb.tostring();="" <="" pre="">

<p>需求：删除一个带内容的目录。<br>原理：从里往外删除，所以需要使用递归完成。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
    public void deleteAll(File dir) { 
      File[] files = dir.listFiles(); 
      for(int x=0; x<files.length; x++)="" {="" if(files[x].isdirectory())="" deleteall(files[x]);="" else="" files[x].delete();="" }="" dir.delete();="" <="" pre="">

<h2 id="3-IO-包中的常见对象和其它对象"><a href="#3-IO-包中的常见对象和其它对象" class="headerlink" title="3. IO 包中的常见对象和其它对象"></a>3. IO 包中的常见对象和其它对象</h2><p><strong>1.IO 包中的常见对象</strong> </p>
<ul>
<li>字节流：     FileInputStream  FileOutputStream   BufferedInputStream   BufferedOutputStream </li>
<li>字符流:       FileReader  FileWriter  BufferedReader     BufferedWriter </li>
<li>转换流:      InputStreamReader  OutputStreamWriter </li>
<li>文件对象:     File 所有的带File的流对象都可以直接操作File对象。</li>
<li>打印流：     PrintStream     PrintWriter  </li>
</ul>
<p><strong>2.IO 包中的其他对象</strong></p>
<ul>
<li>打印流：PrintStream  PrintWriter<br>PrintStream： 是一个字节打印流，System.out对应的类型就是PrintStream。它的构造函数可以接收三种数            据类型的值。 </li>
</ul>
<ol>
<li>字符串路径。 </li>
<li>File对象。 </li>
<li>OutputStream。 </li>
</ol>
<p>PrintWriter： 是一个字符打印流。构造函数可以接收四种类型的值。 </p>
<ol>
<li>字符串路径。 </li>
<li>File对象,<strong>对于1，2类型的数据，还可以指定编码表。也就是字符集</strong>.</li>
<li>OutputStream</li>
<li>Writer <strong>对于3，4类型的数据，可以指定自动刷新</strong>。 </li>
</ol>
<p>注意：该自动刷新值为true 时，只有三个方法可以用：println,printf,format.<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
  //如果想要既有自动刷新，又可执行编码。如何完成流对象的包装？ 
  PrintWrter pw =  
                    new PrintWriter(new OutputSteamWriter(new FileOutputStream("a.txt"),"utf-8"),true); 
  //如果想要提高效率。还要使用打印方法。 
  PrintWrter pw =  
              new PrintWriter(new BufferdWriter(new OutputSteamWriter(new               FileOutputStream("a.txt"),"utf-8")),true); 
</pre>

<p><strong>3.管道流</strong><br>PipedInputStream     PipedOutputStream<br>特点：读取管道流和写入管道流可以进行连接。 连接方式： </p>
<ol>
<li>通过两个流对象的构造函数。 </li>
<li>通过两个对象的connect方法。<br>通常两个流在使用时，需要加入多线程技术，也就是让读写同时运行。<br>注意：对于read方法。该方法是阻塞式的，也就是没有数据的情况，该方法会等待。 </li>
</ol>
<p><strong>4.RandomAccessFile</strong><br>该对象并不是流体系中的一员。该对象中封装了字节流，同时还封装了一个缓冲区(字节数组)，通过内部的指针来操作数组中的数据。该对象可以读数据，可以写入数据，如果写入位置已有数据，会发生数据覆盖。也就是可以对数据进行修改。在使用该对象时，建议数据都是有规则的。或者是分段的。注意；该对象在实例化时，如果要操作的文件不存在，会自动建立。如果要操作的文件存在，则不会建立，如果存在的文件有数据。那么在没有指定指针位置的情况下，写入数据，会将文件开头的数据覆盖。 可以用于多线程的下载，也就是通过多线程往一个文件中同时存储数据。</p>
<p>该对象特点：</p>
<ul>
<li>该对象只能操作文件，所以构造函数接收两种类型的参数。 </li>
</ul>
<ol>
<li>字符串路径。 </li>
<li>File对象。 </li>
</ol>
<ul>
<li>该对象既可以对文件进行读取，也可以写入。 在进行对象实例化时，必须要指定的该对象的操作模式，r rw等。 </li>
<li>该对象中有可以直接操作基本数据类型的方法。 </li>
</ul>
<p>该对象最有特点的方法<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
skipBytes()//跳过指定的字节数。 
seek()//指定指针的位置。 
getFilePointer()//获取指针的位置。 
</pre>

<p>通过这些方法，就可以完成对一个文件数据的随机的访问。 </p>
</files.length;></pre></level;></pre></files.length;></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/12/Java-IO流-2010-12-02-io-3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/12/Java-IO流-2010-12-02-io-3.html" itemprop="url">
                  Java IO流 字节流
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-12-02T00:00:00+08:00">
                2010-12-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/12/Java-IO流-2010-12-02-io-3.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/12/Java-IO流-2010-12-02-io-3.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/12/Java-IO流-2010-12-02-io-3.html" class="leancloud_visitors" data-flag-title="Java IO流 字节流">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：</p>
<p><a href="http://sguotao.com/2010/11/30/io-1/" target="_blank" rel="external">Java IO流 1 IO流的介绍</a> <br><br><a href="http://sguotao.com/2010/12/01/io-2/" target="_blank" rel="external">Java IO流 2 字符流 </a><br><br><a href="http://sguotao.com/2010/12/02/io-3/" target="_blank" rel="external">Java IO流 3 字节流 </a><br><br><a href="http://sguotao.com/2010/12/03/io-4/" target="_blank" rel="external">Java IO流 4 File类 </a><br><br><a href="http://sguotao.com/2012/11/21/io-5/" target="_blank" rel="external">Java IO流 5 序列流</a></p>
<h2 id="1-字节流"><a href="#1-字节流" class="headerlink" title="1. 字节流"></a>1. 字节流</h2><p>抽象基类：InputStream，OutputStream。字节流可以操作任何数据。<br><strong>注意：字符流使用的数组是字符数组</strong>。char [] chs<br><strong>字节流使用的数组是字节数组</strong>。byte [] bt </p>
<p>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
FileOutputStream fos = new FileOutputStream("a.txt"); 
fos.write("abcde");//直接将数据写入到了目的地。 
fos.close();//只关闭资源。 
FileInputStream fis = new FileInputStream("a.txt"); 
//fis.available();//获取关联的文件的字节数。 
</pre>

<p>如果文件体积不是很大，可以这样操作。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
byte[] buf = new byte[fis.available()];//创建一个刚刚好的缓冲区。
</pre>

<p>但是这有一个弊端，就是文件过大，大小超出jvm 的内容空间时，会内存溢出。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
fis.read(buf); 
System.out.println(new String(buf)); 
</pre>

<p>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
/**
  *copy一个图片
  */
BufferedInputStream bufis = new BufferedInputStream(new FileInputStream("1.jpg")); 
BufferedOutputStream bufos =  new BufferedOutputStream(new FileOutptStream("2.jpg")); 
int by = 0; 
while((by=bufis.read())!=-1){ 
      bufos.write(by); 
} 
bufos.close(); 
bufis.close(); 
</pre>

<h2 id="2-字节流-amp-字符流小结"><a href="#2-字节流-amp-字符流小结" class="headerlink" title="2. 字节流&amp;字符流小结"></a>2. 字节流&amp;字符流小结</h2><p><strong>字符流</strong><br>  FileReader. FileWriter.<br>  BufferedReader BufferedWriter. </p>
<p><strong>字节流</strong><br>  FileInputStream FileOutputStream<br>  BufferedInputStream BufferedOutputStream </p>
<p><strong>字节流的read()方法读取一个字节。为什么返回的不是byte类型，而是int 类型呢</strong>？<br>因为read方法读到末尾时返回的是-1。而在所操作的数据中的很容易出现连续多个1的情况，而连续读到8个1，就是-1。导致读取会提前停止。所以将读到的一个字节给提升为一个int 类型的数值，但是只保留原字节，并在剩余二进制位补0。</p>
<p>具体操作是：byte&amp;255    or    byte&amp;0xff 。对于write方法，可以一次写入一个字节，但接收的是一个int 类型数值。只写入该int 类型的数值的最低一个字节（8位）。简单说:read方法对读到的数据进行提升。write对操作的数据进行转换。 </p>
<h2 id="2-转换流"><a href="#2-转换流" class="headerlink" title="2. 转换流"></a>2. 转换流</h2><p><strong>1.转换流特点</strong></p>
<ul>
<li>是字节流和字符流之间的桥梁。 </li>
<li>该流对象中可以对读取到的字节数据进行指定编码表的编码转换。 </li>
</ul>
<p><strong>2.什么时候使用呢?</strong></p>
<ul>
<li>当字节和字符之间有转换动作时。 </li>
<li>流操作的数据需要进行编码表的指定时。 </li>
</ul>
<p><strong>3 具体的对象体现</strong></p>
<ul>
<li>InputStreamReader：字节到字符的桥梁。 </li>
<li>OutputStreamWriter：字符到字节的桥梁。 </li>
</ul>
<p>这两个流对象是字符流体系中的成员。那么它们有转换作用，而本身又是字符流。所以在构造的时候，需要传入字节流对象进来。构造函数：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
InputStreamReader(InputStream)://通过该构造函数初始化，使用的是本系统默认的编码表GBK。 
InputStreamReader(InputStream,String charSet)://通过该构造函数初始化，可以指定编码表。   OutputStreamWriter(OutputStream)://通过该构造函数初始化，使用的是本系统默认的编码表GBK。 
OutputStreamWriter(OutputStream,String charSet)://通过该构造函数初始化，可以指定编码表。
</pre>

<p><strong>4.操作文件的字符流对象是转换流的子类</strong><br><strong>Reader</strong><br>&nbsp;&nbsp;|–InputStreamReader<br>&nbsp;&nbsp;&nbsp;&nbsp;|–FileReader </p>
<p><strong>Writer</strong><br>&nbsp;&nbsp;|–OutputStreamWriter<br>&nbsp;&nbsp;&nbsp;&nbsp;|–FileWriter </p>
<p>转换流中的read方法。已经融入了编码表，在底层调用字节流的read方法时将获取的一个或者多个字节数据进行临时存储，并去查指定的编码表，如果编码表没有指定，查的是默认码表。那么转流的read方法就可以返回一个字符比如中文。转换流已经完成了编码转换的动作，对于直接操作的文本文件的FileReaer而言，就不用在重新定义了，只要继承该转换流，获取其方法，就可以直接操作文本文件中的字符数据了。 </p>
<p>注意： 在使用FileReader操作文本数据时，该对象使用的是默认的编码表。如果要使用指定编码表时，必须使用转换流。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
FileReader fr = new FileReader("a.txt");//操作a.txt的中的数据使用的本系统默认的GBK。
</pre>

<p>操作a.txt中的数据使用的也是本系统默认的GBK。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt")); 
</pre>

<p>这两句的代码的意义相同。如果a.txt中的文件中的字符数据是通过utf-8的形式编码。那么在读取时，就必须指定编码表。那么转换流必须使用。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt"),"utf-8"); 
</pre>

<p><strong>5.流操作的基本规律</strong></p>
<ul>
<li>明确数据源和数据汇（数据目的）。其实是为了明确输入流还是输出流。 </li>
<li>明确操作的数据是否是纯文本数据。其实是为了明确字符流还是字节流。 </li>
</ul>
<p><strong>6.数据源与数据汇</strong></p>
<ul>
<li>数据源：键盘System.in,硬盘File开头的流对象，内存(数组)。 </li>
<li>数据汇：控制台System.out,硬盘File开头的流对象，内存(数组)。 </li>
</ul>
<p><strong>7.需求：将键盘录入的数据存储到一个文件中</strong>。<br>数据源：System.in 既然是源，使用的就是输入流，可用的体系有InputStream，Reader。</p>
<p>因为键盘录入进来的一定是纯文本数据，所以可以使用专门操作字符数据的Reader。发现System.in对应的流是字节读取流。所以要将其进行转换，将字节转成字符即可。所以要使用Reader体系中：InputStreamReader<br>接下来，是否需要提高效率呢？如果需要，那么就加入字符流的缓冲区：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
BufferedReader bur = new BufferedReader(new InputStreamReader(System.in)); 
</pre>

<p>数据汇：一个文件，硬盘。既然是数据汇，那么一定是输出流，可以用的OutputStream,Writer。往文件中存储的都是文本数据，那么可以使用字符流较为方便:Writer。因为操作的是一个文件。所以使用Writer中的FileWriter。是否要提高效率呢？是，那就使用BufferedWriter。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
BufferedWriter bufr = new BufferedWriter(new FileWriter("a.txt")); 
</pre>

<p><strong>8.附加需求：希望将这些文本数据按照指定的编码表存入文件中</strong>。<br>既然是文本数据，而是还是写入到文件中，那么使用的体系还是Writer。因为要指定编码表，所以要使用Writer中的转换流，OutputStreamWriter。是否要提高效率，是，选择BufferedWriter。注意：虽然是最终是文件，但是不可以选择FileWriter。因为该对象是使用默认编码表。 </p>
<p>输出转换流要接收一个字节输出流进来，所以要是用OutputStram体系，而最终输出到一个文件中，那么就要使用OutputStream体系中可以操作的文件的字节流对象FileOutputStream。：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
//String charSet = System.getProperty("file.encoding"); 
String charSet = "utf-8"; 
BufferedWriter  bufw  =  new  BufferedWriter(new  OutputStreamWriter(new 
FileOutputStream("a.txt"),charSet); 
</pre>

<h2 id="3-可以和流相关联的集合对象Properties"><a href="#3-可以和流相关联的集合对象Properties" class="headerlink" title="3. 可以和流相关联的集合对象Properties"></a>3. 可以和流相关联的集合对象Properties</h2><p><strong>Map</strong><br>&nbsp;&nbsp;|–Hashtable<br>&nbsp;&nbsp;&nbsp;&nbsp;|–Properties </p>
<p>Properties:该集合不需要泛型，因为该集合中的键值对都是String类型。 </p>
<ul>
<li>存入键值对：setProperty(key,value); </li>
<li>获取指定键对应的值：value getProperty(key); </li>
<li><p>获取集合中所有键元素：Enumeration    propertyNames(); 在jdk1.6 版本给该类提供一个新的方法：Set<string> stringPropertyNames(); </string></p>
</li>
<li><p>列出该集合中的所有键值对，可以通过参数打印流指定列出到的目的地。<br>list(PrintStream);   list(PrintWriter);<br>例：list(System.out):将集合中的键值对打印到控制台。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
list(new PrintStream("prop.txt"));//将集合中的键值对存储到prop.txt文件中。 
</pre>
</li>
<li><p>可以将流中的规则数据加载进行集合，并称为键值对。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
load(InputStream): //jdk1.6 版本。提供了新的方法。  load(Reader): 
</pre>

</li>
</ul>
<p><strong>注意：流中的数据要是  “键=值” 的规则数据</strong>。 </p>
<ul>
<li>可以将集合中的数据进行指定目的的存储。<br>&lt;?prettify?&gt;<pre class="prettyprint">
store(OutputStram,String comment)方法。 
//jdk1.6 版本。提供了新的方法。 store(Writer ,String comment): 使用该方法存储时，会带着当时存储的时间。
</pre>





</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/12/Java-IO流-2010-12-01-io-2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/12/Java-IO流-2010-12-01-io-2.html" itemprop="url">
                  Java IO流 字符流
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-12-01T00:00:00+08:00">
                2010-12-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/12/Java-IO流-2010-12-01-io-2.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/12/Java-IO流-2010-12-01-io-2.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/12/Java-IO流-2010-12-01-io-2.html" class="leancloud_visitors" data-flag-title="Java IO流 字符流">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：</p>
<p><a href="http://sguotao.com/2010/11/30/io-1/" target="_blank" rel="external">Java IO流 1 IO流的介绍</a> <br><br><a href="http://sguotao.com/2010/12/01/io-2/" target="_blank" rel="external">Java IO流 2 字符流 </a><br><br><a href="http://sguotao.com/2010/12/02/io-3/" target="_blank" rel="external">Java IO流 3 字节流 </a><br><br><a href="http://sguotao.com/2010/12/03/io-4/" target="_blank" rel="external">Java IO流 4 File类 </a><br><br><a href="http://sguotao.com/2012/11/21/io-5/" target="_blank" rel="external">Java IO流 5 序列流</a></p>
<h2 id="1-字符流介绍"><a href="#1-字符流介绍" class="headerlink" title="1. 字符流介绍"></a>1. 字符流介绍</h2><p> <strong>Reader</strong><br>&nbsp;&nbsp;|–InputStreamReader<br>&nbsp;&nbsp;&nbsp;&nbsp;|–FileReader:专门用于处理文件的字符读取流对象。 </p>
<p><strong>Writer</strong><br>&nbsp;&nbsp;|–OutputStreamWriter<br>&nbsp;&nbsp;&nbsp;&nbsp;|–FileWriter:专门用于处理文件的字符写入流对象。 </p>
<h2 id="2-Writer-和-Reader"><a href="#2-Writer-和-Reader" class="headerlink" title="2. Writer 和 Reader"></a>2. Writer 和 Reader</h2><p><strong>Reader中的常见的方法</strong></p>
<ol>
<li>int read()： 读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回-1。</li>
<li>int read(char[])： 将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回-1。</li>
<li>close(): 读取字符其实用的是window系统的功能，就希望使用完毕后，进行资源的释放。 </li>
</ol>
<p><strong>Writer中的常见的方法</strong></p>
<ol>
<li>write(ch): 将一个字符写入到流中。 </li>
<li>write(char[]): 将一个字符数组写入到流中。 </li>
<li>write(String): 将一个字符串写入到流中。 </li>
<li>flush():刷新流，将流中的数据刷新到目的地中，流还存在。 </li>
<li>close():关闭资源：在关闭前会先调用flush()，刷新流中的数据去目的地。然后流关闭。 </li>
</ol>
<h2 id="3-FileWriter和FileReader"><a href="#3-FileWriter和FileReader" class="headerlink" title="3. FileWriter和FileReader"></a>3. FileWriter和FileReader</h2><h3 id="3-1-FileWriter"><a href="#3-1-FileWriter" class="headerlink" title="3.1 FileWriter"></a>3.1 FileWriter</h3><p>该类没有特有的方法。只有自己的构造函数。该类特点在于， </p>
<ol>
<li>用于处理文本文件。 </li>
<li>该类中有默认的编码表， </li>
<li>该类中有临时缓冲。 </li>
</ol>
<p>构造函数：在写入流对象初始化时，必须要有一个存储数据的目的地。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
FileWriter(String filename)
</pre>

<p>该构造函数做了什么事情呢？ </p>
<ol>
<li>调用系统资源。 </li>
<li>在指定位置，创建一个文件。 </li>
</ol>
<p><strong>注意：如果该文件已存在，将会被覆盖.</strong></p>
<p>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
FileWriter(String filename,boolean append)
</pre>

<p>该构造函数：当传入的boolean类型值为true时，会在指定文件末尾处进行数据的续写。 </p>
<h3 id="3-2-FileReader"><a href="#3-2-FileReader" class="headerlink" title="3.2 FileReader"></a>3.2 FileReader</h3><ol>
<li>用于读取文本文件的流对象。 </li>
<li>用于关联文本文件。</li>
</ol>
<p>构造函数：在读取流对象初始化的时候，必须要指定一个被读取的文件。 如果该文件不存在会发生FileNotFoundException.<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
FileReader(String filename); 
</pre>

<p>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
/**
  *将文本数据存储到一个文件中
  */
 class Demo  { 
    public static void main(String[] args) throws IOException { 
      FileWriter fw = new FileWrier("demo.txt"); 
      fw.write("abcdec"); 
      fw.flush(); 
      fw.write("kkkk"); 
      fw.close(); 
    } 
  } 
</pre>

<p>对于读取或者写入流对象的构造函数，以及读写方法，还有刷新关闭功能都会抛出IOException 或其子类。 所以都要进行处理。或者throws抛出，或者try ……catch处理。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
/**
  *完整的异常处理方式 
  */
 class Demo  { 
    public static void main(String[] args)  { 
      FileWriter fw = null; 
      try { 
        fw = new FileWrier("z:\\demo.txt"); 
        fw.write("abcdec"); 
         fw.flush(); 
        fw.write("kkkk"); 
      } catch(IOException e) { 
        System.out.println(e.toString()); 
      } finally{ 
        if(fw!=null) 
          try  { 
            fw.close();   
          } catch(IOException e) { 
            System.out.println("close:"+e.toString()); 
          } 
        } 
    } 
  } 
</pre>

<p>另一个小细节，当指定绝对路径时，定义目录分隔符有两种方式： </p>
<ol>
<li>反斜线  但是一定要写两个。\  new FileWriter(“c:\demo.txt”); </li>
<li>斜线  /   写一个即可。 new FileWriter(“c:/demo.txt”); </li>
</ol>
<p>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
/**
  *读取一个已有的文本文件，将文本数据打印出来 
  *一次读一个字符就打印出来，效率不高。 
  */
class Demo  { 
    public static void main(String[] args) throws IOException  { 
      FileReader fr = new FileReader("demo.txt"); 
      int ch = 0; 
      //一次读一个字符
      while((ch=fr.read())!=-1) { 
        System.out.print((char)ch); 
      } 
      fr.close(); 
    } 
  } 
</pre>

<p>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
/**
  *读一个字符就存入字符数组里，读完1Kb再打印
  */
 class Demo { 
    public static void main(String[] args) { 
      FileReader fr = null; 
      try { 
        fr = new FileReader("demo.txt"); 
        char[] buf = new char[1024];//该长度通常都是1024的整数倍
        int len = 0; 
        while((len=fr.read(buf))!=-1) { 
          System.out.println(new String(buf,0,len)); 
        } 
      } 
      catch(IOException e) { 
        System.out.println(e.toString()); 
      } finally { 
        if(fr!=null) 
          try{ 
            fr.close(); 
          } catch(IOException e){ 
            System.out.println("close:"+e.toString()); 
          } 
      } 
    } 
  } 
</pre>

<h2 id="4-BufferedWriter和BufferedReader"><a href="#4-BufferedWriter和BufferedReader" class="headerlink" title="4. BufferedWriter和BufferedReader"></a>4. BufferedWriter和BufferedReader</h2><p>缓冲区的出现提高了对流的操作效率。原理：其实就是将数组进行封装。 </p>
<ol>
<li>对应的对象： BufferedWriter<br><strong>特有方法： newLine()：跨平台的换行符</strong></li>
<li>对应的对象：BufferedReader：<br><strong>特有方法： readLine():一次读一行，</strong>到行标记时，将行标记之前的字符数据作为字符串返回。当读到末尾时，返回null。 </li>
</ol>
<p>在使用缓冲区对象时，要明确，缓冲的存在是为了增强流的功能而存在，所以在建立缓冲区对象时，要先有流对象存在。其实缓冲内部就是在使用流对象的方法，只不过加入了数组对数据进行了临时存储。为了提高操作数据的效率。代码上的体现： </p>
<p>写入缓冲区对象。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
 //建立缓冲区对象必须把流对象作为参数传递给缓冲区的构造函数
BufferedWriter bufw = new BufferedWriter(new FileWriter("buf.txt")); 
bufw.write("abce");//将数据写入到了缓冲区
bufw.flush();//对缓冲区的数据进行刷新。将数据刷到目的地中
bufw.close();//关闭缓冲区，其实关闭的是被包装在内部的流对象
</pre>

<p>读取缓冲区对象。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
BufferedReader bufr = new BufferedReader(new FileReader("buf.txt"));   
String line = null; 
//按照行的形式取出数据。取出的每一个行数据不包含回车符
while((line=bufr.readLine())!=null) { 
System.out.println(line); } 
bufr.close(); 
</pre>

<p>通过缓冲区的形式，对文本文件进行拷贝。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
 public static void main(String[] args) { 
      BufferedReader bufr = new BufferedReader(new FileReader("a.txt")); 
      BufferedWriter bufw = new BufferedWriter(new FileWriter("b.txt")); 
      String line = null; 
      while((line=bufr.readLine())!=null) { 
        bufw.write(line); 
        bufw.newLine(); 
        bufw.flush(); 
      } 
      bufw.close(); 
      bufr.close(); 
    } 
</pre>

<h2 id="5-readLine-方法的原理"><a href="#5-readLine-方法的原理" class="headerlink" title="5. readLine()方法的原理"></a>5. readLine()方法的原理</h2><p>其实缓冲区中的该方法，用的还是与缓冲区关联的流对象的read方法。只不过，每一次读到一个字符，先不进行具体操作，先进行临时存储。当读取到回车标记时，将临时容器中存储的数据一次性返回。既然明确了原理，我们也可以实现一个类似功能的方法。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
 class MyBufferedReader { 
    private Reader r; 
    MyBufferedReader(Reader r) { 
      this.r = r; 
    } 
    public String myReadLine()throws IOException { 
      //1,创建临时容器
      StringBuilder sb = new StringBuilder(); 
      //2,循环的使用read方法不断读取字符
      int ch = 0; 
      while((ch=r.read())!=-1) { 
        if(ch=='\r') 
          continue; 
        if(ch=='\n') 
          return sb.toString(); 
        else 
          sb.append((char)ch); 
      } 
        if(sb.length()!=0) 
        return sb.toString(); 
      return null; 
    } 
    public void myClose()throws IOException { 
      r.close(); 
    } 
  } 
  main() { 
    MyBufferedReader myBufr = new MyBufferedReader(new FileReader("a.txt")); 
    String line = null; 
    while((line=myBufr.myReadLine())!=null) { 
      System.out.println(line); 
    } 
  } 
</pre>

<h2 id="6-装饰设计模式"><a href="#6-装饰设计模式" class="headerlink" title="6. 装饰设计模式"></a>6. 装饰设计模式</h2><p>字符流缓冲区的出现基于流并增强了流的功能。这也是一种设计模式的体现：装饰设计模式。 实现了对一组对象进行功能的增强。该模式和继承有什么区别呢？它比继承有更好的灵活性。通常装饰类和被装饰类都同属与一个父类或者接口。 </p>
<p><strong>Writer</strong><br>&nbsp;&nbsp;|–MediaWriter<br>&nbsp;&nbsp;&nbsp;&nbsp;|–TextWriter </p>
<p><strong>注：MediaWriter与TextWtiter两个类在JDK 中并不存在，为了更形象的举例说明而“创建”的，不要误解</strong></p>
<p>需求：想要对数据的操作提高效率，就用到了缓冲技术通过所学习的继承特性。可以建立子类复写父类中的write方法即可。</p>
<p>Writer：<strong>注：不要误解，以下两个对象不存在，只为举例.</strong><br>&nbsp;&nbsp;|–MediaWriter<br>&nbsp;&nbsp;&nbsp;&nbsp;|–BufferedMediaWriter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–TextWriter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–BufferedTextWriter </p>
<p>当Writer中子类对象过多，那么为了提高每一个对象效率，每一个对象都有一个自己的子类Buffered。<br>虽然可以实现，但是继承体系变的很臃肿。那么是否可以对其进行一下优化呢？其实子类都是在使用缓冲技术。可不可以对缓冲技术进行描述，将需要增强的对象传递给缓冲区即可。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
  class BufferdWriter { 
    BufferedWriter(MediaWriter mw) { } 
    BufferedWriter(TextWriter mw) { } 
  } 
</pre>

<p>该类虽然完成了对已有两个对象的增强。但是当有新的对象出现时，还要继续在该类中添加构造函数。这样不利于扩展和维护。将对这些对象父类型进行操作即可。这就是多态，提高了程序的扩展性。同时BufferedWriter中一样具体write方法，只不过是增强后的write。所以BuferedWriter也应该是Writer中的一个子类。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
class BufferedWriter extends Writer { 
    private Writer w; 
    BufferedWriter(Writer w){ 
      this.w = w; 
    } 
  } 
</pre>

<p><strong>Writer</strong><br>&nbsp;&nbsp;|–MediaWriter<br>&nbsp;&nbsp;&nbsp;&nbsp;|–TextWriter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–BufferedWriter </p>
<p>这样就会发现装饰设计模式，优化增强功能的部分。比继承要灵活很多。可以在读一行的基础上添加一个行号。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint"> 
class MyLineNumberReader extends MyBufferedReader { 
    private int number; 
    MyLineNumberReader(Reader r) { 
      super(r); 
    } 
    public String myReadLine(){ 
      number++; 
      return super.myReadLine(); 
    } 
    public void setNumber(int number){ 
      this.number = number; 
    } 
    public int getNumber(){ 
      return number; 
    } 
  } 
</pre>







          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/11/Java-IO流-2010-11-30-io-1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/11/Java-IO流-2010-11-30-io-1.html" itemprop="url">
                  Java IO流 IO流的介绍
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-11-30T00:00:00+08:00">
                2010-11-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/11/Java-IO流-2010-11-30-io-1.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/11/Java-IO流-2010-11-30-io-1.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/11/Java-IO流-2010-11-30-io-1.html" class="leancloud_visitors" data-flag-title="Java IO流 IO流的介绍">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：</p>
<p><a href="http://sguotao.com/2010/11/30/io-1/" target="_blank" rel="external">Java IO流 1 IO流的介绍</a> <br><br><a href="http://sguotao.com/2010/12/01/io-2/" target="_blank" rel="external">Java IO流 2 字符流 </a><br><br><a href="http://sguotao.com/2010/12/02/io-3/" target="_blank" rel="external">Java IO流 3 字节流 </a><br><br><a href="http://sguotao.com/2010/12/03/io-4/" target="_blank" rel="external">Java IO流 4 File类 </a><br><br><a href="http://sguotao.com/2012/11/21/io-5/" target="_blank" rel="external">Java IO流 5 序列流</a></p>
<h2 id="1-IO流对象的继承关系"><a href="#1-IO流对象的继承关系" class="headerlink" title="1. IO流对象的继承关系"></a>1. IO流对象的继承关系</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-30%20%E4%B8%8B%E5%8D%883.07.25.png" alt=""></p>
<h2 id="2-常用与流有关的对象"><a href="#2-常用与流有关的对象" class="headerlink" title="2. 常用与流有关的对象"></a>2. 常用与流有关的对象</h2><p><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-30%20%E4%B8%8B%E5%8D%883.07.35.png" alt=""></p>
<h2 id="3-IO流"><a href="#3-IO流" class="headerlink" title="3. IO流"></a>3. IO流</h2><ol>
<li>IO 流<br>用于处理设备上的数据<br>设备：硬盘，内存，键盘录入。 </li>
<li>IO 有具体的分类<br>根据处理的数据类型不同：字节流和字符流。<br>根据流向不同：输入流和输出流。 </li>
<li>字符流的由来<br>因为文件编码的不同，而有了对字符进行高效操作的字符流对象。<br>原理：其实就是基于字节流读取字节时，去查了指定的码表。 </li>
<li>字节流和字符流的区别</li>
</ol>
<ul>
<li>字节流读取的时候，读到一个字节就返回一个字节。字符流使用了字节流读到一个或多个字节(中文对应的字节数是两个，在UTF-8 码表中是3个字节)时先去查指定的编码表，将查到的字符返回。 </li>
<li>字节流可以处理所有类型数据，如图片，mp3，avi。 而字符流只能处理字符数据。 </li>
<li>结论：只要是处理纯文本数据，就要优先考虑使用字符流。除此之外都用字节流。 </li>
</ul>
<ol>
<li>IO的体系。所具备的基本功能就有两个：读  和  写</li>
<li>字节流<br>InputStream（读）,OutputStream（写）。 </li>
<li>字符流：<br>Reader（读），Writer（写）。 </li>
<li>基本的读写操作方式<br>因为数据通常都以文件形式存在。所以就要找到IO 体系中可以用于操作文件的流对象。 通过名称可以更容易获取该对象。 因为IO 体系中的子类名后缀绝大部分是父类名称。而前缀都是体现子类功能的名字。 </li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/10/Java-多线程-2010-10-6-multi-thread-6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/10/Java-多线程-2010-10-6-multi-thread-6.html" itemprop="url">
                  多线程 6 线程组
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-10-06T00:00:00+08:00">
                2010-10-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/10/Java-多线程-2010-10-6-multi-thread-6.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/10/Java-多线程-2010-10-6-multi-thread-6.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/10/Java-多线程-2010-10-6-multi-thread-6.html" class="leancloud_visitors" data-flag-title="多线程 6 线程组">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。</p>
<p><a href="http://sguotao.com/2010/10/01/multi-thread-1/" target="_blank" rel="external">多线程 1 线程与线程类</a><br><br><a href="http://sguotao.com/2010/10/02/multi-thread-2/" target="_blank" rel="external">多线程 2 线程的创建</a><br><br><a href="http://sguotao.com/2010/10/03/multi-thread-3/" target="_blank" rel="external">多线程 3 线程的状态与调度</a><br><br><a href="http://sguotao.com/2010/10/04/multi-thread-4/" target="_blank" rel="external">多线程 4 线程状态的改变</a><br><br><a href="http://sguotao.com/2010/10/05/multi-thread-5/" target="_blank" rel="external">多线程 5 线程的同步与共享</a><br><br><a href="http://sguotao.com/2010/10/06/multi-thread-6/" target="_blank" rel="external">多线程 6 线程组</a></p>
<p>所有Java线程都属于某个线程组(thread group)。线程组提供了一个将多个线程组织成一个线程组对象来管理的机制，如可以通过一个方法调用来启动线程组中的所有线程。</p>
<h2 id="1-创建线程组"><a href="#1-创建线程组" class="headerlink" title="1. 创建线程组"></a>1. 创建线程组</h2><p>线程组是由java.lang包中的ThreadGroup类实现的。它的构造方法如下：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public ThreadGroup(String name)
public ThreadGroup(ThreadGroup parent, String name)
</pre>

<p>name为线程组名，parent为线程组的父线程组，若无该参数则新建线程组的父线程组为当前运行的线程的线程组。当一个线程被创建时，运行时系统都将其放入一个线程组。创建线程时可以明确指定新建线程属于哪个线程组，若没有明确指定则放入缺省线程组中。一旦线程被指定属于哪个线程组，便不能改变，不能删除。</p>
<h2 id="2-缺省线程组"><a href="#2-缺省线程组" class="headerlink" title="2. 缺省线程组"></a>2. 缺省线程组</h2><p>如果在创建线程时没有在构造方法中指定所属线程组，运行时系统会自动将该线程放入创建该线程的线程所属的线程组中。那么当我们创建线程时没有指定线程组，它属于哪个线程组呢?</p>
<p>当Java应用程序启动时，Java运行时系统创建一个名main的ThreadGroup对象。除非另外指定，否则所有新建线程都属于main线程组的成员。</p>
<p><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-30%20%E4%B8%8B%E5%8D%882.23.40.png" alt=""></p>
<p>在一个线程组内可以创建多个线程，也可以创建其它的线程组。一个程序中的线程组和线程构成一个树型结构，如图6所示.</p>
<p>如果在Applet中创建线程，新线程组可能不是main线程组，它依赖于使用的浏览器或Applet查看器。<br>创建属于某个线程组的线程可以通过下面构造方法实现<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public Thread(ThreadGroup group, Runnable target)
public Thread(ThreadGroup group, String name)
public Thread(ThreadGroup group, Runnable target, String name)
</pre>

<p>如下面代码创建的myThread线程属于myThreadGroup线程组。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
ThreadGroup myGroup = new ThreadGroup("My Group of Threads");
Thread myThread = new Thread(myGroup, "a thread for my group");
</pre>

<p>为了得到线程所属的线程组可以调用Thread的getThreadGroup()方法，该方法返回ThreadGroup对象。可以通过下面方法获得线程所属线程组名。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
myThread.getThreadGroup().getName()
</pre>

<p>一旦得到了线程组对象，就可查询线程组的有关信息，如线程组中其他线程、也可仅通过调用一个方法就可实现修改线程组中的线程，如挂起、恢复或停止线程。</p>
<h2 id="3-线程组操作方法"><a href="#3-线程组操作方法" class="headerlink" title="3. 线程组操作方法"></a>3. 线程组操作方法</h2><p>线程组类提供了有关方法可以对线程组操作。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public final String getName() 返回线程组名。
public final ThreadGroup getParent() 返回线程组的父线程组对象。
public final void setMaxPriority(int pri) 设置线程组的最大优先级。线程组中的线程不能超过该优先级。
public final int getMaxPriority() 返回线程组的最大优先级。
public boolean isDestroyed() 测试该线程组对象是否已被销毁。
public int activeCount() 返回该线程组中活动线程的估计数。
public int activeGroupCount() 返回该线程组中活动线程组的估计数。
public final void destroy() 销毁该线程组及其子线程组对象。当前线程组的所有线程必须已经停止。
</pre>

<p>Java语言内在支持多线程的程序设计。线程是进程中的一个单个的顺序控制流，多线程是指单个程序内可以同时运行多个线程。</p>
<p>在Java程序中创建多线程的程序有两种方法。一种是继承Thread类并覆盖其run()方法，另一种是实现Runnable接口并实现其run()方法。</p>
<p>线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。Java的每个线程都有一个优先级，当有多个线程处于就绪状态时，线程调度程序根据线程的优先级调度线程运行。</p>
<p>线程都是独立的、异步执行的线程，但在很多情况下，多个线程需要共享数据资源，这就涉及到线程的同步与资源共享的问题。</p>
<p>所有Java线程都属于某个线程组。线程组提供了一个将多个线程组织成一个线程组对象来管理的机制，如可以通过一个方法调用来启动线程组中的所有线程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/10/Java-多线程-2010-10-5-multi-thread-5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/10/Java-多线程-2010-10-5-multi-thread-5.html" itemprop="url">
                  多线程 5 线程的同步与共享
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-10-05T00:00:00+08:00">
                2010-10-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/10/Java-多线程-2010-10-5-multi-thread-5.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/10/Java-多线程-2010-10-5-multi-thread-5.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/10/Java-多线程-2010-10-5-multi-thread-5.html" class="leancloud_visitors" data-flag-title="多线程 5 线程的同步与共享">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。</p>
<p><a href="http://sguotao.com/2010/10/01/multi-thread-1/" target="_blank" rel="external">多线程 1 线程与线程类</a><br><br><a href="http://sguotao.com/2010/10/02/multi-thread-2/" target="_blank" rel="external">多线程 2 线程的创建</a><br><br><a href="http://sguotao.com/2010/10/03/multi-thread-3/" target="_blank" rel="external">多线程 3 线程的状态与调度</a><br><br><a href="http://sguotao.com/2010/10/04/multi-thread-4/" target="_blank" rel="external">多线程 4 线程状态的改变</a><br><br><a href="http://sguotao.com/2010/10/05/multi-thread-5/" target="_blank" rel="external">多线程 5 线程的同步与共享</a><br><br><a href="http://sguotao.com/2010/10/06/multi-thread-6/" target="_blank" rel="external">多线程 6 线程组</a></p>
<p>前面程序中的线程都是独立的、异步执行的线程。但在很多情况下，多个线程需要共享数据资源，这就涉及到线程的同步与资源共享的问题。</p>
<h2 id="1-资源冲突Ter"><a href="#1-资源冲突Ter" class="headerlink" title="1. 资源冲突Ter"></a>1. 资源冲突Ter</h2><p>下面的例子说明，多个线程共享资源，如果不加以控制可能会产生冲突。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
class Num{
    private int x=0;
    private int y=0;
    void increase(){
        x++;
        y++;
        }
    void testEqual(){
          System.out.println(x+","+y+":"+(x==y));
    }
}
class Counter extends Thread{
private Num num;
Counter(Num num){
  this.num=num;    
}
public void run(){
while(true){
  num.increase();
}
}
}
public class CounterTest{
public static void main(String[] args){
    Num num = new Num();
    Thread count1 = new Counter(num);
    Thread count2 = new Counter(num);
    count1.start();
    count2.start();
    for(int i=0;i<100;i++){ num.testequal();="" try{="" thread.sleep(100);="" }catch(interruptedexception="" e){="" }="" <="" pre="">

<p>上述程序在CounterTest类的main()方法中创建了两个线程类Counter的对象count1和count2，这两个对象共享一个Num类的对象num。两个线程对象开始运行后，都调用同一个对象num的increase()方法来增加num对象的x和y的值。在main()方法的for()循环中输出num对象的x和y的值。程序输出结果有些x、y的值相等，大部分x、y的值不相等。</p>
<p>出现上述情况的原因是：两个线程对象同时操作一个num对象的同一段代码，通常将这段代码段称为临界区(critical sections)。在线程执行时，可能一个线程执行了x++语句而尚未执行y++语句时，系统调度另一个线程对象执行x++和y++，这时在主线程中调用testEqual()方法输出x、y的值不相等。<br>这里可能出现x的值小于y的值的情况，为什么？</p>
<h2 id="2-对象锁的实现"><a href="#2-对象锁的实现" class="headerlink" title="2. 对象锁的实现"></a>2. 对象锁的实现</h2><p>上述程序的运行结果说明了多个线程访问同一个对象出现了冲突，为了保证运行结果正确(x、y的值总相等)，可以使用Java语言的synchronized关键字，用该关键字修饰方法。用synchronized关键字修饰的方法称为同步方法，Java平台为每个具有synchronized代码段的对象关联一个对象锁(object lock)。这样任何线程在访问对象的同步方法时，首先必须获得对象锁，然后才能进入synchronized方法，这时其他线程就不能再同时访问该对象的同步方法了(包括其他的同步方法)。</p>
<p>通常有两种方法实现对象锁：</p>
<ol>
<li>在方法的声明中使用synchronized关键字，表明该方法为同步方法。<br>对于上面的程序我们可以在定义Num类的increase()和testEqual()方法时，在它们前面加上synchronized关键字，如下所示：<br>&lt;?prettify?&gt;<pre class="prettyprint">
synchronized void increase(){
 x++;
 y++;
}
synchronized void testEqual(){
 System.out.println(x+","+y+":"+(x==y)+":"+(x<y)); }="" <="" pre="">

</y));></pre></li>
</ol>
<p>一个方法使用synchronized关键字修饰后，当一个线程调用该方法时，必须先获得对象锁，只有在获得对象锁以后才能进入synchronized方法。一个时刻对象锁只能被一个线程持有。如果对象锁正在被一个线程持有，其他线程就不能获得该对象锁，其他线程就必须等待持有该对象锁的线程释放锁。</p>
<p>如果类的方法使用了synchronized关键字修饰，则称该类对象是线程安全的，否则是线程不安全的。<br>如果只为increase()方法添加synchronized 关键字，结果还会出现x、y的值不相等的情况，请考虑为什么？</p>
<ol>
<li>前面实现对象锁是在方法前加上synchronized 关键字，这对于我们自己定义的类很容易实现，但如果使用类库中的类或别人定义的类在调用一个没有使用synchronized关键字修饰的方法时，又要获得对象锁，可以使用下面的格式：<br>&lt;?prettify?&gt;<pre class="prettyprint">
synchronized(object){
//方法调用
}
</pre>

</li>
</ol>
<p>假如Num类的increase()方法没有使用synchronized 关键字，我们在定义Counter类的run()方法时可以按如下方法使用synchronized为部分代码加锁。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public void run(){
    while(true){
synchronized (num){
        num.increase();
      }
    }}
</pre>

<p>同时在main()方法中调用testEqual()方法也用synchronized关键字修饰，这样得到的结果相同。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
synchronized(num){
    num.testEqual();
}
</pre>

<p>对象锁的获得和释放是由Java运行时系统自动完成的。每个类也可以有类锁。类锁控制对类的synchronized static代码的访问。请看下面的例子：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public class X{
  static int x, y;
  static synchronized void foo(){
     x++;
y++;
}}
</pre>

<p>当foo()方法被调用时(如，使用X.foo())，调用线程必须获得X类的类锁。</p>
<h2 id="3-线程间的同步控制"><a href="#3-线程间的同步控制" class="headerlink" title="3. 线程间的同步控制"></a>3. 线程间的同步控制</h2><p>在多线程的程序中，除了要防止资源冲突外，有时还要保证线程的同步。下面通过生产者-消费者模型来说明线程的同步与资源共享的问题。</p>
<p>假设有一个生产者(Producer)，一个消费者(Consumer)。生产者产生0~9的整数，将它们存储在仓库(CubbyHole)的对象中并打印出这些数来；消费者从仓库中取出这些整数并将其也打印出来。同时要求生产者产生一个数字，消费者取得一个数字，这就涉及到两个线程的同步问题。</p>
<p>这个问题就可以通过两个线程实现生产者和消费者，它们共享CubbyHole一个对象。如果不加控制就得不到预期的结果。</p>
<h3 id="3-1-不同步设计"><a href="#3-1-不同步设计" class="headerlink" title="3.1 不同步设计"></a>3.1 不同步设计</h3><p>首先我们设计用于存储数据的类，该类的定义如下：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
class CubbyHole{
  private int content ;
public synchronized void put(int value){
content = value;
}
  public synchronized int get(){
return content ;
} 
}
</pre>

<p>CubbyHole类使用一个私有成员变量content用来存放整数，put()方法和get()方法用来设置变量content的值。CubbyHole对象为共享资源，所以用synchronized关键字修饰。当put()方法或get()方法被调用时，线程即获得了对象锁，从而可以避免资源冲突。</p>
<p>这样当Producer对象调用put()方法是，它锁定了该对象，Consumer对象就不能调用get()方法。当put()方法返回时，Producer对象释放了CubbyHole的锁。类似地，当Consumer对象调用CubbyHole的get()方法时，它也锁定该对象，防止Producer对象调用put()方法。</p>
<p>接下来我们看Producer和Consumer的定义，这两个类的定义如下：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public class Producer extends Thread {
    private CubbyHole cubbyhole;
    private int number;
    public Producer(CubbyHole c, int number) {
        cubbyhole = c;
        this.number = number;
    }
    public void run() {
       for (int i = 0; i < 10; i++) {
          cubbyhole.put(i);
          System.out.println("Producer #" + this.number + " put: " + i);
          try {
                sleep((int)(Math.random() * 100));
           } catch (InterruptedException e) { }
        }
    }
}
</pre>

<p>Producer类中定义了一个CubbyHole类型的成员变量cubbyhole，它用来存储产生的整数，另一个成员变量number用来记录线程号。这两个变量通过构造方法传递得到。在该类的run()方法中，通过一个循环产生10个整数，每次产生一个整数，调用cubbyhole对象的put()方法将其存入该对象中，同时输出该数。下面是Consumer类的定义：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public class Consumer extends Thread {
    private CubbyHole cubbyhole;
    private int number;
    public Consumer(CubbyHole c, int number) {
        cubbyhole = c;
        this.number = number;
    }
    public void run() {
        int value = 0;
        for (int i = 0; i < 10; i++) {
            value = cubbyhole.get();
      System.out.println("Consumer #" + this.number + " got: " + value);
        }
    }
}
</pre>

<p>在Consumer类的run()方法中也是一个循环，每次调用cubbyhole的get()方法返回当前存储的整数，然后输出。</p>
<p>下面是主程序，在该程序的main()方法中创建一个CubbyHole对象c，一个Producer对象p1，一个Consumer对象c1，然后启动两个线程。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public class ProducerConsumerTest {
    public static void main(String[] args) {
        CubbyHole c = new CubbyHole();
        Producer p1 = new Producer(c, 1);
        Consumer c1 = new Consumer(c, 1);
        p1.start();
        c1.start();
    }
}
</pre>

<p>该程序中对CubbyHole类的设计，尽管使用了synchronized关键字实现了对象锁，但这还不够。程序运行可能出现下面两种情况：</p>
<p>如果生产者的速度比消费者快，那么在消费者来不及取前一个数据之前，生产者又产生了新的数据，于是消费者很可能会跳过前一个数据，这样就会产生下面的结果：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
Consumer: 3
Producer: 4
Producer: 5
Consumer: 5
…
</pre>

<p>反之，如果消费者比生产者快，消费者可能两次取同一个数据，可能产生下面的结果：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
Producer: 4
Consumer: 4
Consumer: 4
Producer: 5
…
</pre>

<h3 id="3-2-监视器模型"><a href="#3-2-监视器模型" class="headerlink" title="3.2 监视器模型"></a>3.2 监视器模型</h3><p>为了避免上述情况发生，就必须使生产者线程向CubbyHole对象中存储数据与消费者线程从CubbyHole对象中取得数据同步起来。为了达到这一目的，在程序中可以采用监视器(monitor)模型，同时通过调用对象的wait()方法和notify()方法实现同步。下面是修改后的CubbyHole类的定义：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
class CubbyHole{
  private int content ;
  private boolean available=false;
public synchronized void put(int value){
 while(available==true){
      try{
wait();
}catch(InterruptedException e){}
} 
content =value;
available=true;
notifyAll();
}
  public synchronized int get(){
    while(available==false){
      try{
wait();
}catch(InterruptedException e){}
    }
available=false;
notifyAll();
return content;
} 
}
</pre>

<p>这里有一个boolean型的私有成员变量available用来指示内容是否可取。当available为true时表示数据已经产生还没被取走，当available为false时表示数据已被取走还没有存放新的数据。</p>
<p>当生产者线程进入put()方法时，首先检查available的值，若其为false，才可执行put()方法，若其为true，说明数据还没有被取走，该线程必须等待。因此在put()方法中调用CubbyHole对象的wait()方法等待。调用对象的wait()方法使线程进入等待状态，同时释放对象锁。直到另一个线程对象调用了notify()或notifyAll()方法，该线程才可恢复运行。</p>
<p>类似地，当消费者线程进入get()方法时，也是先检查available的值，若其为true，才可执行get()方法，若其为false，说明还没有数据，该线程必须等待。因此在get()方法中调用CubbyHole对象的wait()方法等待。调用对象的wait()方法使线程进入等待状态，同时释放对象锁。</p>
<p>上述过程就是监视器模型，其中CubbyHole对象为监视器。通过监视器模型可以保证生产者线程和消费者线程同步，结果正确。</p>
<p>特别注意：wait()、notify()和notifyAll()方法是Object类定义的方法，并且这些方法只能用在synchronized代码段中。它们的定义格式如下：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public final void wait()
public final void wait(long timeout)
public final void wait(long timeout, int nanos)
</pre>

<p>当前线程必须具有对象监视器的锁，当调用该方法时线程释放监视器的锁。调用这些方法使当前线程进入等待(阻塞)状态，直到另一个线程调用了该对象的notify()方法或notifyAll()方法，该线程重新进入运行状态，恢复执行。</p>
<p>timeout和nanos为等待的时间的毫秒和纳秒，当时间到或其他对象调用了该对象的notify()方法或notifyAll()方法，该线程重新进入运行状态，恢复执行。</p>
<p>wait()的声明抛出了InterruptedException，因此程序中必须捕获或声明抛出该异常。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public final void notify()
public final void notifyAll()
</pre>

<p>唤醒处于等待该对象锁的一个或所有的线程继续执行，通常使用notifyAll()方法。</p>
<p>在生产者/消费者的例子中，CubbyHole类的put和get方法就是临界区。当生产者修改它时，消费者不能问CubbyHole对象；当消费者取得值时，生产者也不能修改它。</p>
</100;i++){></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/10/Java-多线程-2010-10-4-multi-thread-4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/10/Java-多线程-2010-10-4-multi-thread-4.html" itemprop="url">
                  多线程 4 线程状态的改变
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-10-04T00:00:00+08:00">
                2010-10-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/10/Java-多线程-2010-10-4-multi-thread-4.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/10/Java-多线程-2010-10-4-multi-thread-4.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/10/Java-多线程-2010-10-4-multi-thread-4.html" class="leancloud_visitors" data-flag-title="多线程 4 线程状态的改变">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。</p>
<p><a href="http://sguotao.com/2010/10/01/multi-thread-1/" target="_blank" rel="external">多线程 1 线程与线程类</a><br><br><a href="http://sguotao.com/2010/10/02/multi-thread-2/" target="_blank" rel="external">多线程 2 线程的创建</a><br><br><a href="http://sguotao.com/2010/10/03/multi-thread-3/" target="_blank" rel="external">多线程 3 线程的状态与调度</a><br><br><a href="http://sguotao.com/2010/10/04/multi-thread-4/" target="_blank" rel="external">多线程 4 线程状态的改变</a><br><br><a href="http://sguotao.com/2010/10/05/multi-thread-5/" target="_blank" rel="external">多线程 5 线程的同步与共享</a><br><br><a href="http://sguotao.com/2010/10/06/multi-thread-6/" target="_blank" rel="external">多线程 6 线程组</a></p>
<h2 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1. 线程的状态"></a>1. 线程的状态</h2><p>一个线程在其生命周期中可以从一种状态改变到另一种状态，线程状态的变迁如图5所示：<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-26%20%E4%B8%8B%E5%8D%887.32.58.png" alt=""></p>
<h2 id="2-控制线程的启动和结束"><a href="#2-控制线程的启动和结束" class="headerlink" title="2. 控制线程的启动和结束"></a>2. 控制线程的启动和结束</h2><p>当一个新建的线程调用它的start()方法后即进入就绪状态，处于就绪状态的线程被线程调度程序选中就可以获得CPU时间，进入运行状态，该线程就开始运行run()方法。</p>
<p>控制线程的结束稍微复杂一点。如果线程的run()方法是一个确定次数的循环，则循环结束后，线程运行就结束了，线程对象即进入死亡状态。如果run()方法是一个不确定循环，早期的方法是调用线程对象的stop()方法，然而由于该方法可能导致线程死锁，因此从1.1版开始，不推荐使用该方法结束线程。一般是通过设置一个标志变量，在程序中改变标志变量的值实现结束线程。请看下面的例子：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
import java.util.*;
class Timer implements Runnable{
    boolean flag=true;
    public void run(){
      while(flag){
        System.out.print("\r\t"+new Date()+"...");
        try{
            Thread.sleep(1000);
        }catch(InterruptedException e){}    
      }
      System.out.println("\n"+Thread.currentThread().getName()+" Stop");
    }
    public void stopRun(){
        flag = false;
    }
}
public class ThreadStop{
    public static void main(String args[]){
       Timer timer = new Timer();
       Thread thread = new Thread(timer);    
       thread.setName("Timer");
       thread.start();
       for(int i=0;i<100;i++){ system.out.print("\r"+i);="" try{="" thread.sleep(100);="" }catch(interruptedexception="" e){}="" }="" timer.stoprun();}}="" <="" pre="">

<p>该程序在Timer类中定义了一个布而变量flag，同时定义了一个stopRun()方法，在其中将该变量设置为false。在主程序中通过调用该方法，从而改变该变量的值，使得run()方法的while循环条件不满足，从而实现结束线程的运行。</p>
<p><strong> 在Thread类中除了stop()方法被标注为不推荐(deprecated) 使用外，suspend()方法和resume()方法也被标明不推荐使用，这两个方法原来用作线程的挂起和恢复。</strong></p>
<h2 id="3-线程阻塞条件"><a href="#3-线程阻塞条件" class="headerlink" title="3. 线程阻塞条件"></a>3. 线程阻塞条件</h2><p>处于运行状态的线程除了可以进入死亡状态外，还可能进入就绪状态和阻塞状态。下面分别讨论这两种情况：</p>
<h3 id="3-1-运行状态到就绪状态"><a href="#3-1-运行状态到就绪状态" class="headerlink" title="3.1 运行状态到就绪状态"></a>3.1 运行状态到就绪状态</h3><p>处于运行状态的线程如果调用了yield()方法，那么它将放弃CPU时间，使当前正在运行的线程进入就绪状态。这时有几种可能的情况：如果没有其他的线程处于就绪状态等待运行，该线程会立即继续运行；如果有等待的线程，此时线程回到就绪状态状态与其他线程竞争CPU时间，当有比该线程优先级高的线程时，高优先级的线程进入运行状态，当没有比该线程优先级高的线程时，但有同优先级的线程，则由线程调度程序来决定哪个线程进入运行状态，因此线程调用yield()方法只能将CPU时间让给具有同优先级的或高优先级的线程而不能让给低优先级的线程。一般来说，在调用线程的yield()方法可以使耗时的线程暂停执行一段时间，使其他线程有执行的机会。</p>
<h3 id="3-2-运行状态到阻塞状态"><a href="#3-2-运行状态到阻塞状态" class="headerlink" title="3.2 运行状态到阻塞状态"></a>3.2 运行状态到阻塞状态</h3><p>有多种原因可使当前运行的线程进入阻塞状态，进入阻塞状态的线程当相应的事件结束或条件满足时进入就绪状态。使线程进入阻塞状态可能有多种原因：</p>
<ol>
<li>线程调用了sleep()方法，线程进入睡眠状态，此时该线程停止执行一段时间。当时间到时该线程回到就绪状态，与其他线程竞争CPU时间。<br>Thread类中定义了一个interrupt()方法。一个处于睡眠中的线程若调用了interrupt()方法，该线程立即结束睡眠进入就绪状态。</li>
<li>如果一个线程的运行需要进行I/O操作，比如从键盘接收数据，这时程序可能需要等待用户的输入，这时如果该线程一直占用CPU，其他线程就得不到运行。这种情况称为I/O阻塞。这时该线程就会离开运行状态而进入阻塞状态。Java语言的所有I/O方法都具有这种行为。</li>
<li>有时要求当前线程的执行在另一个线程执行结束后再继续执行，这时可以调用join()方法实现，join()方法有下面三种格式：<br>&lt;?prettify?&gt;<pre class="prettyprint">
public void join() throws InterruptedException 使当前线程暂停执行，等待调用该方法的线程结束后再执行当前线程。
public void join(long millis) throws InterruptedException 最多等待millis毫秒后，当前线程继续执行。
public void join(long millis, int nanos) throws InterruptedException 可以指定多少毫秒、多少纳秒后继续执行当前线程。
</pre>

</li>
</ol>
<p>上述方法使当前线程暂停执行，进入阻塞状态，当调用线程结束或指定的时间过后，当前线程线程进入就绪状态，例如执行下面代码：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
t.join();
</pre>

<p>将使当前线程进入阻塞状态，当线程t执行结束后，当前线程才能继续执行。</p>
<ol>
<li>线程调用了wait()方法，等待某个条件变量，此时该线程进入阻塞状态。直到被通知(调用了notify()或notifyAll()方法)结束等待后，线程回到就绪状态。</li>
<li>另外如果线程不能获得对象锁，也进入就绪状态。<br>后两种情况在下一节讨论。</li>
</ol>
</100;i++){></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/10/Java-多线程-2010-10-3-multi-thread-3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/10/Java-多线程-2010-10-3-multi-thread-3.html" itemprop="url">
                  多线程 3 线程的状态与调度
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-10-03T00:00:00+08:00">
                2010-10-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/10/Java-多线程-2010-10-3-multi-thread-3.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/10/Java-多线程-2010-10-3-multi-thread-3.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/10/Java-多线程-2010-10-3-multi-thread-3.html" class="leancloud_visitors" data-flag-title="多线程 3 线程的状态与调度">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。</p>
<p><a href="http://sguotao.com/2010/10/01/multi-thread-1/" target="_blank" rel="external">多线程 1 线程与线程类</a><br><br><a href="http://sguotao.com/2010/10/02/multi-thread-2/" target="_blank" rel="external">多线程 2 线程的创建</a><br><br><a href="http://sguotao.com/2010/10/03/multi-thread-3/" target="_blank" rel="external">多线程 3 线程的状态与调度</a><br><br><a href="http://sguotao.com/2010/10/04/multi-thread-4/" target="_blank" rel="external">多线程 4 线程状态的改变</a><br><br><a href="http://sguotao.com/2010/10/05/multi-thread-5/" target="_blank" rel="external">多线程 5 线程的同步与共享</a><br><br><a href="http://sguotao.com/2010/10/06/multi-thread-6/" target="_blank" rel="external">多线程 6 线程组</a></p>
<h2 id="1-线程的生命周期"><a href="#1-线程的生命周期" class="headerlink" title="1. 线程的生命周期"></a>1. 线程的生命周期</h2><p>线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。线程的状态如图4所示：<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-26%20%E4%B8%8B%E5%8D%887.16.48.png" alt=""></p>
<p>下面以前面的Java小程序为例说明线程的状态：</p>
<h3 id="1-1-新建状态-NewThread"><a href="#1-1-新建状态-NewThread" class="headerlink" title="1.1 新建状态 NewThread"></a>1.1 新建状态 NewThread</h3><p>当Applet启动时调用Applet的start()方法，此时小应用程序就创建一个Thread对象clockThread。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public void start() {
        if (clockThread == null) {
           clockThread = new Thread(cp, "Clock");
           clockThread.start(); } }
</pre>

<p>当该语句执行后clockThread就处于新建状态。处于该状态的线程仅仅是空的线程对象，并没有为其分配系统资源。当线程处于该状态，你仅能启动线程，调用任何其他方法是无意义的且会引发IllegalThreadStateException异常(实际上，当调用线程的状态所不允许的任何方法时，运行时系统都会引发IllegalThreadStateException异常)。</p>
<p>注意cp作为线程构造方法的第一个参数，该参数必须是实现了Runnable接口的对象并提供线程运行的run()方法，第二个参数是线程名。</p>
<h3 id="1-2-就绪状态-Runnable"><a href="#1-2-就绪状态-Runnable" class="headerlink" title="1.2 就绪状态 Runnable"></a>1.2 就绪状态 Runnable</h3><p>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，如clockThread.start(); 语句就是启动clockThread线程。start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。</p>
<p>处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。</p>
<h3 id="1-3-运行状态-Running"><a href="#1-3-运行状态-Running" class="headerlink" title="1.3 运行状态 Running"></a>1.3 运行状态 Running</h3><p>当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法，这里run()方法中是一个循环，循环条件是true。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public void run() {
       while (true) {
           repaint();
           try {  Thread.sleep(1000);
           } catch (InterruptedException e){} }
</pre>

<h3 id="1-4-阻塞状态-Blocked"><a href="#1-4-阻塞状态-Blocked" class="headerlink" title="1.4 阻塞状态 Blocked"></a>1.4 阻塞状态 Blocked</h3><p>线程运行过程中，可能由于各种原因进入阻塞状态。所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。有关阻塞状态在后面详细讨论。</p>
<h3 id="1-5-死亡状态-Dead"><a href="#1-5-死亡状态-Dead" class="headerlink" title="1.5 死亡状态 Dead"></a>1.5 死亡状态 Dead</h3><p>线程的正常结束，即run()方法返回，线程运行就结束了，此时线程就处于死亡状态。本例子中，线程运行结束的条件是clockThread为null，而在小应用程序的stop()方法中，将clockThread赋值为null。即当用户离开含有该小应用程序的页面时，浏览器调用stop()方法，将clockThread赋值为null，这样在run()的while循环时条件就为false，这样线程运行就结束了。如果再重新访问该页面，小应用程序的start()方法又会重新被调用，重新创建并启动一个新的线程。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
 public void stop() {
        clockThread = null; }
</pre>

<p>程序不能像终止小应用程序那样通过调用一个方法来结束线程(小应用程序通过调用stop()方法结束小应用程序的运行)。线程必须通过run()方法的自然结束而结束。通常在run()方法中是一个循环，要么是循环结束，要么是循环的条件不满足，这两种情况都可以使线程正常结束，进入死亡状态。<br>例如，下面一段代码是一个循环：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public void run(){
  int i = 0;
  while(i<100){ i++;="" system.out.println("i=" + i );}}
</pre>

<p>当该段代码循环结束后，线程就自然结束了。注意一个处于死亡状态的线程不能再调用该线程的任何方法。</p>
<h2 id=" 2-线程的优先级和调度"=""><a href="#2-线程的优先级和调度" class="headerlink" title="2. 线程的优先级和调度"></a>2. 线程的优先级和调度<p>Java的每个线程都有一个优先级，当有多个线程处于就绪状态时，线程调度程序根据线程的优先级调度线程运行。可以用下面方法设置和返回线程的优先级。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public final void setPriority(int newPriority) 设置线程的优先级。
public final int getPriority() 返回线程的优先级。
</pre>

<p>newPriority为线程的优先级，其取值为1到10之间的整数，也可以使用Thread类定义的常量来设置线程的优先级，这些常量分别为：Thread.MIN_PRIORITY、Thread.NORM_PRIORITY、Thread.MAX_PRIORITY，它们分别对应于线程优先级的1、5和10，数值越大优先级越高。当创建Java线程时，如果没有指定它的优先级，则它从创建该线程那里继承优先级。</p>
<p>一般来说，只有在当前线程停止或由于某种原因被阻塞，较低优先级的线程才有机会运行。<br>前面说过多个线程可并发运行，然而实际上并不总是这样。由于很多计算机都是单CPU的，所以一个时刻只能有一个线程运行，多个线程的并发运行只是幻觉。在单CPU机器上多个线程的执行是按照某种顺序执行的，这称为线程的调度(scheduling)。</p>
<p>大多数计算机仅有一个CPU，所以线程必须与其他线程共享CPU。多个线程在单个CPU是按照某种顺序执行的。实际的调度策略随系统的不同而不同，通常线程调度可以采用两种策略调度处于就绪状态的线程。</p>
<h3 id="2-1-抢占式调度策略"><a href="#2-1-抢占式调度策略" class="headerlink" title="2.1 抢占式调度策略"></a>2.1 抢占式调度策略</h3><p>Java运行时系统的线程调度算法是抢占式的 (preemptive)。Java运行时系统支持一种简单的固定优先级的调度算法。如果一个优先级比其他任何处于可运行状态的线程都高的线程进入就绪状态，那么运行时系统就会选择该线程运行。新的优先级较高的线程抢占(preempt)了其他线程。但是Java运行时系统并不抢占同优先级的线程。换句话说，Java运行时系统不是分时的(time-slice)。然而，基于Java Thread类的实现系统可能是支持分时的，因此编写代码时不要依赖分时。当系统中的处于就绪状态的线程都具有相同优先级时，线程调度程序采用一种简单的、非抢占式的轮转的调度顺序。</p>
<h3 id="2-2-时间片轮转调度策略"><a href="#2-2-时间片轮转调度策略" class="headerlink" title="2.2 时间片轮转调度策略"></a>2.2 时间片轮转调度策略</h3><p>有些系统的线程调度采用时间片轮转(round-robin)调度策略。这种调度策略是从所有处于就绪状态的线程中选择优先级最高的线程分配一定的CPU时间运行。该时间过后再选择其他线程运行。只有当线程运行结束、放弃(yield)CPU或由于某种原因进入阻塞状态，低优先级的线程才有机会执行。如果有两个优先级相同的线程都在等待CPU，则调度程序以轮转的方式选择运行的线程。</p>
</100){></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.sguotao.com/blog/2010/10/Java-多线程-2010-10-2-multi-thread-2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Scott">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scott-小白">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2010/10/Java-多线程-2010-10-2-multi-thread-2.html" itemprop="url">
                  多线程 2 线程的创建
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2010-10-02T00:00:00+08:00">
                2010-10-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2010/10/Java-多线程-2010-10-2-multi-thread-2.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="/blog/2010/10/Java-多线程-2010-10-2-multi-thread-2.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/blog/2010/10/Java-多线程-2010-10-2-multi-thread-2.html" class="leancloud_visitors" data-flag-title="多线程 2 线程的创建">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。</p>
<p><a href="http://sguotao.com/2010/10/01/multi-thread-1/" target="_blank" rel="external">多线程 1 线程与线程类</a><br><br><a href="http://sguotao.com/2010/10/02/multi-thread-2/" target="_blank" rel="external">多线程 2 线程的创建</a><br><br><a href="http://sguotao.com/2010/10/03/multi-thread-3/" target="_blank" rel="external">多线程 3 线程的状态与调度</a><br><br><a href="http://sguotao.com/2010/10/04/multi-thread-4/" target="_blank" rel="external">多线程 4 线程状态的改变</a><br><br><a href="http://sguotao.com/2010/10/05/multi-thread-5/" target="_blank" rel="external">多线程 5 线程的同步与共享</a><br><br><a href="http://sguotao.com/2010/10/06/multi-thread-6/" target="_blank" rel="external">多线程 6 线程组</a></p>
<p>如何创建和运行线程的两种方法。线程运行的代码就是实现了Runnable接口的类的run()方法或者是Thread类的子类的run()方法，因此构造线程体就有两种方法：</p>
<ul>
<li>继承Thread类并覆盖它的run()方法；</li>
<li>实现Runnable接口并实现它的run()方法。</li>
</ul>
<h2 id="1-继承Thread类创建线程"><a href="#1-继承Thread类创建线程" class="headerlink" title="1. 继承Thread类创建线程"></a>1. 继承Thread类创建线程</h2><p>通过继承Thread类，并覆盖run()方法，这时就可以用该类的实例作为线程的目标对象。下面的程序定义了SimpleThread类，它继承了Thread类并覆盖了run()方法。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public class SimpleThread extends Thread{
  public SimpleThread(String str){
    super(str);
}
public void run(){
    for(int i=0; i<100; i++){="" system.out.println(getname()+"="+ i);
      try{
         sleep((int)(Math.random()*100));
      }catch(InterruptedException e){}
    } 
System.out.println(getName()+ " done");="" }="" <="" pre="">

<p> SimpleThread类继承了Thread类，并覆盖了run()方法，该方法就是线程体。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public class ThreadTest{
  public static void main(String args[]){
    Thread t1 = new SimpleThread("Runner A");
    Thread t2 = new SimpleThread("Runner B");
    t1.start();
t2.start(); 
    }
}
</pre>

<p>在ThreadTest类的main()方法中创建了两个SimpleThread类的线程对象并调用线程类的start()方法启动线程。构造线程时没有指定目标对象，所以线程启动后执行本类的run()方法。</p>
<p>注意，实际上ThreadTest程序中有三个线程同时运行。请试着将下段代码加到main()方法中，分析程序运行结果。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
for(int i=0; i<100; i++){="" system.out.println(thread.currentthread().getname()+"="+ i);
   try{
     Thread.sleep((int)(Math.random()*500));
   }catch(InterruptedException e){}
System.out.println(Thread.currentThread().getName()+ " done");="" }="" <="" pre="">

<p>从上述代码执行结果可以看到，在应用程序的main()方法启动时，JVM就创建一个主线程，在主线程中可以创建其他线程。再看下面的程序：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
public class MainThreadDemo{
  public static void main(String args[]){
    Thread t = Thread.currentThread();
    t.setName("MyThread");
    System.out.println(t);
    System.out.println(t.getName());
    System.out.println(t.getThreadGroup().getName());
  }
}
</pre>

<p>该程序输出结果为：<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
Thread[MyThread, 5, main]
MyThread
main
</pre>

<p>上述程序在main()方法中声明了一个Thread对象t，然后调用Thread类的静态方法currentThread()获得当前线程对象。然后重新设置该线程对象的名称，最后输出线程对象、线程组对象名和线程对象名。</p>
<h2 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2. 实现Runnable接口创建线程"></a>2. 实现Runnable接口创建线程</h2><p>可以定义一个类实现Runnable接口，然后将该类对象作为线程的目标对象。实现Runnable接口就是实现run()方法。下面程序通过实现Runnable接口构造线程体。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
class T1 implements Runnable{
  public void run(){
    for(int i=0;i<15;i++) system.out.println("runner="" a="+i);
  }
}
class T2 implements Runnable{
  public void run(){
    for(int j=0;j<15;j++)
      System.out.println(" runner="" b="+j);
  }
}
public class ThreadTest{
  public static void main(String args[]){
    Thread t1=new Thread(new T1()," thread="" a");="" t2="new" thread(new="" t2(),"thread="" b");="" t1.start();="" t2.start();="" }="" <="" pre="">

<p>下面是一个小应用程序，利用线程对象在其中显示当前时间。<br>&lt;?prettify?&gt;</p>
<pre class="prettyprint">
import java.awt.*;
import java.util.*;
import javax.swing.*;
import java.text.DateFormat;
public class ClockDemo extends JApplet{
  private Thread clockThread = null;
  private ClockPanel cp=new ClockPanel();
  public void init(){
      getContentPane().add(cp);
  } 
  public void start() {
 if (clockThread == null) {
        clockThread = new Thread(cp, "Clock");
    clockThread.start();
     }
}
  public void stop() {
     clockThread = null;
  }
}
class ClockPanel extends JPanel implements Runnable{
    public void paintComponent(Graphics g) {
super.paintComponent(g);
      Calendar cal = Calendar.getInstance();
    Date date = cal.getTime();
    DateFormat dateFormatter = DateFormat.getTimeInstance();
    g.setColor(Color.BLUE);
    g.setFont(new Font("TimesNewRoman",Font.BOLD,36));
    g.drawString(dateFormatter.format(date), 50, 50);
  }
    public void run() {
     while (true) {
       repaint();
       try {
          Thread.sleep(1000);
        } catch (InterruptedException e){ }
    }
}
}
</pre>

<p>该小应用程序的运行结果如图3所示：<br><img src="http://7u2np3.com1.z0.glb.clouddn.com/blog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-26%20%E4%B8%8B%E5%8D%887.10.58.png" alt=""></p>
</15;i++)></pre></100;></pre></100;></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Scott" />
          <p class="site-author-name" itemprop="name">Scott</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Scott</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Scott.disqus.com/count.js" async></script>
    

    

  




	





  





  








  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("iH9ug4Eu98bS8XiH30QEwODs-gzGzoHsz", "D0qgHUsqtcQOClhgS4ElkmDQ");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
