<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[怎样和领导谈话]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2017-08-17.html</url>
    <content type="text"><![CDATA[与领导相处，只要永远记住一句话：真理不是争来的。做一个好助手，就要学会经常批评自己，这样，你才能真正的成熟。 怎样和领导谈话 领导永远是对的； 领导最关心的几点作简短、快捷的汇报； 不要诉苦； 学会沉默，即使被误解，要学会以分析的眼光看待领导的批评，批评会使你更成熟，处理事情更有分寸，要尽量寻找自身的原因，以自己的缺点来迎合领导的批评，就会换得一颗平淡的心，会避免所有的争执，而且可以使领导跟你一样经常剖析自己，承认自己也可能弄错。 与领导相处，只要永远记住一句话：真理不是争来的。做一个好助手，就要学会经常批评自己，这样，你才能真正的成熟。谈话是加强沟通、联系上下级关系的一条重要纽带，因此，作为下级的你一定要重视和领导的谈话，把握住自己的分寸。具体地说，应注意以下几个细节： 不妨主动些，作为下属，可以积极主动地与领导交谈，渐渐地消除彼此间可能存在的隔阂，使上级下级关系相处得正常，融洽。当然，这与“巴结”领导不能相提并论，因为工作上的讨论及打招呼是不可能缺少的，这不但能祛除对领导的恐惧感，而且也能使自己的人际关系圆满，工作顺利。 在态度上，必须不卑不亢，对领导应当尊重，你应该承认，领导一般有强过你的地方，或者才干超群，或是经验丰富，所以，对领导要做到有礼貌，谦逊。但是，绝不要采取“低三下四”的态度。绝大多数有见识的领导，对那种一味奉承，随声附和的人，是不会予以重视的。在保持独立人格的前提下，你应采取不卑不亢的态度。在必要的场合，你也不必害怕表示自己的不同观点，只要你是从工作出发，摆事实，讲道理，领导一般是会予以考虑的。 选择适当的时机，领导一天到晚要考虑的问题很多，你应当根据自己的问题的重要与否，选择适当时机去反映。假如你是为个人琐事就不要在他正埋头处理事务时去打扰他。如果你不知道领导何时有空，不妨先给他写张纸条，写上问题的要求，然后请求与他交谈。或写上你要求面谈的时间，地点，请他先约定。这样，领导便可以安排时间了。 事先做好充分的准备，在谈话时，充分了解自己所要说的话的要点，简练，扼要，明确地向领导汇报。如果有些问题是需要请示的，自己心中应有两个以上的方案，而且能向上级分析各方案的利弊，这样有利领导做决断。为此，事先应当周密准备，弄清每个细节，随时可以回答，如果领导同意某一方案，你应尽快将其整理成文字再呈上，以免日后领导又改了主意，造成不必要的麻烦。要先替领导考虑提出问题的可行性。有些人明知客观上不存在解决问题的条件，却一定要去找领导，结果造成了不欢而散的结局。 向领导报告一定要有根有据，美国广告大王布鲁贝在他年轻时，他所在公司的经理问他：“印刷厂把纸送来没有？”他回答：“送过来了，共有5000令。”经理问：“你数了吗？”他说：“没有，是看到单上这样写的。”经理冷冷地说：“你不能在此工作了，本公司不能要一个连自己也不能替自己作证明的人来工作。”从此，布鲁贝克得出一个教训：对领导，不要说自己没有把握的事情。 和领导谈话的技巧卓越的说话技巧，譬如讨好重要人物、避免麻烦事落到自己身上、处理棘手的事务等等，不仅能让你的工作生涯加倍轻松，更能让你名利双收。牢记以下十个句型，并在适当时刻派上用场，加薪与升职必然离你不远。 上司传唤时责无旁贷句型：我马上处理。冷静、迅速的做出这样的回答，会今上司直觉的认为你是名有效率、听话的好部属；相反，犹豫不决的态度只会惹得责任本就繁重的上司不快。夜里睡不好的时候，还可能迁怒到你头上呢！ 表现出团队精神句型：安琪的主意真不错!安琪想出了一条连上司都赞赏的绝妙好计，你恨不得你的脑筋动得比人家快；与其拉长脸孔、暗自不爽，不如偷沾他的光。方法如下：趁著上司听得到的时刻说出本句型。在这个人人都想争著出头的社会里，一个不妒嫉同事的部属，会让上司觉得此人本性纯良、富有团队精神，因而另眼看待。 说服同事帮忙句型：这个报告没有你不行啦!。有件棘手的工作，你无法独力完成，非得找个人帮忙不可；于是你找上了那个对这方面工作最拿手的同事。怎麽开口才能让人家心甘情愿的助你一臂之力呢？送高帽、灌迷汤，并保证他日必定回报；而那位好心人为了不负自己在这方面的名声，通常会答应你的请求。不过，将来有功劳的时候别忘了记上人家一笔。 巧妙闪避你不知道的事句型：让我再认真的想一想，三点以前给您答覆好吗？上司问了你某个与业务有关的问题，而你不知该如何做答，千万不可以说「不知道」。本句型不仅暂时为你解危。也让上司认为你在这件事情上头很用心，一时之间竟不知该如何启齿。不过，事後可得做足功课，按时交出你的答覆。 智退句型：这种话好像不大适合在办公室讲喔!如果有男同事的黄腔令你无法忍受，这句话保证让他们闭嘴。男人有时候确实喜欢开黄腔，但你很难判断他们是无心还是有意，这句话可以令无心的人明白，适可而止。如果他还没有闭嘴的意思，即构成了骚扰，你可以向有关人士举发。 不著痕迹的减轻工作量句型：「我了解这件事根重要；我们能不能先查一查手头上的工作，把最重要的排出个优先顺序？」不如当下就推辞。首先，强调你明白这件任务的重要性，然后请求上司的指示，为新任务与原有工作排出优先顺序不著痕迹的让上司知道你的工作量其实很重，若非你不可的话，有些事就得延后处理或转交他人。 承认疏失但不引起上司不满句型：是我一时失察，不过幸好……放错在所难免，但是你陈述过失的方式，却能影响上司心目中对你的看法。勇于承认自己的疏失非常重要，因为推卸责任只会让你看起来就像个讨人厌、软弱无能、不堪重用的人，不过这不表示你就得因此对每个人道歉，诀窍在于别让所有的矛头都指到自己身上，坦承却淡化你的过失，转移众人的焦点。 面对批评要表现冷静句型：谢谢你告诉我，我会仔细考虑你的建议。自己苦心的成果却遭人修正或批评时，的确是一件令人苦恼的事。不需要将不满的情绪写在脸上，但是却应该让批评你工作成果的人知道，你已接收到他传递的信息。不卑不亢的表现才能表现你的风度 以最婉约的方式传递坏消息句型：我们似乎碰到一些状况…你刚刚才得知，一件非常重要的案子出了问题；如果立刻冲到上司的办公室里报告这个坏消息，就算不干你的事，也只会让上司质疑你处理危机的能力，弄不好还惹来一顿骂、把气出在你头上。此时，你应该以不带情绪起伏的声调，从容不迫的说出本句型，千万别慌慌张张，也别使用「问题」或「麻烦］这一类的字眼；要让上司觉得事情并非无法解决，而「我们」听起来像是你将与上司站在同一阵线，并肩作战。 恰如其分的讨好句型：我很想您对某件事情的看法……许多时候，你与高层要人共处一室，而你不得不说点话以避免冷清尴尬的局面。不过，这也是一个让你能够赢得高层青睐的绝佳时机。但说些什么好呢？每天的例行公事，绝不适合在这个时候被搬出来讲，谈天气嘛，又根本不会让高层对你留下印象。此时，最恰当的莫过一个跟公司前景有关，而又发人深省的话题。问一个大老板关心又熟知的问题，但他滔滔不绝的诉说心得的时候，你不仅获益良多，也会让他对你的求知上进之心刮目相看。 如何消除与领导谈话时的紧张为避免紧张，要淡化交谈的意义，把与领导的交谈视作与常人的交谈完全一样。要有这样的思想：万一谈不成，也没有什么大不了。在淡化交谈意义的同时，要相信自己有能力、有水平与领导对话，并必定能取得理想的效果。淡化后果，充满自信，紧张就不会缠绕你。 单刀直入承认怕：为避免紧张心理的加剧，在你走进办公室见到领导的那一刻，不妨先直截了当地承认：“见到您，我心里非常紧张!”见来者先说怕，许多领导往往会这样说：“怕什么?我是老虎啊?我又不吃人。”有的领导或许会想：难道我平时很严肃，很正经。如此一来，一些领导就会表现出格外的热情和随和，即使你一时仍然紧张，他们也会因你的坦诚而给以谅解。从另一方面来说，自己承认有点怕，并公开说了出来，等于放下了心理包袱，情绪就会慢慢地轻松起来。 事实通常是这样：你越不承认紧张，心理反而会越来越紧张。 随身带个小玩艺：心情紧张，这与你和领导的关系生疏有着很大的关系。交谈前，不妨随身带个自己熟悉的、常用的小玩艺，像旅行剪刀、打火机、钥匙串、小型计算器等，以备必要时玩玩，调剂心理。心理学家认为：怯懦或紧张时，摆弄摆弄自己熟悉的东西，可以起到缓解作用。因为这种东西经常和自己在一起，极熟了，会有一种亲切感和可靠的信赖感，无形中会给你一种胆量，还可以分散过于集中的思想，帮助你活跃思维，打开思路。另外，带个小玩艺，在交谈的空隙摆弄一下，还可避免冷场时无事可做而越发紧张的情况。当然，要掌握分寸，一旦紧张消除，小玩艺就要自然放好，不能长玩不息。 了解兴趣谈兴趣：在与领导交谈前，可先向熟人了解一下他的兴趣和爱好。如果领导喜欢下棋(或书法、或垂钓等)，那么，见面时，就先从这些他感兴趣的话题入手。了解兴趣谈兴趣的目的，是为了找到共同的语言，及时沟通感情和融洽气氛。涉及到感兴趣的话题，领导的话就会多起来，感情也会投入些，态度自然会亲切和平和。几句来去之后，你的心情也许就不会感到紧张了。要注意的是，在谈及感兴趣话题时，一定要实事求是，不要恭维和夸张，如领导的棋艺并不精，你却硬说很高很高，那反而会被他怀疑是吹捧而不予理睬，以致重新造成紧张的气氛。就地取材先闲聊，如领导没有什么特别的兴趣爱好，或者他的兴趣你自己不懂，谈不出内容，那么，不妨采用就地取材闲聊的办法。有交际经验的人总是这样：先说上几句闲话，待彼此有了一定的气氛后再进入正题。为使闲话自然得体，可就地取材。就地取材的内容是很多的：像办公室的陈设、墙上挂着的报纸杂志、近来的天气、领导的衣帽服饰等。如正遇上天气特别冷，就可以天气为材，如桌子上有一只新型的茶杯，可以先观赏一下杯子，然后就谈谈它的特点。先闲聊几句的意义主要在于： 一是可从中捕捉到领导当时的心情，以及时调整自己的话语；二是可以掩饰和缓解自己心情的紧张；三是可以为进入正题作过渡，起桥梁作用。 相信领导通人情：有些人不敢与领导交谈，主要是平时跟领导接触不多，不了解其性格，怕领导态度不好，怕领导不通人情。抱着这种心态去交谈，还会不紧张吗?因此，在交谈时，先要相信领导是通人情的，是不会动辄发脾气的。事实上，许多领导干部是喜欢与普通群众接触的，通人情、讲道理、态度好的领导是绝大多数。只要你反映的事、说的话是合情合理的，即使是为了个人，也用不着紧张。有些人怕与领导交谈是因为领导的威望高、名声大，这更是怕得没理。应该晓得，越是威望高名声大的领导，他们的态度和脾气就越好，就越是通人情。 相信自己能成功：有些人害怕与领导交谈，是由于后果考虑得过多过坏，生怕交谈不成，反而让人留下一个不好的印象，无端惹上一身麻烦。后果考虑过多过坏，心理压力就大了，紧张的心情也就难免。为避免紧张，要淡化交谈的意义，把与领导的交谈视作与常人的交谈完全一样。要有这样的思想：万一谈不成，也没有什么大不了。在淡化交谈意义的同时，要相信自己有能力、有水平与领导对话，并必定能取得理想的效果。淡化后果，充满自信，紧张就不会缠绕你了。 本文链接：http://www.sguotao.top/Android进阶-2017-08-17.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热修复与插件化]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2017-06-25.html</url>
    <content type="text"><![CDATA[class文件与dex文件class文件结构class文件结构特点: class文件是一种8位字节的二进制流文件； 各个数据按顺序紧密的排列，无间隙； 每个类和接口都单独占据一个class文件； dex文件结构虚拟机Java虚拟机虚拟机内存管理垃圾回收ClassLoader原理热修复热修复解决的问题: 刚发布的应用就有很严重的bug； 有一些小功能要及时的推送给用户使用； 热修复AndFix热修复Thinker引入热修复后代码及版本管理插件化插件化解决的问题: 解决应用越来越大所带来的各种技术限制； 解决应用越来越大带来的合作开发问题； 插件化Small插件化Atlas参考文献深入理解Java虚拟机 本文链接：http://www.sguotao.top/Android进阶-2017-06-25.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的异步消息处理机制]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2017-06-17-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[在Android中已经封装好，供我们直接使用的异步消息处理机制主要包括以下几种:Handler消息循环机制，AsyncTask，HandlerThread和IntentService。 HandlerHandler是Android中引入的一种处理线程中消息循环的机制。每个Hanlder都关联了一个线程，每个线程内部都维护了一个消息队列MessageQueue。在创建一个Handler的时候，该Handler就绑定了当前创建Hanlder的线程。Handler通过发送、处理Message和Runnable对象来关联相对应线程的MessageQueue。总结起来，Handler主要有以下两个作用: 可以让对应的Message和Runnable在未来的某个时间点进行相应处理； 自己想要处理的耗时操作放在子线程，让更新UI的操作放在主线程。 Handler的使用方法post(Runnable)先看一段代码: 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends Activity &#123; TextView tvContent; //创建mHandler在主线程，mHandler自动绑定主线程 private Handler mHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvContent = (TextView) this.findViewById(R.id.textView); new DownloadThread().start(); &#125; class DownloadThread extends Thread &#123; @Override public void run() &#123; try &#123; Log.i("scott", "Download Thread id:" + Thread.currentThread().getId()); Log.i("scott", "start download..."); //执行耗时操作 Thread.sleep(3000); Log.i("scott", "download completed..."); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; Log.i("scott", "Handler Thread id:" Thread.currentThread().getId()); MainActivity.this.tvContent.setText("Download complete!"); &#125; &#125;; mHandler.post(runnable); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 总结一下使用post(Runnable)的步骤: 创建Handler对象； 调用Handler的post（Runnable）方法； sendMessage(message）先看一段代码: 12345678910111213141516171819202122232425262728public class MainActivity extends Activity &#123; private static final int MSG_UPDATE_UI = 0; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case MSG_UPDATE_UI: tvContent.setText("Hello Scott!"); break; &#125; super.handleMessage(msg); &#125; &#125;; private TextView tvContent; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvContent = (TextView) this.findViewById(R.id.textView); Message message = mHandler.obtainMessage(); message.what = MSG_UPDATE_UI; message.obj = "Hello Scott!"; mHandler.sendMessage(message); &#125;&#125; 总结一下使用Handler发送消息处理消息的步骤: 创建Handler的对象，重写Handler的handleMessage()方法，根据Message的what来区分消息的种类； 创建Message对象，通过Message.obtain()或Handler.obtainMessage()来获得一个Message对象； 设置Message消息种类和消息内容，通过Message.what设置一个自定义的Message的识别码，以便于在Handler的handleMessage方法中根据what识别出不同的Message。消息内容可以通过Message的两个成员变量arg1和arg2来携带两个int数据，也可以通过Message的ob成员变量携带Object类型的数据。 通过Handler.sendMessage(Message)方法将Message传入Handler中让其在handleMessage中对其进行处理。 Handler的机制原理Handler消息循环机制中几个比较重要的类:Handler,Looper,Message,MessageQueue。类图关系如下:查看Handler的构造方法，在创建Handler时，如果没有显示指定Looper，会通过Looper的myLooper()方法获取Looper对象。 1234567891011public Handler(Callback callback, boolean async) &#123; …… mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 而Looper的myLooper()方法中获取的Looper对象在Looper的prepare()方法中创建。 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 到此完成了Handler与Looper的关联，再看一下MessageQueue，在Handler中的成员变量mQueue实际就是Looper中的mQueue，这一点可以在Handler的构造方法中看出。而Looper的mQueue和mThread在构造方法中完成了初始化操作。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 整个消息循环队列的处理机制，可以用下面一张图来表示:由于Handler的post(Runnable)底层实现也是通过sendMessage的方式实现的。 1234public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; 因此图中统一表述为Message的方式，首先Handler通过sendMessage()方法，将消息放入消息队列MessageQueue中，通过Looper的loop方法进行不断的轮训。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 通过MessageQueue的next()方法，不断取出队列中的Message，交给Handler的dispatchMessage()方法进行处理。 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; Handler引起的内存泄露问题以及解决办法引起内存泄露的原因是:非静态内部类持有外部类的匿名引用，导致外部类无法释放；常见的场景是在Handler的handleMessage()方法中持有了外部Actiivity的引用。 解决办法: 将Handler改为静态内部类，Handler内部持有外部Activity的弱引用; 在退出Ativity时，调用Handler的removeCallback()方法。 AsyncTaskAsyncTask本质上说是一个封装了线程池和Handler的异步框架。 AsyncTask的使用方法在使用AsyncTask时，要先了解AsyncTask的“三个参数和五个方法”。这三个参数是在创建AsyncTask时需要使用: 1234567/** * @Params 表示用于AsyncTask执行任务的参数的类型 * @Progress 表示在后台线程处理任务的进度。 * @Result 表示任务全部完成后所返回的数据类型。 */public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;&#125; 五个方法分别是: 123@MainThreadprotected void onPreExecute() &#123;&#125; onPreExecute()方法是运行在主线程。 12@WorkerThreadprotected abstract Result doInBackground(Params... params); doInBackground()方法运行在工作线程，主要用于执行一些耗时操作，该方法接受Params类型的参数。123@MainThreadprotected void onPostExecute(Result result) &#123;&#125; onPostExecute()方法运行在主线程，doInBackground()执行完成后，会将执行的结果作为参数传递给onPostExecute()方法，参数类型是Result。123@MainThreadprotected void onProgressUpdate(Progress... values) &#123;&#125; onProgressUpdate()方法运行在主线程，doInBackground()在执行过程中，会将任务执行的进度通过publishProgress()方法，传递到onProgressUpdate()方法，进度值的类型是Progress。1234@MainThreadprotected void onCancelled(Result result) &#123; onCancelled();&#125; onCancelled()方法运行在主线程。示例代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Created by scott on 17/6/17. */public class UpdateInfoTask extends AsyncTask&lt;Integer, Integer, String&gt; &#123; private TextView mTextView; private ProgressBar mProgressBar; public UpdateInfoTask(TextView textView, ProgressBar progressBar) &#123; super(); this.mTextView = textView; this.mProgressBar = progressBar; &#125; @Override protected void onPreExecute() &#123; if (null != mTextView) &#123; mTextView.setText("开始执行异步线程"); &#125; &#125; @Override protected String doInBackground(Integer... params) &#123; int i = 0; for (; i &lt; 100; i++) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; publishProgress(i); &#125; return i + params[0].intValue() + ""; &#125; @Override protected void onPostExecute(String s) &#123; if (null != mTextView) &#123; mTextView.setText("异步线程执行结束"); &#125; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; if (null != mProgressBar) &#123; mProgressBar.setProgress(values[0]); &#125; &#125;&#125; AsyncTask的机制原理 AsyncTask的本质上是一个静态的线程池，AsyncTask派生的子类可以实现不同的异步任务，这些任务都是提交到静态的线程池中执行； 线程池中的工作线程执行doInBackground(mParams)方法执行异步任务； 当任务状态改变之后，工作线程会向UI线程发送消息，AsyncTask内部的InternalHandler响应这些消息，并调用相关的回调函数。 AsyncTask的注意事项 内存泄露，与Handler类似，当AsyncTask的子类被声明成非静态内部类，当持有外部类的引用时，就有可能会出现内存泄露。 生命周期(AsyncTask并不会随着Activity的销毁而销毁)，在Activity退出时需要调用AsyncTask的cancel()方法。 结果丢失，主要与Activity的生命周期有关，如屏幕旋转或由于内存不足导致Activity被回收时，之前创建的AsyncTask会持有被销毁的Activity的引用，此时在AsyncTask的onPostExecute()更新界面可能不会生效。 并行or串行，在Android1.6之前AsyncTask是串行的，在Android1.6-Android2.3改为并行，在Android2.3之后，又改回串行。可以通过AsyncTask的executeOnExecutor()方法执行并行，虽然并行的效率较高，建议使用串行，保持线程池的稳定。 HandlerThread通常在Thread中使用Handler大致要经历以下三个过程: 12345678910111213141516class UpdateThread extends Thread&#123; public Looper threadLooper; public Handler threadHandler; @Override public void run() &#123; super.run(); //1.调用Looper.prepare 创建与当前线程绑定的Looper实例 threadLooper.prepare(); //2.使用上面创建的Looper生成Handler实例 threadHandler = new Handler(threadLooper.myLooper()); //3.调用Looper.loop()实现消息循环 threadLooper.loop(); &#125; &#125; 通常开启Thread子线程进行耗时操作，但是多次创建和销毁线程是很耗资源的。为了解决这样的问题，Android系统提供了HandlerThread。HandlerThread实际上是一个带有Looper的线程。 12345678910111213@Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; 查看HandlerThread的源码，会发现HandlerThread对以前在Thread中使用Handler的方式进行了封装,在获取Looper对象时使用了阻塞唤醒机制，保证了获取的Looper对象不会为null。 1234public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; 在创建HandlerThread时，可以设置线程的优先级，线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。 HandlerThread的特点 HandlerThread本质上是一个线程类，它继承了Thread； HandlerThread有自己的内部Looper对象，可以进行looper循环； 通过获取HandlerThread的Looper对象传递给Handler对象，可以在HandleMessage方法中执行异步任务。Handler内部的Looper默认绑定的是UI线程的Looper，通过设置HandlerThread的Looper，Handler就可以处理非UI线程的消息队列中的消息。 优点是不会有堵塞，减少了对性能的消耗，缺点是不能同时进行多任务的处理，需要等待进行处理，处理效率较低； 与线程池注重并发不同，HandlerThread是一个串行队列，HandlerThread背后只有一个线程。 HandlerThread示例代码: 123456789101112131415161718192021222324252627@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); UpdateThread updateThread = new UpdateThread("handler-thread"); updateThread.start(); mHandler = new Handler(updateThread.getLooper()); mHandler.post(new Runnable() &#123; @Override public void run() &#123; //耗时操作，不会阻塞主线程 try &#123; Thread.sleep(10 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; class UpdateThread extends HandlerThread &#123; public UpdateThread(String name) &#123; super(name); &#125; &#125; IntentServiceIntentService是继承并处理异步请求的一个类，它本质是就是封装了HandlerThread和Handler异步框架。在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方法和启动传统Service一样，同时，当任务执行完成后，IntentService会自动停止，而不需要我们手动去控制或stopSelf()。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个。总结一下: 它本质是一种特殊的Service，继承自Service并且本身就是一个抽象类； 它内部通过HandlerThread和Handler实现异步操作。 IntentService的使用方法创建IntentService时，只需实现onHandleIntent和构造方法，onHandleIntent为异步方法，可以执行耗时操作。参考示例代码: 1234567891011121314151617181920/** * Created by scott on 17/6/17. */public class DownloadImageIntentService extends IntentService &#123; public DownloadImageIntentService(String name) &#123; super(name); &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; //耗时操作 try &#123; Thread.sleep(10*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 参考文献HandlerAsyncTask 本文链接：http://www.sguotao.top/Android进阶-2017-06-17-分析Android中的异步消息处理机制.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Kotlin笔记】Kotlin的前世今生]]></title>
    <url>%2FKotlin-2017-06-09-Kotlin-note1.html</url>
    <content type="text"><![CDATA[三周前的Google IO大会上，官方宣布将Kotlin作为除Java、C++外的官方编程语言，在最新一期的TIOBE排行榜中，Kotlin就首次挤进编程语言TOP50。Kotlin是怎样的编程语言？Google为何将Kotlin作为官方的编程语言？Kotlin与其它语言(尤其是Java)相比，有哪些特点呢？带着这些问题，来了解Kotlin。 Kotlin是什么？ Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可以被编译成为JavaScript源代码。它主要是由俄罗斯圣彼得堡的JetBrains开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。[2]2012年1月，著名期刊《Dr. Dobb’s Journal》中Kotlin被认定为该月的最佳语言。[3]虽然与Java语法并不兼容，但Kotlin被设计成可以和Java代码相互运作，并可以重复使用如Java集合框架等的现有Java类库。 这是wikipedia给出的解释，总结一下: 起源自有背书的JetBrains开发团队； 一种基于JVM的静态类型编程语言。 为什么是Kotlin?为什么Google选择了Kotlin，除了一些与Oracle众所周知的原因外，更多的是Kotlin本身的一些特点： 开源，Apache许可证版本2.0下发布； 简洁，与Java相比，节约了大概40%的代码； 容易，如果会Java，很容易上手Kotlin； 安全，避免了空引用； 工具友好，由JetBrains开发，一家创造开发工具而闻名的公司； 互操作，与Java和Android 100%互操作； 与Java相比优势是什么？由于Android 应用使用了JVM，这意味着可以使用任何语言去编写app，只要能够编译成被JVM识别的字节码文件就可以了，同样编译字节码Kotlin与Java相比的优势： 更加易表现，这个重要的特点意味着可以少些很多代码，比如定义一个数据类，只需要进行如下定义，Kotlin会自动生成所有属性和他们的访问器，以及一些常用的方法。 123456data class Person( var id: Long, var name: String, var gender: Int, var address: String ) 更加安全，Kotlin是空安全的，即在编译期间处理了各种null的场景，避免了运行时异常。在Java开发中，需要通过判断是否为null来避免NullPointerException,在Kotlin中通过一个安全调用操作符(?)来明确地指定一个对象是否为空。 123var person:Person ?=null //person可以是nullperson.speak() //编译不过,person可能是nullperson?.speak() //person不为null,调用speak() 函数式，Kotlin是基于面向对象语言，使用了很多函数式编程的概念，主要是Lambda，Java8中也支持Lambda表达式。 可以扩展函数，可以扩展类的更多特性，甚至是一些没有权限访问类的代码；如给fragment添加一个显示toast的函数： 123fun Fragment.toast(message: CharSequence, duration:Int = Toast.LENGTH_LONG)&#123; Toast.makeText(getActivity(),message,duration).show()&#125; 高度互操作，可以使用所有用Java写的代码和第三方库，因为Kotlin和Java之间的相互操作是完美的，甚至可以在项目中进行混合编程。 一点感想Android程序员和其它程序员相比，甚至是其它职业相比，竞争力在本质上还是体现在解决问题的能力上。想要提升这种能力，核心还是建立在扎实的基础和对问题技术的准确认识程度上。编程语言本质上只是一种工具，一个顺手的工具能带来更高的效率，但是如何用好这个工具，将效率和质量提升到最高，还是依赖于开发者的能力。选用一个趁手的工具，夯实基础，加强对事物本质透彻的分析和认识，才是真正回归到提升竞争力的本质上来。 参考文献TIOBE 编程语言社区kotlin-koans 本文链接：http://www.sguotao.top/Kotlin-2017-06-09-Kotlin-note1.html]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Kotlin笔记】Hello Kotlin]]></title>
    <url>%2FKotlin-2017-06-10-Kotlin-note2.html</url>
    <content type="text"><![CDATA[在上一篇 Kotlin的前世今生 中介绍了Kotlin的一些特点，下面记录一下Kotlin开发环境的配置，并且完成“Hello Kotlin”的打印输出。 AndroidStudio由于AndroidStudio是基于Intllij Idead的插件实现，Intellij Idea也是JetBrains开发的，所有AndroidStudio就与Kotlin天生有一层紧密的联系，在AndroidStudio的预览版中已经将Kotlin作为了一个基础插件进行了集成，官方最新的2.3版本还暂时没有集成Kotlin插件，需要手动进行安装，安装的过程也非常的简单，具体路径Preferences–&gt;Plugin,选择Kotlin，安装，重启编译器。Eclipse编译器同样需要手动安装插件，从Intellij 15开始，Kotlin也默认是安装的。 Gradle使用gradle构建Kotlin项目时，需要添加kotlin的依赖，对不同的项目，gradle文件也有所不同。 Java项目123456789101112131415161718192021222324buildscript &#123; ext.kotlin_version = &apos;1.1.2&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; &#125;&#125;apply plugin: &apos;java&apos;apply plugin: &apos;kotlin&apos;sourceCompatibility = 1.7repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version&quot; testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; JavaScript项目JavaScript使用不同的插件1apply plugin: &quot;kotlin2js&quot; Android项目如果通过编译器新建Kotlin项目工程，Gradle文件是默认生成的，如果要手动修改，需要手动添加Kotlin的引用包。在工程的gradle文件中1234567891011buildscript &#123; ext.kotlin_version = &apos;1.1.0&apos; //使用的kotlin版本 repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; &#125;&#125; 创建一个变量来保存当前使用的kotlin的版本号，在每个module的gradle文件中，都会用到这个变量，当使用高版本的kotlin时，直接修改这个变量即可。 Hello Kotlin打开IntelliJ，新建project，选中Kotlin。输入GroupID（项目组织唯一的标识符，建议对应JAVA的包的结构）和 ArtifactID（项目的唯一的标识符，建议对应项目的名称），一路Next。新建的工程中，是没有src文件的，需要手动添加，新建directory，名称src/main/kotlin。新建一个package，创建HelloKotlin.kt。 添加一个main方法，输出“Hello Kotlin”。至此，完成了“Hello Kotlin”的输出。 本文链接：http://www.sguotao.top/Kotlin-2017-06-10-Kotlin-note2.html]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析HTTPS协议]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2017-06-04-%E5%88%86%E6%9E%90HTTPS%E5%8D%8F%E8%AE%AE.html</url>
    <content type="text"><![CDATA[Https 是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 Https并不是一个单独的协议，而是对工作在一加密连接（SSL/TLS）上的常规Http协议。通过在TCP和HTTP之间加入TLS（Transport Layer Security）来加密。Https实际就是在TCP层与Http层之间加入了SSL/TLS来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。 HTTPS和HTTP的区别超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS和HTTP的区别主要为以下几点： https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。由于HTTPS要进行加密处理，所有传输速度比HTTP慢。 SSL/TLS协议SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 SSL协议的作用 认证用户和服务器，确保数据发送到正确的客户机和服务器; 加密数据以防止数据中途被窃取; 维护数据的完整性，确保数据在传输过程中不被改变。 SSL协议的工作过程服务器认证阶段: 客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接； 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息； 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器； 服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段:在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。 TLS/SSL握手SSL 协议既用到了公钥加密技术又用到了对称加密技术，对称加密技术虽然比公钥加密技术的速度快，可是公钥加密技术提供了更好的身份认证技术。SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下： 1.客户端的浏览器向服务器传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。 2.服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。 3.客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行下一步。 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤2中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。 客户端向服务器端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知服务器客户端的握手过程结束。 4.服务器向客户端发出信息，指明后面的数据通讯将使用主密码为对称密钥，同时通知客户端服务器端的握手过程结束。 5.SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 Https加密算法相关密钥密钥是一种参数，它是在使用密码算法过程中输入的参数，同一个明文在相同的密码算法和不同的密钥计算下会产生不同的密文。 对称密钥又称共享密钥加密，对称密钥在加密和解密的过程中使用的密钥是相同的，常见的对称加密算法有DES、3DES、AES、RC5、RC6. 优点是计算速度快，缺点是密钥需要在通讯的两端共享。 非对称密钥又称为公开密钥加密。服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公钥可以自由发布，供任何人使用。 与对称密钥加密相比，非对称加密无需在客户端和服务端之间共享密钥，只要私钥不发给任何用户，即使公钥在网上被截获，也无法被解密，仅有被窃取的公钥是没有任何用处的。 RSA加密过程RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。 RSA加密过程: 服务端生成配对的公钥和私钥； 私钥保存在服务端，公钥发送给客户端； 客户端使用公钥加密明文传输给服务端； 服务端使用私钥解密密文得到明文； 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字。数字证书解决的问题，就是保证现在使用的公钥就是真实服务器发送给我们的。 数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的。 数字签名和CA数据在浏览器和服务器之间传输时，如何保证数据传输是真实服务器发送的而不是被掉包的？同时，如何保证传输的数据没有被人篡改？ 数字签名数字签名就是用于验证传输的内容是不是真实服务器发送的数据，发送的数据有没有被篡改过，是非对称加密的一种应用场景，不过他是反过来用私钥加密，通过与之配对的公钥来解密。 数字签名的过程: 服务端把报文经过Hash处理后生成摘要信息Digest，摘要信息使用私钥private-key加密之后就生成签名，服务器把签名连同报文一起发送给客户端。 客户端接收到数据后，把签名提取出来用公钥public-key解密，如果能正常的解密出来Digest2，那么就能确认是对方发送的。 客户端把报文Text提取出来做同样的Hash处理，得到的摘要信息Digest1，再与之前解密出来的Digest2对比。如果一致，则文本内容没有被修改过。 参考文献超文本传输安全协议数字证书 本文链接：http://www.sguotao.top/Android进阶-2017-06-04-分析HTTPS协议.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析HTTP协议]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2017-06-03-%E5%88%86%E6%9E%90HTTP%E5%8D%8F%E8%AE%AE.html</url>
    <content type="text"><![CDATA[所谓协议，是指指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。Http协议，超文本传输协议(Http)是一种通信协议，它允许将超文本标记语言（HTML）文档从web服务器传送到客户端的浏览器。 HTTP协议的最显著的两个特点: HTTP是构建于TCP/IP协议之上的协议，默认端口号是80。 HTTP是无连接无状态的协议。 HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 请求行（Request Line）请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。其中比较常用的请求方法是GET和POST。 GET最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送。以用google搜索domety为例，Request格式如下: 123456789101112GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */* Referer: &lt;a href="http://www.google.cn/"&gt;http://www.google.cn/&lt;/a&gt; Accept-Language: zh-cn Accept-Encoding: gzip, deflate User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld) Host: &lt;a href="http://www.google.cn"&gt;www.google.cn&lt;/a&gt; Connection: Keep-Alive Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r 可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&amp;”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。 POST对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面的搜索domety为例，如果使用POST方式的话，格式如下： 1234567891011121314POST /search HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */* Referer: &lt;a href="http://www.google.cn/"&gt;http://www.google.cn/&lt;/a&gt; Accept-Language: zh-cn Accept-Encoding: gzip, deflate User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld) Host: &lt;a href="http://www.google.cn"&gt;www.google.cn&lt;/a&gt; Connection: Keep-Alive Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r hl=zh-CN&amp;source=hp&amp;q=domety 可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。POST方式大多用于页面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用GET还是使用POST。 GET/POST方法的区别 提交的数据，get提交的数据会在url链接中，以”?”的形式进行分割，post提交数据都放在http请求的body中。 提交的数据大小是否有限制，get有限制，post没有限制。 取得变量的值Request.QueryString &amp; Request.Form 安全问题，get提交方式有安全隐患。 请求头（Header）请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有： User-Agent：产生请求的浏览器类型。Accept：客户端可识别的内容类型列表。Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 空行（Blank Line）最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 请求数据（Request-Body）请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。 HTTP响应报文HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：状态行、响应头(Response Header)和响应正文。状态行由协议版本、数字形式的状态码、及相应的状态描述，各元素之间以空格分隔。 常见的状态码有如下几种： 200 OK 客户端请求成功 301 Moved Permanently 请求永久重定向 302 Moved Temporarily 请求临时重定向 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 Http协议中容易混淆的知识点URI和URL的区别URI：Uniform Resource Identifier,统一资源标识符，用来唯一的标识一个资源。 URI的三个组成部分: 访问资源的命名机制； 存放资源的主机名； 资源自身的名称，由路径表示，着重强调资源。 URL:Uniform Resource Locator，统一资源定位器，它是一种具体的URI，即URL可以标识一个资源，而且还指明了如何locate这个资源。 URL的三个组成部分： 协议 存有该资源的主机IP地址 主机资源的具体地址； http1.1/http1.0的区别 http1.0产生的背景超文本传输协议（HyperText Transfer Protocol）伴随着计算机网络和浏览器的诞生，Http1.0也随之而来，处于计算机网络中的应用层。 http1.0所做的优化带宽:现阶段已经解决延迟： 1.浏览器阻塞：浏览器对于同一个域名，同时只能有4个连接； 2.DNS查询：浏览器需要知道目标服务器的IP才能建立连接 3.建立连接: 3次握手 http1.1/http1.0的具体区别 a. 缓存处理，Http1.1引入了更多的缓存策略； b. 带宽优化及网络连接的使用，Http1.1在请求头中添加了range，可以请求资源的某个部分。 c. Host头处理，Http1.1请求消息和响应消息都支持Host的改进，在请求中如果没有Host域会报400错误。 d. 长连接，Http1.1支持长连接，减少每次请求都需要建立和关闭连接的消耗。 http1.1和http1.0存在的问题 a. Http1.0在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间； b. Http1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份； c. Http1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本； d. 虽然Http1.1支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务器带来大量的性能压力。 cookie和session的区别Cookie技术是客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。 Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。 Session的工作原理： 创建Session 在创建了Session的同时，服务器会为该Session生成唯一的Session id； 在Session被创建后，就可以调用Session相关的方法在Session中增加内容； 当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session Session和Cookie的区别： 存放位置不同；Session保存在服务端，Cookie保存在客户端； 存取方式不同；Session能存取任意类型的数据，Cookie只能保存字符串； 安全性（隐私策略）不同 有效期上的不同 对服务器造成的压力不同 附录1 HTTP请求报文请求头Header字段说明 Header字段 说明 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: BasicQWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning 附录2 HTTP响应报文响应头ResponseHeader字段说明 Header字段 说明 示例 Accept-Ranges 表明服务器是否支持指定范围请求及哪种类型的分段请求 Accept-Ranges: bytes Age 从原始服务器到代理缓存形成的估算时间（以秒计，非负） Age: 12 Allow 对某网络资源的有效的请求行为，不允许则返回405 Allow: GET, HEAD Cache-Control 告诉所有的缓存机制是否可以缓存及哪种类型 Cache-Control: no-cache Content-Encoding web服务器支持的返回内容压缩编码类型。 Content-Encoding: gzip Content-Language 响应体的语言 Content-Language: en,zh Content-Length 响应体的长度 Content-Length: 348 Content-Location 请求资源可替代的备用的另一地址 Content-Location: /index.htm Content-MD5 返回资源的MD5校验值 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range 在整个返回体中本部分的字节位置 Content-Range: bytes 21010-47021/47022 Content-Type 返回内容的MIME类型 Content-Type: text/html; charset=utf-8 Date 原始服务器消息发出的时间 Date: Tue, 15 Nov 2010 08:12:31 GMT ETag 请求变量的实体标签的当前值 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 响应过期的日期和时间 Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified 请求资源的最后修改时间 Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Location: http://www.zcmhi.com/archives/94.html Pragma 包括实现特定的指令，它可应用到响应链上的任何接收方 Pragma: no-cache Proxy-Authenticate 它指出认证方案和可应用到代理的该URL上的参数 Proxy-Authenticate: Basic refresh 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） Refresh: 5; url=http://www.zcmhi.com/archives/94.html Retry-After 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 Retry-After: 120 Server web服务器软件名称 Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie 设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer 指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards Transfer-Encoding 文件传输编码 Transfer-Encoding:chunked Vary 告诉下游代理是使用缓存响应还是从原始服务器请求 Vary: * Via 告知代理客户端响应是通过哪里发送的 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 警告实体可能存在的问题 Warning: 199 Miscellaneous warning WWW-Authenticate 表明客户端请求实体应该使用的授权方案 WWW-Authenticate: Basic 附录3 HTTP响应报文状态码1xx:信息 table th:first-of-type { width: 150px; } 消息 状态 100 Continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 101 Switching Protocols 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 2xx:成功 消息 状态 200 OK 请求成功（其后是对GET和POST请求的应答文档。） 201 Created 请求被创建完成，同时新的资源被创建。 202 Accepted 供处理的请求已被接受，但是处理未完成。 203 Non-authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 204 No Content 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。 3xx:重定向 消息 状态 300 Multiple Choices 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 301 Moved Permanently 所请求的页面已经转移至新的url。 302 Found 所请求的页面已经临时转移至新的url。 303 See Other 所请求的页面可在别的url下被找到。 304 Not Modified 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取。 306 Unused 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 307 Temporary Redirect 被请求的页面已经临时移至新的url。 4xx:客户端错误 消息 状态 400 Bad Request 服务器未能理解请求。 401 Unauthorized 被请求的页面需要用户名和密码。 401.1 登录失败。 401.2 服务器配置导致登录失败。 401.3 由于 ACL 对资源的限制而未获得授权。 401.4 筛选器授权失败。 401.5 ISAPI/CGI 应用程序授权失败。 401.7 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。 402 Payment Required 此代码尚无法使用。 403 Forbidden 对被请求页面的访问被禁止。 403.1 执行访问被禁止。 403.2 读访问被禁止。 403.3 写访问被禁止。 403.4 要求 SSL。 403.5 要求 SSL 128。 403.6 IP 地址被拒绝。 403.7 要求客户端证书。 403.8 站点访问被拒绝。 403.9 用户数过多。 403.10 配置无效。 403.11 密码更改。 403.12 拒绝访问映射表。 403.13 客户端证书被吊销。 403.14 拒绝目录列表。 403.15 超出客户端访问许可。 403.16 客户端证书不受信任或无效。 403.17 客户端证书已过期或尚未生效。 403.18 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。 403.19 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。 403.20 Passport 登录失败。这个错误代码为 IIS 6.0 所专用。 404 Not Found 服务器无法找到被请求的页面。 404.0 （无）–没有找到文件或目录。 404.1 无法在所请求的端口上访问 Web 站点。 404.2 Web 服务扩展锁定策略阻止本请求。 404.3 MIME 映射策略阻止本请求。 405 Method Not Allowed 请求中指定的方法不被允许。 406 Not Acceptable 服务器生成的响应无法被客户端所接受。 407 Proxy Authentication Required 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 408 Request Timeout 请求超出了服务器的等待时间。 409 Conflict 由于冲突，请求无法被完成。 410 Gone 被请求的页面不可用。 411 Length Required “Content-Length” 未被定义。如果无此内容，服务器不会接受请求。 412 Precondition Failed 请求中的前提条件被服务器评估为失败。 413 Request Entity Too Large 由于所请求的实体的太大，服务器不会接受请求。 414 Request-url Too Long 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 415 Unsupported Media Type 由于媒介类型不被支持，服务器不会接受请求。 416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。 417 Expectation Failed 执行失败。 423 锁定的错误。 5xx:服务端错误 消息 状态 500 Internal Server Error 请求未完成。服务器遇到不可预知的情况。 500.12 应用程序正忙于在 Web 服务器上重新启动。 500.13 Web 服务器太忙。 500.15 不允许直接请求 Global.asa。 500.16 UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。 500.18 URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。 500.100 内部 ASP 错误。 501 Not Implemented 请求未完成。服务器不支持所请求的功能。 502 Bad Gateway 请求未完成。服务器从上游服务器收到一个无效的响应。 502.1 CGI 应用程序超时。 502.2 CGI 应用程序出错。 503 Service Unavailable 请求未完成。服务器临时过载或当机。 504 Gateway Timeout 网关超时。 505 HTTP Version Not Supported 服务器不支持请求中指明的HTTP协议版本。 参考文献HTTP请求报文和HTTP响应报文HTTP百科 本文链接：http://www.sguotao.top/Android进阶-2017-06-03-分析HTTP协议.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析TCP/IP参考模型]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2017-06-03-%E5%88%86%E6%9E%90TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[TCP/IP模型各个层次分别对应于不同的协议。TCP/IP协议栈是数据通信协议的集合 ，包含许多协议。其协议栈名字来源于其中最主要的两个协议TCP（传输控制协议）和IP（网际协议）。TCP/IP协议栈负责确保网络设备之间能够通信。它是一组规则，规定了信息如何在网络中传输。 物理层物理层功能: 规定介质类型、接口类型、信令类型； 规范在终端系统之间激活、维护和关闭物理链路的电气、机械、流程和功能等方面的要求； 规范电平、数据速率、最大传输距离和物理接头等特征。 物理层介质： 同轴电缆（coaxical cable） 双绞线（twisted pair） 光纤（fiber） 无线电波（wireless raido） 数据链路层数据链路层协议规定了数据链路层帧的封装方式。数据链路层又分为MAC子层和LLC子层: MAC子层负责指定数据如何通过物理线路进行传输，并向下与物理层通信，它定义了物理编址、网络拓扑、线路规范、错误通知、按序传递和流量控制等功能。 LLC子层负责识别协议类型并对数据进行封装以便通过网络进行传输。LLC子层主要执行数据链路层的大部分功能和网络层的部分功能。如帧的收发功能，在发送时，帧由发送的数据加上地址和CRC校验等构成，接收时将帧拆开，执行地址识别、CRC校验，并具有帧顺序控制、差错控制、流量控制等功能。此外，它还执行数据报、虚电路、多路复用等部分网络层的功能。 mac地址网络设备的MAC地址是全球唯一的。MAC地址由48个二进制位组成，通常我们用十六进制数字来表示。其中前6位十六进制数字由IEEE统一分配给设备制造商，后6位十六进制数字由厂商自行分配。 网络层由于以太网采用广播方式发送数据包，效率比较低，也无法区分哪些MAC地址属于同一子网，引入网络层后，能够区分哪些MAC地址属于同一个子网络，使得我们能够区分不同的计算机是否属于同一个子网络，并且在不同的网络之间转发数据包。 网络层常用协议: IP（Internet Protocol）IP为网络层最主要的协议，其功能即为网络层的主要功能，一是提供逻辑编址，二是提供路由功能，三是报文的封装和解封装。ICMP、ARP、RARP协议辅助IP工作。 ICMP（Internet Control Message Protocol）是一个管理协议并为IP提供信息服务，ICMP消息承载在IP报文中。 ARP（Address Resolution Protocol）实现IP地址到硬件地址的动态映射，即根据已知的IP地址获得相应的硬件地址。 RARP（Reverse Address Resolution Protocol）实现硬件地址到IP地址的动态映射，即根据已知的硬件地址获得相应的IP地址。 传输层当一个数据包从互联网上发来的时候，怎么确定是网页的内容，还是在线聊天的内容？传输层的功能，实现端口到端口的通信。 传输层主要功能： 分段上层数据； 建立端到端连接； 将数据从一端主机传送到另一端主机； 保证数据按序、可靠、正确传输。 传输层协议主要包含传输控制协议TCP（transfer control protocol）和用户数据报文协议UDP（user datagram protocol）: TCP提供面向连接的、可靠的字节流服务。面向连接意味着使用TCP协议作为传输层协议的两个应用之间在相互交换数据之前必须建立一个TCP连接。TCP通过确认、校验、重组等机制为上层应用提供可靠的传输服务。但是TCP连接的建立以及确认、校验等机制都需要耗费大量的工作并且会带来大量的开销。 UDP提供简单的、面向数据报的服务。UDP不保证可靠性，即不保证报文能够到达目的地。UDP适用于更关注传输效率的应用，如SNMP、Radius等，SNMP监控网络并断续发送告警等消息，如果每次发送少量信息都需要建立TCP连接，无疑会降低传输效率，所以诸如SNMP、Radius等更注重传输效率的应用程序都会选择UDP作为传输层协议。另外，UDP还适用于本身具备可靠性机制的应用层协议。 应用层应用层主要功能: 规定应用程序的数据格式。 为用户提供接口、处理特定的应用； 数据加密、解密、压缩、解压缩； 定义数据表示的标准。 应用层的协议包括: FTP(File TransferProtocol) 文件传输协议。用于传输独立的文件，通常用于交互式用户会话。 HTTP(HypertextTransfer Protocol)超文本传输协议。 用于传输那些构成万维网上的页面的文件。 TELNET ：远程终端访问。用于传送具有TELNET控制信息的数据。它提供了与终端设备或终端进程交互的标准方法，支持终端到终端的连接及进程到进程分布式计算的通信。 SMTP(Simple MessageTransfer Protocol)简单邮件传输协议 POP3(Post OfficeProtocol)邮局协议用于发送和接收邮件。 DNS(Domain NameServer)是一个域名服务的协议，提供域名到IP地址的转换，允许对域名资源进行分散管理。 TFTP(Trivial FileTransfer Protocol)简单文件传输协议。设计用于一般目的的、高吞吐量的文件传输。 RIP(RoutingInformation Protocol)路由器用来在 IP 网络上交换路由信息的协议。 SNMP(Simple NetworkManagement Protocol)用于收集网络管理信息，并在网络管理控制台和网络设备（例如路由器、网桥和服务器）之间交换网络管理信息。 Radius(RemoteAuthentication Dial In User Service)拨号接入远端认证协议完成接入用户的认证、授权、计费功能的协议。 TCP/IP模型层间数据封装与解析过程TCP/IP每一层都让数据得以通过网络进行传输，这些层之间使用PDU（协议数据单元）彼此交换信息，确保网络设备之间能够通信。数据封装的过程如图 传输层数据中加入TCP报头后得到PDU被称为segment（数据段）； 数据段被传递给网络层，网络层添加IP报头得到的PDU被称为packet（数据包）； 数据包被传递到数据链路层，封装数据链路层报头得到的PDU被称为frame（数据帧）； 帧被转换为比特，通过网络介质传输。 这种协议栈向下传递数据，并添加报头和报尾的过程称为封装，数据被封装并通过网络传输后，接收设备将删除添加的信息，并根据报头中的信息决定如何将数据沿协议栈上传给合适的应用程序，这个过程称为解封装。不同设备的对等层之间依靠封装和解封装来实现相互间的通信。数据解析的过程如图 TCP/IP模型建立连接与断开连接TCP/IP模型建立连接与断开连接过程如图 三次握手过程(建立连接) 请求端（通常也称为客户端）发送一个SYN段表示客户期望连接服务器端口，初始序列号为a。 服务器发回序列号为b的SYN段作为响应。同时设置确认序号为客户端的序列号加1（a+1）作为对客户端的SYN报文的确认。 客户端设置序列号为服务器端的序列号加1（b+1）作为对服务器端SYN报文段的确认。 四次挥手过程(断开连接) 请求端（通常也称为客户端）想终止连接则发送一个FIN段，序列号设置为a。 服务器回应一个确认序号为客户端的序列号加1（a+1）的ACK确认段，作为对客户端的FIN报文的确认。 服务器端向客户端发送一个FIN终止段（设置序列号为b，确认号为a+1）。 客户端返回一个确认报文（设置序列号为b+1）作为响应。 DNS所提供的服务是用来将主机名和域名转换为IP地址的工作。 DNS查询过程递归:DNS服务器可使用其自身的资源记录信息缓存来应答查询，也可以代表请求客户机来查询或联系其他DNS服务器，以完全解析该名称，并随后将应答返回至客户机。 迭代:客户机自己也可尝试联系其他的DNS服务器来解析名称。如果客户机这么做，它会使用基于服务器应答的独立和附加的查询。 在浏览器中输入域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系； 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器； 如果要查询的域名，不由本地DNS服务器区域解析，但该DNS服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析。 本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名（.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。 如果用的是转发模式，此DNS服务器就会把请求转至上一级DNS服务器，由上一级服务器进行解析。 参考文献1.TCP/IP协议栈及OSI参考模型详解2.TCP三次握手和四次挥手协议 本文链接：http://www.sguotao.top/Android进阶-2017-06-03-分析TCP-IP网络模型.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】程序员为什么会忧虑自己的未来?]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2017-06-02-%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BF%A7%E8%99%91%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%AA%E6%9D%A5.html</url>
    <content type="text"><![CDATA[所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。 文章作者:陈驰远，青橙科技CTO，互联网行业的一名老兵，以下是部分摘录。更多讨论，请戳原文。原文链接:https://juejin.im/post/5930acd6a0bb9f0058af41e5 从去年开始，我参加了一些分享交流，也对外发过一些自己对工作所遇问题的思考。不少程序员加我好友咨询问题，几乎每个人问的问题都跟职业规划有关。这提醒了我，其实我自己也一直在思考同样的问题并尝试规划未来。于是想和大家分享一下自己在这方面的感悟。 本文仅从我自己的角度来剖析对程序员职业规划的看法，并不全面。而下文中提到的程序员群体也泛指在一线具体执行编码任务的程序员，不包含一些高精尖技术岗位的专业技术人才或是已经有自己明确职业规划，已经进阶成功的工程师。 什么引发了焦虑？互联网是一个新兴但高速发展的行业。新兴意味着没有那么多的职场楷模给新人指明方向，也没有一套公认的稳定可复制的职业发展路线。高速发展意味着变革与竞争，大量新人因为行业红利涌入，你无时无刻要跟一群优秀的热血青年同场竞技。 互联网行业工作强度很大，而中国的互联网从业者更忙。程序员更是战场中的排头兵，身体健康的透支导致很难长期抗战。当你意识到自己跟不上节奏的时候，不管是出于对身体状况的担忧，还是对未来潜在威胁的恐惧，又怎会不感到焦虑呢？而程序员的职业特性加剧了这种焦虑，主要表现在以下几方面： 程序员职业复利性较低。什么叫复利性？就如同利息的计算方法一样，在本金相同的情况下，复利获得的利息回报要高于单利，而年期越长，复利效应越高。职业一样有复利效应，一个复利高的职业在职业生涯中后期会展现出越来越高的价值。医生、律师都是复利性很高的职业。而程序员职业复利性较低，主要有两个原因： 专业性强，通用性差。不同技术种类有着自己的技术栈，共用的只有设计思想、编程范式，基础技术等通用知识。 在没有明确规划的情况下，大多数程序员日常工作积累的不是通用知识与综合能力，而仅仅是某项技术的熟练度与经验。这是根本原因。 这造成了一个问题——当职业生涯遇到瓶颈时，程序员很难完成一次完美的进阶。让我们分析下最常见的三类方案： 技术职位之间的转岗。这是最普遍的一种情况，Android转IOS，后端转前端等都在此列。虽然设计原则、编程范式等技术知识是通用的，但作为一线的执行者，技术的熟练度才是影响你工作效率的最大因素，你必须对技术栈非常熟悉才能体现工作的专业度。 转岗往往是无奈之举。 技术转产品/运营岗。很多工程师抱怨产品经理设计的产品有问题，逻辑不严密，用起来很别扭。但让工程师做产品，问题一般会更多。为什么呢？最大的原因在于程序员的思维模式或多或少会受到编程的影响，偏向理性与具象化，缺少了感性的察言观色以及换位思考的能力。设计好一个产品，逻辑严密只是条件之一，但并不是最重要的条件。产品经理需要从用户的行为中挖掘出用户真正的需求，提炼归纳并设计成一个可用的产品。这是大多数程序员很难做好的事情。 技术转管理岗。BAT都有自己的M岗位，高工都可以选择是继续走技术路线还是尝试走管理路线。很多程序员安慰自己，哪天真写不动代码了，那我就做技术经理吧。但我认为管理岗的转变比前面两类都难。管理是一门很深的学问，执行和管理是两回事，需要从根本上改变思维模式。评判一个工程师的好坏可以看工程师的产出，而评判一个管理者的好坏在于整个团队的产出和效率。很多优秀的程序员自己技术能力很强，却很难带领整个团体一起向前进。 程序员职业的壁垒没想象中高，鲁棒性低。鲁棒性也指抗变换性，一个好的职业需要有高的鲁棒性。大部分程序员把自己的职业与某项技能绑定。做过编程的都知道，一个高耦合低抽象的编码鲁棒性一定低。互联网行业变化太快，回头看下诺基亚的发展，Windows桌面应用开发，整个行业如同大浪淘沙。随着云平台的崛起，公有化平台的发展，API服务的开放，可以预见从业者的工作效率会大幅提高，同时很多职业可能会再次洗牌：基础运维工程师，DBA，基础算法工程师，安全工程师，图像算法工程师，数据工程师等等都在此列。 从另外一个角度来说，假设你运气很好，选择了一项长期热门的技术比如Web前端开发。但是因为行业红利太高，无数聪明、努力、上进的热血青年涌入其中。随着社区的发展，在线教育的普及，达到同样熟练度的时间越来越短，而热门互联网技术的发展是以月计，你需要花费大量的时间去学习积累新技术。新人与你的差距会越来越小，你会随时面临被超车的局面。这意味着，很多时候即使你认为自己经验更丰富，能力更强，但你却得不到理想的职位及薪资待遇。 程序员职业能撬动的价值有限。这个概念受启发于《格鲁夫给经理人的第一课》一书。格鲁夫试图定量的分析经理人的产出，于是提出了一个公式：经理人的产出 = 他直接管辖部门的产出 + 他间接影响所及部门的产出。为了定量的分析职业的价值，我也引入了一个公式：产出的价值 = 他自身的产出 + 他直接影响部门的产出 + 他间接影响所及部门的产出 职业能影响的人越多，创造的价值越高，职业的上限价值也越高。 互联网行业的供求关系以及价值体系，造成了一个现象：程序员供不应求使其入行薪资高，但是工作五年以上薪资趋向于稳定。对于绝大部分公司的绝大部分职位，当熟练度和经验达到某一个阈值的时候，选择成本是趋同的，自身效率提高所能带动的价值提高已经很有限。正因为如此，从业者在享受了薪资高速增长之后，很难接受薪资增幅趋缓，职业生涯遇到瓶颈引发焦虑。 我的规划是什么？分析了这么多，我最想表达的意思是：所谓的稳定，是最大的谎言。在高速发展的行业，根本没有一个稳定的职业。解决焦虑的最终办法是重新定位自己的职业生涯，尽量不以所谓的熟练度和经验作为自己的竞争力，将自己的职业生涯押注在某项低门槛的技术上，而是根据自身的情况，持续不断提高综合竞争力，加强自己的不可替代性。 首先我会分析自己的特点，这是建立与他人的差异性和自己独特标签的关键所在，也是最值得加强的地方。我最大的特点是什么？有野心。我不想选择一种得过且过的生活，而会选择一个产出价值更高的事情来做，影响更多的人，创造更高的价值。会沟通。我沟通能力不错，既可以对外谈合作，又可以对内做管理。这会是我相对一般技术型程序员一个很大的不同。专业强。在专业技能层面我有较深的认识与理解，虽然谈不上顶尖，但我知道怎么运用自己的知识能力找到最适合现状的方法解决几乎所有日常问题。技术积累永远是我最核心的竞争力。 知道自己特点之后，我会以此为基础来增强自己的不可替代性。不可替代性不仅仅只是基于个人的能力，还有这几点是需要日常注意积累的：健康的身体。在经历过一次生病后，我更加意识到拥有一个健康的身体才是最重要的。积极健身可是我们青橙员工的必备素质。思想与格局的高度。思想的高度并不是一朝一夕就能拔高的，而是在经历了来自工作与生活的各种挑战之后，静下心来反思总结，从而慢慢积累并提升。人脉与影响力。乐于记录和分享自己的工作感悟。抓住向其他人学习的机会，比如参加一些会议或交流，不管是同行业还是其他行业的，都是很有必要的。人脉和影响力的积累与格局的高度也是相辅相成的，与某些方面比自己优秀的人交流往往会收获满满。当我有了明确的方向并且每天都能看到自己进步的时候，就会对未来充满憧憬。我给自己未来的定位是做一名解决者。何谓解决者？面对未知或已知的问题，知道如何分析本质原因，制定并实施解决方案。附加打油诗一首： 文能设计定需求，武可写码做架构。进做招商引融资，退做大V占风口。产品体验包上线，还要招人带节奏。 本文链接：http://www.sguotao.top/生活感悟-2017-06-02-程序员为什么会忧虑自己的未来.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【RN笔记】ReactNative Flex整理]]></title>
    <url>%2FReactNative-2017-05-17-rn-flex.html</url>
    <content type="text"><![CDATA[Flex容器属性 flex-direction 属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content 属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items 属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 Flex项目属性 order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 本文链接：http://www.sguotao.top/ReactNative-2017-05-17-rn-flex.html]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书笔记】人民的名义]]></title>
    <url>%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2017-05-04-%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89.html</url>
    <content type="text"><![CDATA[车窗外，严酷的冬季让广袤大地褪尽了五彩缤纷，裸露出素朴的本色，宛如卸妆后的母亲。北风凛冽，裹挟着原野上的残草败叶，不时地扑打着路面。然而冷峻的荒漠中，不也孕育着春天的希望吗？ 酣畅淋漓的读完了整本书，热播的电视剧也进入了收官，如何评价书中的人物？我想，不同的人，会因为个人经历的不同，看问题的角度不同，人生观、世界观和价值观不同，对同一个人物，会做出完全不同的评价。 摘自公众号：闲人笔潭 这部剧播出至今，不仅收视率火热，关于剧情、人物的讨论更是一浪高过一浪。而且有意思的地方在于，舆论的反转。 正义精明的检察官变成了何不食肉糜的既得利益者；祁同伟从一个腐败官员变成了一个“寒门难出贵子”的悲情人物；达康书记从一个有能力有抱负的政治家变成了伪君子。而与之相对应的，是孙连城、高育良、沙瑞金甚至陈岩石评价的反转。 公众话题的有趣之处就在于：面对同一个问题，不同人会因为个人经历的不同、三观的不同、立场的不同与角度的不同发表出截然不同的评价。 替祁同伟打抱不平，是因为祁同伟的悲情遭遇让诸多还在奋斗以及奋斗失败的人们心生共鸣。甚至不少人反对“阶级固化”更胜于反腐：腐败损失的是人民的经济利益，阶级固化是近乎堵死了寒门子弟上升的渠道与奋斗的动力。 觉得侯亮平夫妇、陆亦可他们“何不食肉糜”的，也再正常不过。这个世界确实是分层的，但在你心里，可以不分。可钟小艾一句“摆得正自己的位置”，不知让多少人感受到了这种分层，以及优越感。 觉得李达康横行霸道的，是因为谁都不愿意身边有个这样一个聪明、有能力却“不粘锅”的人，“先生如万年青草，可以傲霜雪而不可充栋梁”大家都知道这个人好，但都想离他远点。 而大家讨论着，甚至吵得面红耳赤，当真是为了这么几个角色么？其实大多都是在讲自己的价值观，寻求价值认同啊。 价值观源自于出身、经历、读书思考，是每个人自身的精神之源，这样的动力才让我们每一个人都在为自己深有感触的地方发声。我们理解某些悲剧的时候也在潜意识的担心这些悲剧会不会在自己身上上演，我们控诉某些不公的时候更加感触得到这些不公就在自己的生活中，讨论的是剧情，共鸣的是每个人的经历。所以窃以为，大家最关注的、最感同身受的问题，恐怕也是当下社会存在的最显著的问题。 没错，就是阶级固化。中国是一个伪装成世界的国家，沿海是高楼大厦的现代社会，西部是还在等待扶贫的山区；南部的商业意识已发展数十年，深入人心，东北的人情关系更世代未变，根深蒂固；北上广的孩子们在排歌剧话剧的时候河南河北的学生还在“只要学不死，就往死里学”的标语下挑灯夜读。虽然在同一片土地上，却是不同的世界。 阶级固化所给人带来的就是像祁同伟那样“品学兼优的学生会主席，主动参加缉毒，身中三枪的英雄也被权力任意支配”的恐惧与无力感；还有钟小艾的“只要再努力一下就好了”的“何不食肉糜”般的轻描淡写。但是更会有人认为贪腐了就是贪腐了，没有任何贪腐的理由。这种撕裂的观点可能就是大家不同的经历：有些人苦于成才无门，有些人则受难于贪官污吏，正是这些不同的角度才有了前些天对“达康书记”的赞誉与这些天对“祁厅长”遭遇的同情，以及对这部剧的各种评判。 祁同伟是一个可惜可叹的悲剧，其实剧中哪一位有血有肉的人物不是呢？农民出身一分钱不敢花的赵德汉、善于谋划学识渊博的教授书记高育良、爷爷闹革命出身能熟练背出《共产党宣言》的刘新建。他们都曾拼搏奋斗，也都有了一般人很难拥有的学识、能力，他们最终也都贪污腐化了。有个人的原因，也有制度的原因。 想起几年前的“民国热”，当时还在热心科普民国的种种“真相”，想让向往民国的朋友们知道那是一个路有冻死骨的乱世，可应者渺渺。后来才被一句话点醒：“除了年轻学生，谁会真想去民国，连个手机都没有，只不过都是对现实有些不满罢了。”就如同文艺复兴从来就不是想回到希腊。 评《人民的名义》也不是真的想过天下大同，每个人都是圣人。这些激烈争吵，只是希望我们的价值观能得到更多的认同，希望社会能往更好的一点发展。当人们“一切向钱看”，而没有了价值信仰和精神寄托时，社会的稳定与繁荣就很难持续。当收入不高和升迁无望的政府官员面对诱惑而没有抵抗力时，就很难指望可以一劳永逸地使干部队伍保持廉洁。当某地的政治平衡和权力格局需要借助外力才能打破时，该地政治生态系统的自我修复功能就值得警惕。讨论《人民的名义》时，大概讨论的，可能都是自己的人生吧。 本文链接：http://www.sguotao.top/读书笔记-2017-05-04-人民的名义.html]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人民的名义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的Property Animation]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-05-20-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Property-Animation.html</url>
    <content type="text"><![CDATA[Android的动画可以大体分为两类，分别是传统动画和Android3.0之后出现的属性动画(Property Animation)，关于传统动画的介绍在此前的两篇笔记中，进行了整理。Android动画分析一 View AnimationAndroid动画分析二 Drawable Animation在这一篇中，将对Android3.0之后出现的属性动画(Property Animation)进行整理。既然已经有了View Animation和Drawable Animation了，为什么还要引入Property Animation呢？ 1.使用动画场景的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么View动画就不能再帮我们忙了，也就是说View动画在功能和可扩展方面都有相当大的局限性。 2.Property Animation是改变对象的属性，不仅仅是对view本身做操作。传统的View动画只是改变view的显示效果，并不改变view的属性。郭霖介绍了一个比较形象的例子🌰，比如说，现在屏幕的左上角有一个按钮，然后我们通过View动画将它移动到了屏幕的右下角，点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过View动画将这个按钮绘制到了屏幕的右下角而已。属性动画的实现机制是通过对目标对象进行赋值并修改其属性来实现的，那么之前所说的按钮显示的问题也就不复存在了，如果我们通过属性动画来移动一个按钮，那么这个按钮就是真正的移动了，而不再是仅仅在另外一个位置绘制了而已。 Property AnimationProperty Animation是Android3.0(API11)之后引入的动画，属性动画的引入，极大的地丰富了Android的动画体系，与传统的View动画和Drawable动画还是存在一些差别，在使用的过程中需要留意： 1.传统动画的xml文件存放在res/anim/目录下，而属性动画的xml文件存放在res/animator/目录下，虽然animator有着anim的前缀，但这是两个完全不同的目录。由于存放目录的不同，因此在代码中引用的方式也会有所差别，传统动画可以通过R.anim.filename获得动画的引用，属性通过则通过R.animator.filename获得动画的引用。 2.属性动画常用的Java类与传统动画Java类很相似，比如属性动画集AnimatorSet和传统动画集AnimationSet，在使用时注意区别，可以简化记忆“后缀是mator的是属性动画，后缀是mation的是传统动画”。属性动画中，常用的类，可以简单的用下面的类图进行概括。属性动画也支持xml标签的使用方式，Android API提供了三种类型的标签，分别是&lt;animator&gt;、&lt;objectAnimator&gt;、&lt;set&gt;每个标签都有对应的Java实现类。 &lt;animator&gt;-ValueAnimator ValueAnimator是整个属性动画机制当中最核心的一个类，属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，通过Handler来完成动画的绘制以确保属性的变化发生在UI线程，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。 &lt;animator&gt;标签对应的Java实现类正是ValueAnimator类，&lt;animator&gt;包括以下属性： XML Attribute Description android:duration 动画从开始到结束持续的时长，单位为毫秒 android:startOffset 设置动画执行之前的等待时长，单位为毫秒 android:repeatCount 设置动画重复执行的次数，默认为0，不重复；可设为-1或infinite，表示无限重复 android:repeatMode 设置动画重复执行的模式，RESTART(默认值) 动画重复执行时从起点开始，REVERSE动画会反方向执行 android:interpolator 设置动画的插值器,若不设置，默认使用 AccelerateDecelerateInterpolator android:valueFrom 动画开始的值，可以为int值、float值或color值 android:valueTo 动画结束的值，可以为int值、float值或color值 android:valueType 动画值类型，floatType(默认值) 指定动画值，即以上两个value属性的值为浮点型,intType 指定动画值，即以上两个value属性的值为整型,若为color值，则无需设置该属性 同样的，属性动画也支持代码和资源文件两种创建方式。当使用资源文件时，需要通过AnimatorInflater中的loadAnimator()方法，将资源文件进行加载，得到Animator对象。123Animator animator = AnimatorInflater.loadAnimator(context, R.animator.anim_file); animator.setTarget(view); animator.start(); 资源文件定义方式1234567&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0&quot; android:valueType=&quot;floatType&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot;/&gt; 代码的实现方式12345ValueAnimator valueAnimator = ValueAnimator.ofFloat(1f, 0f);valueAnimator.setDuration(1000);valueAnimator.setRepeatCount(1);valueAnimator.setRepeatMode(ValueAnimator.REVERSE);valueAnimator.start(); &lt;objectAnimator&gt;-ObjectAnimator &lt;objectAnimator&gt;标签对应的Java实现类是ObjectAnimator，相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。ObjectAnimator是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。 由于ObjectAnimation继承ValueAnimator，所以&lt;objectAnimator&gt;除了&lt;animator&gt;的属性外，还包括自身特有的属性： XML Attribute Description android:propertyName 目标对象的属性名，要求目标对象必须提供该属性的setter方法，如果动画的时候没有初始值，还需要提供getter方法 xml资源文件创建方式1234567&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:valueTo=&quot;200&quot; android:valueType=&quot;floatType&quot; android:propertyName=&quot;y&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot;/&gt; 代码创建方式123ObjectAnimator.ofFloat(view,&quot;alpha&quot;,0f,1f) .setDuration(3000) .start(); ObjectAnimator提供了对View属性的设置，因为采用了反射的方式，所以要求View中要有该属性的setter和getter方法。当然，为了对View更方便的设置属性动画，Android系统也提供了View的一些属性和相应的setter和getter方法： XML Attribute Description alpha 透明度，默认为1，表示不透明，0表示完全透明 pivotX 和 pivotY 缩放动画固定点坐标 scaleX 和 scaleY 水平方向和垂直方向的缩放比例 rotation、rotationX 和 rotationY 基于固定点(pivotX,pivotY)做旋转,rotation是旋转度数,rotationX是水平旋转度数,rotationY是竖直旋转度数 translationX 和 translationY 水平方向移动距离和竖直方向移动距离 x 和 y View在父容器内左上角的坐标 通过对上面这些属性的操作，就可以完成传统View动画实现的效果。上面的示例代码中，实现了对一个属性的修改，如果对多个属性进行修改，该如何操纵呢？PropertyValuesHolder可以实现对一组属性或多组属性的持有，可以同时设置多个属性，通过ofPropertyValuesHolder()方法，设置到对应的动画view上，这样局完成了动画过程中，多个属性的修改。 1234PropertyValuesHolder pValue1 = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f, 1f);PropertyValuesHolder pValue2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 0f, 1f);PropertyValuesHolder pValue3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 0f, 1f);ObjectAnimator.ofPropertyValuesHolder(view, pValue1, pValue2, pValue3).setDuration(3000).start(); PropertyValuesHolder类提供了多个of开头的方法，以实现不同数据类型属性的设置，其中有一组方法：1234public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values)static PropertyValuesHolder ofKeyframes(String propertyName, Keyframes keyframes)static PropertyValuesHolder ofKeyframes(Property property, Keyframes keyframes) 在这组方法中，用到了Keyframe和Keyframes两个类，那么这两个类是做什么用的？Keyframe，关键帧，该类型对象由一个time/value对组成，定义了指定时间点的指定值。Keyframe是一个抽象类，在该类中定义了三个实现类ObjectKeyframe，IntKeyframe，FloatKeyframe用来保存Object、Int、Float类型的value。Keyframes是一个接口，KeyframeSet是它的实现类，KeyframeSet可以认为是关键帧Keyframe的辅助类，在KeyframeSet中维护着一个Keyframe类型的list。在API 23以后，可以在xml文件中使用PropertyValuesHolder。1234567&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot;&gt; &lt;propertyValuesHolder android:propertyName=&quot;x&quot; android:valueTo=&quot;400&quot;/&gt; &lt;propertyValuesHolder android:propertyName=&quot;y&quot; android:valueTo=&quot;200&quot;/&gt;&lt;/objectAnimator&gt; 在API16(Android4.1)中，新添加了TimeAnimator类，这个类它并不能直接实现动画效果，这个类有一个TimeListener接口，TimeListener会返回动画持续的时间，与上次调用的间隔时间。 &lt;set&gt;-AnimatorSet属性动画也可以实现多个动画的组合效果，对应AnimatorSet类。由于&lt;set&gt;实现动画组合的标签，所以它有一个设定动画顺序的属性: XML Attribute Description android:ordering 设置动画的时序关系，together(默认值) 动画同时执行，sequentially 动画按顺序执行 当使用组合动画时，既有同时执行，又有顺序执行时，可以通过&lt;set&gt;标签的嵌套来实现。在AnimatorSet内部中定义了一个Builder类，下面几个方法的返回类型都是该Builder类，这样我们在使用这几个方法设定多个动画播放顺序的时候，可以直接通过链式的方式，简化代码，这几个比较常用的方法：123456789101112131415161718192021222324252627/** * 将现有动画插入到传入的动画之后执行 * @param anim * @return */ public AnimatorSet.Builder after(Animator anim) /** * 将现有动画延迟指定毫秒后执行 * @param delay * @return */ public AnimatorSet.Builder after(long delay) /** * 将现有动画插入到传入的动画之前执行 * @param anim * @return */ public AnimatorSet.Builder before(Animator anim) /** * 将现有动画和传入的动画同时执行 * @param anim * @return */ public AnimatorSet.Builder with(Animator anim) Listener属性动画也提供了一下监听器Listener，实现对属性动画状态的监测，通过回调方法实现业务逻辑。在Animator类中定义了两个接口，分别是AnimatorListener和AnimatorPauseListener，使用时通过addListener()和addPauseListener()进行监听器的添加。 123456789101112131415161718192021valueAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; //动画开始时调用 &#125; @Override public void onAnimationEnd(Animator animation) &#123; //动画结束时调用 &#125; @Override public void onAnimationCancel(Animator animation) &#123; //动画被取消时调用 &#125; @Override public void onAnimationRepeat(Animator animation) &#123; //动画重复执行时调用 &#125; &#125;); 由于Animator是ValueAnimator的父类，ObjectAnimator又继承ValueAnimator，因此ValueAnimator和ObjectAnimator都可以对这两个监听器进行添加。注意的是AnimatorPauseListener需要API Level 19。1234567891011valueAnimator.addPauseListener(new Animator.AnimatorPauseListener() &#123; @Override public void onAnimationPause(Animator animation) &#123; //动画暂停时调用 &#125; @Override public void onAnimationResume(Animator animation) &#123; //动画恢复时调用 &#125; &#125;); 系统提供了AnimatorListenerAdapter抽象类实现了这两个接口，这样只需要重写需要的方法，而不必每个方法都重写了。在ValueAnimator中还添加接口AnimatorUpdateListener，可以实现对动画更新操作的监听。123456valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; // 动画更新时调用 &#125; &#125;); ViewPropertyAnimator 在API17(Android3.1)中引入，属性动画的机制已经不是再针对于View而进行设计的了，而是一种不断地对值进行操作的机制，它可以将值赋值到指定对象的指定属性上。但是，在绝大多数情况下，我相信大家主要都还是对View进行动画操作的。Android开发团队也是意识到了这一点，没有为View的动画操作提供一种更加便捷的用法确实是有点太不人性化了，于是在Android 3.1系统当中补充了ViewPropertyAnimator这个机制。 整个ViewPropertyAnimator的功能都是建立在View类新增的animate()方法之上的，这个方法会创建并返回一个ViewPropertyAnimator的实例，之后的调用的所有方法，设置的所有属性都是通过这个实例完成的。 大家注意到，在使用ViewPropertyAnimator时，我们自始至终没有调用过start()方法，这是因为新的接口中使用了隐式启动动画的功能，只要我们将动画定义完成之后，动画就会自动启动。并且这个机制对于组合动画也同样有效，只要我们不断地连缀新的方法，那么动画就不会立刻执行，等到所有在ViewPropertyAnimator上设置的方法都执行完毕后，动画就会自动启动。当然如果不想使用这一默认机制的话，我们也可以显式地调用start()方法来启动动画。 ViewPropertyAnimator的所有接口都是使用连缀的语法来设计的，每个方法的返回值都是它自身的实例，因此调用完一个方法之后可以直接连缀调用它的另一个方法，这样把所有的功能都串接起来，我们甚至可以仅通过一行代码就完成任意复杂度的动画功能。 TypeEvaluator(估值器) 简单来说，就是告诉动画系统如何从初始值过度到结束值。与Interpolator区别是，Interpolator主要是用来控制动画的播放速率。 在TypeEvaluator接口中定义了:1public T evaluate(float fraction, T startValue, T endValue); evaluate()方法当中传入了三个参数，第一个参数fraction用于表示动画的完成度，我们应该根据它来计算当前动画的值应该是多少，第二第三个参数分别表示动画的初始值和结束值。系统提供了7个实现类方便我们使用，分别是ArgbEvaluator、FloatArrayEvaluator、FloatEvaluator、IntArrayEvaluator、IntEvaluator、PointFEvaluator和RectEvaluator。 参考文献Property AnimationAndroid属性动画完全解析(上)，初识属性动画的基本用法Android属性动画完全解析(中)，ValueAnimator和ObjectAnimator的高级用法Android属性动画完全解析(下)，Interpolator和ViewPropertyAnimator的用法 本文链接：http://www.sguotao.top/Android进阶-2016-05-20-分析Android中的Property-Animation.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【RN笔记】ReactNative样式整理]]></title>
    <url>%2FReactNative-2017-04-25-rn-css.html</url>
    <content type="text"><![CDATA[ReactNative的样式是CSS样式的一个子集，并且属性名称与CSS中规定的也不完全相同。 引入样式的几种方法常见的引用样式的几种方法，包括内嵌方式，外联方式和混合方式，还可以把样式定义在单独的文件中，通过import引用。 1. 内嵌方式1234567891011121314151617export default class appProject extends Component &#123; render() &#123; return ( &lt;View style=&#123; &#123; marginTop:200, marginLeft:5, marginRight:5, height:84, flexDirection:&apos;row&apos;, backgroundColor:&apos;#FF0067&apos;, &#125; &#125;&gt; &lt;/View&gt; ) &#125;&#125; 2. 外联方式12345678910const Styles = StyleSheet.create(&#123; container: &#123; marginTop:200, marginLeft:5, marginRight:5, height:84, flexDirection:&apos;row&apos;, backgroundColor:&apos;#FF0067&apos;, &#125;&#125;); 3. 混合方式123456789export default class appProject extends Component &#123; render() &#123; return ( //外层容器 &lt;View style=&#123;[Styles.container,Styles.bg,&#123;color:&apos;red&apos;&#125;]&#125;&gt; &lt;/View&gt; ) &#125;&#125; 4.import引用1234567891011121314151617import React from &apos;react&apos;import &#123; StyleSheet,&#125; from &apos;react-native&apos;;const styles = StyleSheet.create(&#123; container: &#123; marginTop:200, marginLeft:5, marginRight:5, height:84, flexDirection:&apos;row&apos;, &#125;, bg:&#123; backgroundColor:&apos;#FF0067&apos;, &#125;&#125;);module.exports = styles; 通过import进行引入1import styles from &apos;./styles/style&apos;; 常见的属性及说明1.背景 属性名称 取值 对应css属性 backgroundColor color 对应 CSS 中的 background-color 属性 2.宽高尺寸 属性名称 取值 对应css属性 width number 对应 CSS 中的 width 属性 height number 对应 CSS 中的 height 属性 3.外边距相关(margin) 属性名称 取值 对应css属性 margin number 对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白 marginHorizontal number CSS中没有对应的属性，相当于同时设置marginRight和marginLeft marginVertical number CSS中没有对应的属性，相当于同时设置marginTop和marginBottom marginTop number 对应 CSS 中的 margin-top 属性 marginRight number 对应 CSS 中的 margin-right 属性 marginBottom number 对应 CSS 中的 margin-bottom 属性 marginLeft number 对应 CSS 中的 margin-left 属性 4.内边距相关(padding) 属性名称 取值 对应css属性 padding number 对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白 paddingHorizontal number CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft paddingVertical number CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom paddingTop number 对应 CSS 中的 padding-top 属性 paddingRight number 对应 CSS 中的 padding-right 属性 paddingBottom number 对应 CSS 中的 padding-bottom 属性 paddingLeft number 对应 CSS 中的 padding-left 属性 5.边框相关(border) 属性名称 取值 对应css属性 borderStyle solid, dotted, dashed 对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性 borderWidth number 对应 CSS 中的 border-width 属性 borderTopWidth number 对应 CSS 中的 border-top-width 属性 borderRightWidth number 对应 CSS 中的 border-right-width 属性 borderBottomWidth number 对应 CSS 中的 border-bottom-width 属性 borderLeftWidth number 对应 CSS 中的 border-left-width 属性 borderColor color 对应 CSS 中的 border-color 属性 borderTopColor color 对应 CSS 中的 border-top-color 属性 borderRightColor color 对应 CSS 中的 border-right-color 属性 borderBottomColor color 对应 CSS 中的 border-bottom-color 属性 borderLeftColor color 对应 CSS 中的 border-left-color 属性 borderRadius number 对应 CSS 中的 border-radius 属性 borderTopLeftRadius number 对应 CSS 中的 border-top-left-radius 属性 borderTopRightRadius number 对应 CSS 中的 border-top-right-radius 属性 borderBottomLeftRadius number 对应 CSS 中的 border-bottom-left-radius 属性 borderBottomRightRadius number 对应 CSS 中的 border-bottom-right-radius 属性 6.位置相关(position) 属性名称 取值 对应css属性 position absolute, relative 对应 CSS 中的 position 属性，但阉割了 static, fixed 取值 top number&gt; 对应 CSS 中的 top 属性 right number 对应 CSS 中的 right 属性 bottom number 对应 CSS 中的 bottom 属性 left number 对应 CSS 中的 left 属性 7.文本相关(Text) 属性名称 取值 对应css属性 color color 对应 CSS 中的 color 属性 fontFamily string 对应 CSS 中的 font-family 属性 fontSize number 对应 CSS 中的 font-size 属性 fontStyle normal, italic 对应 CSS 中的 font-style 属性，但阉割了 oblique 取值 fontWeight normal, bold 100~900 对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值 lineHeight number 对应 CSS 中的 line-height 属性 textAlign auto, left, right, center, justifyiOS 对应 CSS 中的 text-align 属性，增加了 auto 取值 textAlignVerticalAndroid auto, top, bottom, center 对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub 等值 textShadowColor color 对应 CSS 中的 text-shadow 属性中的颜色定义 textShadowOffset {width: number, height: number} 对应 CSS 中的 text-shadow 属性中的阴影偏移定义 textShadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 letterSpacingiOS number 对应 CSS 中的 letter-spacing 属性，但取值不同 textDecorationColoriOS color 对应 CSS 中的 text-decoration-color 属性 textDecorationLineiOS none, underline, line-through, underline line-through 对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值 textDecorationStyleiOS solid, double, dotted, dashed 对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值 writingDirectioniOS auto, ltr, rtl 对应 CSS 中的 direction 属性，增加了 auto 取值 8.弹性布局相关(Flex) 属性名称 取值 对应css属性 flex number 对应 CSS 中的 flex 属性 flexDirection row, column 对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值 flexWrap wrap, nowrap 对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值 justifyContent flex-start, flex-end, center, space-between, space-around 对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。 alignItems flex-start, flex-end, center, stretch 对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。 alignSelf auto, flex-start, flex-end, center, stretch 对应 CSS 中的 align-self 属性，但阉割了 baseline 取值 9.转换相关(transform) 属性名称 取值 对应css属性 transform [{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}] 对应 CSS 中的 transform 属性 transformMatrix TransformMatrixPropType 类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数 backfaceVisibility visible, hidden 对应 CSS 中的 backface-visibility 属性 10.图片相关 属性名称 取值 对应css属性 resizeMode cover, contain, stretch contain是指无论如何图片都包含在指定区域内，假设设置的宽度高度比图片大，则图片居中显示，否则，图片等比缩小显示 overflow visible, hidden 超出部分是否显示，hidden为隐藏 tintColor number 着色，rgb字符串类型 opacity number 透明度 11.图像变换 属性名称 取值 对应css属性 rotation – 旋转 scaleX – 水平方向缩放 scaleY – 垂直方向缩放 translateX – 水平方向平移 translateY – 水平方向平移 本文链接：http://www.sguotao.top/ReactNative-2017-04-25-rn-css.html]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的内存泄露]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2017-03-24-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html</url>
    <content type="text"><![CDATA[内存泄露与内存溢出内存泄露内存泄露(Memory Leak)是指无用对象（不再使用的对象）持续占有内存，或者无用对象的内存得不到及时释放，从而造成内存空间得不到有效的利用。在Java中，内存泄露的原因，通常是长生命周期的对象，持有短生命周期对象的引用。在《深入理解Java虚拟机》中的解释是，当无用对象一直被有用对象引用，导致无用对象可达，JVM无法对无用对象完成回收。从而造成内存泄露。 内存溢出内存溢出(Out of Memory)是指程序在运行过程中，无法申请到足够的的内存导致的一种错误。内存泄露是会导致内存溢出，但不是导致内存溢出的唯一原因。 Java中的内存泄露Java 内存分配Java中的内存分配主要分三块，静态存储区，栈区和堆区。 静态存储区，编译时分配，存在于程序的整个运行期间，主要用于存放静态数据和常量。 栈区，在方法执行时，用于存放方法内部的局部变量，方法结束后，内存释放。 堆区，通常用来存放new出来的对象，由JVM进行回收处理。 四种引用类型从JDK1.2开始，Java将对象的引用分为了强引用、软引用、弱引用和虚引用。 强引用(Strong Reference),平时使用最多的一种引用，如果一个对象的引用方式是强引用，垃圾回收器不会对该对象进行回收，即使出现了内存空间不足的情况，JVM会抛出Out of Memory,也不会对强引用的对象进行回收。 软引用(Soft Reference),在对象的引用强度上若于强引用，对于弱引用的对象，当内存不足时，JVM会回收软引用对象，释放内存空间。通常情况下，缓存的创建，适合使用软引用的方式。 弱引用(Weak Reference),在对象的引用强度上，弱于软引用，相对于强引用对象的不可回收，弱引用的对象，不存在这种情况，在垃圾回收器工作时，不论内存空间是否充足，都会对弱引用的对象进行回收。弱引用的作用，主要在于解决强引用对象之前的耦合关系，如在集合类中，任何Java对象都可以作为键来使用，当一个键值对被放入到集合中，集合对象本身就对这些键和值产生引用，如果是强引用，只要集合对象本身存在，其中包含的键和值就不会被回收，当集合包含的键和值越来越多时，最后会消耗掉JVM中的全部内存。 虚引用(Phantom Reference)，使用的情况并不多见，主要用来实现比较清晰的内存控制，这对于内存有限的移动设备是很有意义的。虚引用用来跟踪对象被垃圾回收器回收的活动，虚引用和软引用，弱引用的一个明显的区别是，虚引用必须和引用队列联合使用，通过检查引用队列中的内容，可以判断一个对象是否即将被回收。 一个对象的引用类型有多个，怎么判断？判定规则如下： 单条引用链上的可达性，以最弱的一个引用类型来决定； 多条引用链上的可达性，以最强的一个引用类型来决定； 我们假设上图中，1和3为强引用，5为软引用，7为弱引用。对于对象5的引用类型，在路径1–5中，5为软引用类型，依据规则1，对象5为软引用类型。在路径3–7中，7为弱引用类型，所以对象5为弱引用类型。依据规则2，多条引用链上的可达性，以最强的一个引用类型决定，因此，对象5的引用类型为软引用类型。 内存泄露检测工具MonitorsMemory Monitors是AndroidStudio自带的一个性能检测工具，主要包含以下几个功能： 实时查看app的内存使用情况； 能够比较直观的了解到app的运行卡顿是否跟GC的频繁操作有关； 能够了解到app的crash是否跟内存溢出有关； 能够发现内存抖动(在短时间内分配大量内存，频繁的引起GC操作) DDMS Dump什么是Java Heap Dump？首先需要搞明白什么是Java Heap，Java Heap是分配给实例类和数组对象运行数据区，所有Java线程在运行期间共享heap中的数据，Java Heap Dump相当于在应用运行时，某个时间点进行一次快照，在AndroidStudio中，快照会被保存为.hprof类型的文件，保存在captures目录中。 分析.hprof文件，我们可以将.hprof视图分成A、B、C三个部分，在A部分中，可以看到app的整个堆内存信息，显示了在堆内存中的所有的java类。 名称 含义 Total Count 内存中，当前Java类的实例数量 Heap Count 堆内存中，当前Java类的实例数量 Size of 当前Java类每个实例对象需要占用内存的物理大小 Shallow Size 当前Java实例对象占有的内存大小 Retained Size 释放当前Java实例对象后，节省的内存大小 当选中A区域中的某个Java类，可以在B区域中看到选中Java类的所有实例对象。 名称 含义 Depth 当前对象的深度 Shallow Size 当前对象占有的内存大小 Dominating Size 当前对象可支配的内存大小 在B中看到选中Java类的所有实例对象的同时，在C区域能够看到哪些对象引用了该对象。 什么是Allocation Tracker？Allocation Tracker主要用来追踪内存分配信息，Start Allocation Tracking 相当于在程序运行时，某个时间节点，对内存分配信息进行一次快照，生成的快照文件被保存为.alloc类型，保存在captures目录中。Allocation Tracker 也可以在Devices Monitor中启动，在Devices Monitor中使用时，需要设备有Root权限。 MATMAT(Eclipse Memory Analyzer)是一个堆转储文件分析工具，在Monitor的快照文件(.hprof)，需要转换成MAT可以打开的标准.hprof文件，使用Mat工具打开转换后的.hprof文件，会生成一个内存消耗整体状况的报告，从饼状图中，可以比较直观地看到哪些对象占用了多少的内存空间。这里介绍一下，MAT给我们提供的几个分析的维度。 Histogram，在该视图中可以清晰的看出内存中对象的数量，及所占用内存空间的大小。 Dominator Tree:在该视图中，可以在线程的角度观察到哪些对象占用内存空间。 Top Consumers:从包，对象等角度，显示内存的占用情况，能够比较直观的找出占用内存比较多的对象。 Leak Suspects:分析内存泄露的情况，生成一份报表，给出一些problem的建议。 下面介绍一些常用的操作，视图中支持正则表达式筛选，可以过滤出我们比较关心的对象，可以以列表或者树形的结构显示出来，其中： with incoming references:过滤出那些类引用了当前选中的类； with outcoming references:过滤出当前选中类引用了哪些类； 垃圾回收器会对虚拟机的内存空间，即堆空间中已经存在的对象进行识别，如果对象正在被引用，那么称其为存活对象，如果对象不在被引用，则为垃圾回收器回收的对象，这部分对象占用的内存空间可以被回收。 在垃圾回收机制中有一组元素被称为根元素集合，它们是一组被虚拟机直接引用的对象。堆空间中的每个对象都是由一个根元素为起点被层层调用的。所以，一个对象如果被一个存活的根元素所引用，就会被认为是存活对象，不能被回收。这时，可以通过分析一个对象到根元素的引用路径来分析该对象为什么不能够被顺利回收。 当选中某个对象，通过Merge Shortest Paths to GC Root的操作，可以显示对象之间的排除了软引用，弱引用和虚引用的引用关系，这样我们看到的就是被选中对象是否还存在强引用，通过分析 ，能够直接找到内存没有释放的原因。 开发中常见内存泄露的场景1.Context对象使用不当；在Android中经常使用的单例模式，如果使用不当，会出现内存泄露，泄露的主要原因是因为，单例模式中的静态成员变量的生命周期与应用的生命周期一样长。比较常见的场景是，经常在一些工具类中使用单例模式，如xxManager,xxHelper，xxUtils,这些工具类中需要使用Context,由于Activity是间接继承Context，当Activity退出时，单例对象中持有了它的引用，导致Activity回收失败，从而出现内存泄露。处理方式是使用Application,由于Application的生命周期贯穿整个应用，所以当这些工具类需要使用到Context时，使用getApplication()或者getApplicationContext()。 12345678910111213141516 public class Util &#123; private Context mContext; private static Util sInstance; private Util(Context context) &#123; this.mContext = context; &#125; public static Util getInstance(Context context) &#123; if (sInstance == null) &#123;// sInstance = new Util(context); sInstance = new Util(context.getApplicationContext()); &#125; return sInstance; &#125; &#125; 2.内部类使用不当当使用非静态的内部类时，如果出现内部类持有外部类的引用，就会出现内存泄露，优化方法，可以使用静态的内部类，这样内部类就不在持有外部类的引用，不会影响GC对于外部类的回收。 123456789101112131415161718192021public class MyActivity extends AppCompatActivity &#123; /** * 静态成员变量 */ public static InnerClass innerClass = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my); innerClass = new InnerClass(); &#125; class InnerClass &#123; public void doSomeThing() &#123; &#125; &#125;&#125; 3.Handler的异步消息通信在使用Handler时出现内存泄露的主要原因是Handler的生命周期与Activity的生命周期不一致，当应用启动时，创建UI主线程Looper对象，Looper实现了简单的消息队列，主线程Looper对象存在整个应用的生命周期中。 123456789101112131415161718public class HandlerActivity extends Activity &#123; private final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // ... &#125; &#125;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandler.sendMessageDelayed(Message.obtain(), 10*000); finish(); &#125;&#125; 当在Actiivity中使用Handler时，就可能会产生内存泄露，究其根本原因，是我们使用的非静态内部类(或者匿名内部类)默认隐性持有外部类的引用，静态内部类不会持有外部类的引用。在Activity结束时，由于Message是延迟消息，会在主线程的消息队列中，该消息持有Activity中的Handler的引用，Handler默认持有Activity的引用，直至该消息被处理完。此时导致Activity对象无法被回收，就会出现内存泄露。优化方法，可以使用静态内部类继承Handler对象，或者在Activity的onDestory()方法中，调用mHandler.removeCallbacksAndMessages(null); 4.Bitmap使用不当使用Bitmap如果回收不及时，也会出现内存泄露。原因在于Bitmap类没有对外创建对象的构造方法，获得Bitmap对象只能通过BitmapFactory中的各种静态方法，生成Bitmap对象是通过JNI调用底层c来实现的。所以，当我们获取一个Bitmap对象时，其对应的内存中包含两部分内容，一部分是Java，一部分是c,Java部分的内存可以通过GC进行回收，但是c部分的内存GC是不会进行自动回收的，所以，我们在使用Bitmap对象时，需要调用recycle()来主动释放c部分的内存。 123456// 判断是否已经回收if(bitmap != null &amp;&amp; !bitmap.isRecycled())&#123; // 回收并且置为null bitmap.recycle(); bitmap = null; &#125; 5.资源性对象没有及时关闭当我们使用一些资源性对象时，如果没有做关闭操作，也会出现内存泄露，常见的资源性对象包括(Cursor、ContentProvider、File、Stream)等。还有一类如EventBus、BroadCastReceiver在注册后，为了避免重复注册，需要在退出时及时的销毁。 6.集合列表相关集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。 7.Native中存在内存泄露由于Native层的代码多用c或c++来实现，GC无法对这部分内存进行会后处理，这时可能会出现内存泄露，这时候就需要c工程师帮助分析，如Malloc的内存是否做了free处理，指针使用完成后，是否进行了置空处理等等。 参考文章 科普：内存泄漏与内存溢出 Java的内存泄漏 Android 内存泄露总结 Java四种引用类型 MAT使用教程 本文链接：http://www.sguotao.top/Android进阶-2017-03-24-分析Android中的内存泄露.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存泄露</tag>
        <tag>MAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的动态加载机制]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2017-03-17-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[Java的类加载机制ClassLoader我们编写的java代码，最终会编译成.class字节码的形式，一个完整的Java程序，通常会由若干个.class文件组成，在程序运行时，通过该程序的入口函数来调用系统的各个功能，但是程序启动时，并不会一次性将.class文件加载到内存中，根据程序的需要，通过Java的类加载机制来动态加载.class文件，ClassLoader就是来实现.class文件的动态加载的。 Java中各类加载器的关系Java默认会提供三个类加载器，分别为BootStrapClassLoader,ExtClassLoader和AppClassLoader; BootStrapLoader，启动类加载器，是Java类加载层次中最顶层的类加载器，由c代码编写，负责加载JDK中的核心类库（包括JRE classes目录下的.class文件，libs目录下的jar文件）。可以使用System.getProperty(“sun.boot.class.path”)来显示BootStrapLoader加载的jar和.class文件； ExtClassLoader,扩展类加载器，负责加载Java的扩展类库，默认加载/jre/lib/ext目录下的所有jar和.class文件。可以通过可以使用System.getProperty(“java.ext.dirs”)来显示ExtClassLoader加载的jar和.class文件； AppClassLoader,系统类加载器，负责加载classpath目录下所有的jar和class文件。 Java类加载的实现过程 执行程序代码，找到JRE所在目录； 找到jvm.dll(Windows)或者libjvm.so(Linux); 启动JVM，并进行初始化工作 创建BootStrapClassLoader; BootStrapClassLoader会加载ExtClassLoader，并设定ExtClassLoader的parent为BootStrapClassLoader; BootStrapClassLoader会加载AppClassLoader,并设定AppClassLoader的parent为ExtClassLoader; 当AppClassLoader开始加载xxx.class时，类加载器会现将加载的任务交给其parent来完成，如果parent找不到，则自己负责加载。所以在加载xxx.class时的顺序是，BootstrapClassLoader –&gt; ExtClassLoader –&gt; AppClassLoader，如果都找不到，则抛出ClassNotFoundException。这就是非常有名的双亲委托模型。 使用双亲委托模型，有效地解决了.class字节码重复加载的问题，当parent已经加载类某各类的.class字节码时，子类就没有必要再重新进行加载。举个例子，来说明一下双亲委托模型。 123456789// 取得SomeClass的Class实例 Class c = Class.forName(&quot;SomeClass&quot;); // 取得ClassLoader ClassLoader loader = c.getClassLoader(); System.out.println(loader); // 取得父ClassLoader System.out.println(loader.getParent()); // 再取得父ClassLoader System.out.println(loader.getParent().getParent()); 运行结果： 123sun.misc.Launcher\$AppClassLoader@19821fsun.misc.Launcher\$ExtClassLoader@addbf1null 由于SomeClass是自定义的一个Java类，通常会java.class.path中产生字节码，首先AppClassLoader会将加载的任务交给其parent,ExtClassLaoder,ExtClassLoader将加载任务交给其parent，BootStrapClassLoader,由于BootStrapLoader在其目录(sun.boot.class.path)下没有找到该类的字节码，所以由ExtClassLoader来加载，ExtClassLoader在其目录(java.ext.dirs)也没有发现SomeClass的字节码，交给AppClassLoader进行加载，AppClassLoader在(java.class.path)中找到，并进行加载。 加载SomeClass的ClassLoader是AppClassLoader,其parent是ExtClassLoader,而ExtClassLoader的parent是null，这是因为BootStrapClassLoader是由c代码编写的，在JVM中并没有对应的实例对象，所以显示为null。 Dalvik与JVM在Java中，把一些Java类编译成.class文件，通过ClassLoader进行加载，但是在Android上边，情况有所不同，主要的原因在于Android中使用的虚拟机是Dalvik。Android中的Dalvik和Java中的JVM都是将对应的Java类加载到内存中运行。不同的是JVM加载的是.class字节码文件，或是通过defineClass方式产生class，进行加载。Dalvik加载的是.dex文件，.dex文件是Android对.class文件进行了优化，更加适合内存和处理器有限的系统。 Dalvik是基于寄存器的，而JVM是基于栈的。 Dalvik运行dex文件，而JVM运行java字节码 自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。 很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。2014年6月25日,Android L 正式亮相于召开的谷歌I/O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。ART,即Android Runtime。ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time,JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time)。这样的话，应用的启动(首次)和执行都会变得更加快速。 DexClassLoader与PathClassLoader在使用Java虚拟机时，我们经常自定义继承自ClassLoader的类加载器。然后通过defineClass方法来从一个二进制流中加载Class。而在Android中我们无法这么使用，Android中ClassLoader的defineClass方法具体是调用VMClassLoader的defineClass本地静态方法。而这个本地方法什么都没做，只是抛出了一个“UnsupportedOperationException”异常。 12345protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError &#123; throw new UnsupportedOperationException("can't load this type of class file"); &#125; 既然在Dalvik虚拟机里，ClassLoader不好用，那么Android官方为了解决这个问题，帮我们从ClassLoader中派生出了两个类：DexClassLoader和PathClassLoader。先来看一下DexClassLoader和PahtClassLoader的继承关系。 DexClassLoaderDexClassLoader可以加载jar,apk,dex,可以从SD卡进行加载，可以实现dex的动态加载与更新，DexClassLoader要有一个app私有且可写的目录来存储经过优化的.odex文件。构造函数如下： 12345678910111213public class DexClassLoader extends BaseDexClassLoader &#123; /** * * @param dexPath .dex文件路径,多个文件路径使用':'分隔 * @param optimizedDirectory .dex文件优化后生成的.odex文件的路径 * @param librarySearchPath 动态库路径 * @param parent 双亲委派模式,指定父类加载器 */ public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125; &#125; PathClassLoaderPathClassLoader只能加载已经安装的apk文件。Android系统默认使用的类加载器。构造函数如下： 1234567891011121314151617public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125; /** * * @param dexPath .dex文件路径 * @param librarySearchPath 本地库路径 * @param parent 双亲委派模式,指定父类加载器 */ public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125; &#125; DexClassLoader与PathClassLoader的比较通过两个类加载构造函数的对比发现，区别在于DexClassLoader构造函数中的参数optimizedDirectory。Google官方文档中给出optimizedDirectory的说明是，用来存储经过优化后的.odex文件的路径。optimizedDirectory必须是一个内部存储路径，DexClassLoader可以通过构造函数指定optimizedDirectory，所以DexClassLoader可以实现动态加载，外部的.jar/.dex文件，优化后会存在在optimizedDirectory目录中。PathClassLoader由于没有指定该路径，所以只能加载内部的，已经安装的apk中的.odex文件。 整个类加载过程可以简单描述为上面的时序图。ClassLoader在加载过程中，通过loadClass方法，调用BaseDexClassLoader中重载的findClass方法，该方法会遍历DexPathList列表。DexPathList的创建过程如下： 123456public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.originalPath = dexPath; this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125; optimizedDirectory用来缓存优化过的.odex文件，在DexClassLoader中可以通过构造函数进行制定，在PathClassLoader中，optimizedDirectory为null，会直接使用系统中已经安装的apk文件的.odex目录。DexPathList完整的创建过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) &#123; …… this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory); &#125; private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory) &#123; ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); for (File file : files) &#123; ZipFile zip = null; DexFile dex = null; String name = file.getName(); if (name.endsWith(DEX_SUFFIX)) &#123; dex = loadDexFile(file, optimizedDirectory); &#125; else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX) || name.endsWith(ZIP_SUFFIX)) &#123; zip = new ZipFile(file); &#125; …… if ((zip != null) || (dex != null)) &#123; elements.add(new Element(file, zip, dex)); &#125; &#125; return elements.toArray(new Element[elements.size()]); &#125; private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException &#123; if (optimizedDirectory == null) &#123; return new DexFile(file); &#125; else &#123; String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0); &#125; &#125; /** * Converts a dex/jar file path and an output directory to an * output file path for an associated optimized dex file. */ private static String optimizedPathFor(File path, File optimizedDirectory) &#123; String fileName = path.getName(); if (!fileName.endsWith(DEX_SUFFIX)) &#123; int lastDot = fileName.lastIndexOf("."); if (lastDot &lt; 0) &#123; fileName += DEX_SUFFIX; &#125; else &#123; StringBuilder sb = new StringBuilder(lastDot + 4); sb.append(fileName, 0, lastDot); sb.append(DEX_SUFFIX); fileName = sb.toString(); &#125; &#125; File result = new File(optimizedDirectory, fileName); return result.getPath(); &#125; 参考文章1.深入分析Java ClassLoader原理2.分析BootstrapClassLoader/ExtClassLoader/AppClassLoader的加载路径 及”父委托机制”3.簡介類別載入器4.Java虚拟机Dalvik5Android动态加载——DexClassloader分析 本文链接：http://www.sguotao.top/Android进阶-2017-03-17-分析Android中的动态加载机制.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>插件框架</tag>
        <tag>ClassLoader</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样才能让别人觉得与你合作愉快]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2016-08-17-pleasure-working-with-you.html</url>
    <content type="text"><![CDATA[文章作者：咪喵文章来源： TalentGuide 为什么有的人，明明事情做得不少，却永远没人说他好？有的人，不管做什么都得到周围人众口一词的称赞？ 真的是因为两个人做的事差很多吗？也许是。也许，只是一些小习惯改变了他们的口碑。 1. 收到请回答一些人，交给他的事情永远没下文。你不知道他收到了没有，是不是正在做，已经做到了什么进展，啥时候能交付。即使这件事他已经做完了，不去问，他也永远不会告诉你。 收到任务，请告诉对方“我收到了。” 需要时间消化，请告诉对方“我看一下，晚点（给出具体时间段更佳）给你答复。” 事情有进展时，及时周知相关人等最新进度。 事情完成时，通知相关方，并感谢在其中给过帮助的人。 做到这些，不需要很多时间，却会让与你合作的人感到轻松愉快。 2. 要做就别抱怨有的人，接受任务时永远不情不愿，嘴里没完没了地抱怨，最后虽仍然接下了任务，却留下了难以合作的印象。 如果别人的行为确实给自己带来了麻烦或是有为难之处，可以清晰告知对方自己难做的原因，说清楚希望对方如何改进，并告知这样的改进会给双方带来什么好处。 比如对方总给你扔急活，你为了这个急活不得不加班加点，到处求人。正确的做法是告诉对方这件事有哪些环节，分别需要多长时间，以后请提早多少天告知，以便更好的完成。这次帮忙加急，下不为例。这样对方能理解你这次加急赶完是帮了他忙，而不会抱怨每次给你事情都推三阻四还完成得不好。 3. 推进事情要推到有进展才算数有些人，推进一件事的方法是：每隔一段时间，发封不痛不痒的邮件，抄送所有人，摆个样子跟进一下，也不在乎对方是否给了结果。仿佛在说“你看，我推过了，是对方不给做，推不动不关我事哦。出了问题责任是他是他还是他。” 如果是自家孩子病了，有哪位家长会说“我给医生发邮件了，他没回我，所以病治不了了。”显然，孩子生病时家长都是心急火燎的，医生不在会找护士，找主管，找院长，找媒体。用尽一切可用的渠道，一切可用的方法，直到医生给孩子看病为止。 当说一件事情推不动时，扪心自问自己真的做到了像家长为生病的孩子找医生那样努力吗？真的已经用尽了一切可用的力量，找尽了一切可找的人去推动这件事吗？ 装模作样推一推是没有意义的，一定要推到这件事有实质进展为止。实质进展是对方给排期、给解决方案、给具体处理这件事的人。如果什么都没拿到，那根本不算推进过一件事。 4. 做不到早说有的人，交给他的事情，不问永远没问题，一问全是问题。拖过了截止期做不到，罗列出一堆原因，都是ABCDE的问题，与他无关。 OK，就算ABCDE的问题确实与他无关，为什么不能在发现有这些问题时及时反馈呢？自己解决不了的问题，及时反馈并暴露，让有能力解决的人去解决，是靠谱最重要的表现之一。 又有人说，我要是暴露了这些问题得罪了别人怎么办？请问不暴露这些问题，任由时间资源浪费，事情最终没做到，就谁都不得罪了吗？作为一个团队，成事是最重要的。暴露问题是为了解决问题，而不是为了挑事，关键是把握分寸。 还有人说，跟别人没关系，就是堆给我的活太多了，我做不完怎么办？如果是这种情况，更要尽早反馈了。或许你花了大量时间在一件优先级比较低的事情上，导致最重要的事情没有做完。结果把自己累得半死，还谁都不满意。发现自己做不完，就要第一时间跟相关方确认优先级，力保最重要的事情能够及时完成。如果被插入了其他优先级更高的事，也要尽快知会事情被推迟的相关方。 5. 功劳是大家的有些人，干活的时候一天八回地狂催别人。活干完了，人没影了，汇报工作成果时只字不提其他人，仿佛活全是他自己一人干的。这样的人，执行力再好，下次再找人干活时，也难得到别人心甘情愿的帮忙。 无论别人是帮了多小的忙，在事情结束后也要表示感谢。道谢要不嫌隆重，能当面谢的尽量当面去谢，能单独打电话谢的就不要讲其他事情时顺便谢，发邮件表示感谢的话尽量抄送对方老板详细说明感谢的事由。这些事情并不费劲，却会让别人更愿意帮助你。 6. 别吐槽，给解决方案有的人，你一找他解决问题，就开启吐槽模式，内容全是“我有多辛苦多不容易，能做的我都做了，这些问题全是因为balabala……” 每当这时我都好想告诉对方“亲，没有人关心你的心路历程。”我不关心你有多辛苦多不容易你做了多少事情，为什么别人就是没按照你设定的剧本做。我只知道现在有一个问题，我找你只想知道“怎样解决这个问题”。 当有一个问题时，请直奔主题，给解决方案。 7. 敢作敢当当事情搞砸时，最次的做法是想尽办法推卸责任，最好的做法是诚恳道歉，评估影响范围，想尽办法用最快速度修正错误，弥补损失。 不要耍滑头，得意于自己把责任都推出去了，推卸得越成功，实际越失败。不要怕承担，勇于承担责任的人，别人才敢赋予你更大的责任。 8. 结语做到上面这些条，说难不难，说易也不易。说白了，就是要多操些心，多费些力。 有的人说一份工作而已，干嘛把自己搞这么累。我就做好自己这部分，别人的事我不管，跟我没关系，只要出事了别怪我头上就行。当然，若真这么想，没什么不行的，您高兴就好。只是请不要再抱怨为什么自己怀才不遇，升职加薪总是比别人慢。多劳多得，很公平，不是么？ 本文链接：http://www.sguotao.top/生活感悟-2016-08-17-pleasure-working-with-you.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2016-08-11-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.html</url>
    <content type="text"><![CDATA[二叉树 二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树。 二叉树的性质性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）;性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 + 1 满二叉树：深度为k且有2^k －1个结点的二叉树称为满二叉树。 完全二叉树：深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点） 性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1。 二叉树的遍历注意：仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果。声明二叉树的结点: 123456789class TreeNode &#123; String data; TreeNode left; TreeNode right; public TreeNode(String data) &#123; this.data = data; &#125; &#125; 按层遍历12345678910111213141516171819202122232425262728293031323334353637/** * 按层打印二叉树 * * @param root * @return */public void printBinaryTreeByLevel(TreeNode root) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new ArrayBlockingQueue&lt;TreeNode&gt;(100); TreeNode last = root;//当前行的最后结点 TreeNode nLast = root;//下一行的最右结点 queue.add(root); while (!queue.isEmpty()) &#123; TreeNode cur = queue.poll(); list.add(cur.data); if (cur.left != null) &#123; queue.add(cur.left); nLast = cur.left; &#125; if (cur.right != null) &#123; queue.add(cur.right); nLast = cur.right; &#125; if (cur == last) &#123; last = nLast; &#125; &#125; //打印输出 for (String str : list) &#123; System.out.print(str + " "); &#125;&#125; 前序遍历前序遍历的过程: 访问根节点 前序遍历左子树 前序遍历右子树 12345678910111213/** * 递归前序遍历二叉树 * * @param tree */public void recursivePreorderTraversal(TreeNode tree) &#123; if (null == tree) &#123; return; &#125; System.out.print(tree.data + " "); recursivePreorderTraversal(tree.left); recursivePreorderTraversal(tree.right);&#125; 使用迭代法： 12345678910111213141516171819202122232425/** * 迭代前序遍历二叉树 * * @param tree */ public void iterationPreorderTraversal(TreeNode tree) &#123; if (null == tree) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(tree); while (!stack.isEmpty()) &#123; TreeNode treeNode = stack.pop(); System.out.print(treeNode.data + " "); //先将右结点压栈，再将左结点压栈，出栈时先打印左结点，再打印右节点 if (null != treeNode.right) &#123; stack.push(treeNode.right); &#125; if (null != treeNode.left) &#123; stack.push(treeNode.left); &#125; &#125; &#125; 中序遍历中序遍历的过程: 中序遍历左子树 访问根节点 中序遍历右子树 12345678910111213/** * 递归中序遍历二叉树 * * @param tree */public void recursiveInorderTraversal(TreeNode tree) &#123; if (null == tree) &#123; return; &#125; recursiveInorderTraversal(tree.left); System.out.print(tree.data + " "); recursiveInorderTraversal(tree.right);&#125; 使用迭代法: 1234567891011121314151617181920212223/** * 迭代中序遍历二叉树 * * @param tree */public void iterativeInorderTraversal(TreeNode tree) &#123; if (null == tree) &#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = tree; while (!stack.isEmpty() || cur != null) &#123; if (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; else &#123; cur = stack.pop(); System.out.print(cur.data + " "); cur = cur.right; &#125; &#125;&#125; 后序遍历后续遍历的过程: 后序遍历左子树 后序遍历右子树 访问根节点 12345678910111213/** * 递归后序遍历二叉树 * * @param tree */public void recursivePostorderTraversal(TreeNode tree) &#123; if (null == tree) &#123; return; &#125; recursivePostorderTraversal(tree.left); recursivePostorderTraversal(tree.right); System.out.print(tree.data + " ");&#125; 使用迭代法: 12345678910111213141516171819202122232425262728293031/** * 迭代后续遍历二叉树 * * @param tree */public void iterativePostOrderTraversal(TreeNode tree) &#123; if (null == tree) &#123; return; &#125; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;();//stack1用来添加结点及结点的左右结点 Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;();//stack2用来翻转stack1 stack1.push(tree); while (!stack1.isEmpty()) &#123; TreeNode treeNode = stack1.pop(); stack2.push(treeNode); if (null != treeNode.left) &#123; stack1.push(treeNode.left); &#125; if (null != treeNode.right) &#123; stack1.push(treeNode.right); &#125; &#125; while (!stack2.isEmpty()) &#123; System.out.print(stack2.pop().data + " "); &#125;&#125; 测试构建一个二叉树: 12345678910111213141516171819202122232425262728 /** * 构建一个树 * A * / \ * B C * / \ / * D E F * * @return */public TreeNode buidTree() &#123; TreeNode a = new TreeNode("A"); TreeNode b = new TreeNode("B"); TreeNode c = new TreeNode("C"); TreeNode d = new TreeNode("D"); TreeNode e = new TreeNode("E"); TreeNode f = new TreeNode("F"); a.left = b; a.right = c; b.left = d; b.right = e; c.left = f; return a;&#125; 测试代码: 1234567891011121314151617181920212223public static void main(String[] args) &#123; BinaryTree binaryTree = new BinaryTree(); System.out.print("前序遍历(递归):"); binaryTree.recursivePreorderTraversal(binaryTree.buidTree()); System.out.println(); System.out.print("前序遍历(迭代):"); binaryTree.iterationPreorderTraversal(binaryTree.buidTree()); System.out.println(); System.out.print("中序遍历(递归):"); binaryTree.recursiveInorderTraversal(binaryTree.buidTree()); System.out.println(); System.out.print("中序遍历(迭代):"); binaryTree.iterativeInorderTraversal(binaryTree.buidTree()); System.out.println(); System.out.print("后序遍历(递归):"); binaryTree.recursivePostorderTraversal(binaryTree.buidTree()); System.out.println(); System.out.print("后序遍历(迭代):"); binaryTree.iterativePostOrderTraversal(binaryTree.buidTree()); System.out.println(); System.out.print("层次遍历:"); binaryTree.printBinaryTreeByLevel(binaryTree.buidTree()); &#125; 运行结果: 1234567前序遍历(递归):A B D E C F 前序遍历(迭代):A B D E C F 中序遍历(递归):D B E A F C 中序遍历(迭代):D B E A F C 后序遍历(递归):D E B F C A 后序遍历(迭代):D E B F C A 层次遍历:A B C D E F 本文链接：http://www.sguotao.top/数据结构-2016-08-11-二叉树的遍历.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的Activity]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-07-21-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Activity.html</url>
    <content type="text"><![CDATA[Activity的生命周期 Activity是Android与用户进行交互的接口，Activity提供了界面用于处理用户的点击和滑动等交互。 Activity的四种状态Activity主要包括四种状态，分别是:running、paused、stopped和killed。 running状态，Activity处于活动状态，用户可以点击屏幕，Activity会做出响应，此时Activity处于栈顶的状态。 paused状态，Activity失去焦点，此时Activity被一个非全屏的Activity覆盖，或者被一个全屏的透明的Activity覆盖。在paused状态暂时无法与用户进行交互，Activity的成员变量的状态除非因为内存紧张被回收，否则都存在的。 stopped状态，Activity被另外一个Activity完全覆盖，在内存不紧张的情况，Activity成员变量的状态都存在。 killed状态，Activity已经被系统回收，Activity的成员变量状态都不存在了。 Activity的生命周期分析先看官网给出的Activity生命周期的流程图:根据流程图，来分析一下Activity的几个主要的回调方法: onCreate()，Activity创建的时候被回调，是Activity生命周期第一个被回调的方法，在onCreate()中可以setContentview(),还可以设置一些预加载功能。 onStart()，Activity已经启动处于用户可见，但是还不能与用户交互的状态。 onResume()，Activity前台可见，可以与用户进行交互。 onPause()，Activity处于暂停状态，Activity可见，但已经不在栈顶。 onStop()，Activity处于停止状态，被完全覆盖，如果系统内存紧张，Activity可能会被回收。 onRestart()，Activity从停止状态被重新调用时，会回调该方法。 onDestroy()，退出当前Activity时会被回调，是整个生命周期的最后一个方法，可以在该方法中做一些资源释放的操作。 几种主要场景中,Activity回调方法的执行过程: Activity启动过程中: onCreate() –&gt; onStart() –&gt; onResume() 点击Home键回到主界面时,Activity变为不可见状态: onPause() –&gt; onStop() 再次点击Home键返回到之前的Activity时: onRestart() –&gt; onStart() –&gt; onResume() 退出当前Activity时: onPause() –&gt; onStop() –&gt; onDestroy() Activity进程优先级Android中的进程可以根据优先级的不同划分为:前台进程、可见进程、服务进程、后台进程和空进程。当系统资源紧张时，Android系统会优先考虑回收优先级比较低的进程。 系统中前台进程的数量很少, 前台进程几乎不会被系统回收. 只有当内存低到无法保证所有的前台进程同时运行时才会选择杀死某个前台进程。前台进程包含以下场景:进程中包含处于前台的正与用户交互的Activity;进程中包含与前台Activity绑定的Service;进程中包含调用了startForeground()方法的Service;进程中包含正在执行onCreate(),onStart(), 或onDestroy()方法的service;进程中包含正在执行onReceive()方法的BroadcastReceiverd。 可见进程，可视进程不会被系统回收, 除非为了保证前台进程的运行而不得已为之。可见进程的场景:进程中包含未处于前台但仍然可见的Activity(调用了Activity的onPause()方法, 但没有调用onStop()方法)。进程中包含与可见Activity绑定的Service。 服务进程，顾名思义，进程中包含已启动的Service。 后台进程，进程中包含不可见的Activity(onStop()方法调用后的activity)。后台进程不会直接影响用户体验, 为了保证前台进程/可见进程/服务进程的运行, 系统随时都有可能回收一个后台进程。 空进程，不包含任何处于活动状态的进程是一个空进程。系统经常杀死空进程，这不会造成任何影响。空进程存在的唯一理由是为了缓存一些启动数据，以便下次可以更快的启动。 Android任务栈当应用程序打开时就创建了一个任务栈，用于存储当前应用程序的Activity，一个任务栈就是一个Activity的集合，只有在任务栈栈顶的Activity才可以跟用户进行交互。任务栈可以移动到后台，并且保留每一个Activity的状态。退出应用程序时，需要把所有任务栈中的Activity清除出栈。当我们每打开一个Activity的时候它会就往Activity任务栈中压入一个Activity，当我们每销毁一个Activity的时候它会从Activity任务栈中弹出一个Activity。 Activity的启动模式启动模式（launchMode）在多个Activity跳转的过程中扮演着重要的角色，它决定着是否生成新的Activity实例，是否重用已经存在的Activity实例，是否和其他实例共用一个任务栈。Activity的启动模式有四种，分别是:standard、singTop singTask和singleInstance，可以通过在AndroidManifest.xml中Activity的android:launchMode属性进行设置。 Android启动模式: 标准模式standard，默认启动模式，每次激活Activity时都会创建Activity，并放入任务栈中。 栈顶复用模式singletop，如果在任务的栈顶正好存在该Activity的实例， 就重用该实例，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例)。 栈内复用模式singletask，如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中。 singleinstance， 在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦该模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。 Scheme跳转协议Android中的Scheme是一种页面内跳转协议，通过自定义的Scheme协议，可以非常方便的跳转app中的各个页面，通过Scheme协议服务器可以定制化告诉App跳转哪个页面，可以通过通知栏消息定制化跳转页面，也可以实现H5页面跳转页面。scheme协议，主要用于支持一下几种场景： 服务器下发跳转路径，客户端根据服务器下发跳转路径跳转相应的页面； H5页面点击锚点，根据锚点具体跳转路径App端跳转具体的页面； App之间根据跳转路径进行跳转。 使用方式包含下面几个步骤: 在清单文件AndroidManifest中声明用来处理通过Scheme协议跳转的Activity； 123456789101112131415&lt;activity Android:name=".NativeAppActivity" Android:label="@string/app_name"&gt; &lt;intent-filter&gt; &lt;!-- 协议部分--&gt; &lt;data android:host="shareAction" android:scheme="letvclient" /&gt; &lt;category Android:name="Android.intent.category.DEFAULT" /&gt; &lt;category Android:name="Android.intent.category.BROWSABLE" /&gt; &lt;action Android:name="Android.intent.action.VIEW" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 调起处理跳转协议的Activity 1startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("letvclient://shareAction?actionType=xxx&amp;appName=xxx"))); 在处理跳转协议的Activity中解析数据 1234567891011121314151617private void resolveUri(Intent intent, Uri data) &#123; String scheme = intent.getScheme(); if (scheme == null || !LETV_CLIENT.equalsIgnoreCase(scheme)) &#123;// 判断来源 return; &#125; String actionType; String appName; try &#123; actionType = data.getQueryParameter("actionType"); appName = data.getQueryParameter("appName"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; …… &#125; 参考文献[1]GoogleAPI指南-进程和线程[2]GoogleAPI指南-Activity[3]GoogleAPI指南-任务栈和返回栈 本文链接：http://www.sguotao.top/Android进阶-2016-07-21-分析Android中的Activity.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的Binder]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-07-21-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Binder.html</url>
    <content type="text"><![CDATA[在分析Binder之前，需要先了解几个Linux的几个概念。 Linux内核的基础知识 进程隔离/虚拟地址空间:每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。虚拟地址不是现实存在的地址空间。操作系统可以根据分段和分页两种方式，实现虚拟地址到真实物理地址的映射。 系统调用:计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源，进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的系统调用（System Call）。 Binder驱动:Binder驱动是作为一个特殊字符型设备存在，设备节点为/dev/binder，遵循Linux设备驱动模型。在驱动实现过程中，实现与用户空间进程的数据通信。 Binder的通信机制什么是Binder？ 通常意义下，Binder是Android中的一个类，它继承了IBinder接口； 从IPC角度，Binder指的是跨进程通信机制；对于Server进程来说，Binder指的是Binder本地对象,对于Client进程来说，Binder指的是Binder代理对象。在整个传输过程，Binder是可以进行跨进程传递对象的。 从Android Framework角度，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁； 从Android应用层，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。 为什么使用binderAndroid中有大量的CS（Client-Server）应用方式，这就要求Android内部提供IPC方法，Android使用Linux内核，拥有着非常多的跨进程通信机制，但是linux所支持的进程通信方式有两个问题：性能和安全性。 性能目前linux支持的IPC包括传统的管道，System V IPC(消息队列/共享内存/信号量)，以及socket，但只有socket支持Client-Server的通信方式，由于socket是一套通用的网络通信方式，其传输效率低下切有很大的开销，比如socket的连接建立过程和中断连接过程都是有一定开销的。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。 安全性Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。 基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。 Binder通信模型Binder的通信过程可以用下图来简单的描述。 Client与Server通过Binder进行通信的过程可以概括为: ServiceManager的建立； 启动的Service在ServiceManager中进行注册，在已经建立的ServiceManager维护的一张表； Client向ServiceManager中进行查询Service中注册的方法； ServiceManager返回一个代理对象，Client可以通过该代理对象实现与Server的通信。代理对象中有空方法，代理对象中方法的实现是Binder驱动来完成的。整个过程对Client是透明的。 参考文献1.任玉刚.Android开发艺术探索[M].电子工业出版社, 2015.9:1 - 5072.Android Bander设计与实现 - 设计篇3.Android深入浅出之Binder机制 本文链接：http://www.sguotao.top/Android进阶-2016-07-21-分析Android中的Binder.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的Fragment]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-07-21-%E5%88%86%E6%9E%90Androdi%E4%B8%AD%E7%9A%84Fragment.html</url>
    <content type="text"><![CDATA[Fragment介绍Android 在 Android 3.0（API 级别 11）中引入了Fragment，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。 Fragment加载到Activity中的两种方式静态加载方式静态加载方式，直接在布局文件中添加fragment，示例代码: 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:name="com.example.news.ArticleListFragment" android:id="@+id/list" android:layout_weight="1" android:layout_width="0dp" android:layout_height="match_parent" /&gt; &lt;fragment android:name="com.example.news.ArticleReaderFragment" android:id="@+id/viewer" android:layout_weight="2" android:layout_width="0dp" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 动态加载方式动态加载方式，即在Activity运行过程中，将fragment加载到布局文件中，示例代码: 12345678//1.获取一个FragmentTransaction实例FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();//2.调用add()方法添加Fragment对象ExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);//3.调用commit()方法使得fragmentTransaction实例的改变生效fragmentTransaction.commit(); FragmentPagerAdapter与FragmentStatePagerAdapter的区别FragmentPagerAdapter和FragmentStatePagerAdapter都是PagerAdapter的子类，先来看他们的父类PagerAdapter。 PagerAdapter是ViewPager的适配器，ViewPager将调用它来取得所需显示的页，而 PagerAdapter也会在数据变化时，通知ViewPager。如果继承自该类，至少需要实现 instantiateItem(), destroyItem(), getCount() 以及 isViewFromObject()。 FragmentPagerAdapter继承自PagerAdapter。相比通用的PagerAdapter，该类更专注于每一页均为Fragment的情况。该类内的每一个生成的Fragment都将保存在内存之中，因此适用于那些相对静态的页，数量也比较少的那种；如果需要处理有很多页，并且数据动态性较大、占用内存较多的情况，应该使用FragmentStatePagerAdapter。FragmentPagerAdapter 重载实现了几个必须的函数，因此来自 PagerAdapter 的函数，我们只需要实现 getCount()，即可。且，由于 FragmentPagerAdapter.instantiateItem() 的实现中，调用了一个新增的虚函数 getItem()，因此，我们还至少需要实现一个 getItem()。 FragmentStatePagerAdapter 和前面的 FragmentPagerAdapter 一样，是继承子 PagerAdapter。和 FragmentPagerAdapter 不一样的是，正如其类名中的 ‘State’ 所表明的含义一样，该 PagerAdapter 的实现将只保留当前页面，当页面离开视线后，就会被消除，释放其资源；而在页面需要显示时，生成新的页面。这么实现的好处就是当拥有大量的页面时，不必在内存中占用大量的内存。 为什么FragmentPagerAdapter占用内存会比FragmentStatePagerAdapter呢？看一下FragmentPagerAdapter的源码: 123456789@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Detaching item #" + getItemId(position) + ": f=" + object + " v=" + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object);&#125; 再对比看一下FragmentStatePagerAdapter对应的方法: 123456789101112131415161718@Override public void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object + " v=" + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) &#123; mSavedState.add(null); &#125; mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); mCurTransaction.remove(fragment); &#125; FragmentStatePagerAdapter在每次destroyItem()时，将Fragment移除掉，而FragmentPagerAdapter只是detach()，失去关联而已。 Fragment的生命周期一个Fragment从创建到销毁的完整的生命周期如图:图中给出了Fragment在创建和销毁的过程中对一个的Activity的回调方法。对比发现，Fragment生命周期过程中的回调状态比Activity的状态多。 onAttch（Activity activity），这个回调方法是在fragment与activity关联之后调用，我们能在这个方法中获取这个关联的activity的实例。但是当你的sdk更新到android6.0（api-23）是就会显示这个方法是过时的，系统建议使用onAttach（Context context）这个方法代替。 onCreate()，这个回调方法是在fragment初始化的时候调用，我们通常在这个方法中使用getArgument()获取Activity传来的初始化Fragment的参数。需要注意的是，在这个方法中不能获取Activity中的控件，因为此时Activity的onCreate()还没有执行完，即Activity还没有创建完，要想获取Activity相关的资源应该在onActivityCreated()中获取。 onCreateView()：这个回调方法中我们主要是通过布局填充器获取Fragment布局。我们在这个方法中通过view.findViewById()初始化Fragment中的控件。 onActivityCreated()，这个回调方法是在Activity的onCreate()方法执行完执行，通知Fragment，其关联的Activity的onCreate()方法执行完了，即Activity创建完成，可以在这个方法中获取Activity中的资源。 onStart()，这个回调方法是在Activity的onstart()执行完立即执行，这个方法执行完Fragment界面就显示出来了，但是现在还没有获取焦点，用户不能进行交互操作。 onResume()，这个回调方法是在Activity的onResume()方法执行完立即执行，此时Fragment的获取了界面，用户可以操作。 onPause()，Fragment失去焦点，此时用户是不能操作的，执行完立即执行Activity的onPause()方法。 onStop()，Fragment不可见，执行完立即执行Activity的onStop()方法。 onDestroyView(),在onCreateView()中创建的Fragment视图会被销毁。Fragment的视图被回收。 onDestroy()，当这个Fragment不再使用时调用。需要注意的是，它即使经过了onDestroy()阶段，但仍然能从Activity中找到，因为它还没有Detach()。 onDetach()，Fragment与Activity解除关联，Fragment的所有的资源都被回收。 Fragment的通信Fragment的通信，概括起来主要包含以下三种情况: 在Fragment中调用Activity中的方法，通过getActivity()获取到关联的Activity，然后通过获取的Activity实例，调用Activity中的方法。 在Activity中调用Fragment中的方法，Activity中维护着其关联的Fragment的实例，可以直接调用其方法。 在Fragment中调用Fragment中的方法，通过getActivity()获取到关联的Activity，然后通过获取的Activity实例，通过findFragmentById()方法，知道要与之通信的Fragment。 除了上面中介绍的方法，还可以通过接口回调的方法。这里以Fragment调用Activity中的方法为例，介绍接口回调的方式,接口回调主要经历三个步骤: 在Fragment中定义回调接口，声明回调方法 123456/** * 1.在Fragment中定义回调接口，声明回调方法 */public interface ComminuteListener &#123; void comminute();&#125; Fragment关联的Activity实现接口 1234567891011121314151617public class TestFragmentActivity extends Activity implements TestFragment.ComminuteListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); &#125; @Override public void comminute() &#123; showToast(); &#125; public void showToast() &#123; Toast.makeText(this, "toast from Activity", Toast.LENGTH_SHORT).show(); &#125;&#125; 在Fragment的onAttach()方法中，获取接口实例，调用回调方法。 1234567891011@Override public void onAttach(Context context) &#123; super.onAttach(context); try &#123; comminuteListener = (ComminuteListener) getActivity(); &#125;catch (ClassCastException e)&#123; e.printStackTrace(); &#125; comminuteListener.comminute(); &#125; 参考文献[1]Google-API指南-应用组件-Fragment 本文链接：http://www.sguotao.top/Android进阶-2016-07-21-分析Androdi中的Fragment.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的自定义View]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-07-08-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89View.html</url>
    <content type="text"><![CDATA[自定义View的分类 继承View重写onDraw()，这种方法主要用于实现一些不规则的效果，即这种效果不方便通过布局的组合方式来达到，往往需要静态或者动态地显示一些不规则的图形。很显然这需要通过绘制的方式来实现，即重写onDraw方法。采用这种方式需要自己支持wrap_content，并且padding也需要自己处理。 继承ViewGroup派生出特殊的Layout布局，这种方法主要用于实现自定义的布局，即除了LinearLayout、RelativeLayout、FrameLayout这几种系统的布局之外，我们重新定义一种新布局，当某种效果看起来很像几种View组合在一起的时候，可以采用这种方法来实现。采用这种方式稍微复杂一些，需要合适地处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。 继承具体的View，这种方法比较常见，一般是用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现。这种方法不需要自己支持wrap_content和padding等。 继承具体的ViewGroup，这种方法也比较常见，当某种效果看起来很像几种View组合在一起的时候，可以采用这种方法来实现。采用这种方法不需要自己处理ViewGroup的测量和布局这两个过程。需要注意这种方法和方法2的区别，一般来说方法2能实现的效果方法4也都能实现，两者的主要差别在于方法2更接近View的底层。 添加自定义属性1.在values目录下面创建自定义属性的XML，比如attrs.xml，也可以选择类似于attrs_circleview.xml等这种以attrs开头的文件名。 123456&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;CircleView&quot;&gt; &lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 2.在View的构造方法中解析自定义属性的值并做相应处理。 123456public CircleView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CircleView); mColor = a.getColor(styleable.CircleView_circle_color, Color.RED); a.recycle(); init();&#125; 3.在布局文件中使用自定义属性 1234567891011121314151617&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ffffff&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.scott.codelibrary.view.CustomView android:id=&quot;@+id/cv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;100dp&quot; android:layout_margin=&quot;20dp&quot; android:background=&quot;#000000&quot; android:padding=&quot;20dp&quot; app:circle_color=&quot;@color/light_green&quot;/&gt;&lt;/LinearLayout&gt; 自定义View的注意事项让View支持wrap_content这是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。为什么呢？ 如果View在布局中使用wrap_content，那么它的specMode是AT_MOST模式，在这种模式下，它的宽/高等于specSize；这种情况下View的specSize是parentSize，而parentSize是父容器中目前可以使用的大小，也就是父容器当前剩余的空间大小。很显然，View的宽/高就等于父容器当前剩余的空间大小，这种效果和在布局中使用match_parent完全一致。怎么处理呢？直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小。 12345678910111213141516protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; //给View指定默认的宽mWidth，高mHeight setMeasuredDimension(mWidth, mHeight); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(mWidth, heightSpecSize); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSpecSize, mHeight); &#125; &#125; 让View支持padding这是因为直接继承View的控件，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。 不要在View中使用Handler这是因为View内部本身就提供了post系列的方法，完全可以替代Handler的作用，当然除非你很明确地要使用Handler来发送消息。 View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow这一条也很好理解，如果有线程或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄漏。 View带有滑动嵌套情形时，需要处理好滑动冲突如果有滑动冲突的话，那么要合适地处理滑动冲突，否则将会严重影响View的效果。 本文链接：http://www.sguotao.top/Android进阶-2016-07-08-分析Android中的自定义View.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中View的工作流程]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-07-07-%E5%88%86%E6%9E%90Android%E4%B8%ADView%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[在分析View的工作流程时，需要先分析一个很重要的类,MeasureSpec。这个类在View的测量(Measure)过程中会用到。 MeasureSpecMeasureSpec是View的静态内部类，可以理解为是一种测量规格，是一个32位int值，高2位代表SpecMode，低30位代表SpecSize，SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小。SpecMode有三种模式，分别为： UNSPECIFIED:父容器不对View做限制 EXACTLY:父容器已经检测出View所需的精确大小，View的大小为SpecSize中指定的值。 AT_MOST:父容器指定了一个SpecSize，View的大小不大大于该值。 MeasureSpec与LayoutParams系统通过MeasureSpec作为测量规格，对View进行测量，但在设置View的宽高时，都是通过LayoutParams，因此系统在测量View的时候，会将LayoutParams在父容器的约束下转换成MeasureSpec，然后根据确定的MeasureSepc得到View测量后的宽高。有几点需要说明： LayoutParams和父容器一起确定MeasureSpec； 对于DecorView，其MeasureSpec是由窗口的尺寸和自身的LayoutParams共同确定的；由于窗口尺寸是确定的，因此主要与DecorView自身的LayoutParams有关，具体的对应关系如下图描述： 对于普通View，其MeasureSpec是由父容器的MeasureSpec和自身的LayoutParams共同确定的。其对应关系如下图描述：对普通View，简单总结一下： 当View采用固定宽/高的时候，不管父容器的MeasureSpec是什么，View的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小。 当View的宽/高是match_parent时，如果父容器的模式是精准模式，那么View也是精准模式并且其大小是父容器的剩余空间；如果父容器是最大模式，那么View也是最大模式并且其大小不会超过父容器的剩余空间。 当View的宽/高是wrap_content时，不管父容器的模式是精准还是最大模式，View的模式总是最大模式并且大小不能超过父容器的剩余空间。 在UNSPECIFIED模式中，系统内部会进行多次Measure过程，才能确定View的宽高。 View的工作流程ViewRoot是连接WindowManager与DecorView的纽带，View的绘制流程都是通过ViewRoot来完成的。 View的工作流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure用来测量View的宽和高，layout用来确定View在父容器中的放置位置，而draw则负责将View绘制在屏幕上。用一张图来描述View的工作过程： View的测量(Measure)过程在View的Measure过程中，完成对View的测量，确定View的宽高。ViewRoot中的performTraversals()会依次调用ViewRoot中的performMeasure()、performLayout()和performDraw()三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程。其中在performMeasure()中会调用View的measure()方法，在measure()方法中又会调用onMeasure()方法。在onMeasure()中将View宽/高的测量值传给setMeasuredDimension()方法，完成View的测量过程。 对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有子元素的measure()方法，各个子元素再递归去执行这个过程。和View不同的是，ViewGroup是一个抽象类，因此它没有重写View的onMeasure方法，因为不同的ViewGroup子类有不同的布局特性，这导致它们的测量细节各不相同。在ViewGroup的onMeasure()中最后也会调用setMeasuredDimension()方法，完成测量过程。 measure完成以后，通过getMeasuredWidth()/Height()方法就可以正确地获取到View的测量宽/高。需要注意的是，在某些极端情况下，系统可能需要多次measure才能确定最终的测量宽/高，在这种情形下，在onMeasure方法中拿到的测量宽/高很可能是不准确的。一个比较好的习惯是在onLayout方法中去获取View的测量宽/高或者最终宽/高。 View的布局(Layout)过程Layout的作用是ViewGroup用来确定子元素的位置，ViewRoot中的performLayout()中会调用View的layout()方法，在layout()方法中onLayout()方法又会被调用。onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正实现onLayout方法。 当ViewGroup的位置被确定后，它在onLayout()中会遍历所有的子元素并调用其layout()方法，layout()方法确定View本身的位置，而onLayout()方法则会确定所有子元素的位置。 View的绘制(Draw)过程Draw的作用是将View绘制到屏幕上面。View的绘制过程遵循如下几步： 绘制背景background.draw(canvas) 绘制自己（onDraw） 绘制children（dispatchDraw） 绘制装饰（onDrawScrollBars） View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递了下去。 参考文献[1] 任玉刚.Android开发艺术探索[M].电子工业出版社, 2015.9:1 - 507 本文链接：http://www.sguotao.top/Android进阶-2016-07-07-分析Android中View的绘制流程.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中View的事件分发流程]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-07-06-%E5%88%86%E6%9E%90Android%E4%B8%ADView%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.html</url>
    <content type="text"><![CDATA[为什么会有事件分发机制在Android中，View是以树形结构的形式存在的，View可能会重叠在一起，当我们点击的地方有多个View可以响应时，这个点击事件应该由哪个View来处理呢?很多情况下我们的应用都需要支持滑动操作，当处于不同层级的View都可以响应用户的滑动操作时，会出现滑动冲突。如何解决滑动冲突呢？为了解决这样的问题，就引入了事件分发机制。 在分析事件分发之前，有必要理清几个类之间的关系，先看一张类图。 Activity与Window、DecorViewActivity是Android中处理UI交互的组件，但是Activity并没有直接与View产生联系，而是通过Window产生关联。具体可以查看Activity的attach方法。 12345678910111213141516final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); …… &#125; Window是一个抽象类，它有一个唯一实现子类PhoneWindow。Window可以理解为“UI界面的外框”，外框内的具体布局，背景的显示，标题栏的管理，都在window的管理范畴，是view的最顶层的管理容器。DecorView则是PhoneWindow类的一个内部类，继承于FrameLayout，DecorView是整个ViewTree的最顶层View，它是一个FrameLayout布局，代表了整个应用的界面。在该布局下面，有标题view和内容view这两个子元素。其中内容view对应着Acitivity中setContentView()中的view。 Window的另外一个作用，负责与WindowManagerService进行通信，但具体的实现逻辑并没有在Window中，而是交由Window的管理者WindowManager。WindowManager是一个接口，WindowManagerImpl中是其具体实现类，在WindowManagerImpl中通过WindowMangerGlobal来统一管理。 View与ViewRoot从源码上看,ViewRoot与View没有任何血缘关系，ViewRoot是final类型，没有派生子类，也不是View的子类。 12345 @SuppressWarnings(&#123;&quot;EmptyCatchBlock&quot;&#125;) public final class ViewRoot extends Handler implements ViewParent,View.AttachInfo.Callbacks &#123;……&#125; ViewRoot是连接WindowManager与DecorView的纽带，View的绘制流程都是通过ViewRoot来完成的。 在ViewRootImpl的构造方法中，有一个成员变量mWindowSession， 1234567public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mBasePackageName = context.getBasePackageName(); ……&#125; 查看WindowManagerGlobal.getWindowSession()的实现，发现mWindowSession它是ViewRoot利用WMS的openSession()接口来创建得到，用于ViewRoot到WMS的连接，从而实现与WindowManagerService的通信。 12345678910111213141516171819202122public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; InputMethodManager imm = InputMethodManager.getInstance(); IWindowManager windowManager = getWindowManagerService(); sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); ValueAnimator.setDurationScale(windowManager.getCurrentAnimatorScale()); &#125; catch (RemoteException e) &#123; Log.e(TAG, &quot;Failed to open window session&quot;, e); &#125; &#125; return sWindowSession; &#125; &#125; ViewRootImpl并非ViewRoot的实现类，两个类都是final类型，没有派生子类，这两个类实现的功能是一样的，这是在Android不同版本中的称呼不同而已。总结一下： Activity通过Window的唯一派生类PhoneWindow与view产生联系； PhoneWindow内部的DecorView是View的最顶层容器。 ViewRoot是WindowServiceManager与DecorView的纽带，View的绘制流程是都是通过ViewRoot完成。 三个重要的事件分发方法所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。三个方法之间的关系，可以通过一段伪代码的表示： 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume; &#125; 通过上面的伪代码，我们也可以大致了解点击事件的传递规则：对于一个根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup处理，即它的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。 dispatchTouchEvent用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 onInterceptTouchEventActivity和View中是没有该事件，如果在Activity作为事件的原始分发者，如果进行拦截，事件就无法传递到ViewGroup，整个屏幕就无法响应事件，同样View作为事件传递的最末端，没有需要事件分发的子控件，要么消费事件，要么不处理回传。 onInterceptTouchEvent是dispatchTouchEvent内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 onTouchEvent在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。 事件分发流程如果想让图中的View获取事件，事件的分发流程是怎样的？ 当屏幕被点击时，由于View是树形结构，首先事件传递到Activity，Activity在其dispatchTouchEvent中进行处理，然后传递到Window的实际实现类PhoneWindow，PhoneWindow所有关于事件的处理是在其内部类DecorView中完成的，如果在DecorView中的dispatchTouchEvent对事件不进行拦截，会将事件传递到RootView，在RootView的dispatchTouchEvent中调用onInterceptTouchEvent,如果对事件不进行拦截处理，事件会传递到ViewGroup，在ViewGroup中如果对事件不进行拦截，事件会传递到View，View收到事件后，在onTouchEvent中进行消耗处理，同时返回true，返回值经View-&gt;ViewGroup-&gt;RootView-&gt;DecorView-&gt;PhoneWindow-&gt;Activity的路径，最终会传到事件的发起点Activity，至此，完成了事件从Activity到View的分发过程。 OnTouchListener与OnClickListener当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被回调。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的OnTouchListener，其优先级优先级比onTouchEvent要高。在onTouchEvent方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件传递的尾端。 事件分发的完整过程首先事件开始交给Activity所附属的Window进行分发，如果返回true，整个事件循环就结束了，返回false意味着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用。由于Window的唯一实现是PhoneWindow，PhoneWindow将事件直接传递给了DecorView，由于DecorView继承自FrameLayout且是父View，所以最终事件会传递给View。即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。 事件达到顶级View（一般是一个ViewGroup）以后，会调用ViewGroup的dispatchTouchEvent方法，然后的逻辑是这样的：如果顶级ViewGroup拦截事件即onInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。也就是说，如果都提供的话，onTouch会屏蔽掉onTouchEvent。在onTouchEvent中，如果设置了mOnClickListener，则onClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此为止，事件已经从顶级View传递给了下一层View，接下来的传递过程和顶级View是一致的，如此循环，完成整个事件的分发。 总结关于事件传递的机制，这里给出一些结论，根据这些结论可以更好地理解整个传递机制： 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。 正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 某个View一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的onInterceptTouchEvent不会再被调用。这条也很好理解，就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列内的其他方法都直接交给它来处理，因此就不用再调用这个View的onInterceptTouchEvent去询问它是否要拦截了。 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。 如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouch-Event方法默认返回false。 View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。 View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。 onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。 事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 参考文献[1] 任玉刚.Android开发艺术探索[M].电子工业出版社, 2015.9:1 - 507 本文链接：http://www.sguotao.top/Android进阶-2016-07-06-分析Android中View的事件分发流程.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探Android中的View]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-07-05-%E5%88%9D%E6%8E%A2Android%E4%B8%AD%E7%9A%84View.html</url>
    <content type="text"><![CDATA[在Android中，Activity承担着与UI相关的可视化功能，在Activity中会使用到系统提供的大量控件，而View是Android中所有控件的基类,可以认为View是用户界面最基本的控件。 View的位置参数在Android中，默认View的形状是矩形，只要确定View的左上角位置和右下角位置，就可以确定View的位置。在View中，这两个顶点的坐标，对应着View的下面四个属性： top View左上角纵坐标，对应View成员变量mTop,通过getTop()方法得到； left View左上角横坐标，对应View成员变量mLeft，通过getLeft()方法得到； right View右下角横坐标，对应View成员变量mRight，通过getRight()方法得到； bottom View右下角纵坐标，对应View成员变量mBottom,通过getBottom()方法得到。 根据这两个点的坐标，可以计算出View的宽高：width = right - left;height = bottom - top;也可以通过getWidth()和getHeight()获取，内部的计算方式是一样的。 在Android3.0中View又增加了几个属性: x View左上角横坐标，通过getX()方法获得； y View左上角纵坐标，通过getY()方法获得； translationX View左上角相对于父容器在X轴上的偏移量，通过getTranslationX()方法获得； translationY View左上角相对于父容器在y轴上的偏移量，通过getTranslationY()方法获得； translationX和translationY的初始值都是0，x,y与left，top的对应关系：x = left + translationX;y = top + translationY;在View的平移动画中，View的left和top是View起始位置左上角的坐标，不随着动画的运行而改变，x和y随动画的运动而改变。可以认为这几个参数是为属性动画添加的，间接证明了属性动画在运行过程中可以修改View的属性值。 在Android5.0中View又增加了属性z和translationZ,这两个参数并不会影响View的大小，主要与View的阴影效果有关，z值越大，View的投影越大，可以认为是与Material Design相关的。 View的相关类MotionEvent触摸屏幕后产生的事件，比较常用的事件类型： ACTION_DOWN 手指刚触摸屏幕 ACTION_MOVE 手指在屏幕上移动 ACTION_UP 手指离开屏幕 ACTION_CANCEL 手势被取消时 通过MotionEvent可以获取事件发生的位置，getX()和getY()获取的是事件相对于View的坐标，getRawX()和getRawY()获取的是事件相对于屏幕的坐标。为了区别MotionEvent中事件的位置参数与View的位置参数整理为如下图示，图中蓝点表示事件的触发位置。 VelocityTacker用来追踪手指在滑动过程中的水平速度和竖直方向的速度。获取的速度可以是负值，当收拾滑动的方向与坐标系的方向相反时，得到的速度值是负值。获取速度之前必须要计算速度,通过调用computeCurrentVelocity()来实现。 12345678910111213141516171819@Override public boolean onTouchEvent(MotionEvent event) &#123; //添加速度追踪的事件 VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); //追踪1000ms内的速度 velocityTracker.computeCurrentVelocity(1000); int xVelocity = (int) velocityTracker.getXVelocity(); int yVelocity = (int) velocityTracker.getYVelocity(); Log.i(&quot;sguotao&quot;, &quot;xVelocity:&quot; + xVelocity); Log.i(&quot;sguotao&quot;, &quot;yVelocity:&quot; + yVelocity); //回收 velocityTracker.clear(); velocityTracker.recycle(); return super.onTouchEvent(event); &#125; GestureDector在GestueDector中定义了两个常用的接口，OnGestureListener和OnDoubleTapListener,通过这两个接口，可以完成诸如单击、快速滑动、拖动、长按、双击等动作的监测。如果只是监听滑动相关的，建议自己在onTouchEvent中实现，如果要监听双击这种行为的话，那么就使用GestureDetector。 View的滑动滑动在实际开发中非常常见，而且掌握滑动的方法是实现绚丽自定义控件的基础。实现View滑动的三种方式 方式一 scrollTo/scrollByView专门提供了scrollTo/scrollBy两个方法来实现滑动，scrollBy内部也是通过调用scrollTo方法实现的，使用这两个方法实现View的移动，只能将View的内容进行移动，不能将View本身进行移动。用一张图描述scrollTo/scrollBy两个方法的滑动效果。其中mScrollX表示View左边缘和View中内容的左边缘在水平方向的距离，mScrollY表示View上边缘和View中内容的上边缘在竖直方向的距离。 方式二 动画给View添加平移效果实现滑动使用平移动画也可以实现View的滑动，在Android3.0中引入了属性动画后，我们可以通过操作View的translationX和translationY这两个属性实现动画的平移。使用动画的方式，操作简单，适用于没有交互的View和复杂动画效果的场景。 12//targetView在100ms内向右平移100像素ObjectAnimator.ofFloat(targetView,&quot;translationX&quot;,0,100).setDuration(100).start(); 方式三 通过改变View的LayoutParams使View重新布局实现滑动通过改变View布局参数的方式，操作起来复杂，适合有交互View的场景。 1234ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) targetView.params.width += 100; params.leftMargin += 100; targetView.requestLayout(); //或者targetView.setLayoutParams(params); View的弹性滑动所谓的弹性滑动，就是在让滑动以一种渐进的方式进行。 方式一 使用ScrollerScroller本身无法让View弹性滑动，它需要和View的computeScroll方法配合使用才能共同完成这个功能。具体实现过程： 123456789101112131415161718Scroller scroller = new Scroller(mContext); //弹性滑动到指定位置 private void smoothScrollTo(int destX, int destY) &#123; int scrollX = getScrollX(); int delta = destX - scrollX; // 1000ms内滑向destX，效果就是慢慢滑动mScroller. startScroll(scrollX, 0, delta, 0, 1000); invalidate(); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; &#125; 用一张图来表示Scroller实现弹性滑动的过程，总结一下，Scroller本身并不能实现View的滑动，它需要配合View的computeScroll方法才能完成弹性滑动的效果，它不断地让View重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得出View当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成View的滑动。就这样，View的每一次重绘都会导致View进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动，这就是Scroller的工作机制。 方式二 通过动画动画本身就是一个渐进的效果，利用动画天然自带滑动效果。1ObjectAnimator.ofFloat(targetView,&quot;translationX&quot;,0,100).setDuration(100).start(); 方式三 使用延时策略通过使用Handler或View的postDelayed方法，也可以使用线程的sleep方法。来实现渐进式的滑动效果。 123456789101112131415161718192021222324private static final int MESSAGE_SCROLL_TO = 1; private static final int FRAME_COUNT =30; private static final int DELAYED_TIME =33; private int mCount = 0; @SuppressLint(&quot; HandlerLeak&quot;) private Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_SCROLL_TO: &#123; mCount++; if (mCount &lt;= FRAME_COUNT)&#123; float fraction = mCount / (float) FRAME_COUNT; int scrollX = (int) (fraction * 100); targetView.scrollTo(scrollX, 0); mHandler.sendEmptyMessageDelayed(MESSAGE_SCROLL_TO, DELAYED_TIME); &#125; break; &#125; &#125; &#125; ; &#125;; 滑动冲突的处理当界面中出现内外两层同时可以滑动的情况，就有可能会出现滑动冲突。出现滑动冲突可以用一张图来描述： 场景一 外部滑动方向和内部滑动方向不一致这种场景主要描述的是内外两层View出现滑动方向不一致的情况，如外层View左右滑动，内层View上下滑动，或者外层View上下滑动，内层View所有滑动。常见的ViewPager与Fragment组合使用中出现的滑动效果，在这种效果中左右滑动来切换页面，如果每个页面内部又使用了ListView,就有可能会出现滑动冲突，但ViewPager内部处理了这种滑动冲突，如果不是ViewPager而是ScrollView，就会出现这种类型的滑动冲突。 处理场景一中描述的滑动冲突规则：分清是水平滑动还是竖直滑动，来决定哪一层来拦截事件。如图中描述的情况，如果是左右滑动，外层View来拦截事件处理，如果是上下滑动，内层View来拦截事件处理。 具体实现上，可以根据滑动过程中两个点的坐标，来判断滑动距离，滑动角度等。 场景二 外部滑动方向和内部滑动方向一致这种场景主要描述的是内外两层View滑动方向一致的情况，如外层View和内层View同时左右滑动或者同时上下滑动。 处理场景二中描述的滑动冲突，就需要结合具体的业务逻辑来进行区分。 场景三 以上两种场景的嵌套这种场景主要描述的是以上两种场景的组合情况。 处理场景三种描述的滑动冲突与场景二一样，也需要结合具体的业务逻辑来进行区分。 解决冲突的两种方法方法一 外部拦截法所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题。 外部拦截法的实现过程：在父容器的onInterceptTouchEvent方法中： 首先是ACTION_DOWN这个事件，父容器必须返回false，即不拦截ACTION_DOWN事件，这是因为一旦父容器拦截了ACTION_DOWN，那么后续的ACTION_MOVE和ACTION_UP事件都会直接交由父容器处理，这个时候事件没法再传递给子元素了； 其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回true，否则返回false； 最后是ACTION_UP事件，这里必须要返回false，因为ACTION_UP事件本身没有太多意义。考虑一种情况，假设事件交由子元素处理，如果父容器在ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素中的onClick事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInterceptTouchEvent方法在ACTION_UP时返回了false。 方法二 内部拦截法内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和Android中View的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。内部拦截法的实现过程：在子View中需要重写dispathTouchEvent() 123456789101112131415161718192021public boolean dispatchTouchEvent(MotionEventevent) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN:&#123; parent.requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_MOVE:&#123; int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件))&#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; &#125; case MotionEvent.ACTION_UP:&#123; break; &#125; default: break; &#125; return super.dispatchTouchEvent(event); &#125; 除此之外，父容器要拦截除ACTION_DOWN外的所有事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。为什么父容器不能拦截ACTION_DOWN事件呢？那是因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传递到子元素中去，这样内部拦截就无法起作用了。父元素所做的修改如下所示。 12345678public boolean onInterceptTouchEvent(MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_ DOWN)&#123; return false; &#125; else&#123; return true; &#125;&#125; 参考文献[1] 任玉刚.Android开发艺术探索[M].电子工业出版社, 2015.9:1 - 507 本文链接：http://www.sguotao.top/Android进阶-2016-07-05-初探Android中的View.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java String的不可变性]]></title>
    <url>%2FJava-2016-06-15-Java-String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7.html</url>
    <content type="text"><![CDATA[Java String类有一个特点，即它是一个不可变类，一旦被实例化后，就无法被修改。于是就有一个疑问，为什么将String类设计成不可变的？这样设计有什么好处呢？ 什么是不可变对象？一个对象在其被实例化完成后，不能够改变其成员变量，包括基本数据类型的值不能够改变及引用类型索引的对象也不能够被修改。 String的不可变性String类的实例变量，存在一块特殊区域，这部分区域可以称为字符串池，这是在堆存储区中，方法区中的一部分存储区域。当一个字符串被创建的时候，会在字符串池中查找，如果找到，则直接返回该字符串的引用。比如： 123//声明两个字符串String str1 = "abcd";String str2 = "abcd"; 用图来表示这两个字符串的声明过程：在声明str2时，在字符串池中存在“abcd”，因此直接将“abcd”的引用返回。 对象和对象的引用下面一段代码，先看代码： 123String str1 = "abcd"str1="1234"System.out.println(str1); 打印结果”1234”。很容易让人产生一个误区，str1的值是改变的，怎么解释呢？这里需要区分一下对象及对象的引用。对象是存放在堆内存中的，类的实例。引用，存放在栈内存中的，存放指向堆内存中对象的索引。上面这段代码的执行过程可以用下面的图形表示：str1只是一个引用，它指向一个具体的对象，当str1=”1234”执行时，创建了一个新的对象”1234”,引用str1指向了这个新对象，原来的对象“abcd”还存在内存中，没有发生改变。 String的不可变性有哪些特点 线程安全，不可变对象不能够被改变，所以可以再多线程之间共享，不需要任何同步处理。 高效性，在String中的源码中 12//this is used to cache hash code.private int hash; 由于String是不可变的，随意一旦对象被创建，该Hash值也无法修改。所以在使用该对象的hashcode时，可以直接返回。比如在HashMap中，字符串对象的hashcode不可变且永远唯一，这就意味着使用在HashMap中的字符串时，不需要重新计算hashcode值，更加的高效。 本文链接：http://www.sguotao.top/Java-2016-06-15-Java-String的不可变性.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实现点赞效果]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-06-13-Android%E5%AE%9E%E7%8E%B0%E7%82%B9%E8%B5%9E%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[最近接到一个需求，需求中有个点赞动画的需求。决定使用属性动画的方式来实现。其实使用传统的动画，也可以实现相同的效果，出于传统动画会重复调用onDraw()方法进行绘制，可能会存在一些内存和性能的问题。 添加平移动画先来实现一个简单的平移动画，查看一下效果： 123ObjectAnimator translationY = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0f, -100f);translationY.setDuration(1000);translationY.start(); 添加渐变动画再加入一个渐变的效果，查看一下效果： 12345678//translate动画ObjectAnimator translationY = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0f, -100f);//alpha动画ObjectAnimator alpha = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1f, 0f);AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(translationY).before(alpha);animatorSet.setDuration(1000);animatorSet.start(); 实现+1效果怎样实现+1的效果呢？可以考虑添加TextView，通过监听动画的状态实现对TextView显示状态的控制，查看一下运行效果： 1234567891011121314151617181920212223242526272829303132final TextView tv = (TextView) findViewById(R.id.tv); //translate动画 ObjectAnimator translationY = ObjectAnimator.ofFloat(tv, &quot;translationY&quot;, 0f, -100f); //alpha动画 ObjectAnimator alpha = ObjectAnimator.ofFloat(tv, &quot;alpha&quot;, 1f, 0f); alpha.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; tv.setVisibility(View.VISIBLE); &#125; @Override public void onAnimationEnd(Animator animation) &#123; tv.setVisibility(View.GONE); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.play(translationY).with(alpha); animatorSet.setDuration(1000); animatorSet.start(); 封装成View考虑到后期的扩展性和可维护性，将上面这个动画封装成一个自定义View。 本文链接：http://www.sguotao.top/Android进阶-2016-06-13-Android实现点赞效果.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的Drawable Animation]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-05-19-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Drawable-Animation.html</url>
    <content type="text"><![CDATA[在上一篇中对Android传统动画中的View动画进行了一些整理，Android动画分析一 View Animation 在这一篇中，将对Android传统动画中的Drawable动画进行整理。什么是Drawable动画，Drawable动画是将一些列的Drawable资源一个接一个的播放，从而产生动画的效果，可以理解为是Frame Animation。 Drawable Animation这里介绍实现Drawable Animation的两种方式，一种是使用&lt;animation-list&gt;标签，一种是使用AnimationDrawable对象。 Drawable动画的示例在res/drawable目录下定义一个动画文件(注:不是res/anim目录)，文件的根节点是&lt;animation-list&gt;其中android:oneshot属性当值为true时,动画只执行一次，当值为false时，动画重复执行。 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/upgrade_notification01&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/upgrade_notification02&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/upgrade_notification03&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/upgrade_notification04&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/upgrade_notification05&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/upgrade_notification06&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; 在Activity中处理的逻辑: 123456789101112131415161718192021ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test_view_animation); imageView = (ImageView) this.findViewById(R.id.imageView); Button mButton = (Button) this.findViewById(R.id.button); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AnimationDrawable drawableAnim = (AnimationDrawable) imageView.getBackground(); if (drawableAnim.isRunning()) &#123; drawableAnim.stop(); &#125; else &#123; drawableAnim.start(); &#125; &#125; &#125;); &#125; Drawable动画显示效果实现一个下载提示的动画: 一点引申在实现Drawable动画过程中,做一点引申: 定义的xml动画文件根元素是&lt;animation-list&gt;，存放在res/drawable目录，如果放在其他目录，会出现警告，但不影响正常的编译。 AnimationDrawable的start()方法不能够在Activity的onCreate()调用，因为这个时候，AnimationDrawable可能还没有绑定到Window上，如果想实现进入Activity后直接播放动画，可以在onWindowFocusChanged()方法里面调用，因为这个方法是在window已经获取到焦点之后回调的，可以保证已经绑定结束。 在ImageView设置动画时，需要区分&lt;ImageView&gt;的src属性和background属性，在这个示例中，如果使用src属性，会出现NPE异常。出现异常的原因与src属性的绘制时机有关。background属性是view的属性，Android系统提供的所有控件都有该属性，在View的onDraw之前，就已经被绘制。而src属性是ImageView的特有属性，在ImageView的onDraw()方法中才会被绘制。 参考文献drawable-animation 本文链接：http://www.sguotao.top/Android进阶-2016-05-19-分析Android中的Drawable-Animation.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的View Animation]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2016-05-18-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84View-Animation.html</url>
    <content type="text"><![CDATA[在进行Android动画内容整理的时候，发现Android的动画有很多，如官方文档中直接给出的有Property Animation、View Animation、Drawable Animation，还有平时接触比较多的帧动画（Frame Animation）和补间动画（Tweened Animation）等，这些概念需要进行一下梳理。 Android的动画可以分为两类，传统动画和Android3.0之后出现的属性动画(Property Animation)，其中传统动画又包括帧动画(Frame Animation)和补间动画(Tweened Animation)，帧动画的工作原理，类似于动画片，将一个完成的动画拆分为一张张的图片，然后连起来进行播放；补间动画是对View进行的一系列操作，包括淡入淡出(Alpha)，缩放(Scale)，旋转(Rotate)和平移(Translate)。Drawable Animation是将一些列的Drawable资源一个接一个的播放，从而产生动画的效果，可以理解为是Frame Animation。类似的，View Animation可以理解为是Tweened Animation。用一张图来说明一下这几种动画之间的关系。 View AnimationView Animation视图动画，只能作用在View上，完成一些基本的动画，淡入淡出，缩放，旋转和平移，以及这些基本动画的组合。视图动画的实现方式有两种，通常在res/anim目录下定义一个xml文件，xml的根元素可以是&lt;alpha&gt;、&lt;scale&gt;、&lt;rotate&gt;、&lt;translate&gt;及&lt;set&gt;。在&lt;set&gt;中定义了一个动画集，包括四种基本动画，也可以包括一个子&lt;set&gt;。另外一种方式，直接使用这些标签对应的Java类，也可以实现相同的效果。View Animation的类图如下所示。在介绍几种基本动画之前，先介绍一下动画的一些共有属性，四种基本动画除了继承了这些基本属性外，还有一些自身的属性，这些特有属性的介绍，会在每类动画介绍中做详细的说明。这些共有属性包括： XML Attribute Description android:detachWallpaper 设置是否在壁纸上运行，只对设置了壁纸背景的窗口动画(window animation)有效。设为true，则动画只在窗口运行，壁纸背景保持不变 android:duration 动画从开始到结束持续的时长，单位为毫秒 android:fillAfter 设置为true时，动画执行完后，View会停留在动画的最后一帧；默认为false；如果是动画集，需在&lt;set&gt;标签中设置该属性才有效 android:fillBefore 设置为true时，动画执行完后，View回到动画执行前的状态，默认即为true android:fillEnabled 设置为true时，android:fillBefore的值才有效，否则android:fillBefore会被忽略 android:interpolator 设置动画速率的变化，比如加速、减速、匀速等，需要指定Interpolator资源 android:repeatCount 设置动画重复执行的次数，默认为0，即不重复；可设为-1或infinite，表示无限重复 android:repeatMode 设置动画重复执行的模式，可设为以下两个值其中之一：restart 动画重复执行时从起点开始，默认为该值;reverse 动画会反方向执行 android:startOffset 设置动画执行之前的等待时长，毫秒为单位；重复执行时，每次执行前同样也会等待一段时间 android:zAdjustment 表示被设置动画的内容在动画运行时在Z轴上的位置，取值为以下三个值之一：normal 默认值，保持内容在Z轴上的位置不变;top 保持在Z周最上层;bottom 保持在Z轴最下层 &lt;alpha&gt;(淡入淡出)&lt;alpha&gt;可以实现淡入淡出的渐变效果。 alpha动画属性对应AlphaAnimation，alpha动画有两个特有的属性： XML Attribute Description android:fromAlpha 动画开始时的透明度，0.0为全透明，1.0为不透明，默认为1.0 android:toAlpha 动画结束时的透明度，0.0为全透明，1.0为不透明，默认为1.0 alpha动画构造方法12345678910111213/** * 需要在res中定义属性集(不常使用） * @param context 上下文 * @param attrs 属性集 */public AlphaAnimation(Context context, AttributeSet attrs)/** * 在构造法方法中指定动画开始和结束时的透明度(常用方法) * @param fromAlpha 动画开始时的透明度 * @param toAlpha 动画结束时的透明度 */public AlphaAnimation(float fromAlpha, float toAlpha) alpha动画示例123456789101112final ImageView imageView = (ImageView) this.findViewById(R.id.imageView);Button mButton = (Button) this.findViewById(R.id.button);final AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f,1.0f);alphaAnimation.setDuration(3000);mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; imageView.startAnimation(alphaAnimation); &#125;&#125;); &lt;scale&gt;(缩放)&lt;scale&gt;可以实现缩放的效果。 scale动画属性对应ScaleAnimation，scale动画有以下的特有属性： XML Attribute Description fromX 动画开始时X坐标上的缩放尺寸，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大 toX 动画结束时X坐标上的缩放尺寸，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大 fromY 动画开始时Y坐标上的缩放尺寸，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大 toY 动画结束时Y坐标上的缩放尺寸，0.0表示缩放到没有，1.0表示正常无缩放，小于1.0表示收缩，大于1.0表示放大 pivotX 缩放动画相对的固定点X坐标 pivotY 缩放动画相对的固定点Y坐标 pivotXType 缩放动画相对的固定点X坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT pivotXValue 缩放动画相对的固定点X坐标的位置，与pivotXType相关 pivotYType 缩放动画相对的固定点Y坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT pivotYValue 缩放动画相对的固定点Y坐标的位置，与pivotYType相关 scale动画构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 自定义动画时需要重写的方法 * @param context 上下文 * @param attrs 属性集 */public ScaleAnimation(Context context, AttributeSet attrs)/** * * @param fromX 动画开始时X坐标上的缩放尺寸 * @param toX 动画结束时X坐标上的缩放尺寸 * @param fromY 动画开始时Y坐标上的缩放尺寸 * @param toY 动画结束时Y坐标上的缩放尺寸 */public ScaleAnimation(float fromX, float toX, float fromY, float toY)/** * 指定一个固定点,进行动画,固定点的坐标是(pivotX,pivotY) * 第二个构造方法默认固定点的坐标是(0,0),即动画view的的左上角 * * @param fromX 动画开始时X坐标上的缩放尺寸 * @param toX 动画结束时X坐标上的缩放尺寸 * @param fromY 动画开始时Y坐标上的缩放尺寸 * @param toY 动画结束时Y坐标上的缩放尺寸 * @param pivotX 固定点的X坐标坐标,取值为0时表示动画view的左边沿 * @param pivotY 固定点的Y坐标坐标,取值为0时表示动画view的上边沿 */public ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)/** * 通过pivotXType,pivotXValue,pivotYType和pivotYValue确定一个固定点进行动画 * 第三个构造方法中,固定点默认的位置类型(pivotXType、pivotYType)为 Animation.ABSOLUTE * * @param fromX 动画开始时X坐标上的缩放尺寸 * @param toX 动画结束时X坐标上的缩放尺寸 * @param fromY 动画开始时Y坐标上的缩放尺寸 * @param toY 动画结束时Y坐标上的缩放尺寸 * @param pivotXType 固定点X坐标位置的类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.) * @param pivotXValue 固定点X坐标坐标,位置与pivotXType有关 * @param pivotYType 固定点Y坐标位置的类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.) * @param pivotYValue 固定点Y坐标坐标,位置与pivotYType有关 */public ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 这里有必要对这几个构造方法进行一些说明： 第二个构造方法public ScaleAnimation(float fromX, float toX, float fromY, float toY)固定点的默认坐标是(0,0)，即要发生动画view的左上角，通过该构造方法创建的缩放动画，都是相对于该固定点进行的。 第三个构造方法public ScaleAnimation(float fromX, float toX, float fromY, float toY,float pivotX, float pivotY)固定点的坐标可以指定为(pivotX,pivotY),即相对于发生动画view的左上角距离(pivotX,pivotY)的位置，通过该构造方法创建的缩放动画,都是相对这个指定的点进行的。 第四个构造方法public ScaleAnimation(float fromX, float toX, float fromY, float toY,int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)对固定点位置的确定有了更多的方式，固定点位置的确定主要与pivotXType, pivotXValue, pivotYType, pivotYValue这四个值有关。通常pivotXType和pivotYType的值都指定为同一种类型。 当pivotXType和pivotYType为Animation. ABSOLUTE时，与第三个构造方法效果相同，即第三个构造方法默认的pivotXType和pivotYType为Animation. ABSOLUTE。 当pivotXType和pivotYType为Animation.RELATIVE_TO_SELF，固定点的位置相对于动画view，固定点的坐标为(width*pivotXValue,height*pivotYValue),其中width为动画view的宽，height为动画view的高。 当pivotXType和pivotYType为Animation.RELATIVE_TO_PARENT，固定点的位置相对于动画view的父容器view，固定点的坐标为(parentWidth*pivotXValue,parentHeight*pivotYValue),其中parentWidth为父容器view的宽，parentHeight为父容器的高。 scale动画示例12345678910//固定点位置相对于imageview,固定点坐标为imageview的中心 final ScaleAnimation scaleAnimation = new ScaleAnimation(0.5f, 1.0f, 0.5f, 1.0f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); scaleAnimation.setDuration(3000); scaleAnimation.setFillAfter(true);//动画结束时,保持结束的位置不变 mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; imageView.startAnimation(scaleAnimation); &#125; &#125;); &lt;rotate&gt;(旋转)&lt;rotate&gt;可以实现旋转的效果。 rotate动画属性对应RotateAnimation，rotate动画有以下的特有属性： XML Attribute Description fromDegrees 旋转开始的角度，旋转角度从0到360 toDegrees 旋转结束的角度，旋转角度从0到360 pivotX 旋转中心相对的X坐标 pivotY 旋转中心相对的Y坐标 pivotXType 旋转动画中心X坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT pivotXValue 旋转动画中心X坐标的位置，与pivotXType相关 pivotYType 旋转动画中心Y坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT pivotYValue 旋转动画中心Y坐标的位置，与pivotYType相关 rotate动画构造方法12345678910111213141516171819202122232425262728293031323334/** * * @param context * @param attrs */public RotateAnimation(Context context, AttributeSet attrs)/** * 旋转中心的位置(0,0) * @param fromDegrees 旋转动画开始角度 * @param toDegrees 旋转动画结束角度 */public RotateAnimation(float fromDegrees, float toDegrees)/** * 旋转中心相对(0,0)的位置(pivotX,pivotY) * @param fromDegrees 旋转动画开始角度 * @param toDegrees 旋转动画结束角度 * @param pivotX 旋转中心x坐标 * @param pivotY 旋转中心y坐标 */public RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)/** * 通过pivotXType,pivotXValue,pivotYType和pivotYValue确定旋转中心 * @param fromDegrees 旋转动画开始角度 * @param toDegrees 旋转动画结束角度 * @param pivotXType 旋转动画中心x坐标位置类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.) * @param pivotXValue 旋转动画中心x坐标的位置,与pivotXType相关 * @param pivotYType 旋转中心y坐标位置类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.) * @param pivotYValue 旋转动画中心y坐标的位置,与pivotYType相关 */public RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) rotate动画示例123456789101112final ImageView imageView = (ImageView) this.findViewById(R.id.imageView);Button mButton = (Button) this.findViewById(R.id.button);final RotateAnimation rotateAnimation = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);rotateAnimation.setDuration(3000);rotateAnimation.setFillAfter(true);//动画结束时,保持结束的位置不变mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; imageView.startAnimation(rotateAnimation); &#125;&#125;); &lt;translate&gt;(平移)&lt;translate&gt;可以实现平移的动画效果。 translate动画属性对应TranslateAnimation，translate动画有以下特有的属性： XML Attribute Description fromXDelta 平移动画开始点X坐标 toXDelta 平移动画结束点X坐标 fromYDelta 平移动画开始点Y坐标 toYDelta 平移动画结束点Y坐标 fromXType 平移动画开始点X坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT fromXValue 平移动画开始点X坐标位置，与fromXType有关 toXType 平移动画结束点X坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT toXValue 平移动画结束点X坐标位置，与toXType有关 fromYType 平移动画开始点Y坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT fromYValue 平移动画开始点坐标位置，与fromYType有关 toYType 平移动画结束点Y坐标位置类型，取值为以下三个值之一：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT toYValue 平移动画结束点坐标位置，与toYType有关 translate动画构造方法123456789101112131415161718192021222324252627282930/** * * @param context 上下文 * @param attrs 属性集 */public TranslateAnimation(Context context, AttributeSet attrs)/** * 平移动画的起点位置和结束位置坐标都是相对于(0,0)即动画view的左上角. * @param fromXDelta * @param toXDelta * @param fromYDelta * @param toYDelta */public TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)/** * 通过构造参数确定平移动画的起始位置和结束位置的坐标 * * @param fromXType 开始点x坐标位置类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.) * @param fromXValue 开始点x坐标位置,与fromXType有关 * @param toXType 结束点x坐标类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.) * @param toXValue 结束点x坐标位置,与toXType有关 * @param fromYType 开始点y坐标类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.) * @param fromYValue 开始点y坐标位置,与fromYType有关 * @param toYType 结束点y坐标类型,取值范围(Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, or Animation.RELATIVE_TO_PARENT.) * @param toYValue 结束点y坐标类型,与toYType有关 */public TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue) translate动画示例12345678910final TranslateAnimation translateAnimation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 1.0f, Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 1.0f);translateAnimation.setDuration(3000);translateAnimation.setFillAfter(true);//动画结束时,保持结束的位置不变mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; imageView.startAnimation(translateAnimation); &#125;&#125;); &lt;set&gt;动画集&lt;set&gt;是一系列动画的集合，对应AnimationSet,可以实现一些动画的组合。在AnimationSet的构造方法中， 1234567891011/** * Constructor to use when building an AnimationSet from code * * @param shareInterpolator Pass true if all of the animations in this set * should use the interpolator associated with this AnimationSet. * Pass false if each animation should use its own interpolator. */ public AnimationSet(boolean shareInterpolator) &#123; setFlag(PROPERTY_SHARE_INTERPOLATOR_MASK, shareInterpolator); init(); &#125; 当使用代码方式创建动画集时，需要使用到这个构造方法，构造方法需要一个boolean值，当为true时，动画集中的动画使用animationSet的插值器，当为false时，使用每个动画自己的插值器。这里有一个问题，什么是插值器？ Interpolator在Android API 11以前，插值器是Interpolator的直接翻译过来的名称，在Android API 11以后，加入了TimeInterpolator接口。什么是插值器？插值器定义了动画的运行轨迹，如加速和减速等。粗略统计了一下，Android API中关于插值器的接口，抽象类和实现类大概有16个，为了清晰的理解这些接口和类的关系，先抛出一张类图。这么多的实现类，每个插值器实现类的作用是什么？区别又是什么？在TimeInterpolator接口中声明了一个方法 12345678910111213/** * Maps a value representing the elapsed fraction of an animation to a value that represents * the interpolated fraction. This interpolated value is then multiplied by the change in * value of an animation to derive the animated value at the current elapsed animation time. * * @param input A value between 0 and 1.0 indicating our current point * in the animation where 0 represents the start and 1.0 represents * the end * @return The interpolation value. This value can be more than 1.0 for * interpolators which overshoot their targets, or less than 0 for * interpolators that undershoot their targets. */ float getInterpolation(float input); 该函数将当前动画运行的点input映射到一个插值函数中。不同的插值器实现类，对应这不同的插值函数。比如在插值器AccelerateInterpolator中，对应的插值函数是一个抛物线。抛物线的斜率跟mFactor参数有关，mFactor的值越大，抛物线的曲率越大。对应的动画效果是开始阶段动画比较慢，此后会越来越快。 1234567public float getInterpolation(float input) &#123; if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125; &#125; 对一些插值器的效果进行一个简单的描述，具体的运动效果，与对应的插值函数有关。 参考文献prop-animationview animationdrawable-animationAnimationAlphaAnimationRotateAnimationScaleAnimationTranslateAnimationAnimationSetandroid动画（一）Interpolator 本文链接：http://www.sguotao.top/Android进阶-2016-05-18-分析Android中的View-Animation.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和光同尘，静水流深]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2016-05-09-getdown-to-my-work.html</url>
    <content type="text"><![CDATA[北京时间，2016年5月1日，完成了自己人生中一件非常重要的事情，我结婚了，当自己去看婚礼视频的时候，那因紧张而僵硬的表情，在大方自如的媳妇面前，感觉是那么的不协调，我对自己说，我是多么的幸运，能遇到这样的女孩，同时，我也感到一份支撑，一种依靠。2016，我不再单打独斗了。 总想快速从结婚的喜悦中调整到繁忙的工作中来，2016年，对于公司也是非常重要的一年，能成为其中的一员，见证公司和自己的成长，我想着本身也是一种缘分，希望自己能在2016年剩下的日子里，看到自己持续的成长。 今天看到一篇博客，其中的一些文字，让自己感触很深： 好奇心比雄心走得更远：很多人对未来空有满腔的雄心壮志，往往不如对技术要有一份好奇心，一份探索欲，再加上一份执着的人。 要有open的心态：曾经的我也只是把自己的所思所得都放入自己的云笔记，很少整理，这其实不利于技术发展，有空应该多整理自己零散的知识点，觉得不错的点可以拿出来写成博客，那是对能力的又一层提升。另外，在低头做技术的同时，还应该有空抬头看世界，不能闭门造车。 天道酬勤：学历只能代表过去，能力代表现在，潜力代表未来！ 你不把自己逼一把，你压根不知道自己有多优秀，只要努力去学习，去挖掘潜力，进而提升自我技术修为，未来不再是梦！共勉之！ 解决问题的方式：遇到问题，一定要先尝试自己解决，解决不了再请教他人。这是对自己的一个锻炼，也是对他人的一个尊重，可以有多种途径自行搜索： 百度一下，很多时候还是能有所帮助的，不要过分强调google，完全抛弃百度，毕竟中文看起来比较快； 先中文关键词google一下；再英文关键词google一下； stackoverflow.com、知乎等技术问答网站内直接搜索； 查看官方文档； 如果有源码，尝试直接看源码，看能否解决； 有空可以多逛逛github，多看看Google官方文档，多关注社区，定会收获不少； 当然，最最重要的是能静得下心，持之以恒地专研技术。 以前，自己总是用“和光同尘，静水流深”来勉励自己，现在更加觉着这句话的重要。浮躁是在自己这个年纪，甚至是现在这个社会，比较普遍的现象。希望自己不要眼高手低，脚踏实地的走好现在的路，低调做人，高调做事。 本文链接：http://www.sguotao.top/生活感悟-2016-05-09-getdown-to-my-work.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书笔记】解忧杂货店]]></title>
    <url>%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2016-02-20-%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97.html</url>
    <content type="text"><![CDATA[真的要到很久之后，才会明白，每一个选择只要努力过，都是正确的选择。 几个看似独立的故事，互相都存在羁绊，让人觉着这是发生在小镇里一个个普普通通的故事，但正式因为平凡，才有撼动人心的力量。 回答在牛奶箱里深爱的男友身患绝症，年轻的女孩在爱情和梦想间徘徊。 有一天，我对他说：“我比任何人都爱你，想要永远和你在一起，如果我放弃比赛就能让你好起来，我会毫不犹豫地放弃。但如果不是这样，我希望坚持我对梦想。因为一直以来追寻着梦想，我才活出了自我，而你喜欢的也正是这样的我。我没有一刻忘记过你，但请让我去追逐梦想吧。”听完这番话，病床上的他流下泪来。他对我说：“我早就在等你这句话了。看到你为了我而烦恼，我很难过。让深爱的人放弃梦想，这比死还让我痛苦。即使分隔两地，我们的心也会永远在一起。你不要有任何顾虑，我希望你无怨无悔地去追寻梦想。” 年轻女孩找到了阅读自己地图的方法，从那天起，她不再迷茫，重新投身到训练中，因为她明白，陪伴在他身边并不是照顾他的唯一方式。深爱的男友还是离开了人世，但女孩从他临终时满足的表情，和那句“谢谢你带给我的梦想”，得到了更有价值的东西。 深夜的口琴声克郎为了音乐梦想离家漂泊，却在现实中寸步难行。 你对音乐的执着追求，绝不是白白付出。我相信，将会有人因为你的歌而得到救赎。你创作的音乐也必将流传下去。请你始终坚信这一点，坚信到生命最后一刻。 当克朗扛着少年在火力奔跑，他自己也不知道往哪儿跑，红光与黑暗，同时将他包围。在他生命最后一刻，仍要坚持相信。这里我看到的不是为了梦想的执着坚持，打动我的反而是父亲的支持。我们焦虑，是因为我们找不到问题的答案，徘徊在是与非的选择上，其实，每一个选择只要努力过，都是正确的选择。 在思域车上等到天亮绿河怀了有妇之夫的孩子，为应该生下来还是堕胎而纠结。 虽然至今为止的道路绝非一片坦途，但想到正因为活着才有机会感受到痛楚，我就成功克服了种种恐惧。 听着披头士默祷少年浩介面临家庭巨变，挣扎在亲情与未来的迷茫中。人与人之间情断义绝，并不需要什么具体的理由。就算表面上有，也很可能只是心离开的结果，事后才编造出的借口而已。因为倘若心没有离开，当将会导致关系破裂的事态发生时，理应有人努力去挽救。如果没有，说明其实关系早已破裂。 关于家人，除了积极向上的旅行，家人应该尽可能在一起。因为反感、厌倦等理由而离开，不是家人应有的姿态。无论现在多么不开心，你要相信，明天会比今天更好。 来自天上的祈祷 如果把来找我咨询的人比喻成迷途的羔羊，通常他们手上都有地图，却没有去看，或是不知道自己目前的位置。但我相信你不属于这两种情况。你的地图是一张白纸，所以即使想决定目的地，也不知道路在哪里。地图是一张白纸，这当然很伤脑筋。任何人都会不知所措。可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己。对你来说，一切都是自由的，在你面前是无限的可能。这可是很棒的事啊。我衷心祈祷你可以相信自己，无悔地燃烧自己的人生。 这是浪矢杂货店最后的一封回信，不知道是不是初为人父的关系，看到这里，想到了四个月大，能冲我咿咿呀呀的女儿，我想，上面似乎也是我想对女儿说的话。就像希拉里说的一样“我第一次成为你的母亲，你第一次成为我的女儿，让我们彼此关照，共同成长”。如果将来的某一天，女儿也像小说中的人物，在人生的十字路口，不知道该何去何从时，我能否像浪矢杂货店的爷爷一样，告诉她看地图的方式。我多想告诉她，要到很久之后，你就会明白，每一个选择只要努力过，都是正确的选择。 本文链接：http://www.sguotao.top/读书笔记-2016-02-20-解忧杂货店.html]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>解忧杂货店</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【RxJava】一 RxJava是什么]]></title>
    <url>%2FRxJava-2016-01-25.html</url>
    <content type="text"><![CDATA[1.RxJava是什么？GitHub官方给出的解释： RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM. 即一个运行在JVM上的库，通过一个可观测的序列，组成的异步的、基于事件的程序。 2.为什么要使用RxJava?在平时的开发中，当遇到如进行访问网络请求，数据库的查询操作，文件读写操作等耗时操作时，都会放在子线程中来进行。让复杂的业务逻辑，回归简单和清晰。 Rx模式以及优点1，使用观察者模式； 创建：Rx可以方便的创建事件流和数据流； 组合：Rx使用查询式的操作符组合和变换数据流； 监听：Rx可以订阅任何可观察数据流并执行操作；2，简化代码 函数式风格:对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态； 简化代码:Rx的操作符通常可以将复杂的难题简化成为很少的几行代码； 异步错误处理:传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制； 轻松使用并发:Rx的Observerables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题。 3.怎样使用RxJava?响应式编程 Rx提供了一系列的操作符，你可以使用它们来过滤（filter）、选择（select）、变换（transform)、 结合（combine)和组合（compose)多个Observable，这些操作符让执行和复合变得非常高效。 你可以把Observable当做Iterable的推送方式的等价物，使用Iterable,消费者从生产者哪里获取数据， 线程阻塞直至数据准备好。使用Observable，在数据准备好时，生产者将数据推送给消费者。数据可以同步 或异步的到达，这种方式更灵活。 RxAndroid响应式开发 1，Rx是响应式编程的意思，本质是观察者模式，是以观察者（Observer）和订阅者（Subscriber)为基础的异步响应方式。2，在Android编程时，经常会使用后台线程，那么就可以使用这种方式，目前的异步编程方式都会导致一些问题，如： Asynctasks can easily lead to memory leaks.CursorLoaders with a ContentProvider require a large amount of configuration and boilerplate code to setup.Services are intentded for longer running background tasks and not fast-finishing operations,such as makinga network call or loading content from a database.访问网络接口调用返回数据，尤其在使用接口回调时，处理数据比较麻烦。 创建观察者 在异步模型中创建观察者； 定义一个方法，它完成某些任务，然后从异步调用中返回一个值，这个方法时观察者的一部分。 将这个异步调用本身定义为一个Observable 观察者通过订阅（Subscribe)操作关联到那个Observable； 继续业务逻辑，等方法返回时，Observable会发射结果，观察者的方法会开始处理结果或结果集； RxJava的观察者模式 观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感， 需要在B变化的一瞬间做出反应。 RxJava有四个基本概念： Observable（可观察者,即被观察者） Observer（观察者） subscribe（订阅） 事件 Observable和Observer通过subscribe()方法实现订阅关系，从而Observerable可以在需要的时候发出事件来通知Observer。 RxJava基本实现 1.创建Observer Observer即观察者，它决定事件触发的时候将有怎样的行为。RxJava中的Observer接口实现方式： 2.创建Observable Observable即被观察者，它决定什么时候触发事件以及触发怎样的事件。RxJava使用create()方法 来创建一个Observable，并为它定义事件触发规则； 3.Subscribe(订阅) 创建了Observable和Observer之后，再用subscribe()方法将它们联结起来，整条链子就可以工作了。 参考内容https://github.com/ReactiveX/RxJava 本文链接：http://www.sguotao.top/RxJava-2016-01-25.html]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听了好多道理，却还是做不好工作]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2015-12-30-executive-ability.html</url>
    <content type="text"><![CDATA[文章来源：微信公众号 海尔的企业文化内刊上，刊着一张员工砸冰箱的黑白照片。这件事发生在1985年，海尔公司涣散不堪，只能长期靠借钱维持工厂运营。砸冰箱事件源于一封举报信，用户反映海尔的电冰箱有质量问题。经检查，这类不合格的冰箱还有76台，张瑞敏当即决定把冰箱全部砸掉，并由生产者自己动手。 至此，“具备责任心、做好每一个细节”的理念深深刻在每一个员工心里。海尔的管理精髓之一是：日事日毕，日清日高。强调高效的执行力，把每天的工作做完、做好。在此理念下，海尔从一个濒临倒闭的小厂，蜕变为享誉国内外的大集团。执行力的力量功不可没。 我的老大Ella在创业前，曾在腾讯干过几年，当时工作中他们提得最多的一个词，就是“执行力”。这个习惯让她在以后的创业中受益匪浅。Ella曾问过阿里高管：论人才储备，阿里18罗汉，占据各部高层，为什么他们有那么多人可用？ 对方回答：平凡人做非凡事。企业偏爱执行力强的平凡人，愿意帮助这样的员工成长。执行力对职业发展的重要性可见一斑。再有想法不去执行，也是空谈。那么，执行力具体指的是什么？从概念上讲，它包含三个方面：完成任务的意愿、完成任务的能力、完成任务的程度。我用三个小故事来分别解释这三个方面： 我有个朋友，一直口口声声说暗恋一名女孩儿，却从来没有展开追求。他并不是不知道怎么追女孩，在给别人建议时，他头头是道。“你每天给她买早餐，悄悄放在桌上，坚持三个月，肯定成！”“你为什么不这样做？”“不行不行，现在还不是时候，我再等等吧。”等着等着，然后就没有然后了。女孩跟别人好了。心中思绪涌动，但不愿付诸行动。此乃缺乏执行的意愿。 一群老鼠开会，研究怎样才能躲避猫的袭击。有老鼠提议说：不如在猫脖子上挂一个铃铛，猫一靠近，我们就能听到然后逃跑了。大家纷纷赞同这是个好点子，鼠老大决定就这么办！那么问题来了，谁去挂这个铃铛呢？所有老鼠都低着头，谁也不愿意接这个任务，做就等于死。直到鼠老大去世，这个决定依然没有被实施。究其原因，是老鼠们根本不具备执行它的能力。 闺蜜梅梅一个月前定下减肥计划——每天坚持跑步半小时。一个月来，她一天也没落下，但减肥大业毫无成效，这让我很困惑。在陪她跑了一次之后，我彻底明白其中原因：半小时时间里，有10分钟她在做准备工作，10分钟在停下来喝水休息，剩下10分钟才是真正运动的时间。执行程度低，看似完成了目标，实则收效甚微。 以上三个故事，都是缺乏执行力的表现。在职场中，因为多次没有完成工作任务而被解雇的例子比比皆是，相信你也碰到或耳闻过。而执行力强的那些人，总是晋升最快的一类。你可能要问了：道理我都懂，可为什么执行起来这么困难呢？ Lagou将执行力不足的原因总结为三点： 目标定得太离谱； 想得多却做得少； 拖延后潦草收场； 为了摆脱“听了很多道理，却依然做不好工作”的困扰，Lagou 针对原因对症下药，精心准备了10条既有用、又易操作的小技巧，来助你提高执行力，使职场之路更加顺畅。 1.明确目标很多时候你会发现，决定好了的事情，执行起来却非常困难，这通常是目标设定不清晰导致的。目标超过个人能力、目标过大、周期过长、不能分解、指向不明、不掌握资源等等，都会导致目标难以执行。在设定目标的时候，首先要去判定目标的明确性，这时候，我们可以用到著名的“SMART原则”，来衡量已定目标的明确与否。“SMART原则”是： 目标必须是具体的(Specific); 目标必须是可以衡量的(Measurable); 目标必须是可以达到的(Attainable); 目标必须和其他目标具有相关性(Relevant); 目标必须具有明确的截止期限(Time-based)。 例如：你接到一项任务，做一款H5，旨在通过H5实现用户的转化，促使他们去注册你公司的APP。你把这项任务的目标设定为——尽最大可能做出一款能够刷爆朋友圈的H5，实现用户的高效转化——这会让你在实施这项任务时感到茫然。 运用SMART原则，此项目标的设定应为：在两周的时间内（明确期限），做一款H5，实现1万的用户转化（具体目标、可衡量）。在设定这个量的时候，应当考虑渠道数和粉丝数，并参考以往的推广案例里，它们的转化率是多少。如果推广渠道的粉丝总数才5万，你设定1万的转化量，那几乎是不切实际的。 2.将目标分解成多个小目标目标过大、周期过长的任务，会让人不知从何下手。在处理一项庞杂的事务时，很容易出现本末倒置、战线延长的现象。成功hold住大目标的秘诀在于，将之分解为一个个小目标，安排好时间，逐一攻破。目标分解的经典案例是一个关于马拉松的故事：1984年东京国际马拉松邀请赛中，一个名不见经传的山本田一出人意料地夺得冠军，他的技巧在于把路程分解成几个小目标：银行、大树、红房子。他说：“比赛开始后，我就以百米冲刺的速度奋力向第一个目标冲去，到达第一个目标后，我同样的速度冲向第二个目标— —40多公里的路程就被我分解成这么几个小目标轻松地跑完了。” 3.设定奖励机制为自己完成目标设定一个奖励，会让你更有动力去做这件事。比如在你面临一项棘手的任务时，告诉自己如果完成了，就可以去买一个你心仪已久的东西，这会让你更有动力去朝目标努力。同样，可以将奖励机制细分在每个小目标里。每完成一个部分，给自己一个小小的奖励，既能减轻困难感，又能让你更有动力去完成下一个目标。 4.寻找执行后果的吸引力在执行任务之前，先去考量完成目标能给你带来的好处。这里的好处可能是：得到领导的肯定、同事的赞许、职位晋升的可能、金钱收入、经验值增长……这样，你的行动就有了一个具有吸引力的目的地，吸引你主动向前，提高执行力。 5.寻找同伴行为是具有传染性的。试想，如果你与他人共同完成一项任务，当你看到别人已经行动了，你好意思待着不动么？同伴的参与会督促你尽快执行任务，在“自己不能做得比别人差”的心理作用下，让你的执行效果更加地好。 6.在公共场合公开进度,寻求监督很多时候，面子是促进一个人完成目标的重要因素。把你要做的事写在公开场合，让朋友监督，说出去的话，泼出去的水，在众目睽睽之下，为了不丢脸，硬着头皮熬夜也要把这件事做完。 7.五分钟打扫房间法则告诉自己只花5分钟去打扫一下房间，看起来很快很简单的样子。事实上，一旦你开始打扫，你就很可能不会在5分钟之后真的停止打扫。打扫后的改观让你得到了成就感，并且想要一鼓作气打扫完毕。在这种观念下，想要再拖延一段时间在开始的想法，就被攻破了。 8.设定一个你难以承受的惩罚措施为自己设定一个完不成目标就必须接受的惩罚措施，而且，这个惩罚必须是你很难承受的。比如，在你经济紧张的情况下，告诉朋友，如果自己没有达到目标，就给他一千块钱，并立下字据。如果输了那一千，你很可能接下来的日子会十分拮据，避免不受到惩罚，会迫使你提高执行力。 《为学》里曾说到： “自恃其聪与敏而不学者，自败者也；不自限其昏与庸而力学不卷者，自力者也。” 智力有高低，思想有深浅，但如果不付诸行动去执行，一切都是无用的。在职业成长过程中，执行力才是最好的催促剂。就如老大Ella所说的：“甩开膀子干，赢过一切造作。每一个人，无论今天是什么起点，一切皆有可能。” 新的一年马上要来了，开始行动吧!! 本文链接：http://www.sguotao.top/生活感悟-2015-12-30-executive-ability.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2FUML-2015-09-30-UML%E7%B1%BB%E5%9B%BE.html</url>
    <content type="text"><![CDATA[什么是UML类图类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。 在UML中，类使用包含类名、属性和操作且带有分隔线的长方形来表示，如定义一个Employee类，它包含属性name、age和email，以及操作modifyInfo()，在UML类图中该类如图所示.在UML类图中，类一般由三部分组成：第一部分是类名：每个类都必须有一个名字，类名是一个字符串。第二部分是类的属性(Attributes)：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。UML规定属性的表示方式为： 可见性 名称:类型 [ = 缺省值 ] 其中： “可见性”表示该属性对于类外的元素而言是否可见，包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号+、-和#表示。 “名称”表示属性名，用一个字符串表示。 “类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。 “缺省值”是一个可选项，即属性的初始值。 第三部分是类的操作(Operations)：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML规定操作的表示方式为： 可见性 名称(参数列表) [ : 返回类型] 其中： “可见性”的定义与属性的可见性定义相同。 “名称”即方法名，用一个字符串表示。 “参数列表”表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“，”隔开。 “返回类型”是一个可选项，表示方法的返回值类型,可以是基本数据类型，也可以是用户自定义类型，还可以是空类型(void)，如果是构造方法，则无返回类型。 类与类之间的关系关联关系关联(Association)关系，一种结构化关系，用于表示一类对象与另一类对象之间有联系。通常将一个类的对象作为另一个类的成员变量。在使用类图表示关联关系时可以在关联线上标注角色名。 单向关联单向关联用带箭头的实线表示。例如：顾客(Customer)拥有地址(Address)。 双向关联默认情况下，关联是双向的。例如：顾客(Customer)购买商品(Product)并拥有商品，反之，卖出的商品总有某个顾客与之相关联。 自关联在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如：一个节点类(Node)的成员又是节点Node类型的对象。 多重关联多重性关联关系又称为重数性(Multiplicity)关联关系，表示两个关联对象在数量上的对应关系。例如：一个界面(Form)可以拥有零个或多个按钮(Button)，但是一个按钮只能属于一个界面，因此，一个Form类的对象可以与零个或多个Button类的对象相关联，但一个Button类的对象只能与一个Form类的对象关联。对象之间可以存在多种多重性关联关系，常见的多重性表示方式有： table th:first-of-type { width: 100px; } 表示方式 多重性描述 1..1 表示另一个类的一个对象只与该类的一个对象有关系 0..* 表示另一个类的一个对象与该类的零个或多个对象有关系 1..* 表示另一个类的一个对象与该类的一个或多个对象有关系 0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系 m..n 表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n) 聚合关系聚合(Aggregation)关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。例如：汽车发动机(Engine)是汽车(Car)的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系。在代码实现聚合关系时，成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中。 组合关系组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。例如：人的头(Head)与嘴巴(Mouth)，嘴巴是头的组成部分之一，而且如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系。在代码实现组合关系时，通常在整体类的构造方法中直接实例化成员类。 依赖关系依赖(Dependency)关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如：驾驶员开车，在Driver类的drive()方法中将Car类型的对象car作为一个参数传递，以便在drive()方法中能够调用car的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此类Driver依赖类Car。在系统实施阶段，依赖关系通常通过三种方式来实现。 第一种也是最常用的一种方式是将一个类的对象作为另一个类中方法的参数; 第二种方式是在一个类的方法中将另一个类的对象作为其局部变量; 第三种方式是在一个类的方法中调用另一个类的静态方法。 泛化关系泛化(Generalization)关系也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。例如：Student类和Teacher类都是Person类的子类。 接口与实现关系接口和类之间存在一种实现(Realization)关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。例如：定义了一个交通工具接口Vehicle，包含一个抽象操作move()，在类Ship和类Car中都实现了该move()操作。 参考文献[1] 刘伟.设计模式的艺术:软件开发人员内功修炼之道[M].清华大学出版社, 2013.1:1 - 396 本文链接：http://www.sguotao.top/UML-2015-09-30-UML类图.html]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个离职员工的体会]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2015-08-12-a-departing-employee-feelings.html</url>
    <content type="text"><![CDATA[一位在职场工作了7年的老员工离职了，对于和公司同事、领导的相处，还有如何处理心态问题，他给出了自己的忠告。 如果你足够努力，你可以成为一个“精神灵魂”。每个公司、每个社区，都需要不止一个“灵魂人物”。用户中需要培养符合网站气质、对你网站品牌起到正向作用的用户中的灵魂，企业里需要培养资产、项目里的灵魂，这种人越多，企业便能更好的发展。 一个企业里的“精神灵魂”需要具备什么?答案就是特质 所谓特质，其实就是骨子里面的东西。你的小宇宙有多强，决定了你会把事情做到何种程度。比如责任心、态度、对细节的关注、坚韧和坚持、逆境商、做事的魄力、价值观等等。这些东西里有些是先天的，大部分却是后天可以培养出来的。 如果用冰山模型加以区分，你会发展这些基本都是冰山以下的那些东西，而这些东西需要长时间的磨砺，但很多人都在试图避过这个环节，因为我们都渴望顺境。很多人频繁跳槽，这种人一定成不了大事。 我说我愿意用10年时间来磨练自己，可以受任何委屈、任何苦楚、任何不理解，摈弃钱的诱惑，积累冰山以下的东西，换我未来10年、20年的生活。很多人说我傻，我相信傻人早晚会有傻福。 谁都想去一个好的公司，能给未来的自己积累到最好的筹码。其实人生就是选择，机会往往稍纵即逝，关键在于自己不要后悔（当然后悔也是没用的）。 很多人，在不断的选择、跳槽中，彻底迷失了自己。其实去任何公司，哪怕这个公司再烂，只要你足够用心，都能学到很多有用的东西，无心者去哪都一样。我们都在找一个终点，但永远不知道他究竟在哪儿。与其这样，不如好好的完善自己。 牛逼的公司的确能给你一个光环，但不代表你就牛逼。一定要在一家公司好好沉淀个三四年，切莫荒废了自己。 用人单位最看重的是什么？他们更看重你在以前公司积累的内在的东西，不是你平时做什么，而是你做出了什么成绩、你有什么资源、你在这个公司的成长轨迹、因为有你给这个公司带来了什么。 离开了这个公司，你还剩下什么？很多人很可悲。现在这个社会太浮躁，太多人抱怨自己的公司如何如何，抱怨自己的领导如何如何。抱怨是徒劳的，他们经常不会因为你的抱怨而改变，至少本质不会变。关于这个问题，我给6个字：要么忍，要么滚。 这个世界上没有完美的人，公司也如是。你要明白自己在这个公司，真正需要的是什么？如果值得挖，请深挖。如果爱，请深爱。领导也一样，他们能成为你的领导，就一定有比你强的地方，他好的地方，你跟着好好学就是了。觉得不OK，那就另谋出路。 我也曾经极度心理爆棚过。差不多三年半以前，我当时觉得自己特别牛逼。做猫扑贴贴，我们最多时也就5个人的团队，花了2年时间，就超过了大杂烩。猫扑无线，我一个人兼着做的。猫扑的大号微博当年我做起来的，那会都不算我的KPI，2010年做了50万粉丝，纯粉，没刷过，网络媒体排名第一。人人2个page，一个我打理的，一个我接手的。猫扑鬼话在qqzone上面的空间点击，一年做了三四千万点击。后来在这些的基础上成立了第三方运营部门。猫扑的seo部门，是我组建的，当年很多搜索量最高的关键词，有不少也是我做的。 后来呢，我吃了很多亏，明白了很多事情。慢慢心态也越来越平和。 人生是一所大学，很多事情是你永远也无法理解的。我们一直需要学习，包括人性。这个世界上，比自己牛逼的人比比皆是。不要对别人过于苛刻，不必勉强所有人都和你一样。这次离开猫扑也一样，我可以坦然。因为我已经很尽力，我的付出已经太多了。 人要懂得感恩。我真的很感谢猫扑，这些年，没有那些一直支持我的用户，我也不可能一直坚守。社区的核心是用户，用户永远没错。 关于团队，这些年从他们身上，我体会到了很多。猫扑南迁那会，当时的很多运营陪我坚持到了最后，我很感动。 帮过我的人很多，包括老板，在我最困苦和徘徊的时候提拔了我，我也是跟他最久的员工。懂得感恩的人，才会更毫无保留的把自己的潜能爆发出来，投入到工作中。 你需要不断更新自己的思维、扩充自己的视野面。 这个世界变化太快，随时你都可能被淘汰。其实想下，我挺感谢这点认识的。我从来不满足自己现有的知识面，总是去学习和接受一些与工作相关的新东西。乍一看，我做过的东西很多很杂，其实慢慢会发现，做事的逻辑都是相通的。 艾瑞上有个网络媒体排名，2006年我整整研究了一年，后来养成了每周都看的习惯。为了培养数据运营的意识，7年以内，猫扑的数据我从来都是手算，坚持了7年，手稿我都留着。2009年做贴贴时，是我成长最快的时间段，我学会了强逼自己，所有运营手段，我开始不停的轮流尝试。猫扑的所有产品线的逻辑，我全部都懂，我从来没让自己远离过一线。有几个人知道我背后付出过多少努力？ 你的视野面多大，决定了你能做多大的事情。考虑的面越大，你的高度就会远远在其他人之上。如果你有能力接触或者学到的东西，那就多学一点吧，没有任何坏处，对你百利无害。 从小事做起，从细节做起，“一屋不扫，何以扫天下？”很多人问我如何才能做好运营，除了态度和责任心，这取决于你会在这个工作上花多少时间。运营，其实远远没有很多人想象的那么简单，而且现在真正重视运营的公司并不多。运营是做好社区的一个最便捷的门槛，谁都知道懂运营懂用户的产品人员，价值会更高。运营其实很细很碎，基本功太关键。 卖油翁的故事告诉我们熟能生巧、实践出真知。道理永远是道理，不去做永远进不到自己的肚子里。 现在眼高手低的人很多，事情没做到位，或者做了一点点，便自鸣得意了。还有没做就先发表意见的所谓的“聪明人”。我喜欢务实的人，哪怕再笨，也会给几次机会。 抠细节的人往往会被说成固执，殊不知，工作就是由细节组成的。一个好的产品，一定是在不断的实践中，一点点抠出来的，加上一定的机遇。 学会自我排解烦恼，学会自我激励有时候可能更重要。我其实也会吐槽，毕竟我也是个自然人。这些年的确不容易，但这些也都是自找的，怨不得别人。 说实话，我的努力，远远没有换来我的预期，至少没有给我换来好的生活，唯有经验更可贵。马云说的所谓“钱没给到”、“心委屈了”，简直是小儿科。我一直靠自己对自己的认可，支撑着自己。也许这很单纯，这意味着要舍弃很多东西。 其实自我认可、自我激励，一个根本的目的在于帮助自己找到自信。我曾经很自卑。 自我认可需要从小事看起，哪怕你在一个帖子上做的比别人更极致，某一个细节上比别人想的更到位，也该为自己加油和叫好。慢慢地，你就会发现，你很多工作，都会超出其他人了。 “树犹如此，人何以堪”，事情做完了，我也长大了，我需要新的起点，我需要新的生活，所以我走了。 在未来，希望你能全身心的投入到新工作中，做一个更好的自己！ 本文链接：http://www.sguotao.top/生活感悟-2015-08-12-a-departing-employee-feelings.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奋斗的意义]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2015-07-14-Youth-is-to-Struggle.html</url>
    <content type="text"><![CDATA[很多大学生在还没毕业的时候，总感觉自己有能力会混的不错。毕业几年后，发现社会跟学校完全是两个世界。不经常思考的人，惰性总会让人得过且过混日子，不思考未来的路怎么走，就等于你安于现状，接受了平庸而卑微的的生活，失去了年轻人本应该有的那种冲劲儿和干劲儿。没有思考，懒懒散散的混日子，消磨了以前想过“简单而快乐的生活”的信念，这种变化一直通过细微的事情发生着，不静下心来思考，你真的感觉不到你在堕落，在降低自己的生活。 时间是最宝贵的资产，是最昂贵的成本，也是最公平的给予，但是很多人是感觉不到它在一点一点的消失，比如说年龄在一年一年的增加，虽然你外表年轻，但掩饰不了你内心的恐惧。比你年龄大的人，总说你们还年轻，有的是时间，是真的吗？直到你奔三了，你就开始慌乱了。 我们要知道我们工作是为了更好的生活，更好的机会去创业，一个业务娴熟的创业者比只会空想的人创业成功率高得多！没伞的孩子才知道努力向前奔！ 明白你是为谁工作，你是为你自己工作！无论你是在自己创业，还是在公司工作，都要记住，你不是在给别人打工，你是在为自己工作！多接几个项目，多画几张图纸，多交几个朋友，都能学到一些东西，而这些东西是别人剥夺不走的，无论何时都可以为自己增加价值。 混日子是没有前途的，收获与投入成正比！一件事如果是应付一下，很容易，应付完了之后不觉得是在浪费生命吗？也许你今天花了别人几倍的时间和精力去完成一个项目，但到最后你会发现，你的收获是最大的，你的全面解决问题的能力是别人不可能得到的。你在上班的时候要记住你不是为别人打工，你要告诉自己，通过干这件事我能学到什么东西，学到的东西是别人剥夺不走的，客观上可能给公司创造了价值。 哪个成功的人爱抱怨？怨天尤人没有任何作用你慢慢会发现这个社会还是相对公正的，机会还是很多的。怨天尤人除了会使你朋友越来越少，机会越来越少，生活越来越不幸福之外，没有任何好处。成功靠的不是怨天尤人，而是一点点能力的积累。 不喜欢的工作乘早走，做有兴趣的事才容易成功要是不喜欢老板赶快辞职一分钟别见到他，何必为了老板的错误耗费自己的生命，如果你今天决定你又不离开在公司做工作，你应该把工作做好。有人说有几种问题，我有个性我不爱干这个，但是个性是成功人士的专利，你成功你当然觉得有个性别人看着你，你没有成功之前个性能换房子吗？如果个性能换房子，我比你有个性，我们全家有个性，但它换不了一个房子。 青春不再来，混完了你就晚了如果你混日子，对不起，实际上你是混自己，在很多大的公司混的很多，你能黑老板多少钱吗？你一年年薪10万，中低层收入你在单位混10年也就混老板100万，对很多公司来说有人混我100万对公司伤害不了哪去，可是你十年不好好工作荒废了十年，十年可能突然有一天公司倒闭了，或者发现你这个混混把你开掉了，你怎么办呢？你觉得你有竞争力吗？除非你有一个好爸爸！ 奋斗的意义我们的人生应该自己来掌舵，而不是随波逐流，在工作时要努力做好，在创业时多想想经历过的艰辛，人生没有重来，但可以努力将未来过得更好！ 前途看不清方向，但奋力狂奔的人，会稀释周围的迷雾。路走错了，可以换一条，目的地看不到，但挪出的脚步，就会让你比停步不前的那个自己更好一点。不是你非走不可，是困在原地，就会永远消失。 毕业时，我们和大多数毕业生一样，胸中充满了理想和大志，但如今，我们努力的方向都很简单，有自己的房子，车子，有老婆和孩子。想想是这样的简单，又那样的艰难。这不是物质和现实，是生活在改变很多东西，它会磨掉你身上的棱角，或大刀阔斧，或小修小补，但一定会让你朝着适合社会的方向发展。 时间会解构很多东西，包括爱情，包括情绪，包括对所有事情的理解和定义。而最后你成为的那个人，一定会是比原来的那个自己更努力，更优秀，更懂得奋力的定义和意义的人。 我知道你难过，我们都难过，所以要拼命的去过；我知道你想哭，我么都想哭，所以要拼命的忍住。 奋斗的意义，不在于一定会让你取得多大的成就，只是让你在平凡的日子里，活的比原来的自己更好一点，让你与生活少一点妥协，让你有力气保护一切你喜欢的东西，让你对一切美好的事物力所能及。 更重要的，拼命的去努力，才让你在最美的韶光里，你为了成为最好的你，没有辜负努力奋斗的自己。 本文链接：http://www.sguotao.top/生活感悟-2015-07-14-Youth-is-to-Struggle.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015 半年记]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2015-06-16-2015-half-year-diary.html</url>
    <content type="text"><![CDATA[不知不觉，2015就走过了一半，记忆中好像刚过完春节，没多久。 一个半月，没有写一些东西，经历了忙的像狗的日子，经历了旧同事的离职，经历了新同事的入职，现在，似乎变得麻木了，以前，旧同事的离开，自己都会失落好一阵，现在一会儿就好了，因为，我知道，他们会变得更好，他们会走得更高，自己怎能还在原地踏步。每每想到这些，就不难过了。 有些时候，人就是这么贱，忙着的，想清闲，清闲了，又想着被重用，于是就在清闲与忙碌中，累的成了狗。忘记了初心，忘记了为什么而忙。 最近工作中，遇到了一些困惑，又是觉得很委屈。 在平时的工作环境中，有些公司，分工会比较细， 可能一个人从入职那一天起，就确定了他以后的工作内容， 经过几个月的适应期，这些内容很快就会上手， 如果刚好负责的不是核心模块，随着时间的推移， 会产生一种被边缘化的感觉， 现在的自己就遇到了这样的问题，向前辈请教，没想到前辈给出了中肯的答复，很受鼓励。 一般来说，学习都是要利用业余时间进行的。 对于任何公司来说，你能接触到，工作的其实只是很小的部分。如果分工细致的公司，你能接触的更少。 所以还是应该利用业务时间来保持技术敏感度。对于一门技术，尽量按如下方式学习 1. 下载官方Guide、reference、specification之类的文档（qs、tour之类的文件直接忽略，那些文档都是骗骗入门者的，如果你只是想快速了解这个东西，然后方便出去吹牛，可以看看这类文档），认真阅读它们，每个功能点都反复使用大量程序来反复测试、验证。 2. 通过网络浏览一下的各种纸质书（个人喜欢纸质书）的目录，对比之后挑选其中2～3本，快速浏览它们，看看有没有什么值得启发的东西。 3. 把官方提供的各种示例、demo基本都过一遍，一次看不明白的地方多搞一次，记住做一些笔记。 4. 根据兴趣或工作需要，在参考官方demo的基础上，做一些自己的案例。 5. 如果技术是开源的，对于一些感兴趣的实现细节，可以跟踪着查看技术实现的源代码。 想起一个词，似乎很能准确的形容现在的情况，“存在感太弱”。为什么会有这种感觉，我想是因为没有找到自己的位置，没有让自己成为那“不可或缺”的一部分。 记得多年前，在CCTV看到的361°的一个很励志的广告，最后的slogan是“磨自己，才能谋胜利”。我想，是自己磨练的还不够，见识的还不够多。 开始想，是不是要从框架开始学习，毕竟以前，工作五年的J2EE程序员，都会谈架构，现在搞Android，1年就要谈架构，所以自己是不是要多了解一些架构方面的内容？多看一些开源框架？ 这个问题，我是这么想的，以自己现在的编码能力，抽象能力还没有达到一定的境界，很容易陷入为了架构而架构的怪圈，多了解一些框架，总归是好的，可是不能忽略的基础知识的夯实。有时候，很想撂挑子，来逃避一些问题，但是后来想了想，不能一时冲动，每一次的跳槽，都应该有一个明显的成长，不能为了跳槽而跳槽，工资一时的提高，比起能力的提高，孰轻孰重，还是要仔细想想。 计划看一下Android的API Guides，研究一下Android的Samples，在博客中记录自己的学习过程，如果坚持下来，自己会有一个很大的提高吧。 本文链接：http://www.sguotao.top/生活感悟-2015-06-16-2015-half-year-diary.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拿什么拯救你，我的KB程序员生活]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2015-04-15-my-programmer-life.html</url>
    <content type="text"><![CDATA[这是在天涯社区上看到的一篇文章，这是一个女程序员的，切身经历； 说实话，真的累了。 拼命再拼命，努力再努力，和男人们一起摸爬滚打，熬夜加班到凌晨，身心疲惫。 偶尔被关心，也会装作坚强的一笑，连声说没事儿，程序界里无男女。 和项目经理暗战了几万回合，终于熬到了主管的地位。却要时时提防甚至镇压小字辈的程序员。 偶尔从一堆堆方案中抬头，看着软件园里并不晴朗的天空，会想，怎么自己就学理了呢？ 怎么就学会勾心斗角了呢？怎么就知道培养自己小集团了呢？ 当初那个胖乎乎傻乎乎的小妞哪去了？ 那个写了个 学生管理系统 就大肆炫耀觉得天下无敌可以进微软IBM的小菜鸟怎么就消失了呢？ 同学朋友都劝，转行吧。相亲的对象已经发了狠话再不约会就分手。 我笑，这种狠话貌似已经听了很多边，已经麻木了。 越来越沉默，越来越冷静。 上周，人事大变动。研发部只有我和技术总监沉的住气， 笑看风云突起。这次人事的大调，和技术有关，又和技术无关。自己都被自己的冷静吓到了。 团队里只有我一个女程序员，还有一个女UI还是项目经理的人。 很多时候感到孤独，面试过很多女程序员，都毫无保留的直接推荐到老总那里， 却都没有通过。这真的很让我郁闷。 很怀念菜鸟阶段的什么都不想，很怀念那种努力向上拼搏的状态。 入行3年，今年是第4个年头，工资翻了3翻，心态老了3倍。 出差去深圳，坐在从广州到深圳的大巴上，听着歌，舒服的睡了一觉。 所有的人事，所有的机制，所有的东西都离我远去，仿佛从前的一切都回来了。 其实，我不是一个有大出息的人。 只是想找个人好好谈谈恋爱。 只是想安安稳稳的约会逛街吃饭。 最近这位男友也是个程序员。搞笑的是我们在一个园区。 紧挨着2座楼。中午吃饭的时候，我的程序员男友不停的讲着他目前开发的项目。 有时候我看着他那张吃饭都在不停说话的嘴，总是忍不住怀疑他是不是做销售的。 我的上一任男友是学哲学的。硕士。 我报着珍惜大熊猫般的心情珍惜与这位哲学硕士的交往。 不为别的，只为 哲学 这神圣2字。 我的哲学硕士男友果然不负我的期望，教会了我很多人生的哲理。 有时候我都会忍不住暗下决心，一定要写一个网站，把他愤青般的哲学话语都放进去。 当然，我们伟大的爱情之路还是依旧毁于加班和我一有时间就睡觉的懒惰。 27岁，不尴不尬的年龄。 写了一下午的方案，头昏脑胀的突然失控。 我在办公室里大声的宣布，明年一定要结婚。 立刻，办公室热些沸腾。 下班被老总一顿猛训。 老总是一个严肃不苟言笑的人。坚信威严的重要性。 整天如同绑上发条般，就快断了。 打电话给我的程序员男友，说，咱明年结婚吧。 我的程序员男友很稳健的说他明年的计划是坐上技术经理的位置。最快也要后年结婚，希望我能等他。 女人和男人果然不同。 晚上和朋友去必胜客，朋友说她男友的大学同学来了青岛。报社的编辑，说改天让我过过目。 这就是生活。这就是人生。我想。 人生，没有IF ELSE…… 感受还记得自己在深夜加班的情形，还记得那条漆黑的回家路，还记得那是自己鼓励自己说“现在都是在为了未来，拼命的积攒，只有经历越多，才能变得越强”。现在回想起来，虽然很辛苦，但是从来没有后悔过，因为那是一段连自己都感动了的日子，也许这就是青春，这就是成长； 我不知道，自己这种积极向上的劲头会持续多久，也许最终我也不得不向生活妥协，但是我仍然坚信：每一分私下的努力都会有倍增的回收，过去不代表未来，把握当下，创造属于自己的奇迹。成功永远都是属于有毅力的人，从容的人生不孤独，淡定的人生不寂寞，再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达，年轻没有失败，绝不轻易放弃…… 其实，每个人都不曾因为苦而放弃，只会因为扛而成长。在未来的某天，我们轻松了，并不是生活越来越容易，而是我们越来越坚强…… 本文链接：http://www.sguotao.top/生活感悟-2015-04-15-my-programmer-life.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】分析观察者设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2015-02-10-%E5%88%86%E6%9E%90%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[观察者模式的介绍 观察者模式，定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 观察者模式用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。 适用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 观察者模式的写法及特点观察者模式的UML类图:从UML类图中可以看出，观察者模式包含四部分: Subject类观察目标类，目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。参考代码: 12345678910111213141516171819202122232425262728/** * 观察目标类 */public abstract class Subject &#123; //保存注册观察者对象 private List&lt;Observer&gt; mObservers = new ArrayList&lt;&gt;(); //注册观察者 public void attach(Observer observer) &#123; mObservers.add(observer); System.out.println("注册观察者"); &#125; //取消观察者 public void detach(Observer observer) &#123; mObservers.remove(observer); System.out.println("取消观察者"); &#125; //通知所有注册的观察者对象 public void notifyObserver(String state) &#123; for (Observer observer : mObservers) &#123; observer.update(state); &#125; &#125;&#125; ConcreteSubject类目标类具体实现类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知。参考代码: 123456789101112131415/** * 观察目标具体实现类 */public class ConcreteSubject extends Subject &#123; private String state; public String getState() &#123; return state; &#125; public void change(String newState) &#123; this.state = newState; notifyObserver(newState); &#125;&#125; Observer接口观察者，观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。参考代码: 123456/** * 观察者类 */public interface Observer &#123; void update(String state);&#125; ConstreteObserver类观察者具体实现类，实现了在抽象观察者Observer中定义的update()方法。参考代码: 12345678910111213/** * 观察者具体实现类 */public class ConcreteObserver implements Observer &#123; private String data; @Override public void update(String state) &#123; this.data = state; System.out.println("观察者: " + data); &#125;&#125; 观察者模式的优点: 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。 观察者模式在Android中的应用在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了JDK对观察者模式的支持。其中Observable是观察目标类，在Observerable中使用Vector来存储注册的观察者Observer，这里是出于线程安全的考虑。 回调模式 回调模式:实现了抽象类/接口的实例在实现了父类提供的抽象方法后，将该方法交还给父类来处理。 观察者模式处理的是一对多的关系，而回调模式处理的是一对一的关系。在Android中Button点击事件的处理，可以认为是观察者模式，这里的Button可以看做是观察目标类，可以将实现了onClickListener的Activity看作是观察者类，通过给Button设置onClickListener来注册观察者，当触发Button的点击事件后，通过回调模式执行Activity中重写onClickListener的onClick()方法，来完成观察者对目标类状态改变的监听处理。 实现回调模式需要以下几个步骤: 声明回调接口; 定义回调接口的成员变量; 添加设置回调接口成员变量的方法; 添加调用回调方法的方法。 参考代码: 123456789101112131415161718192021222324252627282930313233public class TestCallback &#123; //1.声明回调接口 public interface Callback &#123; void work(); &#125; //2.定义回调接口的成员变量 private Callback mCallback; //3.设置回调接口成员变量的方法 public void setmCallback(Callback mCallback) &#123; this.mCallback = mCallback; &#125; //4.设置回调方法的方法 public void doSomething()&#123; System.out.println("do something"); mCallback.work(); &#125; public static void main(String[] args) &#123; TestCallback testCallback = new TestCallback(); testCallback.setmCallback(new Callback() &#123; @Override public void work() &#123; System.out.println("回调callback"); &#125; &#125;); testCallback.doSomething(); &#125;&#125; 参考文献[1] 刘伟.设计模式的艺术——软件开发人员内功修炼之道[M].清华大学出版社, 2013.1:1 - 396 本文链接：http://www.sguotao.top/设计模式-2015-02-10-分析观察者设计模式.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】分析Builder建造者设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2015-02-04-%E5%88%86%E6%9E%90Builder%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[Builder建造者模式的介绍 建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分(或部件)的复杂对象的创建过程分离，使得同样的构建过程可以创建不同的表示。 Builder建造者模式的适用场景当构造一个对象需要很多参数，并且参数的个数和类型都不固定的时候，可以考虑使用Builder模式。建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。 Builder建造者模式的类图 Builder的写法及特点从Builder建造者模式的类图中可以看出，主要包含四个部分： 1.Build类建造者的抽象接口类，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。参考代码： 1234567891011121314151617/** * 建造者的抽象接口，为创建产品Product对象的各个部件的抽象接口 */public abstract class Builder &#123; //创建产品对象类 Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); //返回产品类 public Product getProduct()&#123; return product; &#125;&#125; 2.ConcreteBuilder类建造者的具体实现类，它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象。参考代码： 12345678910111213141516171819202122232425/** * 构建类具体实现类 */public class ConcreteBuilder extends Builder &#123; @Override public void buildPartA() &#123; System.out.println("build product's partA"); &#125; @Override public void buildPartB() &#123; System.out.println("build product's partB"); &#125; @Override public void buildPartC() &#123; System.out.println("build product's partC"); &#125; @Override public Product getProduct() &#123; System.out.println("build completed,package product"); return super.getProduct(); &#125;&#125; 3.Product类产品类，是被构建的复杂对象，包含多个组成部件。参考代码： 123456789101112131415161718192021/** * 产品类，被构建的复杂对象，包含多个组成部件 */public class Product &#123; private String partA; private String partB; private String partC; public void setPartA(String partA) &#123; this.partA = partA; &#125; public void setPartB(String partB) &#123; this.partB = partB; &#125; public void setPartC(String partC) &#123; this.partC = partC; &#125;&#125; 4.Director导演类，它负责安排复杂对象的建造次序，导演类与建造者抽象接口类之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与导演类进行交互。该类主要有两个作用：一方面它隔离了客户端与产品的具体创建过程；另一方面它控制产品的创建过程。参考代码： 123456789101112131415161718/** * 导演类，负责安排复杂对象的建造次序 */public class Director &#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public Product construct() &#123; builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getProduct(); &#125;&#125; Builder模式的优点和缺点优点: 松散耦合，可以使用同一个构造算法构造出表现上完全不同的产品，从而实现产品表现和产品构建的分离； 可以很容易的改变产品的内部表示，由于使用了建造者抽象接口类Builder，具体的实现对客户端完全透明，这样在修改具体实现过程时，用户是无感知的。 构造算法与具体产品实现的分离，具有了更好的复用性。 缺点: 在生产产品的过程中，会产生多余的Builder对象以及Director对象，对内存有一定的消耗； Builder模式是非线程安全的，如果要在Builder内部类中检查一个参数的合法性，必需要在对象创建完成之后再检查。Builder建造者模式在Android中的应用先看一段代码: 123456789101112131415161718AlertDialog.Builder builder=new AlertDialog.Builder(this);AlertDialog dialog=builder.setTitle("标题") .setIcon(android.R.drawable.ic_dialog_alert) .setView(R.layout.dialog_view) .setPositiveButton(R.string.positive, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;) .setNegativeButton(R.string.negative, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;) .create();dialog.show(); 可以看出AlertDialog对Builder建造者模式进行了延伸，直接使用了建造者的具体实现类，并且将Product产品类与Director导演类进行了合并,延伸之后的类图如下: 总结一下延伸后建造者模式的特点: 外部类提供一个私有构造函数供内部类调用，在该构造函数中完成成员变量的赋值，取值为Builder对象中对应的值。 定义一个静态内部类Builder，内部的成员变量和外部类一致; Builder类通过一系列的方法用于成员变量的赋值，并返回当前对象本身（this）; Builder类提供一个build()方法或者create()方法用于创建对应的外部类，该方法内部调用了外部类的一个私有构造函数，该构造函数的参数就是内部类Builder。 示例代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243public class AlertDialog &#123; private String title; private String message; //1.外部类提供一个私有构造函数供内部类调用， // 在该构造函数中完成成员变量的赋值， // 取值为Builder对象中对应的值。 private AlertDialog(Builder builder) &#123; this.title = builder.title; this.message = builder.message; &#125; //2.定义一个静态内部类Builder， // 内部的成员变量和外部类一致; static class Builder &#123; private String title; private String message; Builder()&#123; &#125; //3.Builder类通过一系列的方法用于成员变量的赋值， // 并返回当前对象本身（this）; public Builder setTitle(String title) &#123; this.title = title; return this; &#125; public Builder setMessage(String message) &#123; this.message = message; return this; &#125; //4.Builder类提供一个build()方法或者create()方法， // 用于创建对应的外部类， // 该方法内部调用了外部类的一个私有构造函数， // 该构造函数的参数就是内部类Builder。 public AlertDialog build() &#123; return new AlertDialog(this); &#125; &#125;&#125; 参考文献[1] 刘伟.设计模式的艺术——软件开发人员内功修炼之道[M].清华大学出版社, 2013.1:1 - 396 本文链接：http://www.sguotao.top/设计模式-2015-02-04-分析Builder建造者模式.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】分析适配器设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2015-02-02-%E5%88%86%E6%9E%90%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[适配器模式的介绍 适配器模式:将接口转换成为客户希望的另外一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适用场景: 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 适配器模式的写法及特点在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。 对象适配器对象适配器的类图 从类图中可以看出，对象适配器模式包含三个组成部分： 1.Target类目标抽象类，定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。参考代码: 1234567/** * 目标抽象类 */public interface Target &#123; //客户需要的接口 void request();&#125; 2.Adapter类适配器类，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。参考代码: 1234567891011121314151617/** * 适配器类 */public class Adapter implements Target &#123; //对象适配器关联适配者类对象 private Adaptee adaptee; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void request() &#123; adaptee.specificRequest(); &#125;&#125; 3.Adaptee类适配者类，即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。参考代码: 123456789/** * 适配者类 */public class Adaptee &#123; public void specificRequest() &#123; System.out.println("Adaptee:specificRequest..."); &#125;&#125; 根据对象适配器UML类图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的specificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。 类适配器除了对象适配器模式之外，适配器模式还有一种形式，那就是类适配器模式，类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系。类适配的类图:根据类适配的定义，调整了适配器类，代码如下: 123456789/** * 适配器类 */public class Adapter extends Adaptee implements Target &#123; @Override public void request() &#123; specificRequest(); &#125;&#125; 适配器模式的优点: 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 适配器模式在Android中的应用在Android中，ListView的布局是由一条一条Item组成的，这每一个Item又是一个View。通过Adapter适配器这个桥梁将View添加到ListView中。一个Adapter是AdapterView视图与数据之间的桥梁，Adapter提供对数据的访问，也负责为每一项数据产生一个对应的View。每一项数据产生对应的View之后，然后将View添加到ListView之中。 参考文献[1] 刘伟.设计模式的艺术——软件开发人员内功修炼之道[M].清华大学出版社, 2013.1:1 - 396 本文链接：http://www.sguotao.top/设计模式-2015-02-02-分析适配器设计模式.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】分析代理设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2015-02-10-%E5%88%86%E6%9E%90%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[代理模式的介绍 代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。 代理模式的使用场景:代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合： 当客户端对象需要访问远程主机中的对象时可以使用远程代理。 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。 智能引用代理 当一个对象被引用时，提供一些额外的操作。智能引用代理根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。 静态代理 静态代理，代理和被代理对象在代理之前是确定的，它们都实现相同的接口或者继承相同的抽象类。 静态代理有两种实现方式:继承方式和聚合方式，主要体现在代理类与被代理类的关系上。继承方式，代理类继承被代理类；组合方式，被代理类是代理类的成员变量。从静态代理的UML类图中，可以看出主要包含3部分内容。 ISubject接口抽象主题接口，声明了代理类与委托类(被代理类)的共同接口，这样一来在任何使用委托类的地方都可以使用代理类。参考实例代码: 1234567/** * 抽象主题接口 */public interface ISubject &#123; void startTask(String taskName);&#125; RealSubject类委托类，即被代理类，它定义了代理角色所代表的真实对象，在委托类中实现了真实的业务操作，客户端可以通过代理类间接调用委托类中定义的操作。参考示例代码: 123456789101112131415/** * 被代理类(委托类) */public class RealSubject implements ISubject &#123; @Override public void startTask(String taskName) &#123; try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("正在执行业务:" + taskName); &#125;&#125; ProxySubject类代理类，它包含了对委托类的引用，从而可以在任何时候操作委托类对象；代理类与委托类实现相同的接口，以便在任何时候都可以替代委托类；代理类还可以控制对委托类的使用，负责在需要的时候创建和删除委托类对象，并对委托类对象的使用加以约束。参考示例代码: 12345678910111213141516171819/** * 代理类 */public class ProxySubject implements ISubject &#123; private ISubject subject; public ProxySubject(ISubject subject) &#123; this.subject = subject; &#125; @Override public void startTask(String taskName) &#123; System.out.println("开始记录任务执行时间"); long startTime = System.currentTimeMillis(); subject.startTask(taskName); long endTime = System.currentTimeMillis(); System.out.println("任务:" + taskName + "执行了" + (endTime - startTime) + "毫秒"); &#125;&#125; 静态代理类的优缺点优点: 业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。 缺点: 代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。 如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 动态代理 动态代理的实现方式，是在代理类和委托类之间，加入了事物处理器(InvocationHandler)。动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。 在JDK实现的动态代理方式中，有两个相关的类，在java.lang.reflect包下，分别是InvocationHandler和Proxy，其中InvocationHandler是一个接口，只有一个invoke方法: 123456789101112public interface InvocationHandler &#123; /** * * @param proxy 代理类 * @param method 被代理的方法 * @param args 被代理的方法参数 * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; Proxy是动态代理类，通过newProxyInstance()方法会返回一个代理类实例。 123456789101112/** * * @param loader 类加载器 * @param interfaces 代理类实现的接口 * @param h 事物处理器 * @return * @throws IllegalArgumentException */ public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 动态代理的实现步骤: 创建一个实现InvocationHandler接口的类，同时实现invoke()方法; 123456789101112131415161718public class ProxyHandler implements InvocationHandler &#123; private Object subject; public ProxyHandler(Object object) &#123; this.subject = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开始记录任务执行时间"); long startTime = System.currentTimeMillis(); method.invoke(subject, args); long endTime = System.currentTimeMillis(); System.out.println("任务:" + args. + "执行了" + (endTime - startTime) + "毫秒"); return null; &#125;&#125; 创建被代理的类，实现抽象主题接口; 123456789101112131415/** * 被代理类(委托类) */public class RealSubject implements ISubject &#123; @Override public void startTask(String taskName) &#123; try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("正在执行业务:" + taskName); &#125;&#125; 调用动态代理类Proxy的静态方法newProxyInstance()，创建一个代理类; 通过代理，调用方法。 12345678private static void testDynamicProxy()&#123; RealSubject realSubject = new RealSubject(); ProxyHandler proxyHandler = new ProxyHandler(realSubject); Class&lt;? extends RealSubject&gt; realSubjectClass = realSubject.getClass(); ISubject subject = (ISubject) Proxy.newProxyInstance(realSubjectClass.getClassLoader(),realSubjectClass.getInterfaces(),proxyHandler); subject.startTask("dynamic stak"); &#125; 所谓的动态代理是这样的一种class，在运行时生成，需要实现一组interfac。在使用动态代理类时，必须实现InvocationHandler接口。动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理InvocationHandler.invoke()。这样，在接口方法数量比较多的时候，可以进行灵活处理，而不需要像静态代理那样每一个方法进行处理。 远程代理 为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中。 远程代理，使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。 远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。 虚拟代理 如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。 保护代理 控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。 缓冲代理 为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 代理模式的优点: 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。 参考文献[1] 刘伟.设计模式的艺术——软件开发人员内功修炼之道[M].清华大学出版社, 2013.1:1 - 396 本文链接：http://www.sguotao.top/设计模式-2015-02-10-分析代理设计模式.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】分析单例设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2015-02-01-%E5%88%86%E6%9E%90%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[单例模式的介绍 单例模式(Singleton Pattern)：是一种对象创建型模式,确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。在Java中，通过类加载ClassLoader加载的类，在JVM范围内，单例模式只产生一个实例。 单例模式有三个要点： 是某个类只能有一个实(私有静态成员变量，存储唯一一个实例)； 是它必须自行创建这个实例(私有构造函数)； 是它必须自行向整个系统提供这个实例(公有静态成员方法，返回唯一一个实例)。 设计模式的类图： 使用单例模式有下面几个好处： 对于频繁使用的对象，可以省略对象创建所花费的时间，这对于那些重量级的对象而言，是非常可观的一笔开销； 由于new操作次数的减少，因而对系统内存的使用频率也会减少，这将减轻GC的压力，缩短GC停顿的时间。 单例模式5种写法及各自特点饿汉式123456789101112131415/** * 饿汉式单例模式 */public class HungrySingleton &#123; //定义静态变量的时候，实例化单例类 private static final HungrySingleton mHungrySingleton = new HungrySingleton(); private HungrySingleton() &#123; &#125; public static HungrySingleton getInstance() &#123; return mHungrySingleton; &#125;&#125; 分析： 饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性； 饿汉式单例类没有引入延时加载机制，无论系统在运行时是否需要使用该单例对象，该类在加载时该对象就需要创建，因此从资源利用效率角度来讲，在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 懒汉式123456789101112131415161718/** * 懒汉式单例模式 */public class LazySingleton &#123; private static LazySingleton mLazySingleton; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; if (null == mLazySingleton) &#123; mLazySingleton = new LazySingleton(); &#125; return mLazySingleton; &#125;&#125; 分析： 懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载； 在多线程并发的情况下，无法保证单例类的实例唯一。必须处理好多个线程同时访问的问题，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。 DCL(DoubleCheckLocking)双重检查锁定123456789101112131415161718192021222324/** * DCL(双重检查所定)单例模式 */public class DCLSingleton &#123; private static volatile DCLSingleton mDclSingleton; private DCLSingleton() &#123; &#125; public static DCLSingleton getInstance() &#123; //第一重检查 if (null == mDclSingleton) &#123; //锁定代码块 synchronized (DCLSingleton.class) &#123; //第二重检查 if (null == mDclSingleton) &#123; mDclSingleton = new DCLSingleton(); &#125; &#125; &#125; return mDclSingleton; &#125;&#125; volatile 是一个类型修饰符，是被设计用来修饰被不同线程访问和修改的变量。volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。被volatile修饰的变量，jvm虚拟机保证从主内存加载到线程工作内存的值是最新的。 分析:由于 mDclSingleton = new DCLSingleton();不是一个原子操作，需要经历以下3个步骤 将变量mDclSingleton存放在栈内存中； new DCLSingleton()，在堆内存中分配一块空间，用来存储DCLSingleton实例； 将在堆内存中分配的DCLSingleton实例空间的索引，赋值给mDclSingleton变量。 JVM可能会对以上3个步骤进行指令优化，如果不使用volatile关键字修饰mDclSingleton，当多个线程使用DCLSingleton时，就可能会创建出多个实例对象，甚至会出现报错。 volatile关键字在JDK1.5中引入，只能运行在JDK1.5+的版本中，volatile关键字会屏蔽JVM所做的一些指令优化操作，可能会导致系统运行效率的降低。 静态内部类12345678910111213141516/** * 静态内部类单例模式 */public class StaticInnerSingleton &#123; private StaticInnerSingleton() &#123; &#125; public static StaticInnerSingleton getInstance() &#123; return SingletonHolder.mInstance; &#125; private static class SingletonHolder &#123; private final static StaticInnerSingleton mInstance = new StaticInnerSingleton(); &#125;&#125; 分析： 单例类的实例变量并不是在单例类声明时创建，只有在调用时，加载内部类时才会被创建，因此就达到了延迟加载的目的； 单例类在内部类中声明为static，而且是final类型，在JVM加载内部类时创建，确保了单例类的成员变量只会被初始化一次，因此保证了线程安全； 没有引入线程锁机制，因此性能也比较高。 枚举123456/** * 枚举单例模式 */public enum EnumSingleton &#123; INSTANCE;&#125; 为什么枚举可以实现单例模式？这要从枚举的特点上找原因，enum类型不支持public和protected修饰符的构造方法，因此构造函数一定要是private 或friendly的。所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的。这一点与单例模式要求构造方法私有化是一致的，也是枚举类实现单例模式的基础。 为什么当枚举中只有实例变量时，是线程安全的，当枚举中声明了成员变量和成员方法时，需要处理线程安全问题？枚举类中的实例，在类加载器进行加载时完成实例化，确保了枚举类的实例只会被初始化一次，因此保证了线程安全。当声明了成员变量和成员方法后，在获取实例变量时，成员变量的状态会受到影响。看一段代码： 12345678910111213141516/** * 枚举单例模式 */public enum EnumSingleton &#123; INSTANCE(0); //声明一个成员变量 private int i; EnumSingleton(int i) &#123; this.i = i; &#125; //声明一个成员方法修改成员变量的值 void doSomething() &#123; System.out.println(i++); &#125;&#125; 测试程序代码： 123456789101112public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; EnumSingleton.INSTANCE.doSomething(); &#125; &#125;).start(); &#125; &#125; 其中一次的运行结果： 在结果中，出现了两次为0的情况，不只是枚举单例模式，以上几种方式的单例模式中，如果声明了成员变量和成员方法，都需要注意线程安全问题。 单例模式的反射安全问题先看一段代码: 123456789101112private static void testSingletonReflex() &#123; try &#123; DCLSingleton s1 = DCLSingleton.getInstance(); Class&lt;DCLSingleton&gt; cls = DCLSingleton.class; Constructor&lt;DCLSingleton&gt; constructor = cls.getDeclaredConstructor(new Class[]&#123;&#125;); constructor.setAccessible(true); DCLSingleton s2 = constructor.newInstance(new Object[]&#123;&#125;); System.out.println(s1 == s2);//false &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 这里使用DCL单例模式获取一个实例对象s1，通过反射方式获取对象s2，结果对象s1和s2并不是同一个对象。使用除枚举方式外，其它类型的单例模式都存在这样的问题。为什么枚举方式不会通过反射方式创建对象呢？ 123456789101112131415161718192021public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); &#125; &#125; //如果是枚举类型抛异常 if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException("Cannot reflectively create enum objects"); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings("unchecked") T inst = (T) ca.newInstance(initargs); return inst; &#125; 查看newInstance()的源码就会发现，如果是枚举类型，会抛出异常”Cannot reflectively create enum objects”。这就说明了枚举方式的单例模式是反射安全的，饿汉式，懒汉式，DCL，静态内部类方式怎么解决反射安全问题呢？可以引入一个标志位flag，通过修改构造方法，当再次创建对象时，抛出一个RuntimeException。 12345678private static volatile boolean flag = true;private Singleton()&#123; if(flag)&#123; flag = false; &#125;else&#123; throw new RuntimeException("The instance already exists！"); &#125;&#125; 单例模式的序列化与反序列化问题先看一段代码： 123456789101112131415161718192021222324252627282930313233private static void testSingletonSerializable() &#123; ObjectOutputStream oos = null; FileOutputStream fileOutputStream = null; FileInputStream fileInputStream = null;; ObjectInputStream ois = null;; try &#123; //Write Obj to file fileOutputStream = new FileOutputStream("testFile"); oos = new ObjectOutputStream(fileOutputStream); oos.writeObject(DCLSingleton.getInstance()); //Read Obj from file File file = new File("testFile"); fileInputStream = new FileInputStream(file); ois = new ObjectInputStream(fileInputStream); DCLSingleton s1 = (DCLSingleton) ois.readObject(); //判断是否是同一个对象 System.out.println(s1 == DCLSingleton.getInstance());//false &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; oos.close(); fileOutputStream.close(); fileInputStream.close(); ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 对应的单例类DCLSingleton实现Serializable接口，通过序列化传递得到一个单例类对象s1,通过直接调用单例类getInstance()得到对象s2，结果s1和s2并不是同一个对象，为什么会出现这样的情况？对象的序列化过程通过ObjectOutputStream和ObjectInputStream来实现的，查看一下ObjectInputStream的源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private Object readOrdinaryObject(boolean unshared) throws IOException &#123; if (bin.readByte() != TC_OBJECT) &#123; throw new InternalError(); &#125; ObjectStreamClass desc = readClassDesc(false); desc.checkDeserialize(); Class&lt;?&gt; cl = desc.forClass(); if (cl == String.class || cl == Class.class || cl == ObjectStreamClass.class) &#123; throw new InvalidClassException("invalid class descriptor"); &#125; Object obj; try &#123; obj = desc.isInstantiable() ? desc.newInstance() : null; &#125; catch (Exception ex) &#123; throw (IOException) new InvalidClassException( desc.forClass().getName(), "unable to create instance").initCause(ex); &#125; passHandle = handles.assign(unshared ? unsharedMarker : obj); ClassNotFoundException resolveEx = desc.getResolveException(); if (resolveEx != null) &#123; handles.markException(passHandle, resolveEx); &#125; if (desc.isExternalizable()) &#123; readExternalData((Externalizable) obj, desc); &#125; else &#123; readSerialData(obj, desc); &#125; handles.finish(passHandle); if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; handles.setObject(passHandle, obj = rep); &#125; &#125; return obj; &#125; 在17-19行，如果Java类可以在运行时被序列化，desc.isInstantiable()返回true，由于单例类实现了Serializable,是可以被序列化的，因此desc.isInstantiable()返回true，desc.newInstance()会通过反射调用无参的构造方法得到一个实例，这就解释了为什么会出现一个新的单例类实例对象。怎么解决单例模式的序列化问题呢？ 在40-50行，发现如果Java类中有readResolve()方法，desc.hasReadResolveMethod()会返回true，此时会通过反射的方式desc.invokeReadResolve()获取单例类的实例对象，而不会重新创建新的实例对象。结论，在单例类中，添加readResolve()方法。 12345678910111213141516171819202122232425262728/** * DCL(双重检查所定)单例模式 */public class DCLSingleton implements Serializable &#123; private static volatile DCLSingleton mDclSingleton; private DCLSingleton() &#123; &#125; public static DCLSingleton getInstance() &#123; //第一重检查 if (null == mDclSingleton) &#123; //锁定代码块 synchronized (DCLSingleton.class) &#123; //第二重检查 if (null == mDclSingleton) &#123; mDclSingleton = new DCLSingleton(); &#125; &#125; &#125; return mDclSingleton; &#125; private Object readResolve()&#123; return mDclSingleton; &#125;&#125; 参考文献[1] 刘伟.设计模式的艺术——软件开发人员内功修炼之道[M].清华大学出版社, 2013.1:1 - 396 本文链接：http://www.sguotao.top/设计模式-2015-02-01-分析单例设计模式.html]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello 2015]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F-2015-01-21-my-2014.html</url>
    <content type="text"><![CDATA[动机都说开通博客，要写篇文章纪念一下，借此感谢Github，Jekyll,MarkDown,感谢像闫肃,黄玄这样的爱分享的童鞋，2014年对我来说，是很重要的一年，认识了很多人，失去了很多人，总得来说，成长了很多，借此写一篇，纪念我逝去的2014。 工作2014年，换了工作，离开了PBI，离开了原来熟悉的环境，离开了熟悉的同事，告别了朝九晚五熟悉的生活节奏，当然也搬离了住了2年的海淀，一切都像当年，从学校出来，搬到海淀的情景。时光荏苒，场景再现，不变的是自己，变了的是身边的人。 以前都是在Android源码的环境下，编译代码，调试应用，曾经一度以为自己对很多知识已经足够了解了，可是突然到了一个更大的平台，你才发现，突来的状况，还是会让你措手不及，所以，当你以为自己很牛了，那是因为你见识的还不够多，在更大的🐂面前，你还是攻击力只有5的渣儿渣儿。 来到了Letv，一切都要从零开始，昨天的已经成为过去，对于未来，还需要今天的积攒，未来还有很长的路要走。 学习2014年，研究生进入了第二年，习惯了没有休息日的节奏，突然闲下来，还会有些不适应。在读研之前，没有认真的想过，自己为什么要读，可能是因为曾经考研未果的不甘吧。如果说，读研的收获是为了见识的更多，学到的更多，那我最大的收获，就是认识了很多小伙伴，是他们让我改变了很多，让我发现自己很多性格上的缺点，从而去弥补不足。 2014年，顺利的通过了开题报告，接下来就安心的准备毕业答辩了，在准备的过程中，把工作中内容和答辩的内容结合起来，深入的去了解移动流媒体的内容，相信在未来的工作中，会有很大的帮助。 生活2014年，去了江西的三清山，当时还没想到，那竟然是最后一次和同事们一起出去玩，好在当时还没有这种离别的情绪，不然也不会玩的这么尽兴。2015年了，衷心的祝森涛，田田，尚喆，赵哥，晶晶…一切都好。 2014年，去了筹划了已久的西藏，认识了能歌善舞的ZuoZuo，特别会聊天的DiDi，还有原原，感谢徐老师拍的照片和视频，本想写一篇日记记录一下来着，看来只能把这事儿推到2015了，很感慨，为什么人们都说你们变黑了，唯独说我变白了呢？ 总结 那时我们有梦，关于青春，关于爱情，关于穿于世界的旅行。 2014年，错过了一些人，有些是因为客观的原因，更多的是因为自己。杰伦结婚了，我们的青春岁月也结束了；科比，阿伦最后一年征战NBA，以后再想看他们打球，只能去翻看以前的视频了，从来没想过他们离开的日子，他们就老了。以后再做错事儿，再也不能拿自己年轻当借口了，遇到合适的人，不能再错过了。 本文链接：http://www.sguotao.top/生活感悟-2015-01-21-my-2014.html]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的.9.png]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2014-12-14-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84ninepatch-png.html</url>
    <content type="text"><![CDATA[一 写在前面作为一枚Android 开发者，适配的问题，使我们不得不去面对的问题，.9.PNG是安卓开发里面的一种特殊的图片，这种格式的图片通过ADT自带的编辑工具生成，使用九宫格切分的方法，使图片支持在android 环境下的自适应展示。PNG的的英文名称为Portable Network Graphics，即便携式网络图片。另有说法是名称来源于非官方的“PNG is Not GIF”。 二 .9.png 介绍什么叫.9.PNG呢，这是Android开发里面的一种特殊的图片.这种格式的图片在android 环境下具有自适应调节大小的能力。 允许开发人员定义可扩展区域，当需要延伸图片以填充比图片本身更大区域时，可扩展区的内容被延展。 允许开发人员定义内容显示区，用于显示文字或其他内容 .9.png图片他的具体不同之处，它的四周与普通的png图片相比多了一个像素位的白色区域，该区域只有在图片被还原和制造的时候才能看到，当打包后无法看见，并且图片的总像素会缩小2个像素，比如25x25像素的9.png图片被打包后会变成23x23像素。在制作的时候要注意掌握尺寸。同时，一个几KB或者几十KB的图片，变得非常的小，一般只有几百个字节那么大。如下图所示：上方(1)和左侧(2)的黑线交叉的部分即可扩展区域,下方(3)和右侧(4)的黑线交叉的部分即内容显示区域(如做button背景图时，button上文字的显示区域)没有黑色条的位置覆盖的区域是图片拉伸时保持不变。 用它可以实现部分拉伸，从而实现图片在Android系统上的完美应用.拆过系统framework-res.apk包的童鞋细心点看，里面有许多有.9.PNG后缀的图片，这些图片是经过Android的工具进行特殊处理过的，如果不处理的话，直接用PNG图就会有失真，拉伸不正常的现象出现。 有些图片的边上有红线（如下图），它表示在这图片为背景的容器组件上子组件所能放置的区域（需要和黑线的扩展结合起来看）。简单的说，就是红线用于控制，去掉不需要的，多余的边框部分的内容。自己根据实际需要，去加上对应的红线，用于去除不需要的多余的边框。 三 .9.png 制作java的jdk、android的sdk中tools目录下的draw9patch.bat 首先我们准备一张需要拉伸的图片，然后将draw9patch.bat打开后，把我们准备的图片拉拽到draw9patch中进行编辑。相信大家已经看到了第二幅图中的黑色的横线条了吧，这个横线条就是通过鼠标左键点击生成的，上端的黑色横条表示图片在水平方向上可以拉伸的区域，左边的黑色横条表示图片可以在竖直方向上被拉伸的区域, 右边黑色条位置向左覆盖的区域表示图片纵向显示内容的区域，底边黑色条位置向上覆盖的区域表示图片横向显示内容的区域。 本文链接：http://www.sguotao.top/Android进阶-2014-12-14-分析Android中的ninepatch-png.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2FJava-2014-11-28-Java%E6%B3%A8%E8%A7%A3.html</url>
    <content type="text"><![CDATA[1.什么是注解 注解Annotation又叫元数据，是JDK5中引入的一种以通用格式为程序提供配置信息的方式。注解使得Java源代码中不但可以包含功能性的实现代码，还可以添加元数据。使用注解Annotation可以使元数据写在程序源码中，使得代码看起来简洁，同时编译器也提供了对注解Annotation的类型检查，使得在编译期间就可以排除语法错误。 注解的功能类似于代码中的注释，所不同的是注解不是提供代码功能的说明，而是实现程序功能的重要组成部分。Java注解已经在很多框架中得到了广泛的使用，用来简化程序中的配置。 从某种角度来说，可以把注解看成是一个XML元素，该元素可以有不同的预定义的属性。而属性的值是可以在声明该元素的时候自行指定的。在代码中使用注解，就相当于把一部分元数据从XML文件移到了代码本身之中，在一个地方管理和维护。 2.常见的使用注解的场景生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等 在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量。一些常用的开源框架，大都采用注解形式的配置方式。 3.基本注解在JDK5中，内置了3个通用目的的注解Annotation，这三个内置的注解在java.lang包下： @Override：这个注解常用在继承类或实现接口的子类方法上，表面该方法是子类覆盖父类的方法，该方法的方法签名要遵循覆盖方法的原则：即访问控制权限必能比父类更严格，不能比父类抛出更多的异常。 @Deprecated：这个注解告诉编译器该元素是过时的，即在目前的JDK版本中已经有新的元素代替该元素。@Deprecated的作用是对不应该在使用的方法添加注释，当编程人员使用这些方法时，将会在编译时显示提示信息，它与javadoc里的@deprecated标记有相同的功能，准确的说，它还不如javadoc @deprecated，因为它不支持参数， @SuppressWarnings：该注解关闭编译器中不合适的警告，即强行压制编译器的警告提示，SuppressWarnings包含的参数有： deprecation：使用了过时的类或方法时的警告 unchecked：执行了未检查的转换时的警告 fall through：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告 path：在类路径、源文件路径等中有不存在的路径时的警告 serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告 finally：任何 finally 子句不能正常完成时的警告 all：关于以上所有情况的警告 4.自定义注解4.1 注解的定义 没有任何元素的空注解Annotation叫做标记Annotation。在声明注解的时候往往需要使用@Target，@Retention等注解，这种注解被称为注解的注解(元数据注解)，即是专门用于处理注解Annotation本身的。 @Target注解：用于指示注解所应用的目标程序元素种类,该注解常和ElementType枚举类型一起联合使用，ElementType枚举提供了java程序中声明的元素类型如下： ANNOTATION_TYPE：注释类型声明。 CONSTRUCTOR：构造方法声明。 FIELD：字段声明(包括枚举常量)。 LOCAL_VARIABLE：局部变量声明。 METHOD：方法声明。 PACKAGE：包声明。 PARAMETER：参数声明。 TYPE:：类，接口或枚举声明。 @Retention注解：该注解用于指示所定义的注解类型的注释在程序声明周期中得保留范围，该注解常和RetentionPolicy枚举联合使用。RetentionPolicy枚举常量定义了注解在代码中的保留策略： CLASS：编译器把注解记录在类文件中，但在运行时JVM不需要保留注解。 RUNTIME：编译器把注解记录在类文件中，在运行时JVM将保留注解，因此可以通过反射机制读取注解。 SOURCE：仅保留在源码中，编译器在编译时就要丢弃掉该注解。 Annotation注解中的元素只能是下面的数据类型： java的8中基本类型，如int, boolean等等，如果可以自动装箱和拆箱，则可以使用对应的对象包装类型。 String类型。 .Class类型。 Enums类型。 Annotation类型。 以上类型的数组。 除了上面这些类型以外，如果在注解中定义其他类型的数据，编译器将会报错。注意：注解中的元素要么指定默认值，要么由使用的类赋值，如果即没有默认值，使用类也没有赋值的话，注解元素是不会像普通类成员变量一样给定默认值，即必须赋值或者显示指定默认值。 如果注解中有一个名称为value 的属性，且只想设置value 的属性（即其它属性都采用默认值或只有一个value 属性）那么可以省略“value = ”部分。 12345678import java.lang.annotation.*;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface DefaultValue&#123; public int id() default -1; public String description() default “”;&#125; 4.2 注解的生命周期一个注解的生命周期包括三个阶段： 1Java 源文件 ---&gt; class 文件 ---&gt; 内存中的字节码 如果一个注解不声明自己的生命周期属于那个阶段，会默认为生命周期是 class 文件阶段。但它也可以由一个@Retetion的元注解指定它的生命周期。 java源文件当在一个注解类前定义了一个@Retetion(RetentionPolicy.SOURCE)的注解，那么说明该注解只保留在一个源文件当中，当编译器将源文件编译成class文件时，它不会将源文件中定义的注解保留在class文件中。 class文件中当在一个注解类前定义了一个@Retetion(RetentionPolicy.CLASS)的注解，那么说明该注解只保留在一个class文件当中，当加载class文件到内存时，虚拟机会将注解去掉，从而在程序中不能访问。 程序运行期间当在一个注解类前定义了一个@Retetion(RetentionPolicy.RUNTIME)的注解，那么说明该注解在程序运行期间都会存在内存当中。此时，我们可以通过反射来获得定义在某个类上的所有注解。 4.3注解的使用注解的使用分为三个过程。 1定义注解--&gt;声明注解--&gt;得到注解 4.3.1 定义注解一个简单的注解： 1234public@interfaceAnnotation01&#123;//定义公共的final静态属性.....//定以公共的抽象方法......&#125; 注解可以有哪些成员注解和接口相似，它只能定义final静态属性和公共抽象方法。 注解的方法1.方法前默认会加上public abstract2.在声明方法时可以定义方法的默认返回值。例如: 12Stringcolor()default&quot;blue&quot;;String[]color()default&#123;&quot;blue&quot;,&quot;red&quot;,......&#125; 3.方法的返回值可以有哪些类型:8种基本类型，String、Class、枚举、注解及这些类型的数组。 4.3.2声明注解1.在哪些元素上声明注解如果定义注解时没有指定@Target元注解来限制它的使用范围，那么该注解可以使用在ElementType枚举指定的任何一个元素前。否则，只能声明在@Target元注解指定的元素前。一般声明的形式：@注解名() 2.对注解的方法的返回值进行赋值对于注解中定义的每一个没有默认返回值的方法，在声明注解时必须对它的每一个方法的返回值进行赋值。一般形式:@注解名(方法名=方法返回值，……)如果方法返回的是一个数组时，那么将方法返回值写在{}符号里@注解名(方法名={返回值1，返回值2，……}，……) 3.对于只含有value方法的注解，在声明注解时可以只写返回值。 4.3.3得到注解对于生命周期为运行期间的注解，都可以通过反射获得该元素上的注解实例。1.声明在一个类中的注解可以通过该类Class对象的getAnnotation或getAnnotations方法获得。2.声明在一个字段中的注解通过Field对象的getAnnotation或getAnnotations方法获得3.声明在一个方法中的注解通过Method对象的getAnnotation或getAnnotations方法获得 参考文档：[1] 成富.Java深度历险（六）——Java注解[Z].InfoQ, 2011.3.23 本文链接：http://www.sguotao.top/Java-2014-11-28-Java注解.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之Json数据解析]]></title>
    <url>%2FJava-2014-11-25-Java-Json%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[1.什么是Json JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于JavaScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成。 2.Json语法规则JSON 语法是 JavaScript 对象表示法语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值： 1&quot;firstName&quot; : &quot;John&quot; 这很容易理解，等价于这条 JavaScript 语句：firstName = “John” JSON 值可以是： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null JSON在线校验格式化工具：bejson 3.Json基础结构JSON建构有两种结构，JSON简单说就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构。 对象：对象在js中表示为“{}”括起来的内容，数据结构为 {key：value,key：value,…}的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。 数组：数组在js中是中括号“[]”括起来的内容，数据结构为 [“java”,”javascript”,”vb”,…]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。经过对象、数组2种结构就可以组合成复杂的数据结构了。 4.Json基础示例简单地说，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在函数之间轻松地传递这个字符串，或者在异步应用程序中将字符串从 Web 客户机传递给服务器端程序。这个字符串看起来有点儿古怪，但是JavaScript很容易解释它，而且 JSON 可以表示比”名称 / 值对”更复杂的结构。例如，可以表示数组和复杂的对象，而不仅仅是键和值的简单列表。 4.1名称 / 值对按照最简单的形式，可以用下面这样的 JSON 表示”名称 / 值对”： 1&#123; &quot;firstName&quot;: &quot;Brett&quot; &#125; 这个示例非常基本，而且实际上比等效的纯文本”名称 / 值对”占用更多的空间： 1firstName=Brett 但是，当将多个”名称 / 值对”串在一起时，JSON 就会体现出它的价值了。首先，可以创建包含多个”名称 / 值对”的 记录，比如： 1&#123; &quot;firstName&quot;: &quot;Brett&quot;, &quot;lastName&quot;:&quot;McLaughlin&quot;, &quot;email&quot;: &quot;aaaa&quot; &#125; 从语法方面来看，这与”名称 / 值对”相比并没有很大的优势，但是在这种情况下 JSON 更容易使用，而且可读性更好。例如，它明确地表示以上三个值都是同一记录的一部分；花括号使这些值有了某种联系。 4.2表示数组当需要表示一组值时，JSON 不但能够提高可读性，而且可以减少复杂性。例如，假设您希望表示一个人名列表。在XML中，需要许多开始标记和结束标记；如果使用典型的名称 / 值对（就像在本系列前面文章中看到的那种名称 / 值对），那么必须建立一种专有的数据格式，或者将键名称修改为 person1-firstName这样的形式。如果使用 JSON，就只需将多个带花括号的记录分组在一起： 1234567&#123;"people": [ &#123; "firstName": "Brett", "lastName":"McLaughlin", "email": "aaaa" &#125;, &#123; "firstName": "Jason", "lastName":"Hunter", "email": "bbbb"&#125;, &#123; "firstName": "Elliotte", "lastName":"Harold", "email": "cccc" &#125; ]&#125; 这不难理解。在这个示例中，只有一个名为 people的变量，值是包含三个条目的数组，每个条目是一个人的记录，其中包含名、姓和电子邮件地址。上面的示例演示如何用括号将记录组合成一个值。当然，可以使用相同的语法表示多个值（每个值包含多个记录）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; "programmers": [ &#123; "firstName": "Brett", "lastName": "McLaughlin", "email": "aaaa" &#125;, &#123; "firstName": "Jason", "lastName": "Hunter", "email": "bbbb" &#125;, &#123; "firstName": "Elliotte", "lastName": "Harold", "email": "cccc" &#125; ], "authors": [ &#123; "firstName": "Isaac", "lastName": "Asimov", "genre": "science fiction" &#125;, &#123; "firstName": "Tad", "lastName": "Williams", "genre": "fantasy" &#125;, &#123; "firstName": "Frank", "lastName": "Peretti", "genre": "christian fiction" &#125; ], "musicians": [ &#123; "firstName": "Eric", "lastName": "Clapton", "instrument": "guitar" &#125;, &#123; "firstName": "Sergei", "lastName": "Rachmaninoff", "instrument": "piano" &#125; ]&#125; 这里最值得注意的是，能够表示多个值，每个值进而包含多个值。但是还应该注意，在不同的主条目（programmers、authors 和 musicians）之间，记录中实际的名称 / 值对可以不一样。JSON 是完全动态的，允许在 JSON 结构的中间改变表示数据的方式。 在处理 JSON 格式的数据时，没有需要遵守的预定义的约束。所以，在同样的数据结构中，可以改变表示数据的方式，甚至可以以不同方式表示同一事物。 5.JSON和XML比较 可读性 JSON和XML的可读性可谓不相上下，一边是简易的语法，一边是规范的标签形式，很难分出胜负。 可扩展性 XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，而JSON却不能扩展的。不过JSON在Javascript主场作战，可以存储Javascript复合对象，有着xml不可比拟的优势。 编码难度 解码难度 实例比较XML和JSON都使用结构化方法来标记数据，下面来做一个简单的比较。用XML表示中国部分省市数据如下： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;country&gt; &lt;name&gt;中国&lt;/name&gt; &lt;province&gt; &lt;name&gt;黑龙江&lt;/name&gt; &lt;cities&gt; &lt;city&gt;哈尔滨&lt;/city&gt; &lt;city&gt;大庆&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;广东&lt;/name&gt; &lt;cities&gt; &lt;city&gt;广州&lt;/city&gt; &lt;city&gt;深圳&lt;/city&gt; &lt;city&gt;珠海&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;台湾&lt;/name&gt; &lt;cities&gt; &lt;city&gt;台北&lt;/city&gt; &lt;city&gt;高雄&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;新疆&lt;/name&gt; &lt;cities&gt; &lt;city&gt;乌鲁木齐&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt;&lt;/country&gt; 用JSON表示如下: 1234567891011121314151617181920212223242526272829&#123; "name":"中国", "province":[ &#123; "name":"黑龙江", "cities":&#123; "city":["哈尔滨","大庆"] &#125; &#125;, &#123; "name":"广东", "cities":&#123; "city":["广州","深圳","珠海"] &#125; &#125;, &#123; "name":"台湾", "cities":&#123; "city":["台北","高雄"] &#125; &#125;, &#123; "name":"新疆", "cities":&#123; "city":["乌鲁木齐"] &#125; &#125;]&#125; 本文链接：http://www.sguotao.top/Java-2014-11-25-Java-Json数据解析.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之屏幕的适配篇]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2014-09-05-Android%E4%B9%8B%E5%B1%8F%E5%B9%95%E7%9A%84%E9%80%82%E9%85%8D.html</url>
    <content type="text"><![CDATA[一 写在前面Android的开源，加速了移动时代的来临，各大厂商纷纷推出自己定制的os，定制的UI，一时间，繁花似锦，各种Android手机，平板如雨后春笋，与此同时，是广大开发者的苦不堪言，各种神奇的小板儿，见过的，没见过的，时刻考验着app的兼容性，各种定制的rom，不经意间就让app崩溃，光是UI的绘制就会花去不少的时间。 二 计量单位 屏幕尺寸：单位inch，指的是屏幕对角线长度。 屏幕密度：单位dpi，指的是每inch上可以显示多少像素点即px。 屏幕分辨率：单位px * px，指的是一屏显示多少像素点。 屏幕无关像素：单位dp/dip，指的是自适应屏幕密度的像素，用于指定控件宽高。 刻度无关像素：单位sp，指的是自适应字体的像素，用于指定文字大小。 于是有个问题，我们平时在绘制UI的过程中，只知道在需要设置控件宽高的时候，单位是dp/dip，设置字体时，单位是sp，下面讨论一下，问什么要这样处理。以我的小米2s为例： 屏幕尺寸：4.3inch（宽高比：16：9）屏幕分辨率：1280*720就算出屏幕的宽高约为：2inch，3.56inch垂直方向的dpi为 1280/3.56 = 359.55水平方向的dpi为 720/2 = 360 通常理论值和实际值还是有区别的，虽然米2s官方称dpi有342，但跑分软件显示是320dpi，这里不去纠结，相信这是工业上切割液晶板时取整为320。 了解的这个过程之后，我们不禁要问dpi和px 之间到底是个啥关系？ dpi px 120dpi(ldpi低密度屏) 1dp = 0.75px(由于像素点是物理点，所以用2个像素点来显示3个dp的内容) 160dpi(mdpi中密度屏) 1dp = 1px 213dpi(tvdpi电视密度屏) 1dp = 1.33px 240dpi(hdpi高密度屏) 1dp = 1.5px 320dpi(xhdpi极高密度屏) 1dp = 2px 因此，dp和sp就完全能够满足自适应的需求，我们就知道了为什么在绘制UI的过程中，Google官方文档建议我们使用dp和sp。 三 适配方案1. Google官方给出的建议 在分辨率中使用wrap_content, fill_parent,或者dp单位。使用sp单位来定义字体大小。 在manifest文件中声明android:requiresSmallestWidthDp、android:compatibleWidthLimitDp、android:largestWidthLimitDp，限定分辨率。 不使用绝对布局。绝对布局是根据像素点排列的，在项目中推荐使用相对布局。 在代码中尽量不使用硬性定义。使用myView.getWidth()在当前屏幕下得到了10的值，但是可能在另一个屏幕下会得到15的值。所以在代码中使用硬性定义的话，会导致屏幕不适配的问题。 针对不同尺寸和不同密度采用不同的资源。尽管系统可以自动识别屏幕大小并作出资源图片的调整，如果想让图片资源保持不同方向比例一致的话，还是在资源中添加多个资源。如果需要精确地摆放图片位置的话，建议修整图片到合适的大小，并根据图片密度放在不同的文件夹下，例如drawable-mdpi和drawable-ldpi里。 2.其他方案 在布局文件中使用weight来控制位置。将控件的layout中的width、height设置为fill-parent，不要使用wrap-content。因为wrap-content的大小是不固定的。而weight（权重）这个属性很好的解决了这个问题。当包裹在控件外面的Layout的width、height属性都设置为fill-parent时，可以利用weight。即如果控件A设置weight为1，控件B设置weight为2，那么A所占的空间为1/（1+2），B所占的空间为2/（1+2）。这样对任何分辨率下的手机都是合适的。 字体大小的设置。需要在res文件夹中创建一个文件夹，叫做values-1280x720。其中1280x7200是手机屏幕的分辨率，根据手机屏幕的情况做不同的命名，一定要保留res里默认的dimens.xml文件，这样的话可以再屏幕分辨率不适应的情况下找到字体大小。屏幕自适应可能会出现识别错误问题，创建一个drawable文件夹即可。也可以将资源文件放入assets中。 一些比较极端的情况，比如1280x800 1280x768 1280x720，这里可以使用一个兼容性的布局，如果里面含有图片而且对于宽度要求十分精确地话，建议修正图片大小或者做填充处理（在边缘为纯色的情况下将背景填充为和边缘颜色一样的色值即可）。 .9.png 图片的使用 通过代码获取屏幕的宽高，进行设置。WindowManager wm = (WindowManager) this.getSystemService(Context.WINDOW_SERVICE); width= wm.getDefaultDisplay().getWidth();// 屏幕宽度 做一张超大的图片，然后等比例缩小图片，来进行图片的适配。 说明： 分辨率限定符的匹配是向下匹配，如果没有values-land-mdpi-1024x552，无法适配到values-land-mdpi-1024x600，那这样就可能适配到下一级，比如values-land-mdpi-800x480，也可以适配到无限定符的values-mdpi里，造成界面显示上的瑕疵，至少可以保证app运行时不至于崩溃。 本文链接：http://www.sguotao.top/Android进阶-2014-09-05-Android之屏幕的适配.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IO流】序列流]]></title>
    <url>%2FJava-2013-12-04-JavaIO%E6%B5%81%E4%B9%8B%E5%BA%8F%E5%88%97%E6%B5%81.html</url>
    <content type="text"><![CDATA[在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：Java IO流 1.IO流的介绍Java IO流 2.字符流Java IO流 3.字节流Java IO流 4.File类Java IO流 5.序列流 序列流SequenceInputStream特点：可以将多个读取流合并成一个流。这样操作起来很方便。 原理：其实就是将每一个读取流对象存储到一个集合中。最后一个流对象结尾作为这个流的结尾。两个构造函数： 12SequenceInputStream(InputStream in1,InputStream in2) //可以将两个读取流合并成一个流SequenceInputStream(Enumeration &amp;lt;? extends InputStream &amp;gt; en) //可以将枚举中的多个流合并成一个流。 作用：可以用于多个数据的合并. 注意：因为Enumeration是Vector中特有的取出方式。而Vector被ArrayList取代。 所以要使用ArrayList集合效率更高一些。那么如何获取Enumeration呢? 1234567891011121314151617181920212223ArrayList &amp;lt;FileInputStream &amp;gt;al = new ArrayList&amp;lt;FileInputStream&amp;gt;(); for(int x=1; x&lt;4; x++) al.add(new FileInputStream(x+".txt")); Iterator&amp;lt;FileInputStream&amp;gt; it = al.iterator(); Enumeration&amp;lt;FileInputStream&amp;gt; en = new Enumeration&amp;lt;FileInputStream&amp;gt;()&#123; public boolean hasMoreElements() &#123; return it.hasNext(); &#125; public FileInputStream nextElement() &#123; return it.next(); &#125; &#125;; //多个流就变成了一个流，这就是数据源。 SequenceInputStream sis = new SequenceInputStream(en); //创建数据目的。 FileOutputStream fos = new FileOutputStream("4.txt"); byte[] buf = new byte[1024*4]; int len = 0; while((len=sis.read(buf))!=-1) &#123; fos.write(buf,0,len); &#125; fos.close(); sis.close(); 如果要一个对文件数据切割。一个读取对应多了输出。 1234567891011FileInputStream fis = new FileInputStream("1.mp3"); FileOutputStream fos = null; byte[] buf = new byte[1024*1024];//是一个1MB的缓冲区。 int len = 0; int count = 1; while((len=fis.read(buf))!=-1) &#123; fos = new FileOutputStream((count++)+".part); fos.write(buf,0,len); fos.close(); &#125; fis.close(); 这样就是将1.mp3文件切割成多个碎片文件。想要合并使用SequenceInputStream即可。对于切割后，合并是需要的一些源文件的信息。可以通过配置文件进行存储。该配置可以通过键=值的形式存在。然后通过Properties对象进行数据的加载和获取。 对象的序列化ObjectInputStream 和ObjectOutputStream可以通过这两个流对象直接操作已有对象并将对象进行本地持久化存储。存储后的对象可以进行网络传输。两个对象的特有方法：ObjectInputStream 1Object readObject()//该方法抛出异常：ClassNotFountException。 ObjectOutputStream 1void writeObject(Object)//被写入的对象必须实现一个接口:Serializable 否则会抛出：NotSerializableException Serializable：该接口其实就是一个没有方法的标记接口。 用于给类指定一个UID。该UID是通过类中的可序列化成员的数字签名运算出来的一个long 型的值。 只要是这些成员没有变化，那么该值每次运算都一样。 该值用于判断被序列化的对象和类文件是否兼容。如果被序列化的对象需要被不同的类版本所兼容。可以在类中自定义UID。定义方式：static final long serialVersionUID = 42L; 注意：对应静态的成员变量，不会被序列化。对应非静态也不想被序列化的成员而言，可以通过transient关键字修饰。 通常，这两个对象成对使用。 操作基本数据类型的流对象DataInputStreamDataInputStream(InputStream);操作基本数据类型的方法： 123456int readInt():一次读取四个字节，并将其转成int 值。 boolean readBoolean():一次读取一个字节。 short readShort(); long readLong(); 剩下的数据类型一样。 String readUTF():按照utf-8修改版读取字符。注意，它只能读writeUTF()写入的字符数据 DataOutputStreamDataOutputStream(OutputStream):操作基本数据类型的方法: 12345678writeInt(int)：一次写入四个字节。 注意：和write(int)不同。write(int)只将该整数的最低一个8位写入。剩余三个8位丢弃。 writeBoolean(boolean); writeShort(short); writeLong(long); 剩下是数据类型也也一样。 writeUTF(String):按照utf-8修改版将字符数据进行存储。只能通过readUTF 读取。 通常只要操作基本数据类型的数据。就需要通过DataStram进行包装。通常成对使用。 操作数组的流对象操作字节数组 12345ByteArrayInputStream ByteArrayOutputStream toByteArray(); toString(); writeTo(OutputStream); 操作字符数组 12CharArrayReader CharArrayWriter 对于这些流，源是内存。目的也是内存。而且这些流并未调用系统资源。使用的就是内存中的数组。所以这些在使用的时候不需要close。操作数组的读取流在构造时，必须要明确一个数据源。所以要传入相对应的数组。 对于操作数组的写入流，在构造函数可以使用空参数。因为它内置了一个可变长度数组作为缓冲区。这几个流的出现其实就是通过流的读写思想在操作数组。类似的对象同理： StringReader，StringWriter。 编码转换在io 中涉及到编码转换的流是转换流和打印流。但是打印流只有输出。在转换流中是可以指定编码表的。默认情况下，都是本机默认的码表。GBK. 这个编码表怎么来的？ 1System.getProperty("file.encoding"); 常见码表： 123456ASCII:美国标准信息交换码。使用的是1个字节的7位来表示该表中的字符。 ISO8859-1:拉丁码表。使用1个字节来表示。 GB2312:简体中文码表。 GBK：简体中文码表，比GB2312融入更多的中文文件和符号。 unicode:国际标准码表。都用两个字节表示一个字符。 UTF-8：对unicode进行优化，每一个字节都加入了标识头。 编码转换： 字符串 –&gt;字节数组 ：编码。通过getBytes(charset); 字节数组–&gt;字符串 ： 解码。通过String类的构造函数完成。String(byte[],charset); 如果编错了，没救！ 如果编对了，解错了，有可能还有救！ 123456String s = "你好"; //编码 byte[] b = s.getBytes("GBK"); //解码String s1 = new String(b,"iso8859-1"); System.out.println(s1);//???? 想要还原。 12345/* 对s1先进行一次解码码表的编码。获取原字节数据。 然后在对原字节数据进行指定编码表的解码。 */ byte[] b1 = s1.getBytes("iso8859-1"); String s2 = new String(b1,"gbk"); System.out.println(s2);//你好 这种情况在tomcat服务器会出现。 因为tomcat服务器默认是iso8859-1的编码表。所以客户端通过浏览器向服务端通过get提交方式提交中文数据时，服务端获取到会使用ISO8859-1进行中文数据的解码。会出现乱码。 这时就必须要对获取的数据进行iso8859-1编码。然后在按照页面指定的编码表进行解码即可，而对于post提交，这种方法也通用。但是post有更好的解决方式。 request.setCharacterEncoding(“utf-8”);即可。所以建立客户端提交使用post提交方式。 本文链接：http://www.sguotao.top/Java-2013-12-04-JavaIO流之序列流.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IO流】File类]]></title>
    <url>%2FJava-2013-12-03-JavaIO%E6%B5%81%E4%B9%8BFile%E7%B1%BB.html</url>
    <content type="text"><![CDATA[在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：Java IO流 1.IO流的介绍Java IO流 2.字符流Java IO流 3.字节流Java IO流 4.File类Java IO流 5.序列流 File类该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。 可以通过对象的思想来操作文件以及文件夹。1.构造函数 123File(String filename)//将一个字符串路径(相对或者绝对)封装成File对象，该路径是可存在的，也可以是不存在。 File(String parent,String child); File(File parent,String child); 2.特别的字段：separator:跨平台的目录分隔符。 1File file = new File("c:"+File.separator+"abc"+File.separator+"a.txt"); 3.常见方法1) 创建： 123boolean createNewFile()throws IOException//创建文件，如果被创建的文件已经存在，则不创建。 boolean mkdir()// 创建文件夹。 boolean mkdirs()//创建多级文件夹。 2) 删除： 123boolean delete()//可用于删除文件或者文件夹。 注意：**对于文件夹只能删除不带内容的空文件夹，对于带有内容的文件夹，不可以直接删除，必须要从里往外删除**。 void deleteOnExit()//删除动作交给系统完成。无论是否反生异常，系统在退出时执行删除动作。 3) 判断： 1234567boolean canExecute()boolean canWrite()boolean canRead()boolean exists()//判断文件或者文件夹是否存在。 boolean isFile()//判断File对象中封装的是否是文件。 boolean isDirectory()//判断File对象中封装的是否是文件夹。 boolean isHidden()//判断文件或者文件夹是否隐藏。在获取硬盘文件或者文件夹时，对于系统目录中的文件，java是无法访问的，所以在遍历，可以避免遍历隐藏文件。 4) 获取： 1234567891011getName()//获取文件或者文件夹的名称。 getPath()//File对象中封装的路径是什么，获取的就是什么。 getAbsolutePath()//无论File对象中封装的路径是什么，获取的都是绝对路径。 getParent()//获取File对象封装文件或者文件夹的父目录。 注意：**如果封装的是相对路径，那么返回的是null.**long length()//获取文件大小。 long lastModified()//获取文件或者文件最后一次修改的时间。 static File[] listRoots()//获取的是被系统中有效的盘符。 String[] list()//获取指定目录下当前的文件以及文件夹名称。 String[] list(Filenamefilter)//可以根据指定的过滤器，过滤后的文件及文件夹名称。 File[] listFiles()//获取指定目录下的文件以及文件夹对象。 5) 重命名： 1234renameTo(File): File f1 = new File("c:\\a.txt"); File f2 = new File("c:\\b.txt"); f1.renameTo(f2);//将c盘下的a.txt文件改名为b.txt文件。 递归其实就是在使用一个功能过程中，又对该功能有需求。就出现了函数自身调用自身。注意： 一定要限定条件，否则内存溢出。 使用递归时，调用次数不要过多，否则也会出现内存溢出。 需求：想要列出指定目录下的文件以及文件夹中的文件(子文件)。列出指定目录下的当前的文件或者文件夹。想要列出当前目录下的文件夹中的文件，其实就是在重新使用该功能。 1234567891011public void listDir(File dir,int level) &#123; System.out.println(getLevel(level)+dir.getName()); level++; File[] files = dir.listFiles(); for(int x =0; x&lt;files.length; x++) &#123; if(files[x].isDirecotry())//如果遍历到的是目录。 listDir(files[x],level);//那么就行该功能的重复使用递归。 else System.out.println(getLevel(level)+files[x].getName()); &#125; &#125; 想要对列出的目录有一些层次关系。 12345678public String getLevel(int level) &#123; StringBuilder sb = new StringBuilder(); sb.append("|--"); for(int x=0; x&lt;level; x++) &#123; sb.insert(0,"| "); &#125; return sb.toString(); &#125; 需求：删除一个带内容的目录。原理：从里往外删除，所以需要使用递归完成。 12345678910public void deleteAll(File dir) &#123; File[] files = dir.listFiles(); for(int x=0; x&lt;files.length; x++) &#123; if(files[x].isDirectory()) deleteAll(files[x]); else files[x].delete(); &#125; dir.delete(); &#125; IO 包中的常见对象和其它对象1.IO 包中的常见对象 字节流： FileInputStream FileOutputStream BufferedInputStream BufferedOutputStream 字符流: FileReader FileWriter BufferedReader BufferedWriter 转换流: InputStreamReader OutputStreamWriter 文件对象: File 所有的带File的流对象都可以直接操作File对象。 打印流： PrintStream PrintWriter 2.IO 包中的其他对象 打印流：PrintStream PrintWriterPrintStream： 是一个字节打印流，System.out对应的类型就是PrintStream。它的构造函数可以接收三种数 据类型的值。 字符串路径。 File对象。 OutputStream。 PrintWriter： 是一个字符打印流。构造函数可以接收四种类型的值。 字符串路径。 File对象,对于1，2类型的数据，还可以指定编码表。也就是字符集. OutputStream Writer 对于3，4类型的数据，可以指定自动刷新。 注意：该自动刷新值为true 时，只有三个方法可以用：println,printf,format. 123456//如果想要既有自动刷新，又可执行编码。如何完成流对象的包装？ PrintWrter pw = new PrintWriter(new OutputSteamWriter(new FileOutputStream("a.txt"),"utf-8"),true); //如果想要提高效率。还要使用打印方法。 PrintWrter pw = new PrintWriter(new BufferdWriter(new OutputSteamWriter(new FileOutputStream("a.txt"),"utf-8")),true); 3.管道流PipedInputStream PipedOutputStream特点：读取管道流和写入管道流可以进行连接。 连接方式： 通过两个流对象的构造函数。 通过两个对象的connect方法。通常两个流在使用时，需要加入多线程技术，也就是让读写同时运行。注意：对于read方法。该方法是阻塞式的，也就是没有数据的情况，该方法会等待。 4.RandomAccessFile该对象并不是流体系中的一员。该对象中封装了字节流，同时还封装了一个缓冲区(字节数组)，通过内部的指针来操作数组中的数据。该对象可以读数据，可以写入数据，如果写入位置已有数据，会发生数据覆盖。也就是可以对数据进行修改。在使用该对象时，建议数据都是有规则的。或者是分段的。注意；该对象在实例化时，如果要操作的文件不存在，会自动建立。如果要操作的文件存在，则不会建立，如果存在的文件有数据。那么在没有指定指针位置的情况下，写入数据，会将文件开头的数据覆盖。 可以用于多线程的下载，也就是通过多线程往一个文件中同时存储数据。 该对象特点： 该对象只能操作文件，所以构造函数接收两种类型的参数。 字符串路径。 File对象。 该对象既可以对文件进行读取，也可以写入。 在进行对象实例化时，必须要指定的该对象的操作模式，r rw等。 该对象中有可以直接操作基本数据类型的方法。 该对象最有特点的方法： 123skipBytes()//跳过指定的字节数。 seek()//指定指针的位置。 getFilePointer()//获取指针的位置。 通过这些方法，就可以完成对一个文件数据的随机的访问。 本文链接：http://www.sguotao.top/Java-2013-12-03-JavaIO流之File类.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IO流】字节流]]></title>
    <url>%2FJava-2013-12-02-JavaIO%E6%B5%81%E4%B9%8B%E5%AD%97%E8%8A%82%E6%B5%81.html</url>
    <content type="text"><![CDATA[在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：Java IO流 1.IO流的介绍Java IO流 2.字符流Java IO流 3.字节流Java IO流 4.File类Java IO流 5.序列流 字节流抽象基类：InputStream，OutputStream。字节流可以操作任何数据。注意：字符流使用的数组是字符数组。char [] chs字节流使用的数组是字节数组。byte [] bt 12345FileOutputStream fos = new FileOutputStream("a.txt"); fos.write("abcde");//直接将数据写入到了目的地。 fos.close();//只关闭资源。 FileInputStream fis = new FileInputStream("a.txt"); //fis.available();//获取关联的文件的字节数。 如果文件体积不是很大，可以这样操作。 1byte[] buf = new byte[fis.available()];//创建一个刚刚好的缓冲区。 但是这有一个弊端，就是文件过大，大小超出jvm 的内容空间时，会内存溢出。 12345678910111213fis.read(buf); System.out.println(new String(buf)); /** *copy一个图片 */BufferedInputStream bufis = new BufferedInputStream(new FileInputStream("1.jpg")); BufferedOutputStream bufos = new BufferedOutputStream(new FileOutptStream("2.jpg")); int by = 0; while((by=bufis.read())!=-1)&#123; bufos.write(by); &#125; bufos.close(); bufis.close(); 字节流&amp;字符流小结字符流 FileReader. FileWriter. BufferedReader BufferedWriter. 字节流 FileInputStream FileOutputStream BufferedInputStream BufferedOutputStream 字节流的read()方法读取一个字节。为什么返回的不是byte类型，而是int 类型呢？因为read方法读到末尾时返回的是-1。而在所操作的数据中的很容易出现连续多个1的情况，而连续读到8个1，就是-1。导致读取会提前停止。所以将读到的一个字节给提升为一个int 类型的数值，但是只保留原字节，并在剩余二进制位补0。 具体操作是：byte&amp;255 or byte&amp;0xff 。对于write方法，可以一次写入一个字节，但接收的是一个int 类型数值。只写入该int 类型的数值的最低一个字节（8位）。简单说:read方法对读到的数据进行提升。write对操作的数据进行转换。 转换流1.转换流特点 是字节流和字符流之间的桥梁。 该流对象中可以对读取到的字节数据进行指定编码表的编码转换。 2.什么时候使用呢? 当字节和字符之间有转换动作时。 流操作的数据需要进行编码表的指定时。 3.具体的对象体现 InputStreamReader：字节到字符的桥梁。 OutputStreamWriter：字符到字节的桥梁。 这两个流对象是字符流体系中的成员。那么它们有转换作用，而本身又是字符流。所以在构造的时候，需要传入字节流对象进来。构造函数： 123InputStreamReader(InputStream)://通过该构造函数初始化，使用的是本系统默认的编码表GBK。 InputStreamReader(InputStream,String charSet)://通过该构造函数初始化，可以指定编码表。 OutputStreamWriter(OutputStream)://通过该构造函数初始化，使用的是本系统默认的编码表GBK。 OutputStreamWriter(OutputStream,String charSet)://通过该构造函数初始化，可以指定编码表。 4.操作文件的字符流对象是转换流的子类Reader&nbsp;&nbsp;|–InputStreamReader&nbsp;&nbsp;&nbsp;&nbsp;|–FileReader Writer&nbsp;&nbsp;|–OutputStreamWriter&nbsp;&nbsp;&nbsp;&nbsp;|–FileWriter 转换流中的read方法。已经融入了编码表，在底层调用字节流的read方法时将获取的一个或者多个字节数据进行临时存储，并去查指定的编码表，如果编码表没有指定，查的是默认码表。那么转流的read方法就可以返回一个字符比如中文。转换流已经完成了编码转换的动作，对于直接操作的文本文件的FileReaer而言，就不用在重新定义了，只要继承该转换流，获取其方法，就可以直接操作文本文件中的字符数据了。 注意： 在使用FileReader操作文本数据时，该对象使用的是默认的编码表。如果要使用指定编码表时，必须使用转换流。 1FileReader fr = new FileReader("a.txt");//操作a.txt的中的数据使用的本系统默认的GBK。 操作a.txt中的数据使用的也是本系统默认的GBK。 1InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt")); 这两句的代码的意义相同。如果a.txt中的文件中的字符数据是通过utf-8的形式编码。那么在读取时，就必须指定编码表。那么转换流必须使用。 1InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt"),"utf-8"); 5.流操作的基本规律 明确数据源和数据汇（数据目的）。其实是为了明确输入流还是输出流。 明确操作的数据是否是纯文本数据。其实是为了明确字符流还是字节流。 6.数据源与数据汇 数据源：键盘System.in,硬盘File开头的流对象，内存(数组)。 数据汇：控制台System.out,硬盘File开头的流对象，内存(数组)。 7.需求：将键盘录入的数据存储到一个文件中。数据源：System.in 既然是源，使用的就是输入流，可用的体系有InputStream，Reader。 因为键盘录入进来的一定是纯文本数据，所以可以使用专门操作字符数据的Reader。发现System.in对应的流是字节读取流。所以要将其进行转换，将字节转成字符即可。所以要使用Reader体系中：InputStreamReader接下来，是否需要提高效率呢？如果需要，那么就加入字符流的缓冲区： 1BufferedReader bur = new BufferedReader(new InputStreamReader(System.in)); 数据汇：一个文件，硬盘。既然是数据汇，那么一定是输出流，可以用的OutputStream,Writer。往文件中存储的都是文本数据，那么可以使用字符流较为方便:Writer。因为操作的是一个文件。所以使用Writer中的FileWriter。是否要提高效率呢？是，那就使用BufferedWriter。 1BufferedWriter bufr = new BufferedWriter(new FileWriter("a.txt")); 8.附加需求：希望将这些文本数据按照指定的编码表存入文件中。既然是文本数据，而是还是写入到文件中，那么使用的体系还是Writer。因为要指定编码表，所以要使用Writer中的转换流，OutputStreamWriter。是否要提高效率，是，选择BufferedWriter。注意：虽然是最终是文件，但是不可以选择FileWriter。因为该对象是使用默认编码表。 输出转换流要接收一个字节输出流进来，所以要是用OutputStram体系，而最终输出到一个文件中，那么就要使用OutputStream体系中可以操作的文件的字节流对象FileOutputStream。： 1234//String charSet = System.getProperty("file.encoding"); String charSet = "utf-8"; BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("a.txt"),charSet); 可以和流相关联的集合对象PropertiesMap&nbsp;&nbsp;|–Hashtable&nbsp;&nbsp;&nbsp;&nbsp;|–Properties Properties:该集合不需要泛型，因为该集合中的键值对都是String类型。 存入键值对：setProperty(key,value); 获取指定键对应的值：value getProperty(key); 获取集合中所有键元素：Enumeration propertyNames(); 在jdk1.6 版本给该类提供一个新的方法：Set stringPropertyNames(); 列出该集合中的所有键值对，可以通过参数打印流指定列出到的目的地。list(PrintStream); list(PrintWriter); 例：list(System.out):将集合中的键值对打印到控制台。 1list(new PrintStream("prop.txt"));//将集合中的键值对存储到prop.txt文件中。 可以将流中的规则数据加载进行集合，并称为键值对。 1load(InputStream): //jdk1.6 版本。提供了新的方法。 load(Reader): 注意：流中的数据要是 “键=值” 的规则数据。 可以将集合中的数据进行指定目的的存储。12store(OutputStram,String comment)方法。 //jdk1.6 版本。提供了新的方法。 store(Writer ,String comment): 使用该方法存储时，会带着当时存储的时间。 本文链接：http://www.sguotao.top/Java-2013-12-02-JavaIO流之字节流.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IO流】字符流]]></title>
    <url>%2FJava-2013-12-01-JavaIO%E6%B5%81%E4%B9%8B%E5%AD%97%E7%AC%A6%E6%B5%81.html</url>
    <content type="text"><![CDATA[在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：Java IO流 1.IO流的介绍Java IO流 2.字符流Java IO流 3.字节流Java IO流 4.File类Java IO流 5.序列流 字符流介绍 Reader&nbsp;&nbsp;|–InputStreamReader&nbsp;&nbsp;&nbsp;&nbsp;|–FileReader:专门用于处理文件的字符读取流对象。 Writer&nbsp;&nbsp;|–OutputStreamWriter&nbsp;&nbsp;&nbsp;&nbsp;|–FileWriter:专门用于处理文件的字符写入流对象。 Writer 和 ReaderReader中的常见的方法 int read()： 读取一个字符。返回的是读到的那个字符。如果读到流的末尾，返回-1。 int read(char[])： 将读到的字符存入指定的数组中，返回的是读到的字符个数，也就是往数组里装的元素的个数。如果读到流的末尾，返回-1。 close(): 读取字符其实用的是window系统的功能，就希望使用完毕后，进行资源的释放。 Writer中的常见的方法 write(ch): 将一个字符写入到流中。 write(char[]): 将一个字符数组写入到流中。 write(String): 将一个字符串写入到流中。 flush():刷新流，将流中的数据刷新到目的地中，流还存在。 close():关闭资源：在关闭前会先调用flush()，刷新流中的数据去目的地。然后流关闭。 FileWriter和FileReader3.1 FileWriter该类没有特有的方法。只有自己的构造函数。该类特点在于， 用于处理文本文件。 该类中有默认的编码表， 该类中有临时缓冲。 构造函数：在写入流对象初始化时，必须要有一个存储数据的目的地。 1FileWriter(String filename) 该构造函数做了什么事情呢？ 调用系统资源。 在指定位置，创建一个文件。 注意：如果该文件已存在，将会被覆盖. 1FileWriter(String filename,boolean append) 该构造函数：当传入的boolean类型值为true时，会在指定文件末尾处进行数据的续写。 FileReader 用于读取文本文件的流对象。 用于关联文本文件。 构造函数：在读取流对象初始化的时候，必须要指定一个被读取的文件。 如果该文件不存在会发生FileNotFoundException. 12345678910111213FileReader(String filename); /** *将文本数据存储到一个文件中 */ class Demo &#123; public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWrier("demo.txt"); fw.write("abcdec"); fw.flush(); fw.write("kkkk"); fw.close(); &#125; &#125; 对于读取或者写入流对象的构造函数，以及读写方法，还有刷新关闭功能都会抛出IOException 或其子类。 所以都要进行处理。或者throws抛出，或者try ……catch处理。 1234567891011121314151617181920212223/** *完整的异常处理方式 */ class Demo &#123; public static void main(String[] args) &#123; FileWriter fw = null; try &#123; fw = new FileWrier("z:\\demo.txt"); fw.write("abcdec"); fw.flush(); fw.write("kkkk"); &#125; catch(IOException e) &#123; System.out.println(e.toString()); &#125; finally&#123; if(fw!=null) try &#123; fw.close(); &#125; catch(IOException e) &#123; System.out.println("close:"+e.toString()); &#125; &#125; &#125; &#125; 另一个小细节，当指定绝对路径时，定义目录分隔符有两种方式： 反斜线 但是一定要写两个。\\ new FileWriter(“c:\\demo.txt”); 斜线 / 写一个即可。 new FileWriter(“c:/demo.txt”); 1234567891011121314151617181920212223242526272829303132333435363738394041/** *读取一个已有的文本文件，将文本数据打印出来 *一次读一个字符就打印出来，效率不高。 */class Demo &#123; public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader("demo.txt"); int ch = 0; //一次读一个字符 while((ch=fr.read())!=-1) &#123; System.out.print((char)ch); &#125; fr.close(); &#125; &#125; /** *读一个字符就存入字符数组里，读完1Kb再打印 */ class Demo &#123; public static void main(String[] args) &#123; FileReader fr = null; try &#123; fr = new FileReader("demo.txt"); char[] buf = new char[1024];//该长度通常都是1024的整数倍 int len = 0; while((len=fr.read(buf))!=-1) &#123; System.out.println(new String(buf,0,len)); &#125; &#125; catch(IOException e) &#123; System.out.println(e.toString()); &#125; finally &#123; if(fr!=null) try&#123; fr.close(); &#125; catch(IOException e)&#123; System.out.println("close:"+e.toString()); &#125; &#125; &#125; &#125; BufferedWriter和BufferedReader缓冲区的出现提高了对流的操作效率。原理：其实就是将数组进行封装。 对应的对象： BufferedWriter特有方法： newLine()：跨平台的换行符 对应的对象：BufferedReader：特有方法： readLine():一次读一行，到行标记时，将行标记之前的字符数据作为字符串返回。当读到末尾时，返回null。 在使用缓冲区对象时，要明确，缓冲的存在是为了增强流的功能而存在，所以在建立缓冲区对象时，要先有流对象存在。其实缓冲内部就是在使用流对象的方法，只不过加入了数组对数据进行了临时存储。为了提高操作数据的效率。代码上的体现： 写入缓冲区对象。 12345 //建立缓冲区对象必须把流对象作为参数传递给缓冲区的构造函数BufferedWriter bufw = new BufferedWriter(new FileWriter("buf.txt")); bufw.write("abce");//将数据写入到了缓冲区bufw.flush();//对缓冲区的数据进行刷新。将数据刷到目的地中bufw.close();//关闭缓冲区，其实关闭的是被包装在内部的流对象 读取缓冲区对象。 123456BufferedReader bufr = new BufferedReader(new FileReader("buf.txt")); String line = null; //按照行的形式取出数据。取出的每一个行数据不包含回车符while((line=bufr.readLine())!=null) &#123; System.out.println(line); &#125; bufr.close(); 通过缓冲区的形式，对文本文件进行拷贝。 123456789101112public static void main(String[] args) &#123; BufferedReader bufr = new BufferedReader(new FileReader("a.txt")); BufferedWriter bufw = new BufferedWriter(new FileWriter("b.txt")); String line = null; while((line=bufr.readLine())!=null) &#123; bufw.write(line); bufw.newLine(); bufw.flush(); &#125; bufw.close(); bufr.close(); &#125; readLine()方法的原理其实缓冲区中的该方法，用的还是与缓冲区关联的流对象的read方法。只不过，每一次读到一个字符，先不进行具体操作，先进行临时存储。当读取到回车标记时，将临时容器中存储的数据一次性返回。既然明确了原理，我们也可以实现一个类似功能的方法。 123456789101112131415161718192021222324252627282930313233class MyBufferedReader &#123; private Reader r; MyBufferedReader(Reader r) &#123; this.r = r; &#125; public String myReadLine()throws IOException &#123; //1,创建临时容器 StringBuilder sb = new StringBuilder(); //2,循环的使用read方法不断读取字符 int ch = 0; while((ch=r.read())!=-1) &#123; if(ch=='\r') continue; if(ch=='\n') return sb.toString(); else sb.append((char)ch); &#125; if(sb.length()!=0) return sb.toString(); return null; &#125; public void myClose()throws IOException &#123; r.close(); &#125; &#125; main() &#123; MyBufferedReader myBufr = new MyBufferedReader(new FileReader("a.txt")); String line = null; while((line=myBufr.myReadLine())!=null) &#123; System.out.println(line); &#125; &#125; 装饰设计模式字符流缓冲区的出现基于流并增强了流的功能。这也是一种设计模式的体现：装饰设计模式。 实现了对一组对象进行功能的增强。该模式和继承有什么区别呢？它比继承有更好的灵活性。通常装饰类和被装饰类都同属与一个父类或者接口。 Writer&nbsp;&nbsp;|–MediaWriter&nbsp;&nbsp;&nbsp;&nbsp;|–TextWriter 注：MediaWriter与TextWtiter两个类在JDK 中并不存在，为了更形象的举例说明而“创建”的，不要误解 需求：想要对数据的操作提高效率，就用到了缓冲技术通过所学习的继承特性。可以建立子类复写父类中的write方法即可。 Writer：注：不要误解，以下两个对象不存在，只为举例.&nbsp;&nbsp;|–MediaWriter&nbsp;&nbsp;&nbsp;&nbsp;|–BufferedMediaWriter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–TextWriter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–BufferedTextWriter 当Writer中子类对象过多，那么为了提高每一个对象效率，每一个对象都有一个自己的子类Buffered。虽然可以实现，但是继承体系变的很臃肿。那么是否可以对其进行一下优化呢？其实子类都是在使用缓冲技术。可不可以对缓冲技术进行描述，将需要增强的对象传递给缓冲区即可。 1234class BufferdWriter &#123; BufferedWriter(MediaWriter mw) &#123; &#125; BufferedWriter(TextWriter mw) &#123; &#125; &#125; 该类虽然完成了对已有两个对象的增强。但是当有新的对象出现时，还要继续在该类中添加构造函数。这样不利于扩展和维护。将对这些对象父类型进行操作即可。这就是多态，提高了程序的扩展性。同时BufferedWriter中一样具体write方法，只不过是增强后的write。所以BuferedWriter也应该是Writer中的一个子类。 123456class BufferedWriter extends Writer &#123; private Writer w; BufferedWriter(Writer w)&#123; this.w = w; &#125; &#125; Writer&nbsp;&nbsp;|–MediaWriter&nbsp;&nbsp;&nbsp;&nbsp;|–TextWriter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|–BufferedWriter 这样就会发现装饰设计模式，优化增强功能的部分。比继承要灵活很多。可以在读一行的基础上添加一个行号。 12345678910111213141516class MyLineNumberReader extends MyBufferedReader &#123; private int number; MyLineNumberReader(Reader r) &#123; super(r); &#125; public String myReadLine()&#123; number++; return super.myReadLine(); &#125; public void setNumber(int number)&#123; this.number = number; &#125; public int getNumber()&#123; return number; &#125; &#125; 本文链接：http://www.sguotao.top/Java-2013-12-01-JavaIO流之字符流.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【IO流】Java IO流的介绍]]></title>
    <url>%2FJava-2013-11-30-JavaIO%E6%B5%81%E7%9A%84%E4%BB%8B%E7%BB%8D.html</url>
    <content type="text"><![CDATA[在学习Java IO相关的内容时，会遇到成对出现的流，为方便日后查阅，整理以下笔记内容：Java IO流 1.IO流的介绍Java IO流 2.字符流Java IO流 3.字节流Java IO流 4.File类Java IO流 5.序列流 1. IO流对象的继承关系 2. 常用与流有关的对象 3. IO流 IO 流用于处理设备上的数据设备：硬盘，内存，键盘录入。 IO 有具体的分类根据处理的数据类型不同：字节流和字符流。根据流向不同：输入流和输出流。 字符流的由来因为文件编码的不同，而有了对字符进行高效操作的字符流对象。原理：其实就是基于字节流读取字节时，去查了指定的码表。 字节流和字符流的区别 字节流读取的时候，读到一个字节就返回一个字节。字符流使用了字节流读到一个或多个字节(中文对应的字节数是两个，在UTF-8 码表中是3个字节)时先去查指定的编码表，将查到的字符返回。 字节流可以处理所有类型数据，如图片，mp3，avi。 而字符流只能处理字符数据。 结论：只要是处理纯文本数据，就要优先考虑使用字符流。除此之外都用字节流。 IO的体系。所具备的基本功能就有两个：读 和 写 字节流InputStream（读）,OutputStream（写）。 字符流：Reader（读），Writer（写）。 基本的读写操作方式因为数据通常都以文件形式存在。所以就要找到IO 体系中可以用于操作文件的流对象。 通过名称可以更容易获取该对象。 因为IO 体系中的子类名后缀绝大部分是父类名称。而前缀都是体现子类功能的名字。 本文链接：http://www.sguotao.top/Java-2013-11-30-JavaIO流的介绍.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【集合框架】Set]]></title>
    <url>%2FJava-2013-11-26-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6Set.html</url>
    <content type="text"><![CDATA[概述Java -中的Set和正好和数学上直观的集（set）的概念是相同的。Set最大的特性就是不允许在其中存放的元素是重复的。根据这个特点，我们就可以使用Set 这个接口来实现前面提到的关于商品种类的存储需求。Set 可以被用来过滤在其他集合中存放的元素，从而得到一个没有包含重复新的集合。 常用方法按照定义，Set 接口继承 Collection 接口，而且它不允许集合中存在重复项。所有原始方法都是现成的，没有引入新方法。具体的 Set 实现类依赖添加的对象的 equals() 方法来检查等同性。我们简单的描述一下各个方法的作用： 1234567891011121314public int size() ：返回set中元素的数目，如果set包含的元素数大于 Integer.MAX_VALUE，返回Integer.MAX_VALUE public boolean isEmpty() ：如果set中不含元素，返回true public boolean contains(Object o) ：如果set包含指定元素，返回true public Iterator iterator() ：返回set中元素的迭代器，元素返回没有特定的顺序，除非set是提高了该保证的某些类的实例 public Object[] toArray() ：返回包含set中所有元素的数组 public Object[] toArray(Object[] a) ：返回包含set中所有元素的数组，返回数组的运行时类型是指定数组的运行时类型 public boolean add(Object o) ：如果set中不存在指定元素，则向set加入public boolean remove(Object o) ：如果set中存在指定元素，则从set中删除 public boolean removeAll(Collection c) ：如果set包含指定集合，则从set中删除指定集合的所有元素 public boolean containsAll(Collection c) ：如果set包含指定集合的所有元素，返回 true。如果指定集合也是一个set，只有是当前set的子集时，方法返回true public boolean addAll(Collection c) ：如果set中中不存在指定集合的元素，则向set中加入所有元素 public boolean retainAll(Collection c) ：只保留set中所含的指定集合的元素（可选操作）。换言之，从set中删除所有指定集合不包含的元素。 如果指定集合也是一个 set，那么该操作修改set的效果是使它的值为两个set的交集 public boolean removeAll(Collection c) ：如果set包含指定集合，则从set中删除指定集合的所有元素 public void clear() ：从set中删除所有元素 “集合框架” 支持 Set 接口两种普通的实现：HashSet 和 TreeSet以及LinkedHashSet。下表中是Set的常用实现类的描述： 在更多情况下，您会使用 HashSet 存储重复自由的集合。同时HashSet中也是采用了Hash算法的方式进行存取对象元素的。所以添加到 HashSet 的对象对应的类也需要采用恰当方式来实现 hashCode() 方法。虽然大多数系统类覆盖了 Object 中缺省的 hashCode() 实现，但创建您自己的要添加到 HashSet 的类时，别忘了覆盖 hashCode()。 对于Set的使用，我们先以一个简单的例子来说明： 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class HashSetDemo &#123; public static void main(String[] args) &#123; Set set1 = new HashSet(); if (set1.add("a")) &#123;//添加成功 System.out.println("1 add true"); &#125; if (set1.add("a")) &#123;//添加失败 System.out.println("2 add true"); &#125; set1.add("000");//添加对象到Set集合中 set1.add("111"); set1.add("222"); System.out.println("集合set1的大小："+set1.size()); System.out.println("集合set1的内容："+set1); set1.remove("000");//从集合set1中移除掉 "000" 这个对象 System.out.println("集合set1移除 000 后的内容："+set1); System.out.println("集合set1中是否包含000 ："+set1.contains("000")); System.out.println("集合set1中是否包含111 ："+set1.contains("111")); Set set2=new HashSet(); set2.add("111"); set2.addAll(set1);//将set1 集合中的元素全部都加到set2中 System.out.println("集合set2的内容："+set2); set2.clear();//清空集合 set1 中的元素 System.out.println("集合set2是否为空 ："+set2.isEmpty()); Iterator iterator = set1.iterator();//得到一个迭代器 while (iterator.hasNext()) &#123;//遍历 Object element = iterator.next(); System.out.println("iterator = " + element); &#125; //将集合set1转化为数组 Object s[]= set1.toArray(); for(int i=0;i&lt;s.length;i++)&#123; System.out.println(s[i]); &#125; &#125;&#125; 程序执行的结果为： 12345678910111213141 add true集合set1的大小：4集合set1的内容：[222, a, 000, 111]集合set1移除 000 后的内容：[222, a, 111]集合set1中是否包含000 ：false集合set1中是否包含111 ：true集合set2的内容：[222, a, 111]集合set2是否为空 ：trueiterator = 222iterator = aiterator = 111222a111 从上面的这个简单的例子中，我们可以发现，Set中的方法与直接使用Collection中的方法一样。唯一需要注意的就是Set中存放的元素不能重复。 我们再看一个例子，来了解一下其它的Set的实现类的特性： 1234567891011121314151617181920package c08;import java.util.*;public class SetSortExample &#123; public static void main(String args[]) &#123; Set set1 = new HashSet(); Set set2 = new LinkedHashSet(); for(int i=0;i&lt;5;i++)&#123; //产生一个随机数，并将其放入Set中 int s=(int) (Math.random()*100); set1.add(new Integer( s)); set2.add(new Integer( s)); System.out.println("第 "+i+" 次随机数产生为："+s); &#125; System.out.println("未排序前HashSet："+set1); System.out.println("未排序前LinkedHashSet："+set2); //使用TreeSet来对另外的Set进行重构和排序 Set sortedSet = new TreeSet(set1); System.out.println("排序后 TreeSet ："+sortedSet); &#125;&#125; 该程序的一次执行结果为： 12345678第 0 次随机数产生为：96第 1 次随机数产生为：64第 2 次随机数产生为：14第 3 次随机数产生为：95第 4 次随机数产生为：57未排序前HashSet：[64, 96, 95, 57, 14]未排序前LinkedHashSet：[96, 64, 14, 95, 57]排序后 TreeSet ：[14, 57, 64, 95, 96] 从这个例子中，我们可以知道HashSet的元素存放顺序和我们添加进去时候的顺序没有任何关系，而LinkedHashSet 则保持元素的添加顺序。TreeSet则是对我们的Set中的元素进行排序存放。 一般来说，当您要从集合中以有序的方式抽取元素时，TreeSet 实现就会有用处。为了能顺利进行，添加到 TreeSet 的元素必须是可排序的。 而您同样需要对添加到TreeSet中的类对象实现 Comparable 接口的支持。对于Comparable接口的实现，在前一小节的Map中已经简单的介绍了一下。我们暂且假定一棵树知道如何保持 java.lang 包装程序器类元素的有序状态。一般说来，先把元素添加到 HashSet，再把集合转换为 TreeSet 来进行有序遍历会更快。这点和HashMap的使用非常的类似。 其实Set的实现原理是基于Map上面的。通过下面我们对Set的进一步分析大家就能更加清楚的了解这点了。 实现原理Java中Set的概念和数学中的集合(set)一致，都表示一个集内可以存放的元素是不能重复的。前面我们会发现，Set中很多实现类和Map中的一些实现类的使用上非常的相似。而且前面再讲解Map的时候，我们也提到：Map中的“键值对”，其中的“键”是不能重复的。这个和Set中的元素不能重复一致。我们以HashSet为例来分析一下，会发现其实Set利用的就是Map中“键”不能重复的特性来实现的。 先看看HashSet中的有哪些属性,再结合构造函数来看看： 通过这些方法，我们可以发现，其实HashSet的实现，全部的操作都是基于HashMap来进行的。我们看看是如何通过HashMap来保证我们的HashSet的元素不重复性的： 看到这个操作我们可以发现HashSet的巧妙实现：就是建立一个“键值对”，“键”就是我们要存入的对象，“值”则是一个常量。这样可以确保，我们所需要的存储的信息之是“键”。而“键”在Map中是不能重复的，这就保证了我们存入Set中的所有的元素都不重复。而判断是否添加元素成功，则是通过判断我们向Map中存入的“键值对”是否已经存在，如果存在的话，那么返回值肯定是常量：PRESENT ，表示添加失败。如果不存在，返回值就为null 表示添加成功。我们再看看其他的方法实现： 了解了这些后，我们就不难理解，为什么HashMap中需要注意的地方，在HashSet中也同样的需要注意。其他的Set的实现类也是差不多的原理。至此对于Set我们就应该能够比较好的理解了。 总结用“集合框架”设计软件时，记住该框架四个基本接口的下列层次结构关系会有用处： Collection 接口是一组允许重复的对象。 Set 接口继承 Collection，但不允许重复。 List 接口继承 Collection，允许重复，并引入位置下标。 Map 接口既不继承 Set 也不继承 Collection, 存取的是键值对 本文链接：http://www.sguotao.top/Java-2013-11-26-集合框架Set.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【集合框架】Map]]></title>
    <url>%2FJava-2013-11-25-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6Map.html</url>
    <content type="text"><![CDATA[概述数学中的映射关系在Java中就是通过Map来实现的。它表示，里面存储的元素是一个对（pair）,我们通过一个对象，可以在这个映射关系中找到另外一个和这个对象相关的东西。前面提到的我们对于根据帐号名得到对应的人员的信息，就属于这种情况的应用。我们讲一个人员的帐户名和这人员的信息作了一个映射关系，也就是说，我们把帐户名和人员信息当成了一个“键值对”，“键”就是帐户名，“值”就是人员信息。下面我们先看看Map 接口的常用方法。 常用方法Map 接口不是 Collection 接口的继承。而是从自己的用于维护键-值关联的接口层次结构入手。按定义，该接口描述了从不重复的键到值的映射。我们可以把这个接口方法分成三组操作：改变、查询和提供可选视图。改变操作允许您从映射中添加和除去键-值对。键和值都可以为 null。但是，您不能把 Map 作为一个键或值添加给自身。 123456789Object put(Object key,Object value)：//用来存放一个键-值对Map中Object remove(Object key)：//根据key(键)，移除一个键-值对，并将值返回void putAll(Map mapping) ：//将另外一个Map中的元素存入当前的Map中void clear() ：//清空当前Map中的元素，查询操作允许您检查映射内容：Object get(Object key) ：//根据key(键)取得对应的值boolean containsKey(Object key) ：//判断Map中是否存在某键（key）boolean containsValue(Object value)://判断Map中是否存在某值(value)int size()://返回Map中 键-值对的个数boolean isEmpty() ：//判断当前Map是否为空 最后一组方法允许您把键或值的组作为集合来处理。 123public Set keySet() ：//返回所有的键（key），并使用Set容器存放public Collection values() ：//返回所有的值（Value），并使用Collection存放public Set entrySet() ：//返回一个实现 Map.Entry 接口的元素 Set 因为映射中键的集合必须是唯一的，就使用 Set 来支持。因为映射中值的集合可能不唯一，就使用Collection 来支持。最后一个方法返回一个实现 Map.Entry 接口的元素 Set。我们看看Map的常用实现类的比较，如下表： 下面我们看一个简单的例子： 12345678910111213141516171819202122232425import java.util.*; public class MapTest &#123;public static void main(String[] args) &#123; Map map1 = new HashMap(); Map map2 = new HashMap(); map1.put("1","aaa1"); map1.put("2","bbb2"); map2.put("10","aaaa10"); map2.put("11","bbbb11");//根据键 "1" 取得值："aaa1" System.out.println("map1.get("1")="+map1.get("1")); // 根据键 "1" 移除键值对"1"-"aaa1"System.out.println("map1.remove("1")="+map1.remove("1")); System.out.println("map1.get("1")="+map1.get("1")); map1.putAll(map2);//将map2全部元素放入map1中 map2.clear();//清空map2 System.out.println("map1 IsEmpty?="+map1.isEmpty()); System.out.println("map2 IsEmpty?="+map2.isEmpty()); System.out.println("map1 中的键值对的个数size = "+map1.size()); System.out.println("KeySet="+map1.keySet());//set System.out.println("values="+map1.values());//Collection System.out.println("entrySet="+map1.entrySet()); System.out.println("map1 是否包含键：11 = "+map1.containsKey("11")); System.out.println("map1 是否包含值：aaa1 = "+map1.containsValue("aaa1")); &#125;&#125; 运行输出结果为： 1234567891011map1.get("1")=aaa1map1.remove("1")=aaa1map1.get("1")=nullmap1 IsEmpty?=falsemap2 IsEmpty?=truemap1 中的键值对的个数size = 3KeySet=[10, 2, 11]values=[aaaa10, bbb2, bbbb11]entrySet=[10=aaaa10, 2=bbb2, 11=bbbb11]map1 是否包含键：11 = truemap1 是否包含值：aaa1 = false 在该例子中，我们创建一个HashMap，并使用了一下Map接口中的各个方法。其中Map中的entrySet()方法先提一下，该方法返回一个实现 Map.Entry 接口的对象集合。集合中每个对象都是底层 Map 中一个特定的键-值对。 Map.Entry 接口是Map 接口中的一个内部接口，该内部接口的实现类存放的是键值对。在下面的实现原理中，我们会对这方面再作介绍，现在我们先不管这个它的具体实现。 我们再看看排序的Map是如何使用： 123456789101112131415161718import java.util.*;public class MapSortExample &#123; public static void main(String args[]) &#123; Map map1 = new HashMap(); Map map2 = new LinkedHashMap(); for(int i=0;i&lt;10;i++)&#123; double s=Math.random()*100;//产生一个随机数，并将其放入Map中 map1.put(new Integer((int) s),"第 "+i+" 个放入的元素："+s+"\n"); map2.put(new Integer((int) s),"第 "+i+" 个放入的元素："+s+"\n"); &#125; System.out.println("未排序前HashMap："+map1); System.out.println("未排序前LinkedHashMap："+map2); //使用TreeMap来对另外的Map进行重构和排序 Map sortedMap = new TreeMap(map1); System.out.println("排序后："+sortedMap); System.out.println("排序后："+new TreeMap(map2)); &#125;&#125; 该程序的一次运行结果为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344未排序前HashMap：&#123;64=第 1 个放入的元素：64.05341725531845, 15=第 9 个放入的元素：15.249165766266382, 2=第 4 个放入的元素：2.66794706854534, 77=第 0 个放入的元素：77.28814965781416, 97=第 5 个放入的元素：97.32893518378948, 99=第 2 个放入的元素：99.99412014935982, 60=第 8 个放入的元素：60.91451419025399, 6=第 3 个放入的元素：6.286974058646977, 1=第 7 个放入的元素：1.8261658496439903, 48=第 6 个放入的元素：48.736039522423106&#125;未排序前LinkedHashMap：&#123;77=第 0 个放入的元素：77.28814965781416, 64=第 1 个放入的元素：64.05341725531845, 99=第 2 个放入的元素：99.99412014935982, 6=第 3 个放入的元素：6.286974058646977, 2=第 4 个放入的元素：2.66794706854534, 97=第 5 个放入的元素：97.32893518378948, 48=第 6 个放入的元素：48.736039522423106, 1=第 7 个放入的元素：1.8261658496439903, 60=第 8 个放入的元素：60.91451419025399, 15=第 9 个放入的元素：15.249165766266382&#125;排序后：&#123;1=第 7 个放入的元素：1.8261658496439903, 2=第 4 个放入的元素：2.66794706854534, 6=第 3 个放入的元素：6.286974058646977, 15=第 9 个放入的元素：15.249165766266382, 48=第 6 个放入的元素：48.736039522423106, 60=第 8 个放入的元素：60.91451419025399, 64=第 1 个放入的元素：64.05341725531845, 77=第 0 个放入的元素：77.28814965781416, 97=第 5 个放入的元素：97.32893518378948, 99=第 2 个放入的元素：99.99412014935982&#125;排序后：&#123;1=第 7 个放入的元素：1.8261658496439903, 2=第 4 个放入的元素：2.66794706854534, 6=第 3 个放入的元素：6.286974058646977, 15=第 9 个放入的元素：15.249165766266382, 48=第 6 个放入的元素：48.736039522423106, 60=第 8 个放入的元素：60.91451419025399, 64=第 1 个放入的元素：64.05341725531845, 77=第 0 个放入的元素：77.28814965781416, 97=第 5 个放入的元素：97.32893518378948, 99=第 2 个放入的元素：99.99412014935982&#125; 从运行结果，我们可以看出，HashMap的存入顺序和输出顺序无关。而LinkedHashMap 则保留了键值对的存入顺序。TreeMap则是对Map中的元素进行排序。在实际的使用中我们也经常这样做：使用HashMap或者LinkedHashMap 来存放元素，当所有的元素都存放完成后，如果使用则是需要一个经过排序的Map的话，我们再使用TreeMap来重构原来的Map对象。这样做的好处是：因为HashMap和LinkedHashMap 存储数据的速度比直接使用TreeMap 要快，存取效率要高。当完成了所有的元素的存放后，我们再对整个的Map中的元素进行排序。这样可以提高整个程序的运行的效率，缩短执行时间。 这里需要注意的是，TreeMap中是根据键（Key）进行排序的。而如果我们要使用TreeMap来进行正常的排序的话，Key 中存放的对象必须实现Comparable 接口。我们简单介绍一下这个接口： Comparable 接口在 java.lang 包中，Comparable 接口适用于一个类有自然顺序的时候。假定对象集合是同一类型，该接口允许您把集合排序成自然顺序。 它只有一个方法：compareTo() 方法，用来比较当前实例和作为参数传入的元素。如果排序过程中当前实例出现在参数前（当前实例比参数大），就返回某个负值。如果当前实例出现在参数后（当前实例比参数小），则返回正值。否则，返回零。如果这里不要求零返回值表示元素相等。零返回值可以只是表示两个对象在排序的时候排在同一个位置。 上面例子中的整形的包装类：Integer 就实现了该接口。我们可以看一下这个类的源码：可以看到compareTo 方法里面通过判断当前的Integer对象的值是否大于传入的参数的值来得到返回值的。在 Java 2 SDK，版本 1.2 中有十四个类实现 Comparable 接口。下表展示了它们的自然排序。虽然一些类共享同一种自然排序，但只有相互可比的类才能排序。 这里只是简单的介绍一下排序接口，如果要详细的了解排序部分内容的话，可以参考文章最后的附录部分对于排序的更加详细的描述。我们再回到Map中来，Java提供的API中除了上面介绍的几种Map比较常用以为还有一些Map，大家可以了解一下： WeakHashMap： WeakHashMap 是 Map 的一个特殊实现，它只用于存储对键的弱引用。当映射的某个键在 WeakHashMap 的外部不再被引用时，就允许垃圾收集器收集映射中相应的键值对。使用 WeakHashMap 有益于保持类似注册表的数据结构，其中条目的键不再能被任何线程访问时，此条目就没用了。 IdentifyHashMap： Map的一种特性实现，关键属性的hash码不是由hashCode()方法计算，而是由 System.identityHashCode 方法计算，使用==进行比较而不是equals()方法。 通过简单的对与Map中各个常用实现类的使用，为了更好的理解Map，下面我们再来了解一下Map的实现原理。 实现原理有的人可能会认为 Map 会继承 Collection。在数学中，映射只是对（pair）的集合。但是，在“集合框架”中，接口 Map 和 Collection 在层次结构没有任何亲缘关系，它们是截然不同的。这种差别的原因与 Set 和 Map 在 Java 库中使用的方法有关。Map 的典型应用是访问按关键字存储的值。它支持一系列集合操作的全部，但操作的是键-值对，而不是单个独立的元素。因此 Map 需要支持 get() 和 put() 的基本操作，而 Set 不需要。此外，还有返回 Map 对象的 Set 视图的方法： 1Set set = aMap.keySet(); 下面我们以HashMap为例，对Map的实现机制作一下更加深入一点的理解。 因为HashMap里面使用Hash算法，所以在理解HashMap之前，我们需要先了解一下Hash算法和Hash表。 Hash，一般翻译做“散列”，也有直接音译为”哈希”的，就是把任意长度的输入（又叫做 预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能 会散列成相同的输出，而不可能从散列值来唯一的确定输入值。 说的通俗一点，Hash算法的意义在于提供了一种快速存取数据的方法,它用一种算法建立键值与真实值之间的对应关系,(每一个真实值只能有一个键值,但是一个键值可以对应多个真实值),这样可以快速在数组等里面存取数据。 我们建立一个HashTable（哈希表），该表的长度为N，然后我们分别在该表中的格子中存放不同的元素。每个格子下面存放的元素又是以链表的方式存放元素。 当添加一个新的元素Entry 的时候，首先我们通过一个Hash函数计算出这个Entry元素的Hash值hashcode。通过该hashcode值，就可以直接定位出我们应该把这个Entry元素存入到Hash表的哪个格子中，如果该格子中已经存在元素了，那么只要把新的Entry元存放到这个链表中即可。 如果要查找一个元素Entry的时候，也同样的方式，通过Hash函数计算出这个Entry元素的Hash值hashcode。然后通过该hashcode值，就可以直接找到这个Entry是存放到哪个格子中的。接下来就对该格子存放的链表元素进行逐个的比较查找就可以了。 举一个比较简单的例子来说明这个算法的运算方式：假定我们有一个长度为8的Hash表（可以理解为一个长度为8的数组）。在这个Hash表中存放数字：如下表 假定我们的Hash函数为：Hashcode = X%8 ——– 对8 取余数其中X是我们需要放入Hash表中的数字，而这个函数返回的Hashcode就是Hash码。假定我们有下面10个数字需要依次存入到这个Hash表中：11 , 23 , 44 , 9 , 6 , 32 , 12 , 45 , 57 , 89通过上面的Hash函数，我们可以得到分别对应的Hash码：11――3 ; 23――7 ；44――4 ；9――1；6――6；32――0；12――4；45――5；57――1；89――1；计算出来的Hash码分别代表，该数字应该存放到Hash表中的哪个对应数字的格子中。如果改格子中已经有数字存在了，那么就以链表的方式将数字依次存放在该格子中，如下表： Hash表和Hash算法的特点就是它的存取速度比数组差一些，但是比起单纯的链表，在查找和存储方面却要好很多。同时数组也不利于数据的重构而排序等方面的要求。 更具体的说明，读者可以参考数据结构相关方面的书籍。 简单的了解了一下Hash算法后，我们就来看看HashMap的属性有哪些：里面最重要的3个属性： transient Entry[] table: 用来存放键值对的对象Entry数组，也就是Hash表 transient int size：当前Map中存放的键值对的个数 final float loadFactor：负载因子，用来决定什么情况下应该对Entry进行扩容 我们Entry 对象是Map接口中的一个内部接口。即是使用它来保存我们的键值对的。 我们看看这个Entry 内部接口在HashMap中的实现：通过查看源码，我们可以看到Entry类有点类似一个单向链表。其中： final Object key 和 Object value;存放的就是我们放入Map中的键值对。而属性Entry next;表示当前键值对的下一个键值对是哪个Entry。 接下来，我们看看HashMap的主要的构造函数：我们主要看看 public HashMap(int initialCapacity, float loadFactor)因为，另外两个构造函数实行也是同样的方式进行构建一个HashMap 的。该构造函数： 首先是判断参数int initialCapacity和float loadFactor是否合法 然后确定Hash表的初始化长度。确定的策略是：通过传进来的参数initialCapacity 来找出第一个大于它的2的次方的数。比如说我们传了18这样的一个initialCapacity 参数，那么真实的table数组的长度为2的5次方，即32。之所以采用这种策略来构建Hash表的长度，是因为2的次方的运算对于现代的处理器来说，可以通过一些方法得到更加好的执行效率。 接下来就是得到重构因子（threshold）了，这个属性也是HashMap中的一个比较重要的属性，它表示，当Hash表中的元素被存放了多少个之后，我们就需要对该Hash表进行重构。 最后就是使用得到的初始化参数capacity 来构建Hash表：Entry[] table。 下面我们看看一个键值对是如何添加到HashMap中的。该put方法是用来添加一个键值对（key-value）到Map中，如果Map中已经存在相同的键的键值对的话，那么就把新的值覆盖老的值，并把老的值返回给方法的调用者。如果不存在一样的键，那么就返回null 。我们看看方法的具体实现： 首先我们判断如果key为null则使用一个常量来代替该key值，该行为在方法maskNull（）终将key替换为一个非null 的对象k。 计算key值的Hash码：hash 通过使用Hash码来定位，我们应该把当前的键值对存放到Hash表中的哪个格子中。indexFor()方法计算出的结果：i 就是Hash表（table）中的下标。 然后遍历当前的Hash表中table[i]格中的链表。从中判断已否已经存在一样的键(Key)的键值对。如果存在一样的key的键，那么就用新的value覆写老的value，并把老的value返回 如果遍历后发现没有存在同样的键值对，那么就增加当前键值对到Hash表中的第i个格子中的链表中。并返回null 。 最后我们看看一个键值对是如何添加到各个格子中的链表中的：我们先看void addEntry(int hash, Object key, Object value, int bucketIndex)方法，该方法的作用就用来添加一个键值对到Hash表的第bucketIndex个格子中的链表中去。这个方法作的工作就是： 创建一个Entry对象用来存放键值对。 添加该键值对 —- Entry对象到链表中 最后在size属性加一，并判断是否需要对当前的Hash表进行重构。如果需要就在 void resize(int newCapacity)方法中进行重构。之所以需要重构，也是基于性能考虑。大家可以考虑这样一种情况，假定我们的Hash表只有4个格子，那么我们所有的数据都是放到这4个格子中。如果存储的数据量比较大的话，例如100。这个时候，我们就会发现，在这个Hash表中的4个格子存放的4个长长的链表。而我们每次查找元素的时候，其实相当于就是遍历链表了。这种情况下，我们用这个Hash表来存取数据的性能实际上和使用链表差不多了。 但是如果我们对这个Hash表进行重构，换为使用Hash表长度为200的表来存储这100个数据，那么平均2个格子里面才会存放一个数据。这个时候我们查找的数据的速度就会非常的快。因为基本上每个格子中存放的链表都不会很长，所以我们遍历链表的次数也就很少，这样也就加快了查找速度。但是这个时候又存在了另外的一个问题。我们使用了至少200个数据的空间来存放100个数据，这样就造成至少100个数据空间的浪费。 在速度和空间上面，我们需要找到一个适合自己的中间值。在HashMap中我们通过负载因子（loadFactor）来决定应该什么时候应该重构我们的Hash表，以达到比较好的性能状态。 我们再看看重构Hash表的方法：void resize(int newCapacity)是如何实现的,它的实现方式比较简单： 首先判断如果Hash表的长度已经达到最大值，那么就不进行重构了。因为这个时候Hash表的长度已经达到上限，已经没有必要重构了。 然后就是构建新的Hash表 把老的Hash表中的对象数据全部转移到新的Hash表newTable中，并设置新的重构因子threshold 对于HashMap中的实现原理，我们就分析到这里。大家可能会发现，HashCode的计算，是用来定位我们的键值对应该放到Hash表中哪个格子中的关键属性。而这个HashCode的计算方法是调用的各个对象自己的实现的hashCode()方法。而这个方法是在Object对象中定义的，所以我们自己定义的类如果要在集合中使用的话，就需要正确的覆写hashCode() 方法。下面就介绍一下应该如何正确覆写hashCode()方法。 覆写hashCode()在明白了HashMap具有哪些功能，以及实现原理后，了解如何写一个hashCode()方法就更有意义了。当然，在HashMap中存取一个键值对涉及到的另外一个方法为equals ()，因为该方法的覆写在高级特性已经讲解了。这里就不做过多的描述。 设计hashCode（）时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该生成同样的值。如果在将一个对象用put（）方法添加进HashMap时产生一个hashCode()值，而用get()取出时却产生了另外一个hashCode()值，那么就无法重新取得该对象了。所以，如果你的hashCode()方法依赖于对象中易变的数据，那用户就要小心了，因为此数据发生变化时，hashCode()就会产生一个不同的hash码，相当于产生了一个不同的“键”。 此外，也不应该使hashCode()依赖于具有唯一性的对象信息，尤其是使用this的值，这只能产生很糟糕的hashCode()。因为这样做无法生成一个新的“键”，使之与put()种原始的“键值对”中的“键”相同。例如，如果我们不覆写Object的hashCode()方法，那么调用该方法的时候，就会调用Object的hashCode()方法的默认实现。Object的hashCode（）方法，返回的是当前对象的内存地址。下次如果我们需要取一个一样的“键”对应的键值对的时候，我们就无法得到一样的hashCode值了。因为我们后来创建的“键”对象已经不是存入HashMap中的那个内存地址的对象了。 我们看一个简单的例子，就能更加清楚的理解上面的意思。假定我们写了一个类： Person （人），我们判断一个对象“人”是否指向同一个人，只要知道这个人的身份证号一直就可以了。先看我们没有实现hashCode的情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package c08.hashEx;import java.util.*;//身份证类class Code&#123; final int id;//身份证号码已经确认,不能改变 Code(int i)&#123; id=i; &#125; //身份号号码相同，则身份证相同 public boolean equals(Object anObject) &#123; if (anObject instanceof Code)&#123; Code other=(Code) anObject; return this.id==other.id; &#125;return false; &#125; public String toString() &#123; return "身份证:"+id; &#125; &#125;//人员信息类class Person &#123; Code id;// 身份证 String name;// 姓名 public Person(String name, Code id) &#123; this.id=id; this.name=name; &#125; //如果身份证号相同，就表示两个人是同一个人 public boolean equals(Object anObject) &#123; if (anObject instanceof Person)&#123; Person other=(Person) anObject; return this.id.equals(other.id); &#125; return false; &#125; public String toString() &#123; return "姓名:"+name+" 身份证:"+id.id+"\n"; &#125;&#125;public class HashCodeEx &#123; public static void main(String[] args) &#123; HashMap map=new HashMap(); Person p1=new Person("张三",new Code(123)); map.put(p1.id,p1);//我们根据身份证来作为key值存放到Map中 Person p2=new Person("李四",new Code(456)); map.put(p2.id,p2); Person p3=new Person("王二",new Code(789)); map.put(p3.id,p3); System.out.println("HashMap 中存放的人员信息:\n"+map); // 张三 改名为：张山 但是还是同一个人。 Person p4=new Person("张山",new Code(123));map.put(p4.id,p4); System.out.println("张三改名后 HashMap 中存放的人员信息:\n"+map); //查找身份证为：123 的人员信息 System.out.println("查找身份证为：123 的人员信息:"+map.get(new Code(123))); &#125;&#125; 运行结果为： 123456789101112HashMap 中存放的人员信息:&#123;身份证:456=姓名:李四 身份证:456, 身份证:123=姓名:张三 身份证:123, 身份证:789=姓名:王二 身份证:789&#125;张三改名后 HashMap 中存放的人员信息:&#123;身份证:456=姓名:李四 身份证:456, 身份证:123=姓名:张三 身份证:123, 身份证:123=姓名:张山 身份证:123, 身份证:789=姓名:王二 身份证:789&#125;查找身份证为：123 的人员信息:null 上面的例子的演示的是，我们在一个HashMap中存放了一些人员的信息。并以这些人员的身份证最为人员的“键”。当有的人员的姓名修改了的情况下，我们需要更新这个HashMap。同时假如我们知道某个身份证号，想了解这个身份证号对应的人员信息如何，我们也可以根据这个身份证号在HashMap中得到对应的信息。 而例子的输出结果表示，我们所做的更新和查找操作都失败了。失败的原因就是我们的身份证类：Code 没有覆写hashCode()方法。这个时候，当查找一样的身份证号码的键值对的时候，使用的是默认的对象的内存地址来进行定位。这样，后面的所有的身份证号对象new Code(123) 产生的hashCode()值都是不一样的。所以导致操作失败。 下面，我们给Code类加上hashCode（）方法，然后再运行一下程序看看： 12345678910111213141516171819202122//身份证类class Code&#123; final int id;//身份证号码已经确认,不能改变 Code(int i)&#123; id=i; &#125; //身份号号码相同，则身份证相同 public boolean equals(Object anObject) &#123;if (anObject instanceof Code)&#123; Code other=(Code) anObject; return this.id==other.id; &#125; return false; &#125; public String toString() &#123; return "身份证:"+id; &#125; //覆写hashCode方法，并使用身份证号作为hash值 public int hashCode()&#123; return id; &#125;&#125; 再次执行上面的HashCodeEx 的结果就为： 1234567891011HashMap 中存放的人员信息:&#123;身份证:456=姓名:李四 身份证:456, 身份证:789=姓名:王二 身份证:789, 身份证:123=姓名:张三 身份证:123&#125;张三改名后 HashMap 中存放的人员信息:&#123;身份证:456=姓名:李四 身份证:456, 身份证:789=姓名:王二 身份证:789, 身份证:123=姓名:张山 身份证:123&#125;查找身份证为：123 的人员信息:姓名:张山 身份证:123 这个时候，我们发现。我们想要做的更新和查找操作都成功了。 对于Map部分的使用和实现，主要就是需要注意存放“键值对”中的对象的equals()方法和hashCode()方法的覆写。如果需要使用到排序的话，那么还需要实现Comparable 接口中的compareTo() 方法。我们需要注意Map中的“键”是不能重复的，而是否重复的判断，是通过调用“键”对象的equals（）方法来决定的。而在HashMap中查找和存取“键值对”是同时使用hashCode（）方法和equals（）方法来决定的。 本文链接：http://www.sguotao.top/Java-2013-11-25-集合框架Map.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【集合框架】List]]></title>
    <url>%2FJava-2013-11-24-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6List.html</url>
    <content type="text"><![CDATA[概述前面我们讲述的Collection接口实际上并没有直接的实现类。而List是容器的一种，表示列表的意思。当我们不知道存储的数据有多少的情况，我们就可以使用List 来完成存储数据的工作。例如前面提到的一种场景。我们想要在保存一个应用系统当前的在线用户的信息。我们就可以使用一个List来存储。因为List的最大的特点就是能够自动的根据插入的数据量来动态改变容器的大小。下面我们先看看List接口的一些常用方法。 常用方法List 就是列表的意思，它是Collection 的一种，即继承了 Collection 接口，以定义一个允许重复项的有序集合。该接口不但能够对列表的一部分进行处理，还添加了面向位置的操作。List 是按对象的进入顺序进行保存对象，而不做排序或编辑操作。它除了拥有Collection接口的所有的方法外还拥有一些其他的方法。 面向位置的操作包括插入某个元素或 Collection 的功能，还包括获取、删除或更改元素的功能。在 List 中搜索元素可以从列表的头部或尾部开始，如果找到元素，还将报告元素所在的位置。 1234567void add(int index, Object element): //添加对象element到位置index上 boolean addAll(int index, Collection collection) ：//在index位置后添加容器collection中所有的元素 Object get(int index) ：//取出下标为index的位置的元素 int indexOf(Object element) ：//查找对象element 在List中第一次出现的位置 int lastIndexOf(Object element) ：//查找对象element 在List中最后出现的位置 Object remove(int index) ：//删除index位置上的元素 Object set(int index, Object element) ：//将index位置上的对象替换为 element 并返回老的元素。 List的实现先看一下下面表格： 在“集合框架”中有两种常规的 List 实现：ArrayList 和 LinkedList。使用两种 List 实现的哪一种取决于您特定的需要。如果要支持随机访问，而不必在除尾部的任何位置插入或除去元素，那么，ArrayList 提供了可选的集合。但如果，您要频繁的从列表的中间位置添加和除去元素，而只要顺序的访问列表元素，那么，LinkedList 实现更好。 我们以ArrayList 为例，先看一个简单的例子：例子中，我们把12个月份存放到ArrayList 中，然后用一个循环，并使用get（）方法将列表中的对象都取出来。而LinkedList 添加了一些处理列表两端元素的方法（下图只显示了新方法）：使用这些新方法，您就可以轻松的把 LinkedList 当作一个堆栈、队列或其它面向端点的数据结构。我们再来看另外一个使用LinkedList 来实现一个简单的队列的例子： 123456789101112131415import java.util.*;public class ListExample &#123; public static void main(String args[]) &#123; LinkedList queue = new LinkedList(); queue.addFirst("Bernadine"); queue.addFirst("Elizabeth"); queue.addFirst("Gene"); queue.addFirst("Elizabeth"); queue.addFirst("Clara"); System.out.println(queue); queue.removeLast(); queue.removeLast(); System.out.println(queue); &#125;&#125; 运行程序产生了以下输出。请注意，与 Set 不同的是 List 允许重复。 12【Clara, Elizabeth, Gene, Elizabeth, Bernadine】【Clara, Elizabeth, Gene】 该的程序演示了具体 List 类的使用。第一部分，创建一个由 ArrayList 支持的 List。填充完列表以后，特定条目就得到了。示例的 LinkedList 部分把 LinkedList 当作一个队列，从队列头部添加东西，从尾部除去。List 接口不但以位置友好的方式遍历整个列表，还能处理集合的子集： 123ListIterator listIterator() //返回一个ListIterator 跌代器，默认开始位置为０ListIterator listIterator(int startIndex)//返回一个ListIterator 跌代器，开始startIndexList subList(int fromIndex, int toIndex) //返回一个子列表List ,元素存放fromIndex 到toIndex之前的一个元素。 处理 subList() 时，位于 fromIndex 的元素在子列表中，而位于 toIndex 的元素则不是，提醒这一点很重要。以下 for-loop 测试案例大致反映了这一点： 123for (int i=fromIndex; i&lt;toIndex; i++) &#123; // process element at position i&#125; 此外，我们还应该提醒的是：对子列表的更改（如 add()、remove() 和 set() 调用）对底层 List 也有影响。 ListIterator 接口ListIterator 接口继承 Iterator 接口以支持添加或更改底层集合中的元素，还支持双向访问。以下源代码演示了列表中的反向循环。请注意 ListIterator 最初位于列表尾之后（list.size()），因为第一个元素的下标是0。 12345List list = ...;ListIterator iterator = list.listIterator(list.size());while (iterator.hasPrevious()) &#123; Object element = iterator.previous(); // Process element&#125; 正常情况下，不用 ListIterator 改变某次遍历集合元素的方向 — 向前或者向后。虽然在技术上可能实现时，但在 previous() 后立刻调用 next()，返回的是同一个元素。把调用 next() 和 previous() 的顺序颠倒一下，结果相同。我们看一个List的例子： 1234567891011121314151617181920212223242526272829import java.util.*;public class ListIteratorTest &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add("aaa"); list.add("bbb"); list.add("ccc"); list.add("ddd"); System.out.println("下标0开始："+list.listIterator(0).next());//next() System.out.println("下标1开始:"+list.listIterator(1).next());System.out.println("子List 1-3:"+list.subList(1,3)); //子列表 ListIterator it = list.listIterator(); //默认从下标0开始 //隐式光标属性add操作 ,插入到当前的下标的前面 it.add("sss"); while(it.hasNext())&#123; System.out.println("next Index="+it.nextIndex()+",Object="+it.next()); &#125; //set属性 ListIterator it1 = list.listIterator(); it1.next();it1.set("ooo");ListIterator it2 = list.listIterator(list.size());//下标 while(it2.hasPrevious())&#123; System.out.println("previous Index="+it2.previousIndex()+",Object="+it2.previous()); &#125; &#125;&#125; 程序的执行结果为： 123456789101112下标0开始：aaa下标1开始:bbb子List 1-3:[bbb, ccc]next Index=1,Object=aaanext Index=2,Object=bbbnext Index=3,Object=cccnext Index=4,Object=dddprevious Index=4,Object=dddprevious Index=3,Object=cccprevious Index=2,Object=bbbprevious Index=1,Object=aaaprevious Index=0,Object=ooo 我们还需要稍微再解释一下 add() 操作。添加一个元素会导致新元素立刻被添加到隐式光标的前面。因此，添加元素后调用 previous() 会返回新元素，而调用 next() 则不起作用，返回添加操作之前的下一个元素。下标的显示方式，如下图所示：对于List 的基本用法我们学会了，下面我们来进一步了解一下List的实现原理，以便价升我们对于集合的理解。 实现原理前面已经提了一下Collection的实现基础都是基于数组的。下面我们就已ArrayList 为例，简单分析一下ArrayList 列表的实现方式。首先，先看下它的构造函数。下列表格是在SUN提供的API中的描述： 123ArrayList() //Constructs an empty list with an initial capacity of ten.ArrayList(Collection c) //Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.ArrayList(int initialCapacity) //Constructs an empty list with the specified initial capacity. 其中第一个构造函数ArrayList()和第二构造函数ArrayList(Collection c) 是按照Collection 接口文档所述，所应该提供两个构造函数，一个无参数，一个接受另一个 Collection。第3个构造函数：ArrayList(int initialCapacity) 是ArrayList实现的比较重要的构造函数，虽然，我们不常用它，但是某认的构造函数正是调用的该带参数：initialCapacity 的构造函数来实现的。 其中参数：initialCapacity 表示我们构造的这个ArrayList列表的初始化容量是多大。如果调用默认的构造函数，则表示默认调用该参数为initialCapacity =10 的方式，来进行构建一个ArrayList列表对象。为了更好的理解这个initialCapacity 参数的概念，我们先看看ArrayList在Sun 提供的源码中的实现方式。先看一下它的属性有哪些：ArrayList 继承了AbstractList 我们主要看看ArrayList中的属性就可以了。ArrayList中主要包含2个属性： 12private transient Object elementData[];private int size; 其中数组:：elementData[] 是列表的实现核心属性：数组。 我们使用该数组来进行存放集合中的数据。而我们的初始化参数就是该数组构建时候的长度，即该数组的length属性就是initialCapacity 参数。Keys：transient 表示被修饰的属性不是对象持久状态的一部分，不会自动的序列化。第2个属性：size表示列表中真实数据的存放个数。我们再来看一下ArrayList的构造函数,加深一下ArrayList是基于数组的理解。从源码中可以看到默认的构造函数调用的就是带参数的构造函数： 1public ArrayList(int initialCapacity) 不过参数initialCapacity＝10 。我们主要看ArrayList(int initialCapacity) 这个构造函数。可以看到： 1this.elementData = new Object[initialCapacity]; 我们就是使用的initialCapacity 这个参数来创建一个Object数组。而我们所有的往该集合对象中存放的数据，就是存放到了这个Object数组中去了。我们在看看另外一个构造函数的源码：这里，我们先看size() 方法的实现形式。它的作用即是返回size属性值的大小。然后我们再看另外一个构造函数public ArrayList(Collection c) ，该构造函数的作用是把另外一个容器对象中的元素存放到当前的List 对象中。 可以看到，首先，我们是通过调用另外一个容器对象C 的方法size()来设置当前的List对象的size属性的长度大小。 接下来，就是对elementData 数组进行初始化，初始化的大小为原先容器大小的1.1倍。最后，就是通过使用容器接口中的Object[] toArray(Object[] a) 方法来把当前容器中的对象都存放到新的数组elementData 中。这样就完成了一个ArrayList 的建立。可能大家会存在一个问题，那就是，我们建立的这个ArrayList 是使用数组来实现的，但是数组的长度一旦被定下来，就不能改变了。而我们在给ArrayList对象中添加元素的时候，却没有长度限制。这个时候，ArrayList 中的elementData 属性就必须存在一个需要动态的扩充容量的机制。我们看下面的代码，它描述了这个扩充机制： 这个方法的作用就是用来判断当前的数组是否需要扩容，应该扩容多少。其中属性 modCount是继承自父类，它表示当前的对象对elementData数组进行了多少次扩容，清空，移除等操作。该属性相当于是一个对于当前List 对象的一个操作记录日志号。 我们主要看下面的代码实现： 首先得到当前elementData 属性的长度oldCapacity。 然后通过判断oldCapacity和minCapacity参数谁大来决定是否需要扩容。 如果minCapacity大于oldCapacity，那么我们就对当前的List对象进行扩容。扩容的的策略为：取(oldCapacity * 3)/2 + 1和minCapacity之间更大的那个。然后使用数组拷贝的方法，把以前存放的数据转移到新的数组对象中。 如果minCapacity不大于oldCapacity那么就不进行扩容。 下面我们看看上的那个ensureCapacity方法的是如何使用的:上的两个add方法都是往List 中添加元素。每次在添加元素的时候，我们就需要判断一下，是否需要对于当前的数组进行扩容。 我们主要看看 public boolean add(Object o)方法，可以发现在添加一个元素到容器中的时候，首先我们会判断是否需要扩容。因为只增加一个元素，所以扩容的大小判断也就为当前的size+1来进行判断。然后，就把新添加的元素放到数组elementData中。 第二个方法public boolean addAll(Collection c)也是同样的原理。将新的元素放到elementData数组之后。同时改变当前List 对象的size属性。 类似的List 中的其他的方法也都是基于数组进行操作的。大家有兴趣可以看看源码中的更多的实现方式。最后我们再看看如何判断在集合中是否已经存在某一个对象的： 由源码中我们可以看到，public boolean contains(Object elem)方法是通过调用public int indexOf(Object elem)方法来判断是否在集合中存在某个对象elem。我们看看indexOf方法的具体实现。 首先我们判断一下elem 对象是否为null ，如果为null的话，那么遍历数组elementData 把第一个出现null的位置返回。 如果elem不为null 的话，我们也是遍历数组elementData ，并通过调用elem对象的equals()方法来得到第一个相等的元素的位置。 这里我们可以发现，ArrayList中用来判断是否包含一个对象，调用的是各个对象自己实现的equals()方法。在前面的高级特性里面，我们可以知道：如果要判断一个类的一个实例对象是否等于另外一个对象，那么我们就需要自己覆写Object类的public boolean equals(Object obj) 方法。如果不覆写该方法的话，那么就会调用Object的equals()方法来进行判断。这就相当于比较两个对象的内存应用地址是否相等了。在集合框架中，不仅仅是List，所有的集合类，如果需要判断里面是否存放了的某个对象，都是调用该对象的equals()方法来进行处理的。 本文链接：http://www.sguotao.top/Java-2013-11-24-集合框架List.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【集合框架】Collection]]></title>
    <url>%2FJava-2013-11-23-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6Collection.html</url>
    <content type="text"><![CDATA[常用方法Collection 接口用于表示任何对象或元素组。想要尽可能以常规方式处理一组元素时，就使用这一接口。Collection 在前面的大图也可以看出，它是List和Set 的父类。并且它本身也是一个接口。它定义了作为集合所应该拥有的一些方法。如下：注意:集合必须只有对象，集合中的元素不能是基本数据类型。 添加和删除操作Collection接口支持如添加和删除等基本操作。设法除去一个元素时，如果这个元素存在，除去的仅仅是集合中此元素的一个实例。 12boolean add(Object element) boolean remove(Object element) 查询操作Collection 接口还支持查询操作： 1234int size() boolean isEmpty() boolean contains(Object element) Iterator iterator() 组操作组操作 ：Collection 接口支持的其它操作，要么是作用于元素组的任务，要么是同时作用于整个集合的任务。 12345boolean containsAll(Collection collection) boolean addAll(Collection collection) void clear() void removeAll(Collection collection) void retainAll(Collection collection) containsAll() 方法允许您查找当前集合是否包含了另一个集合的所有元素，即另一个集合是否是当前集合的子集。其余方法是可选的，因为特定的集合可能不支持集合更改。 addAll() 方法确保另一个集合中的所有元素都被添加到当前的集合中，通常称为并。 clear() 方法从当前集合中除去所有元素。 removeAll() 方法类似于 clear() ，但只除去了元素的一个子集。 retainAll() 方法类似于 removeAll() 方法，不过可能感到它所做的与前面正好相反：它从当前集合中除去不属于另一个集合的元素，即交。 我们看一个简单的例子，来了解一下集合类的基本方法的使用： 12345678910111213141516171819202122232425import java.util.*; public class CollectionToArray &#123; public static void main(String[] args) &#123; Collection collection1=new ArrayList();//创建一个集合对象 collection1.add("000");//添加对象到Collection集合中 collection1.add("111"); collection1.add("222"); System.out.println("集合collection1的大小："+collection1.size()); System.out.println("集合collection1的内容："+collection1); collection1.remove("000");//从集合collection1中移除掉 "000" 这个对象 System.out.println("集合collection1移除 000 后的内容："+collection1); System.out.println("集合collection1中是否包含000 ："+collection1.contains("000")); System.out.println("集合collection1中是否包含111 ："+collection1.contains("111")); Collection collection2=new ArrayList(); collection2.addAll(collection1);//将collection1 集合中的元素全部都加到collection2中 System.out.println("集合collection2的内容："+collection2); collection2.clear();//清空集合 collection1 中的元素 System.out.println("集合collection2是否为空 ："+collection2.isEmpty()); //将集合collection1转化为数组 Object s[]= collection1.toArray(); for(int i=0;i&lt;s.length;i++)&#123; System.out.println(s[i]); &#125; &#125; &#125; 运行结果为： 123456789集合collection1的大小：3 集合collection1的内容：[000, 111, 222] 集合collection1移除 000 后的内容：[111, 222] 集合collection1中是否包含000 ：false 集合collection1中是否包含111 ：true 集合collection2的内容：[111, 222] 集合collection2是否为空 ：true 111 222 这里需要注意的是，Collection 它仅仅只是一个接口，而我们真正使用的时候，确是创建该接口的一个实现类。做为集合的接口，它定义了所有属于集合的类所都应该具有的一些方法。而ArrayList （列表）类是集合类的一种实现方式。这里需要一提的是，因为Collection的实现基础是数组，所以有转换为Object数组的方法： 12Object[] toArray() Object[] toArray(Object[] a) 其中第二个方法Object[]toArray(Object[] a) 的参数 a 应该是集合中所有存放的对象的类的父类。 迭代器任何容器类，都必须有某种方式可以将东西放进去，然后由某种方式将东西取出来。毕竟，存放事物是容器最基本的工作。对于ArrayList，add（）是插入对象的方法，而get()是取出元素的方式之一。ArrayList很灵活，可以随时选取任意的元素，或使用不同的下标一次选取多个元素。 如果从更高层的角度思考，会发现这里有一个缺点：要使用容器，必须知道其中元素的确切类型。初看起来这没有什么不好的，但是考虑如下情况：如果原本是ArrayList ，但是后来考虑到容器的特点，你想换用Set ，应该怎么做？或者你打算写通用的代码，它们只是使用容器，不知道或者说不关心容器的类型，那么如何才能不重写代码就可以应用于不同类型的容器？ 所以迭代器(Iterator)的概念，也是出于一种设计模式就是为达成此目的而形成的。所以Collection不提供get()方法。如果要遍历Collectin中的元素，就必须用Iterator。 迭代器（Iterator）本身就是一个对象，它的工作就是遍历并选择集合序列中的对象，而客户端的程序员不必知道或关心该序列底层的结构。此外，迭代器通常被称为“轻量级”对象，创建它的代价小。但是，它也有一些限制，例如，某些迭代器只能单向移动。 Collection 接口的 iterator() 方法返回一个 Iterator。Iterator 和您可能已经熟悉的 Enumeration 接口类似。使用 Iterator 接口方法，您可以从头至尾遍历集合，并安全的从底层 Collection 中除去元素。 下面，我们看一个对于迭代器的简单使用： 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class IteratorDemo &#123; public static void main(String[] args) &#123; Collection collection = new ArrayList(); collection.add("s1"); collection.add("s2"); collection.add("s3"); Iterator iterator = collection.iterator();//得到一个迭代器 while (iterator.hasNext()) &#123;//遍历 Object element = iterator.next(); System.out.println("iterator = " + element); &#125; if(collection.isEmpty()) System.out.println("collection is Empty!"); else System.out.println("collection is not Empty! size="+collection.size()); Iterator iterator2 = collection.iterator(); while (iterator2.hasNext()) &#123;//移除元素 Object element = iterator2.next(); System.out.println("remove: "+element); iterator2.remove(); &#125; Iterator iterator3 = collection.iterator(); if (!iterator3.hasNext()) &#123;//察看是否还有元素 System.out.println("还有元素"); &#125; if(collection.isEmpty()) System.out.println("collection is Empty!"); //使用collection.isEmpty()方法来判断 &#125; &#125; 程序的运行结果为： 123456789iterator = s1 iterator = s2 iterator = s3 collection is not Empty! size=3 remove: s1 remove: s2 remove: s3 还有元素 collection is Empty! 可以看到，Java的Collection的Iterator 能够用来： 使用方法 iterator() 要求容器返回一个Iterator .第一次调用Iterator 的next() 方法时，它返回集合序列的第一个元素。 使用next() 获得集合序列的中的下一个元素。 使用hasNext()检查序列中是否元素。 使用remove()将迭代器新返回的元素删除。 需要注意的是,方法删除由next方法返回的最后一个元素，在每次调用next时，remove方法只能被调用一次。 Java 实现的这个迭代器的使用就是如此的简单。Iterator（跌代器）虽然功能简单，但仍然可以帮助我们解决许多问题，同时针对List 还有一个更复杂更高级ListIterator。您可以在下面的List讲解中得到进一步的介绍。 本文链接：http://www.sguotao.top/Java-2013-11-23-集合框架Collection.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【集合框架】容器简介]]></title>
    <url>%2FJava-2013-11-22-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[容器集合Java里面最重要，最常用也就是集合(Collection, List, Set,Map)一部分了。能够用好集合和理解好集合对于做Java程序的开发拥有无比的好处。本文详细解释了关于Java中的集合是如何实现的，以及他们的实现原理。 到目前为止，我们已经学习了如何创建多个不同的对象，定义了这些对象以后，我们就可以利用它们来做一些有意义的事情。 举例来说，假设要存储许多雇员，不同的雇员的区别仅在于雇员的身份证号。我们可以通过身份证号来顺序存储每个雇员，但是在内存中实现呢？是不是要准备足够的内存来存储1000个雇员，然后再将这些雇员逐一插入？如果已经插入了500条记录，这时需要插入一个身份证号较低的新雇员，该怎么办呢？是在内存中将500条记录全部下移后，再从开头插入新的记录? 还是创建一个映射来记住每个对象的位置？当决定如何存储对象的集合时，必须考虑如下问题。 对于对象集合，必须执行的操作主要以下三种： 添加新的对象 删除对象 查找对象 我们必须确定如何将新的对象添加到集合中。可以将对象添加到集合的末尾、开头或者中间的某个逻辑位置。 从集合中删除一个对象后，对象集合中现有对象会有什么影响呢？可能必须将内存移来移去，或者就在现有对象所驻留的内存位置下一个“洞”。 在内存中建立对象集合后，必须确定如何定位特定对象。可建立一种机制，利用该机制可根据某些搜索条件（例如身份证号）直接定位到目标对象；否则，便需要遍历集合中的每个对象，直到找到要查找的对象为止。 数组的作用是可以存取一组数据。但是它却存在一些缺点，使得无法使用它来比较方便快捷的完成上述应用场景的要求。 首先，在很多数情况下面，我们需要能够存储一组数据的容器，这一点虽然数组可以实现，但是如果我们需要存储的数据的个数多少并不确定。比如说：我们需要在容器里面存储某个应用系统的当前的所有的在线用户信息，而当前的在线用户信息是时刻都可能在变化的。 也就是说，我们需要一种存储数据的容器，它能够自动的改变这个容器的所能存放的数据数量的大小。这一点上，如果使用数组来存储的话，就显得十分的笨拙。 我们再假设这样一种场景：假定一个购物网站，经过一段时间的运行，我们已经存储了一系列的购物清单了，购物清单中有商品信息。如果我们想要知道这段时间里面有多少种商品被销售出去了。那么我们就需要一个容器能够自动的过滤掉购物清单中的关于商品的重复信息。如果使用数组，这也是很难实现的。 最后再想想，我们经常会遇到这种情况，我知道某个人的帐号名称，希望能够进一步了解这个人的其他的一些信息。也就是说，我们在一个地方存放一些用户信息，我们希望能够通过用户的帐号来查找到对应的该用户的其他的一些信息。再举个查字典例子：假设我们希望使用一个容器来存放单词以及对于这个单词的解释，而当我们想要查找某个单词的意思的时候，能够根据提供的单词在这个容器中找到对应的单词的解释。如果使用数组来实现的话，就更加的困难了。 为解决这些问题，Java里面就设计了容器集合，不同容器集合以不同的格式保存对象。 数学背景在常见用法中，集合（collection）和数学上直观的集（set）的概念是相同的。集是一个唯一项组，也就是说组中没有重复项。实际上，“集合框架”包含了一个 Set 接口和许多具体的 Set 类。但正式的集概念却比 Java 技术提前了一个世纪，那时英国数学家 George Boole 按逻辑正式的定义了集的概念。大部分人在小学时通过我们熟悉的维恩图引入的“集的交”和“集的并”学到过一些集的理论。 集的基本属性如下： 集内只包含每项的一个实例 集可以是有限的，也可以是无限的 可以定义抽象概念 集不仅是逻辑学、数学和计算机科学的基础，对于商业和系统的日常应用来说，它也很实用。“连接池”这一概念就是数据库服务器的一个开放连接集。Web 服务器必须管理客户机和连接集。文件描述符提供了操作系统中另一个集的示例。 映射是一种特别的集。它是一种对（pair）集，每个对表示一个元素到另一元素的单向映射。一些映射示例有： IP 地址到域名（DNS）的映射 关键字到数据库记录的映射 字典（词到含义的映射） 2 进制到 10 进制转换的映射 就像集一样，映射背后的思想比 Java 编程语言早的多，甚至比计算机科学还早。而Java中的Map 就是映射的一种表现形式。 容器的分类既然您已经具备了一些集的理论，您应该能够更轻松的理解“集合框架”。 “集合框架”由一组用来操作对象的接口组成。不同接口描述不同类型的组。在很大程度上，一旦您理解了接口，您就理解了框架。虽然您总要创建接口特定的实现，但访问实际集合的方法应该限制在接口方法的使用上；因此，允许您更改基本的数据结构而不必改变其它代码。 Java容器类类库的用途是“保存对象”，并将其划分为两个不同的概念： Collection一组对立的元素，通常这些元素都服从某种规则。List必须保持元素特定的顺序，而Set 不能有重复元素。Map 一组成对的“键值对”对象。初看起来这似乎应该是一个Collection ，其元素是成对的对象，但是这样的设计实现起来太笨拙了，于是我们将Map明确的提取出来形成一个独立的概念。 另一方面，如果使用Collection 表示Map的部分内容，会便于查看此部分内容。因此Map一样容易扩展成多维Map ，无需增加新的概念，只要让Map中的键值对的每个“值”也是一个Map即可。 Collection和Map的区别在于容器中每个位置保存的元素个数。Collection 每个位置只能保存一个元素（对象）。此类容器包括：List ，它以特定的顺序保存一组元素；Set 则是元素不能重复。Map保存的是“键值对”，就像一个小型数据库。我们可以通过“键”找到该键对应的“值”。 Collection – 对象之间没有指定的顺序，允许重复元素。 Set – 对象之间没有指定的顺序，不允许重复元素 List– 对象之间有指定的顺序，允许重复元素,并引入位置下标。 Map – 接口用于保存关键字（Key）和数值（Value）的集合，集合中的每个对象加入时都提供数值和关键字。Map 接口既不继承 Set 也不继承 Collection。 List、Set、Map共同的实现基础是Object数组除了四个历史集合类外，Java 2 框架还引入了六个集合实现，如下表所示。 这里没有 Collection 接口的实现，接下来看一下下面的这张关于集合框架的大图： 这张图看起来有点吓人，熟悉之后就会发现其实只有三种容器：Map，List和Set ，它们各自有两个三个实现版本。常用的容器用黑色粗线框表示。 点线方框代表“接口”，虚线方框代表抽象类，而实线方框代表普通类（即具体类，而非抽象类）。虚线箭头指出一个特定的类实现了一个接口（在抽象类的情况下，则是“部分”实现了那个接口）。实线箭头指出一个类可生成箭头指向的那个类的对象。例如任何集合( Collection )都能产生一个迭代器( Iterator )，而一个List 除了能生成一个ListIterator （列表迭代器）外,还能生成一个普通迭代器,因为List 正是从集合继承来的。 本文链接：http://www.sguotao.top/Java-2013-11-22-集合框架容器简介.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析Android中的Activity Task栈及启动模式]]></title>
    <url>%2FAndroid%E8%BF%9B%E9%98%B6-2013-11-11-%E5%88%86%E6%9E%90Android%E4%B8%AD%E7%9A%84Activity-Task%E6%A0%88%E5%8F%8A%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[在Android中，一个activity可以激活另一个activity（可能属于另一个应用程序）。若新的被激活的activity属于另一个应用程序，则那个activity会运行在那个应用程序的进程中，但是从用户的角度来看，好像就是属于本应用程序一样。 Android是通过将之前的activity组件和新被激活的activity组件放入同一个任务栈来实现这个功能的。从用户的角度看，一个任务栈就代表了“一个应用程序”。它实际上是一个栈，里面放着一组被排列好的相关的activity组件。位于栈底的activity（根activity）就是开启这个任务栈的activity组件，一般情况下，就是应用程序的主界面。而位于栈顶的activity组件即代表当前被激活的activity组件（可接收用户行为的activity）。 什么是任务栈任务栈中包含了activity组件的对象，且任务栈中可以包含某一个activity组件类型的多个实例对象。在任务栈中的activity组件不能被重排序，只能被压栈和弹栈。 任务栈不是某个类型，也不是某一个元素，它是一组activity组件的组织形式。所以没有办法在不影响任务栈中的activity组件的情况下，单独设置任务栈的参数。根activity的参数既是整个任务栈的参数，它会影响任务栈中的所有activity组件。 当某个应用程序在前后台切换的时候，实际上就是代表这个应用程序的一个任务栈在前后台切换。刚刚描述的行为是activity和任务栈的默认行为，但也有办法在很多方面对它进行修改： 方法1：在发送的请求（即Intent对象）中设置一些标记。 方法2：在manifest文件中，对接收请求（即Intent对象）的activity组件设置一些属性。 所以在请求者和接收者中都可以进行控制。在Intent对象中主要的标志有：1234FLAG_ACTIVITY_NEW_TASK FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_RESET_TASK_IF_NEEDED FLAG_ACTIVITY_SINGLE_TOP 在标签中，主要的属性有：123456taskAffinity launchMode allowTaskReparenting clearTaskOnLaunch alwaysRetainTaskState finishOnTaskLaunch 接下来的内容就会讲解一些Intent标志和标签属性的作用和用法。 亲缘关系和新的任务默认情况下，一个应用程序中的activity组件彼此之间是亲属关系――也就是说它们属于同一个任务栈。但是我们可以通过设置某个标签的taskAffinity属性来为这个activity组件设置亲属关系。在不同的应用程序中定义的activity组件可以共用同一个亲属关系，或者在同一个的应用程序中定义的activity组件可以使用不同的亲属关系。亲属关系会在两种情况下发挥作用： 1）负责激活activity组件的Intent对象中包含了FLAG_ACTIVITY_NEW_TASK标志。 2）被激活的activity组件的allowTaskReparenting属性被设置为“true”。 关于FLAG_ACTIVITY_NEW_TASK标志量默认情况下，一个被激活的新activity会和负责激活它的那个activity组件存在于同一个任务栈中。但是若负责激活的Intent对象包含了FLAG_ACTIVITY_NEW_TASK标志，则系统会为存放那个即被激活的新activity寻找一个新的任务栈。此时，若已经存在了相同亲属关系的任务栈，则系统会直接将这个即被激活的新activity放入到这个任务栈中；否则系统会开始一个新的任务栈。 关于allowTaskReparenting属性若一个activity组件的allowTaskReparenting被置为“true”，则当与这个activity有相同的亲属关系的任务栈被切换到前台的时候，这个activity会从当前存在的任务栈中移动到与其有相同的亲属关系的任务栈中。若从用户的角度来看，一个.apk文件包含了一个以上的“应用程序”，那你可能要为那些activity组件指定不同的亲属关系。 启动模式标签的launchMode属性可以设置为四种不同的模式：1234“standard”（默认模式） “singleTop” “singleTask” “singleInstance” 这几种模式的区别体现以下四点上： 1)当这个activity被激活的时候，会放入哪个任务栈。对于“standard”和“singleTop”模式，这个新被激活的activity会放入和之前的activity相同的任务栈中――除非如前所述，Intent对象包含FLAG_ACTIVITY_NEW_TASK标志。但“singleTask”和“singleInstance”模式则表示这个新被激活的activity不会放入已经存在的任务栈中，它会重新开启一个任务栈，并作为这个新的任务栈的根activity。 2)是否可以存在这个activity类型的多个实例。对于“standard”和“singleTop”模式，可以有多个实例，并且这些实例可以属于不同的任务栈，每个任务栈也可以包含有这个activity类型的多个实例。但“singleTask”和“singleInstance”模式则表示至多只可以存在这个activity类型的一个实例。又因为有第一点必须是根activity的限制，所以这意味着在同一时间，在手机上绝不会存在多于一个的由这个activity启动的任务栈。 3)包含此activity的任务栈是否可以包含其它的activity。“singleInstance”模式表示包含此activity的任务栈不可以包含其它的activity。若此activity启动了另一个activity组件，那么无论那个activity组件的启动模式是什么或是Intent对象中是否包含了FLAG_ACTIVITY_NEW_TASK标志，它都会被放入另外的任务栈。在其它方面“singleInstance”模式和“singleTask”模式是一样的。其余三种启动模式则允许包含此activity的任务栈包含其它的activity。 4)每一个activity实例处理一个intent对于默认的“standard”模式，每当响应一个Intent对象，都会创建一个这种activity类型的新的实例。即每一个activity实例处理一个intent。对于“singleTop”模式，只有当这个activity的实例当前处于任务栈的栈顶位置，则它会被重复利用来处理新到达的intent对象。否则就和“standard”模式的行为一样。正如第二点所说的，“singleTask”和“singleInstance”模式表示只能有一个实例，所以这个唯一的实例需要处理所有新到达的intent对象。又由于“singleInstance”模式的activity实例总是位于任务栈的栈顶，所以这样做很正常。但对于“singleTask”模式的acitvity，在其上面可能存在其它的activity组件，所以它的位置并不是栈顶，在这种情况下，intent对象会被丢弃。（虽然会被丢弃，但是这个intent对象会使这个任务栈切换到前台） 如果一个新到达的intent对象是被一个已经存在的activity组件来处理的，那么这个activity的onNewIntent(android.content.Intent)方法会被系统调用。注意：若为了处理一个新到达的intent对象而创建了一个activity实例，则用户按下“BACK”键就会退到之前的那个activity。但若这个新到达的intent对象是由一个已经存在的activity组件来处理的，那么用户按下“BACK” 键就不会回退到处理这个新intent对象之前的状态了。 清理任务栈如果一个任务栈在很长的一段时间都被用户保持在后台的，那么系统就会将这个任务栈中除了根activity以外的其它所有activity全部清除掉。从这之后，当用户再将任务栈切换到前台，则只能显示根activity了。以上说的是默认模式，可以通过标签的一些属性来更改： 1）alwaysRetainTaskState属性如果将根activity的alwaysRetainTaskState属性设置为“true”，则即便一个任务栈在很长的一段时间都被用户保持在后台的，系统也不会对这个任务栈进行清理。 2）clearTaskOnLaunch属性如果将根activity的clearTaskOnLaunch属性设置为“true”，那么只有这个任务栈切换到了后台，那么系统就会将这个任务栈中除了根activity以外的其它所有activity全部清除掉。即和alwaysRetainTaskState的行为完全相反。 3) finishOnTaskLaunch属性这个属性的行为类似于clearTaskOnLaunch，但是此属性作用于单个的activity对象，而不是整个任务栈。当这个任务栈切换到了后台，这个属性可以使任务栈清理包括根activity在内的任何activity对象。 这里也有另一种方法来使activity对象从任务栈中被移除。若Intent对象包含FLAG_ACTIVITY_CLEAR_TOP标志，并且在目标任务栈中已经存在了用于处理这个Intent对象的activity类型的一个实例，那么在任务栈中这个实例之上的所有activity实例会被移除。从而用于处理这个Intent对象的activity类型的那个实例会位于任务栈的栈顶，并用来处理那个Intent对象。若那个匹合的activity类型的启动模式是“standard”，则这个已经存在于任务栈中的匹合的activity类型的实例也会被移除，并且一个新的此类型activity的实例被创建并压栈来处理这个Intent对象。 FLAG_ACTIVITY_CLEAR_TOP这个标志经常和FLAG_ACTIVITY_NEW_TASK标志结合使用，这样结合使用的意思是在另一个任务栈中定位已经存在的匹合的activity类型的实例，并且让此实例位于栈顶。 启动任务栈通过将一个activity类型的intent-filter的动作设置为“android.intent.action.MAIN”，类别设置为“android.intent.category.LAUNCHER”可以使这个activity实例称为一个任务栈的入口。拥有这种类型的intent-filter的activity类型的图标和名字也会显示在application launcher中。 第二个能力是很重要的：用户必须能够使一个任务栈切换到后台，也可以随时将其切换到前台。出于这个原因，使activity在启动时新开任务栈的启动模式（即“singleTask”和“singleInstance”模式）只应该被利用在拥有拥有“android.intent.action.MAIN”动作和“android.intent.category.LAUNCHER”类别的intent-filter的activity类型上。 类似的限制同样体现在FLAG_ACTIVITY_NEW_TASK标志上。如果这个标志使一个activity开始了一个新的任务栈，并且用户点击“HOME”键将其切换到了后台，则必须有某种方式使用户可以重新将那个任务栈切换到前台。一些实例（比如通知管理器），总是在外部的任务栈中开启一个activity，而不是其自身的任务栈，所以它们总是将FLAG_ACTIVITY_NEW_TASK标志放入Intent对象中，并将Intent对象传入startActivity()方法中。 对于在某些情况下，你不希望用户能够返回到某一个activity，那么可以通过设置标签的“finishOnTaskLaunch”属性为“true”来实现。 本文链接：http://www.sguotao.top/Android进阶-2013-11-11-分析Android中的Activity-Task栈及启动模式.html]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【多线程】线程组]]></title>
    <url>%2FJava-2013-10-6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%BB%84.html</url>
    <content type="text"><![CDATA[在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。多线程 1 线程与线程类多线程 2 线程的创建多线程 3 线程的状态与调度多线程 4 线程状态的改变多线程 5 线程的同步与共享多线程 6 线程组 所有Java线程都属于某个线程组(thread group)。线程组提供了一个将多个线程组织成一个线程组对象来管理的机制，如可以通过一个方法调用来启动线程组中的所有线程。 创建线程组线程组是由java.lang包中的ThreadGroup类实现的。它的构造方法如下： 12public ThreadGroup(String name)public ThreadGroup(ThreadGroup parent, String name) name为线程组名，parent为线程组的父线程组，若无该参数则新建线程组的父线程组为当前运行的线程的线程组。当一个线程被创建时，运行时系统都将其放入一个线程组。创建线程时可以明确指定新建线程属于哪个线程组，若没有明确指定则放入缺省线程组中。一旦线程被指定属于哪个线程组，便不能改变，不能删除。 缺省线程组如果在创建线程时没有在构造方法中指定所属线程组，运行时系统会自动将该线程放入创建该线程的线程所属的线程组中。那么当我们创建线程时没有指定线程组，它属于哪个线程组呢? 当Java应用程序启动时，Java运行时系统创建一个名main的ThreadGroup对象。除非另外指定，否则所有新建线程都属于main线程组的成员。 在一个线程组内可以创建多个线程，也可以创建其它的线程组。一个程序中的线程组和线程构成一个树型结构，如图6所示. 如果在Applet中创建线程，新线程组可能不是main线程组，它依赖于使用的浏览器或Applet查看器。创建属于某个线程组的线程可以通过下面构造方法实现 123public Thread(ThreadGroup group, Runnable target)public Thread(ThreadGroup group, String name)public Thread(ThreadGroup group, Runnable target, String name) 如下面代码创建的myThread线程属于myThreadGroup线程组。 12ThreadGroup myGroup = new ThreadGroup("My Group of Threads");Thread myThread = new Thread(myGroup, "a thread for my group"); 为了得到线程所属的线程组可以调用Thread的getThreadGroup()方法，该方法返回ThreadGroup对象。可以通过下面方法获得线程所属线程组名。 1myThread.getThreadGroup().getName() 一旦得到了线程组对象，就可查询线程组的有关信息，如线程组中其他线程、也可仅通过调用一个方法就可实现修改线程组中的线程，如挂起、恢复或停止线程。 线程组操作方法线程组类提供了有关方法可以对线程组操作。 12345678public final String getName() 返回线程组名。public final ThreadGroup getParent() 返回线程组的父线程组对象。public final void setMaxPriority(int pri) 设置线程组的最大优先级。线程组中的线程不能超过该优先级。public final int getMaxPriority() 返回线程组的最大优先级。public boolean isDestroyed() 测试该线程组对象是否已被销毁。public int activeCount() 返回该线程组中活动线程的估计数。public int activeGroupCount() 返回该线程组中活动线程组的估计数。public final void destroy() 销毁该线程组及其子线程组对象。当前线程组的所有线程必须已经停止。 Java语言内在支持多线程的程序设计。线程是进程中的一个单个的顺序控制流，多线程是指单个程序内可以同时运行多个线程。 在Java程序中创建多线程的程序有两种方法。一种是继承Thread类并覆盖其run()方法，另一种是实现Runnable接口并实现其run()方法。 线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。Java的每个线程都有一个优先级，当有多个线程处于就绪状态时，线程调度程序根据线程的优先级调度线程运行。 线程都是独立的、异步执行的线程，但在很多情况下，多个线程需要共享数据资源，这就涉及到线程的同步与资源共享的问题。 所有Java线程都属于某个线程组。线程组提供了一个将多个线程组织成一个线程组对象来管理的机制，如可以通过一个方法调用来启动线程组中的所有线程。 本文链接：http://www.sguotao.top/Java-2013-10-6-多线程之线程组.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【多线程】线程的同步与共享]]></title>
    <url>%2FJava-2013-10-5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%85%B1%E4%BA%AB.html</url>
    <content type="text"><![CDATA[在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。多线程 1 线程与线程类多线程 2 线程的创建多线程 3 线程的状态与调度多线程 4 线程状态的改变多线程 5 线程的同步与共享多线程 6 线程组 前面程序中的线程都是独立的、异步执行的线程。但在很多情况下，多个线程需要共享数据资源，这就涉及到线程的同步与资源共享的问题。 资源冲突下面的例子说明，多个线程共享资源，如果不加以控制可能会产生冲突。 12345678910111213141516171819202122232425262728293031323334353637class Num&#123; private int x=0; private int y=0; void increase()&#123; x++; y++; &#125; void testEqual()&#123; System.out.println(x+","+y+":"+(x==y)); &#125;&#125;class Counter extends Thread&#123;private Num num;Counter(Num num)&#123; this.num=num; &#125;public void run()&#123;while(true)&#123; num.increase(); &#125; &#125;&#125;public class CounterTest&#123;public static void main(String[] args)&#123; Num num = new Num(); Thread count1 = new Counter(num); Thread count2 = new Counter(num); count1.start(); count2.start(); for(int i=0;i&lt;100;i++)&#123; num.testEqual(); try&#123; Thread.sleep(100); &#125;catch(InterruptedException e)&#123; &#125; &#125; &#125;&#125; 上述程序在CounterTest类的main()方法中创建了两个线程类Counter的对象count1和count2，这两个对象共享一个Num类的对象num。两个线程对象开始运行后，都调用同一个对象num的increase()方法来增加num对象的x和y的值。在main()方法的for()循环中输出num对象的x和y的值。程序输出结果有些x、y的值相等，大部分x、y的值不相等。 出现上述情况的原因是：两个线程对象同时操作一个num对象的同一段代码，通常将这段代码段称为临界区(critical sections)。在线程执行时，可能一个线程执行了x++语句而尚未执行y++语句时，系统调度另一个线程对象执行x++和y++，这时在主线程中调用testEqual()方法输出x、y的值不相等。这里可能出现x的值小于y的值的情况，为什么？ 对象锁的实现上述程序的运行结果说明了多个线程访问同一个对象出现了冲突，为了保证运行结果正确(x、y的值总相等)，可以使用Java语言的synchronized关键字，用该关键字修饰方法。用synchronized关键字修饰的方法称为同步方法，Java平台为每个具有synchronized代码段的对象关联一个对象锁(object lock)。这样任何线程在访问对象的同步方法时，首先必须获得对象锁，然后才能进入synchronized方法，这时其他线程就不能再同时访问该对象的同步方法了(包括其他的同步方法)。 通常有两种方法实现对象锁：1.在方法的声明中使用synchronized关键字，表明该方法为同步方法。对于上面的程序我们可以在定义Num类的increase()和testEqual()方法时，在它们前面加上synchronized关键字，如下所示： 1234567synchronized void increase()&#123; x++; y++;&#125;synchronized void testEqual()&#123; System.out.println(x+","+y+":"+(x==y)+":"+(x&lt;y));&#125; 一个方法使用synchronized关键字修饰后，当一个线程调用该方法时，必须先获得对象锁，只有在获得对象锁以后才能进入synchronized方法。一个时刻对象锁只能被一个线程持有。如果对象锁正在被一个线程持有，其他线程就不能获得该对象锁，其他线程就必须等待持有该对象锁的线程释放锁。 如果类的方法使用了synchronized关键字修饰，则称该类对象是线程安全的，否则是线程不安全的。如果只为increase()方法添加synchronized 关键字，结果还会出现x、y的值不相等的情况，请考虑为什么？ 2.前面实现对象锁是在方法前加上synchronized 关键字，这对于我们自己定义的类很容易实现，但如果使用类库中的类或别人定义的类在调用一个没有使用synchronized关键字修饰的方法时，又要获得对象锁，可以使用下面的格式： 123synchronized(object)&#123; //方法调用&#125; 假如Num类的increase()方法没有使用synchronized 关键字，我们在定义Counter类的run()方法时可以按如下方法使用synchronized为部分代码加锁。 1234567public void run()&#123; while(true)&#123;synchronized (num)&#123; num.increase(); &#125; &#125;&#125; 同时在main()方法中调用testEqual()方法也用synchronized关键字修饰，这样得到的结果相同。 123synchronized(num)&#123; num.testEqual();&#125; 对象锁的获得和释放是由Java运行时系统自动完成的。每个类也可以有类锁。类锁控制对类的synchronized static代码的访问。请看下面的例子： 123456public class X&#123; static int x, y; static synchronized void foo()&#123; x++;y++;&#125;&#125; 当foo()方法被调用时(如，使用X.foo())，调用线程必须获得X类的类锁。 线程间的同步控制在多线程的程序中，除了要防止资源冲突外，有时还要保证线程的同步。下面通过生产者-消费者模型来说明线程的同步与资源共享的问题。 假设有一个生产者(Producer)，一个消费者(Consumer)。生产者产生0~9的整数，将它们存储在仓库(CubbyHole)的对象中并打印出这些数来；消费者从仓库中取出这些整数并将其也打印出来。同时要求生产者产生一个数字，消费者取得一个数字，这就涉及到两个线程的同步问题。 这个问题就可以通过两个线程实现生产者和消费者，它们共享CubbyHole一个对象。如果不加控制就得不到预期的结果。 不同步设计首先我们设计用于存储数据的类，该类的定义如下： 123456789class CubbyHole&#123;private int content ;public synchronized void put(int value)&#123;content = value;&#125;public synchronized int get()&#123;return content ;&#125; &#125; CubbyHole类使用一个私有成员变量content用来存放整数，put()方法和get()方法用来设置变量content的值。CubbyHole对象为共享资源，所以用synchronized关键字修饰。当put()方法或get()方法被调用时，线程即获得了对象锁，从而可以避免资源冲突。 这样当Producer对象调用put()方法时，它锁定了该对象，Consumer对象就不能调用get()方法。当put()方法返回时，Producer对象释放了CubbyHole的锁。类似地，当Consumer对象调用CubbyHole的get()方法时，它也锁定该对象，防止Producer对象调用put()方法。 接下来我们看Producer和Consumer的定义，这两个类的定义如下： 1234567891011121314151617public class Producer extends Thread &#123; private CubbyHole cubbyhole; private int number; public Producer(CubbyHole c, int number) &#123; cubbyhole = c; this.number = number; &#125; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; cubbyhole.put(i); System.out.println("Producer #" + this.number + " put: " + i); try &#123; sleep((int)(Math.random() * 100)); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; Producer类中定义了一个CubbyHole类型的成员变量cubbyhole，它用来存储产生的整数，另一个成员变量number用来记录线程号。这两个变量通过构造方法传递得到。在该类的run()方法中，通过一个循环产生10个整数，每次产生一个整数，调用cubbyhole对象的put()方法将其存入该对象中，同时输出该数。下面是Consumer类的定义： 123456789101112131415public class Consumer extends Thread &#123; private CubbyHole cubbyhole; private int number; public Consumer(CubbyHole c, int number) &#123; cubbyhole = c; this.number = number; &#125; public void run() &#123; int value = 0; for (int i = 0; i &lt; 10; i++) &#123; value = cubbyhole.get(); System.out.println("Consumer #" + this.number + " got: " + value); &#125; &#125;&#125; 在Consumer类的run()方法中也是一个循环，每次调用cubbyhole的get()方法返回当前存储的整数，然后输出。 下面是主程序，在该程序的main()方法中创建一个CubbyHole对象c，一个Producer对象p1，一个Consumer对象c1，然后启动两个线程。 123456789public class ProducerConsumerTest &#123; public static void main(String[] args) &#123; CubbyHole c = new CubbyHole(); Producer p1 = new Producer(c, 1); Consumer c1 = new Consumer(c, 1); p1.start(); c1.start(); &#125;&#125; 该程序中对CubbyHole类的设计，尽管使用了synchronized关键字实现了对象锁，但这还不够。程序运行可能出现下面两种情况： 如果生产者的速度比消费者快，那么在消费者来不及取前一个数据之前，生产者又产生了新的数据，于是消费者很可能会跳过前一个数据，这样就会产生下面的结果： 12345Consumer: 3Producer: 4Producer: 5Consumer: 5… 反之，如果消费者比生产者快，消费者可能两次取同一个数据，可能产生下面的结果： 12345Producer: 4Consumer: 4Consumer: 4Producer: 5… 监视器模型为了避免上述情况发生，就必须使生产者线程向CubbyHole对象中存储数据与消费者线程从CubbyHole对象中取得数据同步起来。为了达到这一目的，在程序中可以采用监视器(monitor)模型，同时通过调用对象的wait()方法和notify()方法实现同步。下面是修改后的CubbyHole类的定义： 123456789101112131415161718192021222324class CubbyHole&#123; private int content ; private boolean available=false;public synchronized void put(int value)&#123; while(available==true)&#123; try&#123;wait();&#125;catch(InterruptedException e)&#123;&#125;&#125; content =value;available=true;notifyAll();&#125; public synchronized int get()&#123; while(available==false)&#123; try&#123;wait();&#125;catch(InterruptedException e)&#123;&#125; &#125;available=false;notifyAll();return content;&#125; &#125; 这里有一个boolean型的私有成员变量available用来指示内容是否可取。当available为true时表示数据已经产生还没被取走，当available为false时表示数据已被取走还没有存放新的数据。 当生产者线程进入put()方法时，首先检查available的值，若其为false，才可执行put()方法，若其为true，说明数据还没有被取走，该线程必须等待。因此在put()方法中调用CubbyHole对象的wait()方法等待。调用对象的wait()方法使线程进入等待状态，同时释放对象锁。直到另一个线程对象调用了notify()或notifyAll()方法，该线程才可恢复运行。 类似地，当消费者线程进入get()方法时，也是先检查available的值，若其为true，才可执行get()方法，若其为false，说明还没有数据，该线程必须等待。因此在get()方法中调用CubbyHole对象的wait()方法等待。调用对象的wait()方法使线程进入等待状态，同时释放对象锁。 上述过程就是监视器模型，其中CubbyHole对象为监视器。通过监视器模型可以保证生产者线程和消费者线程同步，结果正确。 特别注意：wait()、notify()和notifyAll()方法是Object类定义的方法，并且这些方法只能用在synchronized代码段中。它们的定义格式如下： 123public final void wait()public final void wait(long timeout)public final void wait(long timeout, int nanos) 当前线程必须具有对象监视器的锁，当调用该方法时线程释放监视器的锁。调用这些方法使当前线程进入等待(阻塞)状态，直到另一个线程调用了该对象的notify()方法或notifyAll()方法，该线程重新进入运行状态，恢复执行。 timeout和nanos为等待的时间的毫秒和纳秒，当时间到或其他对象调用了该对象的notify()方法或notifyAll()方法，该线程重新进入运行状态，恢复执行。 wait()的声明抛出了InterruptedException，因此程序中必须捕获或声明抛出该异常。 12public final void notify()public final void notifyAll() 唤醒处于等待该对象锁的一个或所有的线程继续执行，通常使用notifyAll()方法。 在生产者/消费者的例子中，CubbyHole类的put和get方法就是临界区。当生产者修改它时，消费者不能问CubbyHole对象；当消费者取得值时，生产者也不能修改它。 本文链接：http://www.sguotao.top/Java-2013-10-5-多线程之线程的同步与共享.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【多线程】线程状态的改变]]></title>
    <url>%2FJava-2013-10-4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%8A%B6%E6%80%81%E7%9A%84%E6%94%B9%E5%8F%98.html</url>
    <content type="text"><![CDATA[在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。多线程 1 线程与线程类多线程 2 线程的创建多线程 3 线程的状态与调度多线程 4 线程状态的改变多线程 5 线程的同步与共享多线程 6 线程组 线程的状态一个线程在其生命周期中可以从一种状态改变到另一种状态，线程状态的变迁如图5所示： 控制线程的启动和结束当一个新建的线程调用它的start()方法后即进入就绪状态，处于就绪状态的线程被线程调度程序选中就可以获得CPU时间，进入运行状态，该线程就开始运行run()方法。 控制线程的结束稍微复杂一点。如果线程的run()方法是一个确定次数的循环，则循环结束后，线程运行就结束了，线程对象即进入死亡状态。如果run()方法是一个不确定循环，早期的方法是调用线程对象的stop()方法，然而由于该方法可能导致线程死锁，因此从1.1版开始，不推荐使用该方法结束线程。一般是通过设置一个标志变量，在程序中改变标志变量的值实现结束线程。请看下面的例子： 1234567891011121314151617181920212223242526272829import java.util.*;class Timer implements Runnable&#123; boolean flag=true; public void run()&#123; while(flag)&#123; System.out.print("\r\t"+new Date()+"..."); try&#123; Thread.sleep(1000); &#125;catch(InterruptedException e)&#123;&#125; &#125; System.out.println("\n"+Thread.currentThread().getName()+" Stop"); &#125; public void stopRun()&#123; flag = false; &#125;&#125;public class ThreadStop&#123; public static void main(String args[])&#123; Timer timer = new Timer(); Thread thread = new Thread(timer); thread.setName("Timer"); thread.start(); for(int i=0;i&lt;100;i++)&#123; System.out.print("\r"+i); try&#123; Thread.sleep(100); &#125;catch(InterruptedException e)&#123;&#125; &#125; timer.stopRun();&#125;&#125; 该程序在Timer类中定义了一个布尔变量flag，同时定义了一个stopRun()方法，在其中将该变量设置为false。在主程序中通过调用该方法，从而改变该变量的值，使得run()方法的while循环条件不满足，从而实现结束线程的运行。 在Thread类中除了stop()方法被标注为不推荐(deprecated) 使用外，suspend()方法和resume()方法也被标明不推荐使用，这两个方法原来用作线程的挂起和恢复。 线程阻塞条件处于运行状态的线程除了可以进入死亡状态外，还可能进入就绪状态和阻塞状态。下面分别讨论这两种情况： 运行状态到就绪状态处于运行状态的线程如果调用了yield()方法，那么它将放弃CPU时间，使当前正在运行的线程进入就绪状态。这时有几种可能的情况：如果没有其他的线程处于就绪状态等待运行，该线程会立即继续运行；如果有等待的线程，此时线程回到就绪状态状态与其他线程竞争CPU时间，当有比该线程优先级高的线程时，高优先级的线程进入运行状态，当没有比该线程优先级高的线程时，但有同优先级的线程，则由线程调度程序来决定哪个线程进入运行状态，因此线程调用yield()方法只能将CPU时间让给具有同优先级的或高优先级的线程而不能让给低优先级的线程。一般来说，在调用线程的yield()方法可以使耗时的线程暂停执行一段时间，使其他线程有执行的机会。 运行状态到阻塞状态有多种原因可使当前运行的线程进入阻塞状态，进入阻塞状态的线程当相应的事件结束或条件满足时进入就绪状态。使线程进入阻塞状态可能有多种原因： 线程调用了sleep()方法，线程进入睡眠状态，此时该线程停止执行一段时间。当时间到时该线程回到就绪状态，与其他线程竞争CPU时间。Thread类中定义了一个interrupt()方法。一个处于睡眠中的线程若调用了interrupt()方法，该线程立即结束睡眠进入就绪状态。 如果一个线程的运行需要进行I/O操作，比如从键盘接收数据，这时程序可能需要等待用户的输入，这时如果该线程一直占用CPU，其他线程就得不到运行。这种情况称为I/O阻塞。这时该线程就会离开运行状态而进入阻塞状态。Java语言的所有I/O方法都具有这种行为。 有时要求当前线程的执行在另一个线程执行结束后再继续执行，这时可以调用join()方法实现，join()方法有下面三种格式： 123public void join() throws InterruptedException 使当前线程暂停执行，等待调用该方法的线程结束后再执行当前线程。public void join(long millis) throws InterruptedException 最多等待millis毫秒后，当前线程继续执行。public void join(long millis, int nanos) throws InterruptedException 可以指定多少毫秒、多少纳秒后继续执行当前线程。 上述方法使当前线程暂停执行，进入阻塞状态，当调用线程结束或指定的时间过后，当前线程线程进入就绪状态，例如执行下面代码： 1t.join(); 将使当前线程进入阻塞状态，当线程t执行结束后，当前线程才能继续执行。 线程调用了wait()方法，等待某个条件变量，此时该线程进入阻塞状态。直到被通知(调用了notify()或notifyAll()方法)结束等待后，线程回到就绪状态。 另外如果线程不能获得对象锁，也进入就绪状态。后两种情况在下一节讨论。 本文链接：http://www.sguotao.top/Java-2013-10-4-多线程之状态的改变.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【多线程】线程的状态与调度]]></title>
    <url>%2FJava-2013-10-3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%B0%83%E5%BA%A6.html</url>
    <content type="text"><![CDATA[在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。多线程 1 线程与线程类多线程 2 线程的创建多线程 3 线程的状态与调度多线程 4 线程状态的改变多线程 5 线程的同步与共享多线程 6 线程组 线程的生命周期线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。线程的状态如图4所示： 下面以前面的Java小程序为例说明线程的状态： 新建状态 NewThread当Applet启动时调用Applet的start()方法，此时小应用程序就创建一个Thread对象clockThread。 123456public void start() &#123; if (clockThread == null) &#123; clockThread = new Thread(cp, "Clock"); clockThread.start(); &#125; &#125; 当该语句执行后clockThread就处于新建状态。处于该状态的线程仅仅是空的线程对象，并没有为其分配系统资源。当线程处于该状态，你仅能启动线程，调用任何其他方法是无意义的且会引发IllegalThreadStateException异常(实际上，当调用线程的状态所不允许的任何方法时，运行时系统都会引发IllegalThreadStateException异常)。 注意cp作为线程构造方法的第一个参数，该参数必须是实现了Runnable接口的对象并提供线程运行的run()方法，第二个参数是线程名。 就绪状态 Runnable一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，如clockThread.start(); 语句就是启动clockThread线程。start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度的。 运行状态 Running当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法，这里run()方法中是一个循环，循环条件是true。 123456789public void run() &#123; while (true) &#123; repaint(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e)&#123; &#125; &#125; 阻塞状态 Blocked线程运行过程中，可能由于各种原因进入阻塞状态。所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。有关阻塞状态在后面详细讨论。 死亡状态 Dead线程的正常结束，即run()方法返回，线程运行就结束了，此时线程就处于死亡状态。本例子中，线程运行结束的条件是clockThread为null，而在小应用程序的stop()方法中，将clockThread赋值为null。即当用户离开含有该小应用程序的页面时，浏览器调用stop()方法，将clockThread赋值为null，这样在run()的while循环时条件就为false，这样线程运行就结束了。如果再重新访问该页面，小应用程序的start()方法又会重新被调用，重新创建并启动一个新的线程。 123public void stop() &#123; clockThread = null; &#125; 程序不能像终止小应用程序那样通过调用一个方法来结束线程(小应用程序通过调用stop()方法结束小应用程序的运行)。线程必须通过run()方法的自然结束而结束。通常在run()方法中是一个循环，要么是循环结束，要么是循环的条件不满足，这两种情况都可以使线程正常结束，进入死亡状态。例如，下面一段代码是一个循环： 1234567public void run()&#123; int i = 0; while(i&lt;100)&#123; i++; System.out.println("i = " + i ); &#125;&#125; 当该段代码循环结束后，线程就自然结束了。注意一个处于死亡状态的线程不能再调用该线程的任何方法。 线程的优先级和调度Java的每个线程都有一个优先级，当有多个线程处于就绪状态时，线程调度程序根据线程的优先级调度线程运行。可以用下面方法设置和返回线程的优先级。 12public final void setPriority(int newPriority) 设置线程的优先级。public final int getPriority() 返回线程的优先级。 newPriority为线程的优先级，其取值为1到10之间的整数，也可以使用Thread类定义的常量来设置线程的优先级，这些常量分别为：Thread.MIN_PRIORITY、Thread.NORM_PRIORITY、Thread.MAX_PRIORITY，它们分别对应于线程优先级的1、5和10，数值越大优先级越高。当创建Java线程时，如果没有指定它的优先级，则它从创建该线程那里继承优先级。 一般来说，只有在当前线程停止或由于某种原因被阻塞，较低优先级的线程才有机会运行。前面说过多个线程可并发运行，然而实际上并不总是这样。由于很多计算机都是单CPU的，所以一个时刻只能有一个线程运行，多个线程的并发运行只是幻觉。在单CPU机器上多个线程的执行是按照某种顺序执行的，这称为线程的调度(scheduling)。 大多数计算机仅有一个CPU，所以线程必须与其他线程共享CPU。多个线程在单个CPU是按照某种顺序执行的。实际的调度策略随系统的不同而不同，通常线程调度可以采用两种策略调度处于就绪状态的线程。 抢占式调度策略Java运行时系统的线程调度算法是抢占式的 (preemptive)。Java运行时系统支持一种简单的固定优先级的调度算法。如果一个优先级比其他任何处于可运行状态的线程都高的线程进入就绪状态，那么运行时系统就会选择该线程运行。新的优先级较高的线程抢占(preempt)了其他线程。但是Java运行时系统并不抢占同优先级的线程。换句话说，Java运行时系统不是分时的(time-slice)。然而，基于Java Thread类的实现系统可能是支持分时的，因此编写代码时不要依赖分时。当系统中的处于就绪状态的线程都具有相同优先级时，线程调度程序采用一种简单的、非抢占式的轮转的调度顺序。 时间片轮转调度策略有些系统的线程调度采用时间片轮转(round-robin)调度策略。这种调度策略是从所有处于就绪状态的线程中选择优先级最高的线程分配一定的CPU时间运行。该时间过后再选择其他线程运行。只有当线程运行结束、放弃(yield)CPU或由于某种原因进入阻塞状态，低优先级的线程才有机会执行。如果有两个优先级相同的线程都在等待CPU，则调度程序以轮转的方式选择运行的线程。 本文链接：http://www.sguotao.top/Java-2013-10-3-多线程之线程的状态与调度.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【多线程】线程的创建]]></title>
    <url>%2FJava-2013-10-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA.html</url>
    <content type="text"><![CDATA[在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。多线程 1 线程与线程类多线程 2 线程的创建多线程 3 线程的状态与调度多线程 4 线程状态的改变多线程 5 线程的同步与共享多线程 6 线程组 如何创建和运行线程的两种方法。线程运行的代码就是实现了Runnable接口的类的run()方法或者是Thread类的子类的run()方法，因此构造线程体就有两种方法： 继承Thread类并覆盖它的run()方法； 实现Runnable接口并实现它的run()方法。 继承Thread类创建线程通过继承Thread类，并覆盖run()方法，这时就可以用该类的实例作为线程的目标对象。下面的程序定义了SimpleThread类，它继承了Thread类并覆盖了run()方法。 1234567891011121314public class SimpleThread extends Thread&#123; public SimpleThread(String str)&#123; super(str);&#125;public void run()&#123; for(int i=0; i&lt;100; i++)&#123; System.out.println(getName()+" = "+ i); try&#123; sleep((int)(Math.random()*100)); &#125;catch(InterruptedException e)&#123;&#125; &#125; System.out.println(getName()+ " DONE"); &#125;&#125; SimpleThread类继承了Thread类，并覆盖了run()方法，该方法就是线程体。 12345678public class ThreadTest&#123; public static void main(String args[])&#123; Thread t1 = new SimpleThread("Runner A"); Thread t2 = new SimpleThread("Runner B"); t1.start(); t2.start(); &#125;&#125; 在ThreadTest类的main()方法中创建了两个SimpleThread类的线程对象并调用线程类的start()方法启动线程。构造线程时没有指定目标对象，所以线程启动后执行本类的run()方法。 注意，实际上ThreadTest程序中有三个线程同时运行。请试着将下段代码加到main()方法中，分析程序运行结果。 1234567for(int i=0; i&lt;100; i++)&#123; System.out.println(Thread.currentThread().getName()+"="+ i); try&#123; Thread.sleep((int)(Math.random()*500)); &#125;catch(InterruptedException e)&#123;&#125;System.out.println(Thread.currentThread().getName()+ " DONE"); &#125; 从上述代码执行结果可以看到，在应用程序的main()方法启动时，JVM就创建一个主线程，在主线程中可以创建其他线程。再看下面的程序： 123456789public class MainThreadDemo&#123; public static void main(String args[])&#123; Thread t = Thread.currentThread(); t.setName("MyThread"); System.out.println(t); System.out.println(t.getName()); System.out.println(t.getThreadGroup().getName()); &#125;&#125; 该程序输出结果为： 123Thread[MyThread, 5, main]MyThreadmain 上述程序在main()方法中声明了一个Thread对象t，然后调用Thread类的静态方法currentThread()获得当前线程对象。然后重新设置该线程对象的名称，最后输出线程对象、线程组对象名和线程对象名。 实现Runnable接口创建线程可以定义一个类实现Runnable接口，然后将该类对象作为线程的目标对象。实现Runnable接口就是实现run()方法。下面程序通过实现Runnable接口构造线程体。 1234567891011121314151617181920class T1 implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;15;i++) System.out.println("Runner A="+i); &#125;&#125;class T2 implements Runnable&#123; public void run()&#123; for(int j=0;j&lt;15;j++) System.out.println("Runner B="+j); &#125;&#125;public class ThreadTest&#123; public static void main(String args[])&#123; Thread t1=new Thread(new T1(),"Thread A"); Thread t2=new Thread(new T2(),"Thread B"); t1.start(); t2.start(); &#125;&#125; 下面是一个小应用程序，利用线程对象在其中显示当前时间。 123456789101112131415161718192021222324252627282930313233343536373839import java.awt.*;import java.util.*;import javax.swing.*;import java.text.DateFormat;public class ClockDemo extends JApplet&#123; private Thread clockThread = null; private ClockPanel cp=new ClockPanel(); public void init()&#123; getContentPane().add(cp); &#125; public void start() &#123; if (clockThread == null) &#123; clockThread = new Thread(cp, "Clock"); clockThread.start(); &#125;&#125; public void stop() &#123; clockThread = null; &#125;&#125;class ClockPanel extends JPanel implements Runnable&#123; public void paintComponent(Graphics g) &#123;super.paintComponent(g); Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); DateFormat dateFormatter = DateFormat.getTimeInstance(); g.setColor(Color.BLUE); g.setFont(new Font("TimesNewRoman",Font.BOLD,36)); g.drawString(dateFormatter.format(date), 50, 50); &#125; public void run() &#123; while (true) &#123; repaint(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e)&#123; &#125; &#125;&#125;&#125; 该小应用程序的运行结果如图3所示： 本文链接：http://www.sguotao.top/Java-2013-10-2-多线程之线程的创建.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【多线程】线程与线程类]]></title>
    <url>%2FJava-2013-10-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%B1%BB.html</url>
    <content type="text"><![CDATA[在学习Java多线程的过程中，Java 线程工具和 API 看似简单，但是，编写有效使用线程的复杂程序并不容易。做如下整理，方便日后查阅。多线程 1 线程与线程类多线程 2 线程的创建多线程 3 线程的状态与调度多线程 4 线程状态的改变多线程 5 线程的同步与共享多线程 6 线程组 Java语言的一个重要特点是内在支持多线程的程序设计。多线程是指在单个的程序内可以同时运行多个不同的线程完成不同的任务。多线程的程序设计具有广泛的应用。本章主要讲授线程的概念、如何创建多线程的程序、线程的生存周期与状态的改变、线程的同步与互斥等内容。 线程的概念线程的概念来源于计算机的操作系统的进程的概念。进程是一个程序关于某个数据集的一次运行。也就是说，进程是运行中的程序，是程序的一次运行活动。 线程和进程的相似之处在于，线程和运行的程序都是单个顺序控制流。有些教材将线程称为轻量级进程(light weight process)。线程被看作是轻量级进程是因为它运行在一个程序的上下文内，并利用分配给程序的资源和环境。 作为单个顺序控制流，线程必须在运行的程序中得到自己运行的资源，如必须有自己的执行栈和程序计数器。线程内运行的代码只能在该上下文内。因此还有些教程将执行上下文(execution context)作为线程的同义词。 所有的程序员都熟悉顺序程序的编写，如我们编写的名称排序和求素数的程序就是顺序程序。顺序程序都有开始、执行序列和结束，在程序执行的任何时刻，只有一个执行点。线程（thread）则是进程中的一个单个的顺序控制流。单线程的概念很简单，如图1所示。 多线程（multi-thread）是指在单个的程序内可以同时运行多个不同的线程完成不同的任务，图2说明了一个程序中同时有两个线程运行。 有些程序中需要多个控制流并行执行。例如， 1234for(int i = 0; i &lt; 100; i++) System.out.println("Runner A = " + i);for(int j = 0; j &lt; 100; j++ ) System.out.println("Runner B = "+j); 上面的代码段中，在只支持单线程的语言中，前一个循环不执行完不可能执行第二个循环。要使两个循环同时执行，需要编写多线程的程序。 很多应用程序是用多线程实现的，如Hot Java Web浏览器就是多线程应用的例子。在Hot Java 浏览器中，你可以一边滚动屏幕，一边下载Applet或图像，可以同时播放动画和声音等。 2. Thread类和Runnable接口多线程是一个程序中可以有多段代码同时运行，那么这些代码写在哪里，如何创建线程对象呢?首先，我们来看Java语言实现多线程编程的类和接口。在java.lang包中定义了Runnable接口和Thread类。Runnable接口中只定义了一个方法，它的格式为： 1public abstract void run() 这个方法要由实现了Runnable接口的类实现。Runnable对象称为可运行对象，一个线程的运行就是执行该对象的run()方法。 Thread类实现了Runnable接口，因此Thread对象也是可运行对象。同时Thread类也是线程类，该类的构造方法如下： 1234567public Thread() public Thread(Runnable target)public Thread(String name)public Thread(Runnable target, String name)public Thread(ThreadGroup group, Runnable target)public Thread(ThreadGroup group, String name)public Thread(ThreadGroup group, Runnable target, String name) target为线程运行的目标对象，即线程调用start()方法启动后运行那个对象的run()方法，该对象的类型为Runnable，若没有指定目标对象，则以当前类对象为目标对象；name为线程名，group指定线程属于哪个线程组（有关线程组的概念请参考第6节）。Thread类的常用方法有: 12345public static Thread currentThread() 返回当前正在执行的线程对象的引用。public void setName(String name) 设置线程名。public String getName() 返回线程名。public static void sleep(long millis) throws InterruptedExceptionpublic static void sleep(long millis, int nanos) throws InterruptedException 使当前正在执行的线程暂时停止执行指定的毫秒时间。指定时间过后，线程继续执行。该方法抛出InterruptedException异常，必须捕获。 12345678public void run() 线程的线程体。public void start() 由JVM调用线程的run()方法，启动线程开始执行。public void setDaemon(boolean on) 设置线程为Daemon线程。public boolean isDaemon() 返回线程是否为Daemon线程。public static void yield() 使当前执行的线程暂停执行，允许其他线程执行。public ThreadGroup getThreadGroup() 返回该线程所属的线程组对象。public void interrupt() 中断当前线程。public boolean isAlive() 返回指定线程是否处于活动状态。 本文链接：http://www.sguotao.top/Java-2013-10-1-多线程之线程与线程类.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 设置全屏显示]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-08-15-android%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E6%98%BE%E7%A4%BA.html</url>
    <content type="text"><![CDATA[Android中实现全屏显示的两种方式: 方式一在AndroidManifest.xml文件中通过设置Application或Activity的android:theme属性12345678&lt;activity android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot; android:name=&quot;.TestViewAnimation&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 方式二在Activity的onCreate()方法中进行设置(两行代码还必须写在setContentView()前面。)123456789@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); /*set it to be no title*/ requestWindowFeature(Window.FEATURE_NO_TITLE); /*set it to be full screen*/ getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.activity_test_view_animation); &#125; 方式三(补充)在AppCompatActivity设置全屏，情况有些特殊。发现当Activity继承AppCompatActivity时，以上两种方法会出现Crash和无法编译的情况。这时需要我们创建一个style样式，并在AndroidManifest.xml文件中需要全屏显示的Activity使用该样式。12345&lt;style name=&quot;theme_fullscreen&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowActionBar&quot;&gt;false&lt;/item&gt;&lt;/style&gt; 本文链接：http://www.sguotao.top/Android基础-2012-08-15-android设置全屏显示.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础16 传感器]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-08-14-android-basic-16.html</url>
    <content type="text"><![CDATA[1. 传感器传感器类型：方向、加速度(重力)、光线、磁场、距离(临近性)、温度等。 方向传感器 Sensor.TYPE_ORIENTATION 加速度(重力)传感器 | Sensor.TYPE_ACCELEROMETER光线传感器 | Sensor.TYPE_LIGHT磁场传感器 | Sensor.TYPE_MAGNETIC_FIELD距离(临近性)传感器 | Sensor.TYPE_PROXIMITY温度传感器 | Sensor.TYPE_TEMPERATURE 代码实现： 1234//获取某种类型的感应器Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);//注册监听，获取传感器变化值sensorManager.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_GAME); 上面第三个参数为采样率：最快、游戏、普通、用户界面。当应用程序请求特定的采样率时，其实只是对传感器子系统的一个建议，不保证特定的采样率可用。 最快 SensorManager.SENSOR_DELAY_FASTEST 最低延迟，一般不是特别敏感的处理不推荐使用，该种模式可能造成手机电力大量消耗，由于传递的为原始数据，算法不处理好将会影响游戏逻辑和UI的性能。 游戏 | SensorManager.SENSOR_DELAY_GAME | 游戏延迟，一般绝大多数的实时性较高的游戏都使用该级别。普通 | SensorManager.SENSOR_DELAY_NORMAL | 标准延迟，对于一般的益智类或EASY级别的游戏可以使用，但过低的采样率可能对一些赛车类游戏有跳帧现象。用户界面 | SensorManager.SENSOR_DELAY_UI | 一般对于屏幕方向自动旋转使用，相对节省电能和逻辑处理，一般游戏开发中我们不使用。 下面介绍如何获取加速度(重力)传感器和方向传感器的测量值： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends Activity &#123; private TextView accelerometer; private TextView orientation; private SensorManager sensorManager; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); //①获取感应器管理器 sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); accelerometer = (TextView) findViewById(R.id.accelerometer); orientation = (TextView) findViewById(R.id.orientation); &#125; @Override protected void onResume() &#123; //②获取重力加速度传感器 Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); //③注册监听器 sensorManager.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_GAME); Sensor sensor1 = sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);//获取方向传感器 sensorManager.registerListener(listener, sensor1, SensorManager.SENSOR_DELAY_GAME); super.onResume(); &#125; @Override protected void onPause() &#123; //④注消所有传感器监听 sensorManager.unregisterListener(listener); super.onPause(); &#125; private SensorEventListener listener = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent event) &#123;//当传感器的值发生变化 float x = event.values[SensorManager.DATA_X]; float y = event.values[SensorManager.DATA_Y]; float z = event.values[SensorManager.DATA_Z]; switch (event.sensor.getType()) &#123; case Sensor.TYPE_ACCELEROMETER: accelerometer.setText(&quot;Accelerometer Sensor: &quot; + x + &quot;, &quot; + y + &quot;, &quot; + z); break; case Sensor.TYPE_ORIENTATION: orientation.setText(&quot;Orientation Sensor: &quot; + x + &quot;, &quot; + y + &quot;, &quot; + z); break; &#125; &#125; @Override public void onAccuracyChanged(Sensor sensor, int accuracy) &#123;//当传感器的精度变化时 &#125; &#125;;&#125; 方法orientation.setText(x，y，z);参数的含义 x该值表示方位，0代表北（North）；90代表东（East）；180代表南（South）；270代表西（West）如果x值正好是这4个值之一，并且手机是水平放置，手机的顶部对准的方向就是该值代表的方向。 y值表示倾斜度，或手机翘起的程度。当手机绕着X轴倾斜时该值发生变化。y值的取值范围是-180≤y值 ≤180。 z值来测量桌子等物体的倾斜度。z值表示手机沿着Y轴的滚动角度。表示手机沿着Y轴的滚动角度。取值范围是-90≤z值≤90。假设将手机屏幕朝上水平放在桌面上，这时如果桌面是平的，z值应为0。将手机左侧逐渐抬起时，z值逐渐变小，直到手机垂直于桌面放置，这时z值是-90。将手机右侧逐渐抬起时，z值逐渐增大， 直到手机垂直于桌面放置，这时z值是90。在垂直位置时继续向右或向左滚动，z值会继续在-90至90之间变化。 假设将手机屏幕朝上水平放在桌子上，这时如果桌子是完全水平的，y值应该是0（由于很少有桌子是绝对水平的，因此，该值很可能不为0，但一般都是-5和5之间的某个值）。这时从手机顶部开始抬起，直到将手机沿X轴旋转180度（屏幕向下水平放在桌面上）。在这个旋转过程中，y值会在0到-180之间变化，也就是说，从手机顶部抬起时，y的值会逐渐变小，直到等于-180。如果从手机底部开始抬起，直到将手机沿X轴旋转180度，这时y值会在0到180之间变化。也就是y值会逐渐增大，直到等于180。可以利用y值和使用方向传感器（案例：指南针） 2. NinePatch图片NinePatch是一种很有用的PNG图片格式，它可以在特定区域随文字大小进行缩放。如下： 从上图可以看到，背景图片的中间区域会随着文字的大小进行缩放。背景图片是一张NinePatch图片。 NinePatch图片可以使用android自带的draw9patch工具来制作，该工具在SDK安装路径的tools目录下。执行该工具，然后点击“File”-&gt;“open 9-path”打开一张用于制作NinePatch图片的原来图片。在画布的上方和左方的边上画线指定缩放区域，勾选“Show patches”可显示画定的区域，绿色为固定大小区域，红色为缩放区域，文字会摆放在红色区域。制作完后，点击“File” “save 9-path”保存图片，draw9patch工具会自动为图片加上*.9.png后缀。 把制作好的图片拷贝进项目的res/drawable目录，然后编写代码。如下： 1234&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;退出&quot; android:textColor=&quot;#330000&quot; android:background=&quot;@drawable/button&quot;/&gt; 3. 触摸事件3.1 拖拽XML配置： 123456&lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;matrix&quot; android:src=&quot;@drawable/bb2&quot; /&gt; Java代码实现： 1234567891011121314151617181920212223ImageView imageView = (ImageView) findViewById(R.id.img);imageView.setOnTouchListener(new MyListener());private final class MyListener implements OnTouchListener &#123; private float x; private float y; private Matrix startMatrix = new Matrix(); private Matrix matrix = new Matrix(); public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: x = event.getX(); y = event.getY(); startMatrix.set(imageView.getImageMatrix()); break; case MotionEvent.ACTION_MOVE: matrix.set(startMatrix); matrix.postTranslate(event.getX() - x, event.getY() - y); break; &#125; imageView.setImageMatrix(matrix); return true; &#125;&#125; 3.2 多点触控1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private final class MyListener implements OnTouchListener &#123; private float x; private float y; private Matrix matrix = new Matrix(); private Matrix startMatrix = new Matrix(); private int type; private float startDis; private PointF point; public boolean onTouch(View v, MotionEvent event) &#123; System.out.println(event.getAction()); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: type = 1; x = event.getX(); y = event.getY(); startMatrix.set(imageView.getImageMatrix()); break; case MotionEvent.ACTION_MOVE: matrix.set(startMatrix); if (type == 1) matrix.postTranslate(event.getX() - x, event.getY() - y); else &#123; float scale = getDis(event) / startDis; matrix.postScale(scale, scale, point.x, point.y); &#125; break; case MotionEvent.ACTION_POINTER_DOWN: type = 2; startMatrix.set(imageView.getImageMatrix()); startDis = getDis(event); point = getPoint(event); break; &#125; imageView.setImageMatrix(matrix); return true; &#125; &#125; private float getDis(MotionEvent event) &#123; float a = event.getX(1) - event.getX(0); float b = event.getY(1) - event.getY(0); return (float) Math.sqrt(a * a + b * b); &#125; private PointF getPoint(MotionEvent event) &#123; float x = (event.getX(0) + event.getX(1)) / 2; float y = (event.getY(0) + event.getY(1)) / 2; return new PointF(x, y);&#125; 4. 读取SIM卡文档位置：android-sdk-windows\platforms\android-8\sources\ContactsProvider\src\com\android\providers\contacts\ CallLogProvider.java 4.1 判断SIM卡属于那个运营商SIM卡的IMSI码是SIM卡唯一标识：IMSI 国际移动用户识别码（IMSI：International Mobile Subscriber Identification Number）是区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息。IMSI由MCC、MNC、MSIN组成，其中MCC为移动国家号码，由3位数字组成，唯一地识别移动客户所属的国家，我国为460；MNC为网络id，由2位数字组成，用于识别移动客户所归属的移动网络，中国移动为00，中国联通为01,中国电信为03；MSIN为移动客户识别码，采用等长11位数字构成。唯一地识别国内GSM.移动通信网中移动客户。所以要区分是移动还是联通，只需取得SIM卡中的MNC字段即可。需要权限 12&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; Java代码实现：第一种方法:获取手机的IMSI码,并判断是中国移动\中国联通\中国电信 123456789TelephonyManager telManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE); String imsi = telManager.getSubscriberId(); if(imsi!=null)&#123;//因为移动网络编号46000下的IMSI已经用完,所以虚拟了一个46002编号，134/159号段使用了此编号 if(imsi.startsWith(&quot;46000&quot;) || imsi.startsWith(&quot;46002&quot;))&#123; //中国移动 &#125;else if(imsi.startsWith(&quot;46001&quot;))&#123; //中国联通 &#125;else if(imsi.startsWith(&quot;46003&quot;))&#123; //中国电信 &#125;&#125; 第二种方法 12345678TelephonyManager telManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE); String operator = telManager.getSimOperator(); if(operator!=null)&#123; if(operator.equals(&quot;46000&quot;) || operator.equals(&quot;46002&quot;))&#123; //中国移动 &#125;else if(operator.equals(&quot;46001&quot;))&#123;//中国联通 &#125;else if(operator.equals(&quot;46003&quot;))&#123;//中国电信 &#125;&#125; 4.2 从SIM卡中获取联系人信息Android系统内部通过Contentprovider对外共享Sim卡存放的联系人等信息，你可以通过操作Contentprovider来实现Sim卡信息的添删改查操作。 需要权限： 1&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; Java代码实现： 12345Uri uri = Uri.parse(&quot;content://icc/adn&quot;); Cursor c = getContentResolver().query(uri, null, null, null, null); while (c.moveToNext()) System.out.println(c.getString(c.getColumnIndex(&quot;name&quot;)) + &quot;: &quot; + c.getString(c.getColumnIndex(&quot;number&quot;))); 4.3 删除呼叫记录需要权限 12&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot; /&gt; 负责存放呼叫记录的内容提供者源码在ContactsProvider项目下： 源码路径：com\android\providers\contacts\CallLogProvider.java 使用到的数据库在：/data/data/com.android.providers.contacts/databases/contacts2.db 表名:calls 呼叫记录有三种类型 来电：CallLog.Calls.INCOMING_TYPE （常量值：1） 外拔：CallLog.Calls.OUTGOING_TYPE（常量值：2） 未接：CallLog.Calls.MISSED_TYPE（常量值：3） 删除指定号码的来电或未接呼叫记录：Java代码实现： 123456789101112131415161718192021222324IncomingCallLogContentObserver observer = new IncomingCallLogContentObserver(new Handler());observer.setNumber(&quot;5554&quot;);getContentResolver().registerContentObserver(CallLog.Calls.CONTENT_URI, true, observer);private class IncomingCallLogContentObserver extends ContentObserver &#123; private String number; public IncomingCallLogContentObserver(Handler handler)&#123; super(handler); &#125; public void setNumber(String number)&#123; this.number = number; &#125; public void onChange(boolean paramBoolean)&#123; ContentResolver contentResolver = getContentResolver(); if(number!=null)&#123; Uri localUri = CallLog.Calls.CONTENT_URI; Cursor cursor = contentResolver.query(localUri, new String[]&#123;&quot;_id&quot;&#125;, &quot;number=? AND (type=1 OR type=3)&quot;, new String[]&#123;number&#125;, &quot;_id desc limit 1&quot;); if(cursor.moveToFirst())&#123; contentResolver.delete(localUri, &quot;_id=?&quot;, new String[]&#123;cursor.getString(0)&#125;); &#125; cursor.close(); &#125; contentResolver.unregisterContentObserver(this); &#125;｝ 本文链接：http://www.sguotao.top/Android基础-2012-08-14-android-basic-16.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础15 动画特效]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-08-13-android-basic-15.html</url>
    <content type="text"><![CDATA[1. Tween动画将某个组件以渐变的方式实现透明、缩放、移动、旋转等动画效果。 详见文档android-sdk-windows/docs/guide/topics/resources/animation-resource.html 2. Frame动画通过多个画面连续播放实现动画效果，开发步骤： 把准备好的图片放进项目res/ drawable下。 在项目的res目录下创建文件夹anim，然后在anim文件夹下面定义动画XML文件，文件名称 可以自定义。当然也可以采用编码方式定义动画效果（使用AnimationDrawable类）。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:oneshot=&quot;false&quot;&gt;&lt;item android:drawable=&quot;@drawable/girl_1&quot; android:duration=&quot;200&quot; /&gt;&lt;item android:drawable=&quot;@drawable/girl_2&quot; android:duration=&quot;200&quot; /&gt;&lt;item android:drawable=&quot;@drawable/girl_3&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; 为View控件绑定动画效果。调用代表动画的AnimationDrawable的start()方法开始动画。详见文档 android-sdk-windows/docs/guide/topics/resources/animation-resource.html 3. 使用动画切换Activity在startActivity()方法调用之后调用overridePendingTransition(int enterAnim, int exitAnim)方法enterAnim 进入的动画资源idexitAnim 退出的动画 资源id 4. 使用动画翻页XML配置 12345678910111213&lt;ViewFlipper android:id=&quot;@+id/viewFlipper&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/bb2&quot;/&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/bb3&quot;/&gt;&lt;/ViewFlipper&gt; Java代码 123456789101112131415161718192021public boolean onTouchEvent(MotionEvent event) &#123; ViewFlipper viewFlipper = (ViewFlipper) findViewById(R.id.viewFlipper); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: start = event.getX(); break; case MotionEvent.ACTION_UP: float end = event.getX(); if (end &gt; start) &#123; viewFlipper.setInAnimation(this, R.anim.previous_enter); viewFlipper.setOutAnimation(this, R.anim.previous_exit); viewFlipper.showPrevious(); &#125; else if (end &lt; start) &#123; viewFlipper.setInAnimation(this, R.anim.next_enter); viewFlipper.setOutAnimation(this, R.anim.next_exit); viewFlipper.showNext(); &#125; break; &#125; return super.onTouchEvent(event);&#125; 5. 动画练习5.1 本例要实现对ImageView对象进行渐变尺寸缩放动画效果 在项目的res目录下创建文件夹anim，然后在anim文件夹下面定义动画XML文件,文件名称可以自定义，如：scale.xml，内容如下： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;scale android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:fromXScale=&quot;0.0&quot; android:fromYScale=&quot;0.0&quot; android:toXScale=&quot;5&quot; android:toYScale=&quot;5&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:fillAfter=&quot;false&quot; android:duration=&quot;5000&quot; /&gt; &lt;/set&gt; 动画的进度使用interpolator控制，android提供了几个Interpolator 子类，实现了不同的速度曲线，如LinearInterpolator实现了匀速效果、Accelerateinterpolator实现了加速效果、DecelerateInterpolator实现了减速效果等。还可以定义自己的Interpolator子类，实现抛物线、自由落体等物理效果。 fromXScale（浮点型） 属性为动画起始时X坐标上的缩放尺寸fromYScale（浮点型） 属性为动画起始时Y坐标上的缩放尺寸toXScale（浮点型） 属性为动画结束时X坐标上的缩放尺寸toYScale（浮点型） 属性为动画结束时Y坐标上的缩放尺寸 说明: 以上四种属性值0.0表示收缩到没有1.0表示正常无缩放值小于1.0表示收缩值大于1.0表示放大pivotX（浮点型） 属性为动画相对于物件的X坐标的开始位置pivotY（浮点型） 属性为动画相对于物件的Y坐标的开始位置 说明:以上两个属性值 从0%-100%中取值50%为物件的X或Y方向坐标上的中点位置duration（长整型）属性为动画持续时间 。说明: 时间以毫秒为单位fillAfter（布尔型）属性当设置为true，该动画转化在动画结束后被应用 在layout文件添加&lt;ImageView&gt;节点： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;&gt;&lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/icon&quot; android:id=&quot;@+id/imageView&quot; /&gt;&lt;/LinearLayout&gt; 说明：除了可以对&lt;ImageView&gt;实现动画效果，其实也可以对其他View实现动画效果，如：&lt;TextView&gt; 在Activity里对ImageView使用前面定义好的动画效果： 123456789101112public class AnimationActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ImageView imageView = (ImageView)this.findViewById(R.id.imageView); //加载动画XML文件,生成动画指令 Animation animation = AnimationUtils.loadAnimation(this, R.anim.scale); //开始执行动画 imageView.startAnimation(animation); &#125;&#125; 备注：上面采用的是xml文件定义动画效果，作为代替，也可以采用编码方式实现。下面采用编码方式实现上述例子同样的效果： 123456789101112public class AnimationActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ImageView imageView = (ImageView)this.findViewById(R.id.imageView); ScaleAnimation animation = new ScaleAnimation(0.0f, 5f, 0.0f, 5f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); animation.setDuration(5000); //设置持续时间5秒 imageView.startAnimation(animation); &#125;&#125; 5.2 其他动画效果定义例子 渐变透明度动画效果 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;alpha android:fromAlpha=&quot;0.1&quot; android:toAlpha=&quot;1.0&quot; android:duration=&quot;3000&quot;/&gt;&lt;/set&gt; 编码实现透明度动画效果： 1234567891011public class AnimationActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ImageView imageView = (ImageView)this.findViewById(R.id.imageView); AlphaAnimation animation = new AlphaAnimation(0.1, 1.0); animation.setDuration(5000); //设置持续时间5秒 imageView.startAnimation(animation); &#125;&#125; 画面位置移动动画效果 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;translateandroid:repeatCount=&quot;2&quot;android:fromXDelta=&quot;0&quot;android:fromYDelta=&quot;0&quot;android:toXDelta=&quot;120&quot;android:toYDelta=&quot;120&quot;android:duration=&quot;3000&quot;/&gt;&lt;!-- fromXDelta fromYDelta 为动画起始时 X和Y坐标上的位置toXDelta toYDelta为动画结束起始时 X和Y坐标上的位置 --&gt;&lt;/set&gt; 编码实现位置移动动画效果： 1234567891011public class AnimationActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ImageView imageView = (ImageView)this.findViewById(R.id.imageView); TranslateAnimation animation = new TranslateAnimation(0, 120, 0, 120); animation.setDuration(5000); //设置持续时间5秒 imageView.startAnimation(animation); &#125;&#125; 画面旋转动画效果 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;rotateandroid:interpolator=&quot;@android:anim/accelerate_interpolator&quot;android:repeatCount=&quot;2&quot;android:fromDegrees=&quot;0&quot;android:toDegrees=&quot;+360&quot;android:pivotX=&quot;50%&quot;android:pivotY=&quot;50%&quot;android:duration=&quot;3000&quot;/&gt;&lt;!-- repeatCount 重复次数fromDegrees为动画起始时物件的角度:当角度为负数——表示逆时针旋转当角度为正数——表示顺时针旋转(负数fromDegrees——toDegrees正数:顺时针旋转)(负数fromDegrees——toDegrees负数:逆时针旋转)(正数fromDegrees——toDegrees正数:顺时针旋转)(正数fromDegrees——toDegrees负数:逆时针旋转)toDegrees属性为动画结束时物件旋转的角度 可以大于360度pivotX,pivotY 为动画相对于物件的X、Y坐标的开始位置。说明：以上两个属性值 从0%-100%中取值,50%为物件的X或Y方向坐标上的中点位置 --&gt;&lt;/set&gt; 编码实现： 123RotateAnimation animation = new RotateAnimation(0, -90, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);animation.setDuration(500);imageView.startAnimation(animation); Frame动画例子a) 把准备好的图片放进项目res/ drawable下。图片有：girl_1.gif, girl_2.gif, girl_3.gifb) 在项目的res目录下创建文件夹anim，然后在anim文件夹下面定义动画XML文件，文件名称可以自定义,如：frame.xml。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/girl_1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/girl_2&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/girl_3&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; 上面的XML就定义了一个Frame动画，其包含3帧动画，3帧动画中分别应用了drawable中的3张图片：girl_1.gif, girl_2.gif, girl_3.gif，每帧动画持续200毫秒。android:oneshot属性如果为true，表示动画只播放一次停止在最后一帧上，如果设置为false表示动画循环播放。 c) 为View控件绑定动画效果，调用代表动画的AnimationDrawable的start()方法开始动画。 12345678910111213141516171819public class FrameActivity extends Activity &#123; private AnimationDrawable animationDrawable; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ImageView imageView = (ImageView)this.findViewById(R.id.imageView); imageView.setBackgroundResource(R.anim.frame); animationDrawable = (AnimationDrawable) imageView.getBackground(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;//按下 animationDrawable.start(); return true; &#125; return super.onTouchEvent(event); &#125;&#125; 有一点需要强调的是：启动Frame动画的代码animationDrawable.start();不能应用在OnCreate()方法中，因为在OnCreate()中 AnimationDrawable还没有完全的与ImageView绑定。在OnCreate()中启动动画，只能看到第一张图片。这里在触摸事件中实现的。 本文链接：http://www.sguotao.top/Android基础-2012-08-13-android-basic-15.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础14 样式与主题]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-08-12-android-basic-14.html</url>
    <content type="text"><![CDATA[1. 样式(style)android中的样式和CSS样式作用相似，都是用于为界面元素定义显示风格，它是一个包含一个或者多个view控件属性的集合。如：需要定义字体的颜色和大小。在CSS中是这样定义的： 123&lt;style&gt; .ncist&#123;COLOR:#0000CC;font-size:18px;&#125;&lt;/style&gt; 可以像这样使用上面的css样式：华北科技，在Android中可以这样定义样式：在res/values/styles.xml文件中添加以下内容 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;style name=“ncist”&gt; &lt;!-- 为样式定义一个全局唯一的名字--&gt; &lt;item name=“android:textSize”&gt;18px&lt;/item&gt; &lt;!-- name属性的值为使用了该样式的View控件的属性 --&gt; &lt;item name=&quot;android:textColor&quot;&gt;#0000CC&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 在layout文件中可以像下面这样使用上面的android样式： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; ....&gt; &lt;TextView style=&quot;@style/ncist&quot; ..... /&gt;&lt;/LinearLayout&gt; &lt;style&gt;元素中有一个parent属性。这个属性可以让当前样式继承一个父样式，并且具有父样式的值。当然，如果父样式的值不符合你的需求，你也可以对它进行修改，如下： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;style name=&quot;ncist&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;18px&lt;/item&gt; &lt;!-- name属性为样式要用在的View控件持有的属性 --&gt; &lt;item name=&quot;android:textColor&quot;&gt;#0000CC&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;subncist&quot; parent=&quot;@style/ncist&quot;&gt; &lt;item name=&quot;android:textColor&quot;&gt;#FF0000&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 继承样式有两种定义方式 继承样式，在&lt;style&gt;标签中配置属性parent 123&lt;style name=&quot;style2&quot; parent=&quot;@style/style1&quot;&gt; &lt;item name=&quot;android:textColor&quot;&gt;#FF0000&lt;/item&gt;&lt;/style&gt; 继承样式，在name中引用其他样式 123&lt;style name=&quot;style2.style3&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;30sp&lt;/item&gt;&lt;/style&gt; 使用样式在layout文件的标签中配置style属性 12&lt;Button style=&quot;@style/style2.style3&quot; android:text=&quot;这是一个按钮&quot;/&gt; 2. 主题(theme)android中主题也是用于为应用定义显示风格，它的定义和样式的定义相同，如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;&lt;style name=“ncistTheme&quot;&gt; &lt;item name=“android:windowNoTitle”&gt;true&lt;/item&gt; &lt;!– 没标题 &lt;item name=“android:windowFullscreen”&gt;?android:windowNoTitle&lt;/item&gt; &lt;!– 全屏显示 &lt;/style&gt;&lt;/resources&gt; 上面“?android:windowNoTitle”中的问号用于引用在当前主题中定义过的资源的值。下面代码显示在AndroidManifest.xml中如何为应用设置上面定义的主题： 1234&lt;application android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/ncistTheme&quot;&gt; ......&lt;/application&gt; 除了可以在AndroidManifest.xml中设置主题，同样也可以在代码中设置主题，如下：setTheme(R.style.ncistTheme); 3. 样式与主题的区别尽管在定义上，样式和主题基本相同，但是它们使用的地方不同。 样式用在单独的View，如：EditText、TextView等； 主题通过AndroidManifest.xml中的&lt;application&gt;和&lt;activity&gt;用在整个应用或者某个 Activity，主题对整个应用或某个Activity进行全局性影响。 如果一个应用使用了主题，同时应用下的view也使用了样式，那么当主题和样式属性发生冲突时，样式的优先级高于主题。 另外android系统也定义了一些主题，例如：&lt;activity android:theme=“@android:style/Theme.Dialog”&gt;，该主题可以让Activity看起来像一个对话框，还有透明主题：@android:style/Theme.Translucent 。如果需要查阅这些主题，可以在文档的referenceandroid–&gt;R.style 中查看。 注意：如果使用android内置的样式，IDE自动提示的“_”要替换成“.” 4. 国际化与屏幕适配4.1 国际化在values和drawable文件夹后加上语言以及地区名，程序中需要国际化的部分使用资源IDvalues-en-rUS ；values-zh-rCN；values-zh-rTW 匹配规则 在匹配资源时先会找语言、地区完全匹配的 如果没有地区匹配的，则查找语言匹配的如果没有语言匹配的则找默认values 4.2 屏幕适配在layout文件夹后加上分辨率，系统会根据屏幕尺寸自动选择，注意分辨率中的乘号是“x”不是“*”，并且大的数字在“x”之前，否则编译无法通过；如果没有匹配的分辨率会找默认layout文件夹。 本文链接：http://www.sguotao.top/Android基础-2012-08-12-android-basic-14.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础13 常用UI（下）]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-08-11-android-basic-13.html</url>
    <content type="text"><![CDATA[1.菜单(Menu)1.1 普通menu 重写Activity的onCreateOptionsMenu(Menu menu)方法，该方法用于创建选项菜单，在用户按下手机的“Menu”按钮时就会显示创建好的菜单，在onCreateOptionsMenu(Menu menu)方法内部可以调用Menu.add()方法实现菜单的添加。 重写Activity的onMenuItemSelected()方法，该方法用于处理菜单被选择事件 通过手机上提供的“MENU”按钮可以打开菜单，如果希望通过代码打开菜单，可以调用Activity的openOptionsMenu()方法。 1234567891011121314151617181920212223242526public class MenuActivity extends Activity &#123;private static final String TAG = &quot;MenuActivity&quot;;private static final int MENU_ADD = Menu.FIRST;private static final int MENU_UPDATE = Menu.FIRST + 1; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.menu); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; menu.add(Menu.NONE, MENU_ADD, Menu.NONE, &quot;添加&quot;); menu.add(Menu.NONE, MENU_UPDATE, Menu.NONE, &quot;更新&quot;); return super.onCreateOptionsMenu(menu); &#125; @Override public boolean onMenuItemSelected(int featureId, MenuItem item) &#123; switch (item.getItemId()) &#123; case MENU_ADD: Log.i(TAG, &quot;add was selected&quot;); return true; case MENU_UPDATE: Log.i(TAG, &quot;update was selected&quot;); return true; default: return super.onMenuItemSelected(featureId, item);&#125; &#125; &#125; 1.2 SubMenu 添加子菜单调用menu对象的addSubMenu(final CharSequence title)，该方法返回一个SubMenu对象 添加子菜单的菜单项调用SubMenu对象的add(CharSequence title) 方法 12345678public boolean onCreateOptionsMenu(Menu menu) &#123; menu.add(0, 1, 1, &quot;苹果&quot;); menu.add(0, 2, 2, &quot;香蕉&quot;); SubMenu subMenu = menu.addSubMenu(1, 100, 100, &quot;桃子&quot;); subMenu.add(2, 101, 101, &quot;大桃子&quot;); subMenu.add(2, 102, 102, &quot;小桃子&quot;); return true; &#125; 1.3 Context Menu类似于电脑上的右键，长按某个View之后弹出来的菜单。首先在main.xml里定义若干个按钮。首先要注册一下，在onCreate方法里，如下代码： 123456789@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); b1 = (Button) findViewById(R.id.b1); b2 = (Button) findViewById(R.id.b2); registerForContextMenu(b1); registerForContextMenu(b2); &#125; 然后覆盖onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)。 123456789101112131415Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) &#123; if(v==b1)&#123; menu.setHeaderTitle(&quot;这是1&quot;); menu.add(200, 200, 200, &quot;Context Menu 1&quot;); menu.add(200, 201, 201, &quot;Context Menu 2&quot;); &#125; else if(v==b2)&#123; menu.setHeaderTitle(&quot;这是2&quot;); menu.add(300, 300, 300, &quot;C 1&quot;); menu.add(300, 301, 301, &quot;C 2&quot;); &#125; super.onCreateContextMenu(menu, v, menuInfo); &#125; 1.4 动态Menu动态菜单就是根据不同的界面有不同的菜单。下面的代码实现这样的功能：当主界面的某个TextView的值是“M“和“N”时，弹出不同的菜单。 12345678910111213141516@Overridepublic boolean onPrepareOptionsMenu(Menu menu) &#123; String currentText = tv1.getText().toString(); if(&quot;M&quot;.equals(currentText))&#123; menu.clear();//先清掉菜单 MenuItem item = menu.add(0, 400, 401, &quot;to N&quot;);//可以通过点击这个菜单项来改变tv1的值这样(变成N)就可以测试了 item.setIcon(android.R.drawable.alert_dark_frame);//android自带的图标 &#125; if(&quot;N&quot;.equals(currentText))&#123; menu.clear();//先清掉菜单 MenuItem item = menu.add(0, 401, 402, &quot;to M&quot;);//可以通过点击这个菜单项来改变tv1的值这样(变成M)就可以测试了 item.setIcon(android.R.drawable.alert_light_frame); &#125; menu.add(0, 402, 403, &quot;Now is &quot; + currentText);//现在共有两个菜单子项 return super.onPrepareOptionsMenu(menu); &#125; 1.5 用xml文件方式创建Menu之前都是用代码的方法创建Menu,用xml配置文件也可以相当方便地制作菜单。要res/目录下建一个文件夹，名为menu，下面建一个xml文件，名为menu_xml_file.xml，代码如下： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;group android:id=&quot;@+id/grout_main&quot;&gt; &lt;item android:id=&quot;@+id/menu_1&quot; android:title=&quot;This 1&quot;/&gt; &lt;item android:id=&quot;@+id/menu_2&quot; android:title=&quot;This 2&quot; /&gt; &lt;/group&gt;&lt;/menu&gt; 在Activity中覆盖onCreateOptionsMenu(Menu menu)方法，代码如下： 123456@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.menu_xml_file, menu); return true; &#125; 其他的都和在Activity中制作菜单一样。 2. 手势识别(GestureOverlayView) 建立手势库使用SDK自带例子GestureBuilder建立手势库（位置：android-sdk-windows\samples\android-8\GestureBuilder）。使用GestureBuilder之前，你需要恢复其到开发环境，然后进行编绎并部署到手机上。此时，就可以使用GestureBuilder建立手势库，生成的手势库文件在SCDard上，默认文件名称为：gestures 在应用中加载手势库文件，然后开发手势识别代码。把手势库文件gestures文件拷贝到项目的res/raw目录下。然后在布局文件中添加用于手势绘制的View： 12345&lt;android.gesture.GestureOverlayView android:id=&quot;@+id/gov&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:gestureStrokeType=&quot;multiple&quot;/&gt; 为View添加手势监听事件：gestureOverlayView.addOnGesturePerformedListener(); 得到手势库：mLibrary = GestureLibraries.fromRawResource(this, R.raw.gestures); 加载手势库：mLibrary.load(); 大多数情况下，手势都是通过一笔完成。然而有一些特别的需求就需要通过多个笔画来实现，这时可以使用gestureStrokeType属性进行设置：android:gestureStrokeType=”multiple” 代码实现： 123456789101112131415161718192021222324252627282930313233public class MainActivity extends Activity &#123; private GestureOverlayView gestureOverlayView; private GestureLibrary mLibrary; private boolean state; private EditText addressText; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); addressText = (EditText)this.findViewById(R.id.address); gestureOverlayView = (GestureOverlayView)this.findViewById(R.id.gestures); //当用户完成一次Gesture绘制后，系统将自动调用Listener对象的onGesturePerformed()方法 gestureOverlayView.addOnGesturePerformedListener(new GestureListener()); mLibrary = GestureLibraries.fromRawResource(this, R.raw.gestures); state = mLibrary.load();//加载手势库 &#125; private final class GestureListener implements GestureOverlayView.OnGesturePerformedListener&#123; @Override public void onGesturePerformed(GestureOverlayView overlay, Gesture gesture) &#123; if(state)&#123; List&lt;Prediction&gt; predictions = mLibrary.recognize(gesture); //从手势库中查询匹配的内容，匹配的结果可能包括多个相似的结果，匹配度高的结果放在最前面 if(!predictions.isEmpty())&#123; Prediction prediction = predictions.get(0); //prediction的score属性代表了与手势的相似程度name代表手势对应的名称 if(prediction.score &gt; 1)&#123; addressText.setText(prediction.name); &#125; &#125; &#125; &#125; &#125;&#125; 3. 编码实现软件界面Android除了可以使用xml实现软件界面，还可以通过编码方式实现软件的界面，而且在某种情况下只能采用编码方式实现软件的界面，例如：软件运行时需要根据运算结果决定显示某些内容。如果不是必须，建议使用xml，因为这样可以使应用遵守mvc设计模式，具有良好的软件分层结构。下面代码实现了如HelloWorld项目一样的软件界面： 123456789101112131415public class MainActivity extends Activity &#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); LinearLayout linearLayout = new LinearLayout(this); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams( ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT); TextView textView = new TextView(this); textView.setText(R.string.hello); textView.setId(34); LinearLayout.LayoutParams textParams = new LinearLayout.LayoutParams( ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); linearLayout.addView(textView, textParams); setContentView(linearLayout, layoutParams); &#125;&#125; 4. 网页视图(WebView)因为android软件开发分工目前还没有细化，程序员往往需要负责软件界面的开发，虽然软件的界面图片已经由美工设计好了，但如果使用layout技术把软件做成如图片所示的界面确实很困难，而且也比较耗时。Android通过WebView实现了JS代码与Java代码互相通信的功能，使的android软件的界面开发也可以采用HTML网页技术，这样，广大网页美工可以参与进android软件的界面开发工作，从而让程序员从中解脱出来。 XML配置 1234&lt;WebViewandroid:id=&quot;@+id/webView&quot;android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; /&gt; 在项目的assets目录放入index.html文件 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show(jsondata)&#123; var jsonobjs = eval(jsondata); var table = document.getElementById(&quot;personTable&quot;); for(var y=0; y&lt;jsonobjs.length; y++)&#123; var tr = table.insertRow(table.rows.length); var td1 = tr.insertCell(0); var td2 = tr.insertCell(1); td2.align = &quot;center&quot;; var td3 = tr.insertCell(2); td3.align = &quot;center&quot;; td1.innerHTML = jsonobjs[y].name; td2.innerHTML = jsonobjs[y].amount; td3.innerHTML = &quot;&lt;a href=&apos;javascript:contact.call(\&quot;&quot;+ jsonobjs[y].phone+ &quot;\&quot;)&apos;&gt;&quot;+ jsonobjs[y].phone+ &quot;&lt;/a&gt;&quot;; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;javascript:contact.showcontacts()&quot;&gt; &lt;table border=&quot;0&quot; width=&quot;100%&quot; id=&quot;personTable&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td width=&quot;30%&quot;&gt;姓名&lt;/td&gt; &lt;td width=&quot;30%&quot; align=&quot;center&quot;&gt;存款&lt;/td&gt; &lt;td align=&quot;center&quot;&gt;电话&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HtmlActivity extends Activity &#123;private WebView webView;private Handler handler = new Handler(); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); webView = (WebView)this.findViewById(R.id.webView); webView.getSettings().setJavaScriptEnabled(true); webView.getSettings().setSaveFormData(false); webView.getSettings().setSavePassword(false); webView.getSettings().setSupportZoom(false); webView.addJavascriptInterface(new NcistJavaScript(), “ncist”); //addJavascriptInterface方法中要绑定的Java对象 webView.setWebChromeClient(new NcistWebClient()); webView.loadUrl(&quot;file:///android_asset/index.html&quot;); &#125; private final class NcistJavaScript&#123; public void personlist()&#123; webview.loadUrl(&quot;javascript:contactlist(&apos;&quot;+ getPersonJson() + &quot;&apos;)&quot;); &#125; public void call(final String phone)&#123; startActivity(new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:&quot;+ phone))); &#125; public static String getPersonJson() &#123;//生成json字符串 try &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;id&quot;, 56); jsonObject.put(&quot;name&quot;, &quot;老张&quot;); jsonObject.put(&quot;phone&quot;, &quot;5556&quot;); JSONObject jsonObject2 = new JSONObject(); jsonObject2.put(&quot;id&quot;, 89); jsonObject2.put(&quot;name&quot;, &quot;老方&quot;); jsonObject2.put(&quot;phone&quot;, &quot;5558&quot;); JSONArray jsonArray = new JSONArray(); jsonArray.put(jsonObject); jsonArray.put(jsonObject2); return jsonArray.toString(); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; return &quot;&quot;; &#125; &#125; private final class NcistWebClient extends WebChromeClient&#123; @Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; new AlertDialog.Builder(HtmlActivity.this) .setTitle(&quot;提示信息&quot;) .setMessage(message) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener()&#123; public void onClick(DialogInterface dialoginterface, int i)&#123;&#125; &#125;).show(); return true; &#125; &#125;&#125; 本文链接：http://www.sguotao.top/Android基础-2012-08-11-android-basic-13.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础12 常用UI（中）]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-08-10-android-basic-12.html</url>
    <content type="text"><![CDATA[1. 拖动条(SeekBar) SeekBar.getProgress()获取拖动条当前值 调用setOnSeekBarChangeListener()方法，处理拖动条值变化事件，把SeekBar.OnSeekBarChangeListener实例作为参数传入。 代码处理: 123456789101112131415161718192021222324252627282930public class SeekBarActivity extends Activity &#123; private SeekBar seekBar; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.seekbar); seekBar = (SeekBar) findViewById(R.id.seekBar); seekBar.setMax(100);//设置最大刻度 seekBar.setProgress(30);//设置当前刻度 seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromTouch) &#123; Log.v(&quot;onProgressChanged()&quot;, String.valueOf(progress) + &quot;, &quot; + String.valueOf(fromTouch)); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123;//开始拖动 Log.v(&quot;onStartTrackingTouch()&quot;, String.valueOf(seekBar.getProgress())); &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123;//结束拖动 Log.v(&quot;onStopTrackingTouch()&quot;, String.valueOf(seekBar.getProgress())); &#125; &#125;); Button button = (Button)this.findViewById(R.id.seekBarButton); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(SeekBarActivity.this, String.valueOf(seekBar.getProgress()), 1).show(); &#125;&#125;); &#125;&#125; 2. 进度条(ProgressBar)在布局xml文件中添加进度条代码： 12345&lt;ProgressBar android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;20px&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:id=&quot;@+id/downloadbar&quot;/&gt; 在代码中操作进度条： 12ProgressBar.setMax(100);//设置最大刻度ProgressBar.setProgress(0);//设置进度条的当前刻度，如果进度条的最大刻度为100，当前刻度为50，进度条将进行到一半。 3. 输入内容自动完成文本框(AutoCompleteTextView)AutoCompleteTextView和EditText组件类似，都可以输入文本。但AutoCompleteTextView组件可以和一个字符串数组或List对象绑定，当用户输入两个及以上字符时，系统将在AutoCompleteTextView组件下方列出字符串数组中所有以输入字符开头的字符串，这一点和www.google.com的搜索框非常相似，当输入某一个要查找的字符串时，google搜索框就会列出以这个字符串开头的最热门的搜索字符串列表。 12345&lt;AutoCompleteTextView android:layout_width=&quot;fill_parent“ android:layout_height=&quot;wrap_content“ &lt;!– completionThreshold 指定至少输入几个字符后才会出现自动提示功能 android:completionThreshold=&quot;1“ android:id=&quot;@+id/name&quot; /&gt; 代码处理： 12345public void onCreate(Bundle savedInstanceState) &#123; …… String[] names = &#123;&quot;老张&quot;, &quot;老方&quot;, &quot;老毕&quot;, &quot;李明&quot; , &quot;李丽&quot;, &quot;陈江&quot;, &quot;abc&quot;, &quot;acc&quot;&#125;; AutoCompleteTextView nameText = (AutoCompleteTextView)this.findViewById(R.id.name);ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_dropdown_item_1line, names); nameText.setAdapter(adapter);&#125; 4. 多次输入内容自动完成(MultiAutoCompleteTextView)除了AutoCompleteTextView控件外，我们还可以使用MultiAutoCompleteTextView控件来完成连续输入的功能。也就是说，当输入完一个字符串后，在该字符串后面输入一个逗号（,），在逗号前后可以有任意多个空格，然后再输入一个字符串，仍然会显示自动提示列表。使用MultiAutoCompleteTextView时，需要为它的setTokenizer()方法指定MultiAutoCompleteTextView.CommaTokenizer类对象实例，该对象表示采用逗号作为输入多个字符串的分隔符。 12345&lt; MultiAutoCompleteTextView android:layout_width=&quot;fill_parent“ android:layout_height=&quot;wrap_content“ &lt;!– completionThreshold 指定至少输入几个字符后才会出现自动提示功能 android:completionThreshold=&quot;1“ android:id=&quot;@+id/name&quot; /&gt; 代码处理 1234567public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); String[] names = &#123;&quot;老张&quot;, &quot;老方&quot;, &quot;老毕&quot;, &quot;李明&quot; , &quot;李丽&quot;, &quot;陈江&quot;, &quot;abc&quot;, &quot;acc&quot;&#125;; MultiAutoCompleteTextView nameText = (MultiAutoCompleteTextView)this.findViewById(R.id.name);ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_dropdown_item_1line,names); nameText.setAdapter(adapter); nameText.setTokenizer(new MultiAutoCompleteTextView.CommaTokenizer());&#125; 5. 列表视图(ListView)列表的显示需要三个元素： ListVeiw 用来展示列表的View。 适配器 用来把数据映射到ListView上的中介。 数据具体的将被映射的字符串，图片，或者基本组件。根据列表的适配器类型，列表分为三种，ArrayAdapter，SimpleAdapter和SimpleCursorAdapter。其中以ArrayAdapter最为简单，只能展示一行字。SimpleAdapter有最好的扩充性，可以自定义出各种效果。SimpleCursorAdapter可以认为是SimpleAdapter对数据库的简单结合，可以方面的把数据库的内容以列表的形式展示出来。 5.1 ArrayAdapter类型ListView 123456789101112131415161718public class MyListView extends Activity &#123; private ListView listView; @Override public void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); listView = new ListView(this); listView.setAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1,getData())); setContentView(listView); &#125; private List&lt;String&gt; getData()&#123; List&lt;String&gt; data = new ArrayList&lt;String&gt;(); data.add(&quot;测试数据1&quot;); data.add(&quot;测试数据2&quot;); data.add(&quot;测试数据3&quot;); data.add(&quot;测试数据4&quot;); return data; &#125;&#125; 上面代码使用了ArrayAdapter(Context context, int textViewResourceId, List objects)来装配数据，要装配这些数据就需要一个连接ListView视图对象和数组数据的适配器来两者的适配工作，ArrayAdapter的构造需要三个参数，依次为this,布局文件（注意这里的布局文件描述的是列表的每一行的布局，android.R.layout.simple_list_item_1是系统定义好的布局文件只显示一行文字，数据源(一个List集合)。同时用setAdapter()完成适配的最后工作。 5.2 SimpleCursorAdapter类型ListView sdk的解释是这样的：An easy adapter to map columns from a cursor to TextViews or ImageViews defined in an XML file. You can specify which columns you want, which views you want to display the columns, and the XML file that defines the appearance of these views。 简单的说就是方便把从游标得到的数据进行列表显示，并可以把指定的列映射到对应的TextView中。下面的程序是从电话簿中把联系人显示到类表中。先在通讯录中添加一个联系人作为数据库的数据。然后获得一个指向数据库的Cursor并且定义一个布局文件（当然也可以使用系统自带的）。 12345678910111213141516public class MyListView2 extends Activity &#123; private ListView listView; @Override public void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); listView = new ListView(this); Cursor cursor = getContentResolver().query(People.CONTENT_URI, null, null, null, null); startManagingCursor(cursor); ListAdapter listAdapter = new SimpleCursorAdapter(this, android.R.layout.simple_expandable_list_item_1, cursor, new String[]&#123;People.NAME&#125;, new int[]&#123;android.R.id.text1&#125;); listView.setAdapter(listAdapter); setContentView(listView); &#125;&#125; Cursor cursor = getContentResolver().query(People.CONTENT_URI, null, null, null, null);先获得一个指向系统通讯录数据库的Cursor对象获得数据来源。startManagingCursor(cursor);我们将获得的Cursor对象交由Activity管理，这样Cursor的生命周期和Activity便能够自动同步，省去自己手动管理Cursor。 SimpleCursorAdapter 构造函数前面3个参数和ArrayAdapter是一样的，最后两个参数：一个包含数据库的列的String型数组，一个包含布局文件中对应组件id的int型数组。其作用是自动的将String型数组所表示的每一列数据映射到布局文件对应id的组件上。上面的代码，将NAME列的数据一次映射到布局文件的id为text1的组件上。注意：需要在AndroidManifest.xml中如权限： 1&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt; 5.3 SimpleAdapter类型ListViewSimpleAdapter的扩展性最好，可以定义各种各样的布局出来，可以放上ImageView（图片），还可以放上Button（按钮），CheckBox（复选框）等等。下面的代码都直接继承了ListActivity，ListActivity和普通的Activity没有太大的差别，不同就是对显示ListView做了许多优化，方面显示而已。下面的程序是实现一个带有图片的类表。 首先需要定义好一个用来显示每一个列内容的xml。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5px&quot;/&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;#FFFFFFFF&quot; android:textSize=&quot;22px&quot; /&gt; &lt;TextView android:id=&quot;@+id/info&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;#FFFFFFFF&quot; android:textSize=&quot;13px&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 实现代码： 123456789101112131415161718192021222324252627282930313233public class MyListView3 extends ListActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); SimpleAdapter adapter = new SimpleAdapter(this,getData(),R.layout.vlist, new String[]&#123;&quot;title&quot;,&quot;info&quot;,&quot;img&quot;&#125;, new int[]&#123;R.id.title,R.id.info,R.id.img&#125;); setListAdapter(adapter); &#125; private List&lt;Map&lt;String, Object&gt;&gt; getData() &#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;G1&quot;); map.put(&quot;info&quot;, &quot;google 1&quot;); map.put(&quot;img&quot;, R.drawable.i1); list.add(map); map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;G2&quot;); map.put(&quot;info&quot;, &quot;google 2&quot;); map.put(&quot;img&quot;, R.drawable.i2); list.add(map); map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;G3&quot;); map.put(&quot;info&quot;, &quot;google 3&quot;); map.put(&quot;img&quot;, R.drawable.i3); list.add(map); return list; &#125; &#125; 使用simpleAdapter的数据用一般都是HashMap构成的List，list的每一节对应ListView的每一行。HashMap的每个键值数据映射到布局文件中对应id的组件上。因为系统没有对应的布局文件可用，我们可以自己定义一个布局vlist.xml。下面做适配，new一个SimpleAdapter参数依次是：this，布局文件（vlist.xml），HashMap的 title 和 info，img。布局文件的组件id，title，info，img。布局文件的各组件分别映射到HashMap的各元素上，完成适配。 5.4 有按钮的ListView但是有时候，列表不光会用来做显示用，同样可以在在上面添加按钮。添加按钮首先要写一个有按钮的xml文件，然后自然会想到用上面的方法定义一个适配器，然后将数据映射到布局文件上。但是事实并非这样，因为按钮是无法映射的，即使你成功的用布局文件显示出了按钮也无法添加按钮的响应，这时就要研究一下ListView是如何现实的了，而且必须要重写一个类继承BaseAdapter.下面的示例将显示一个按钮和一个图片,两行字如果单击按钮将删除此按钮的所在行。并告诉你ListView究竟是如何工作的。 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/img&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5px&quot;/&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;#FFFFFFFF&quot; android:textSize=&quot;22px&quot; /&gt; &lt;TextView android:id=&quot;@+id/info&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;#FFFFFFFF&quot; android:textSize=&quot;13px&quot; /&gt; &lt;/LinearLayout&gt; &lt;Button android:id=&quot;@+id/view_btn&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/s_view_btn&quot; android:layout_gravity=&quot;bottom|right&quot; /&gt;&lt;/LinearLayout&gt; 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class MyListView4 extends ListActivity &#123; private List&lt;Map&lt;String, Object&gt;&gt; mData; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mData = getData(); MyAdapter adapter = new MyAdapter(this); setListAdapter(adapter); &#125; private List&lt;Map&lt;String, Object&gt;&gt; getData() &#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;G1&quot;); map.put(&quot;info&quot;, &quot;google 1&quot;); map.put(&quot;img&quot;, R.drawable.i1); list.add(map); map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;G2&quot;); map.put(&quot;info&quot;, &quot;google 2&quot;); map.put(&quot;img&quot;, R.drawable.i2); list.add(map); map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;, &quot;G3&quot;); map.put(&quot;info&quot;, &quot;google 3&quot;); map.put(&quot;img&quot;, R.drawable.i3); list.add(map); return list; &#125; // ListView 中某项被选中后的逻辑 @Override protected void onListItemClick(ListView l, View v, int position, long id) &#123; Log.v(&quot;MyListView4-click&quot;, (String)mData.get(position).get(&quot;title&quot;)); &#125; /** * listview中点击按键弹出对话框 */ public void showInfo()&#123; new AlertDialog.Builder(this) .setTitle(&quot;我的listview&quot;) .setMessage(&quot;介绍...&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;) .show(); &#125; public final class ViewHolder&#123; public ImageView img; public TextView title; public TextView info; public Button viewBtn; &#125; public class MyAdapter extends BaseAdapter&#123; private LayoutInflater mInflater; public MyAdapter(Context context)&#123; this.mInflater = LayoutInflater.from(context); &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int arg0) &#123; return null; &#125; @Override public long getItemId(int arg0) &#123; return 0; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; holder=new ViewHolder(); convertView = mInflater.inflate(R.layout.vlist2, null); holder.img = (ImageView)convertView.findViewById(R.id.img); holder.title = (TextView)convertView.findViewById(R.id.title); holder.info = (TextView)convertView.findViewById(R.id.info); holder.viewBtn = (Button)convertView.findViewById(R.id.view_btn); convertView.setTag(holder); &#125;else &#123; holder = (ViewHolder)convertView.getTag(); &#125; holder.img.setBackgroundResource((Integer)mData.get(position).get(&quot;img&quot;)); holder.title.setText((String)mData.get(position).get(&quot;title&quot;)); holder.info.setText((String)mData.get(position).get(&quot;info&quot;)); holder.viewBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; showInfo(); &#125; &#125;); return convertView; &#125; &#125;&#125; 下面将对上述代码，做详细的解释，listView在开始绘制的时候，系统首先调用getCount（）函数，根据他的返回值得到listView的长度（这也是为什么在开始的第一张图特别的标出列表长度），然后根据这个长度，调用getView（）逐一绘制每一行。如果你的getCount（）返回值是0的话，列表将不显示同样return 1，就只显示一行。 系统显示列表时，首先实例化一个适配器（这里将实例化自定义的适配器）。当手动完成适配时，必须手动映射数据，这需要重写getView（）方法。系统在绘制列表的每一行的时候将调用此方法。getView()有三个参数，position表示将显示的是第几行，covertView是从布局文件中inflate来的布局。我们用LayoutInflater的方法将定义好的vlist2.xml文件提取成View实例用来显示。然后将xml文件中的各个组件实例化（简单的findViewById()方法）。这样便可以将数据对应到各个组件上了。但是按钮为了响应点击事件，需要为它添加点击监听器，这样就能捕获点击事件。至此一个自定义的listView就完成了，现在让我们回过头从新审视这个过程。系统要绘制ListView了，他首先获得要绘制的这个列表的长度，然后开始绘制第一行，怎么绘制呢？调用getView()函数。在这个函数里面首先获得一个View（实际上是一个ViewGroup），然后再实例并设置各个组件，显示之。好了，绘制完这一行了。那 再绘制下一行，直到绘完为止。在实际的运行过程中会发现listView的每一行没有焦点了，这是因为Button抢夺了listView的焦点，只要布局文件中将Button设置为没有焦点就OK了。 本文链接：http://www.sguotao.top/Android基础-2012-08-10-android-basic-12.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础11 常用UI（上）]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-07-21-android-basic-11.html</url>
    <content type="text"><![CDATA[1. 单选框(RadioButton)要完成单选框显示，需要使用到RadioGroup和RadioButton(单选框)。 RadioGroup用于对单选框进行分组，相同组内的单选框只有一个单选框能被选中。 RadioGroup.check(R.id.dotNet);将id名为dotNet的单选框设置成选中状态。 (RadioButton) findViewById(radioGroup.getCheckedRadioButtonId());//获取被选中的单选框。 RadioButton.getText();//获取单选框的值 调用setOnCheckedChangeListener()方法，处理单选框被选择事件，把RadioGroup.OnCheckedChangeListener实例作为参数传入界面设计代码： 1234567891011121314151617&lt;RadioGroup android:id=&quot;@+id/radioGroup&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt;&lt;RadioButton android:id=&quot;@+id/java&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;java&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/dotNet&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;dotNet&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/php&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;PHP&quot; /&gt;&lt;/RadioGroup&gt; 处理程序： 12345678910public void onCreate(Bundle savedInstanceState) &#123; ...... RadioGroup radioGroup = (RadioGroup) findViewById(R.id.radioGroup); radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123; public void onCheckedChanged(RadioGroup group, int checkedId) &#123; RadioButton radioButton = (RadioButton) findViewById(checkedId); Log.i(TAG, String.valueOf(radioButton.getText())); &#125; &#125;);&#125; 2. 多选框(CheckBox) 每个多选框都是独立的，可以通过迭代所有多选框，然后根据其状态是否被选中再获取其值。 CheckBox.setChecked(true);//设置成选中状态。 CheckBox.getText();//获取多选框的值 调用setOnCheckedChangeListener()方法，处理多选框被选择事件，把CompoundButton.OnCheckedChangeListener实例作为参数传入。 代码处理: 12345678910111213141516171819202122232425262728293031public class CheckBoxActivity extends Activity &#123;private List&lt;CheckBox&gt; checkboxs = new ArrayList&lt;CheckBox&gt;(); @Overridepublic void onCreate(Bundle savedInstanceState) &#123;…… checkboxs.add((CheckBox) findViewById(R.id.checkboxdotNet)); checkboxs.add((CheckBox) findViewById(R.id.checkboxjava)); checkboxs.add((CheckBox) findViewById(R.id.checkboxphp)); checkboxs.get(1).setChecked(true);//设置成选中状态 for(CheckBox box : checkboxs)&#123; box.setOnCheckedChangeListener(listener); &#125; Button button = (Button)findViewById(R.id.checkboxButton); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; List&lt;String&gt; values = new ArrayList&lt;String&gt;(); for(CheckBox box : checkboxs)&#123; if(box.isChecked())&#123; values.add(box.getText().toString()); &#125; &#125; Toast.makeText(CheckBoxActivity.this, values.toString(), 1).show(); &#125;&#125;); &#125; CompoundButton.OnCheckedChangeListener listener = new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; CheckBox checkBox = (CheckBox) buttonView; Log.i(TAG, &quot;isChecked=&quot;+ isChecked +&quot;,value=&quot;+ checkBox.getText());//输出单选框的值 &#125; &#125;;&#125; 3. 下拉列表框(Spinner) Spinner.getItemAtPosition(Spinner.getSelectedItemPosition());获取下拉列表框的值 调用setOnItemSelectedListener()方法，处理下拉列表框被选择事件，把AdapterView.OnItemSelectedListener实例作为参数传入。 代码处理: 12345678910111213141516171819202122public class SpinnerActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; …… //第二个参数为下拉列表框每一项的界面样式，该界面样式由Android系统提供，当然您也可以自定义 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); adapter.add(&quot;java&quot;); adapter.add(&quot;dotNet&quot;); adapter.add(&quot;php&quot;); Spinner spinner = (Spinner) findViewById(R.id.spinner); spinner.setAdapter(adapter); spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int position, long id) &#123; Spinner spinner = (Spinner)adapterView; String itemContent = (String)adapterView.getItemAtPosition(position); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; view) &#123; Log.i(TAG, view.getClass().getName()); &#125; &#125;); &#125;&#125; 3.1 下拉列表框—采用javabean作为Adapter元素很多时候显示在下拉列表框的值并不是希望得到的值，如果要做一个联系人下拉列表框，列表框列出的是联系人的姓名，因为姓名有可能相同，所以我们希望得到的值应该为该联系人的id，要实现这种需求我们需要自定义Adapter，当然自定义Adapter需要我们编写一小段代码，如果我们不想编写Adapter，又能实现我们的需求，那是最好不过的了。通过观察ArrayAdapter中getView(int position, View convertView, ViewGroup parent)的内部代码发现，如果为ArrayAdapter指定的实际泛型参数类型没有实现CharSequence（字符串）接口，将会调用该类型对象的toString()向下拉列表框输出显示值。利用这个特点我们可以重写javaBean的toString()向下拉列表框提供显示值。 代码处理: 12345678910111213141516171819202122232425262728293031323334353637383940public class SpinnerActivity extends Activity &#123; private static final String TAG = &quot;SpinnerActivity&quot;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.spinner); ArrayAdapter&lt;Person&gt; adapter = new ArrayAdapter&lt;Person&gt;(this, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); adapter.add(new Person(12, &quot;李明&quot;)); adapter.add(new Person(100, &quot;李明&quot;)); adapter.add(new Person(62, &quot;张天&quot;)); Spinner spinner = (Spinner) findViewById(R.id.spinner); spinner.setAdapter(adapter); spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int position, long id) &#123; Spinner spinner = (Spinner)adapterView; Person person = (Person)adapterView.getItemAtPosition(position); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; view) &#123; Log.i(TAG, view.getClass().getName()); &#125; &#125;); &#125;&#125;Person.java:public class Person &#123; private Integer id; private String name; public Person(Integer id, String name) &#123; this.id = id; this.name = name; &#125; …… @Override public String toString() &#123; return name; &#125;&#125; 3.2 下拉列表框–自定义选项界面样式 Spinner.getItemAtPosition(Spinner.getSelectedItemPosition());获取下拉列表框的值 调用setOnItemSelectedListener()方法，处理下拉列表框被选择事件，把AdapterView.OnItemSelectedListener实例作为参数传入。 下拉列表框每一项的界面样式:stylespinner.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/contentTextView&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#F4FDFF&quot; /&gt; 代码处理: 123456789101112131415161718192021222324public class SpinnerActivity extends Activity &#123; private static final String TAG = &quot;SpinnerActivity&quot;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.spinner); //第二个参数为layout文件在R文件的id,第三个参数为TextView在layout文件的id ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.stylespinner,R.id.contentTextView); adapter.add(&quot;java&quot;); adapter.add(&quot;dotNet&quot;); adapter.add(&quot;php&quot;); Spinner spinner = (Spinner) findViewById(R.id.spinner); spinner.setAdapter(adapter); spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int position, long id) &#123; Spinner spinner = (Spinner)adapterView; String itemContent = (String)adapterView.getItemAtPosition(position); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; view) &#123; Log.i(TAG, view.getClass().getName()); &#125; &#125;); &#125;&#125; 3.3 总结实现spinner的步骤： 定义标签 创建一个适配器 获取Spinner标签，调用setAdapter(SpinnerAdapter adapter)方法设置一个适配器 调用setOnItemSelectedListener(OnItemSelectedListener listener)方法设置监听器监听选中事件 Spinner适配器的数据来源： 1) 使用字符串构建适配器 1234ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item);adapter.add(&quot;Java&quot;);adapter.add(&quot;.NET&quot;);adapter.add(&quot;PHP&quot;); 2) 使用JavaBean构建适配器 1234ArrayAdapter&lt;User&gt; adapter = new ArrayAdapter&lt;User&gt;(this, android.R.layout.simple_spinner_item);adapter.add(new User(1, &quot;lhm&quot;, &quot;lhm@ncist.cn&quot;));adapter.add(new User(2, &quot;yzk&quot;, &quot;yzk@ncist.cn&quot;));adapter.add(new User(3, &quot;hsp&quot;, &quot;hsp@ncist.cn&quot;)); 3) 使用资源文件构建适配器 1ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource(this, R.array.names, android.R.layout.simple_spinner_item); 4) 自定义适配器样式 12ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.custom, R.id.content);//R.layout.custom 布局文件ID ，R.id.content 哪一个组件用来显示文本 本文链接：http://www.sguotao.top/Android基础-2012-07-21-android-basic-11.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础10 通知]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-07-15-android-basic-10.html</url>
    <content type="text"><![CDATA[关于通知的文档位置：android-sdk-windows/docs/guide/topics/ui/notifiers/index.html 1. 土司通知a) 创建通知 12Toast.makeText(Context context, CharSequence text, int duration)Toast.makeText(Context context, int resId, int duration) b) 发送通知 show() 2. 状态栏通知 通知用于在状态栏显示消息，消息到来时以图标方式表示，如果需要查看消息，可以拖动状态栏到屏幕下方即可查看消息。发送消息的代码如下： 1234567891011121314151617//获取通知管理器NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);int icon = android.R.drawable.stat_notify_chat;long when = System.currentTimeMillis();//新建一个通知，指定其图标和标题//第一个参数为图标,第二个参数为短暂提示标题,第三个为通知时间Notification notification = new Notification(icon, null, when); notification.defaults = Notification.DEFAULT_SOUND;//发出默认声音Intent openintent = new Intent(this, OtherActivity.class);//当点击消息时就会向系统发送openintent意图，点击时发送PendingIntent contentIntent = PendingIntent.getActivity(this, 0, openintent, 0);//设置通知点击事件notification.setLatestEventInfo(this, “标题”, “我是内容&quot;, contentIntent);//发送消息，第一个参数为自定义的通知唯一标识mNotificationManager.notify(0, notification); 注意：设置通知点击后清除，设置Notification 对象属性 n.flags = Notification.FLAG_AUTO_CANCEL; 3. 对话框通知3.1 普通对话框当应用需要显示一个进度条或需要用户对信息进行确认时，可以使用对话框来完成。下面代码将打开一个如图所示的对话框：代码采用的是一个链式调用，像setTitle()、setMessage()这些方法，他们的返回值都是当前对话框对象。 123456789101112131415161718new AlertDialog.Builder(context) .setTitle(&quot;java培训&quot;) .setCancelable(false) //设置不能通过“后退”按钮关闭对话框 .setMessage(&quot;浏览华北科技网站?&quot;) .setPositiveButton(&quot;确认&quot;, new DialogInterface.OnClickListener()&#123; public void onClick(DialogInterface dialoginterface, int i)&#123; Uri uri = Uri.parse(&quot;http://www.ncist.cn/&quot;);//打开链接 Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); &#125; &#125;) .setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int id) &#123; dialog.cancel(); &#125; &#125;) .show();//显示对话框 3.2 选项列表的对话框下面代码将打开一个如图所示的选项列表对话框： 12345678final String[] items = &#123;&quot;java&quot;, &quot;.net&quot;, &quot;php&quot;&#125;;new AlertDialog.Builder(SenderNotificationActivity.this).setTitle(&quot;选择语言&quot;) .setItems(items, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int item) &#123; Toast.makeText(getApplicationContext(), items[item], Toast.LENGTH_SHORT).show(); &#125; &#125;).show();//显示对话框 3.3 带单选框列表对话框下面代码将打开一个如图所示的带单选框的列表对话框： 12345678910final String[] items = &#123;&quot;java&quot;, &quot;.net&quot;, &quot;php&quot;&#125;;//setSingleChoiceItems()的第二个参数是设置默认选项，选项索引从0开始，-1代表不选择任何选项。new AlertDialog.Builder(SenderNotificationActivity.this).setTitle(&quot;选择语言&quot;).setSingleChoiceItems(items, 1, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int item) &#123; Toast.makeText(getApplicationContext(), items[item], Toast.LENGTH_SHORT).show(); dialog.cancel(); &#125;&#125;).show();//显示对话框 3.4 带多选项列表的对话框下面代码将打开一个如图所示的多选项列表对话框： 123456789101112131415161718final String[] items = &#123;&quot;java&quot;, &quot;.net&quot;, &quot;php&quot;&#125;;new AlertDialog.Builder(SenderNotificationActivity.this).setCancelable(false).setTitle(&quot;选择语言&quot;).setMultiChoiceItems(items, new boolean[]&#123;false,true,false&#125;, new DialogInterface.OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which, boolean isChecked) &#123; if(isChecked)&#123; Toast.makeText(getApplicationContext(), items[which], Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;).setPositiveButton(&quot;确认&quot;,new DialogInterface.OnClickListener()&#123; public void onClick(DialogInterface dialoginterface, int i)&#123; dialoginterface.dismiss(); &#125;&#125;).show();//显示对话框 3.5 进度对话框调用setProgressStyle()方法设置进度对话框风格。有两种风格： ProgressDialog.STYLE_SPINNER 旋体进度条风格 (为默认风格) ProgressDialog.STYLE_HORIZONTAL 横向进度条风格 下面代码将打开一个如图所示的一个进度对话框： 1234567891011121314151617181920212223242526public class ProgressDialogActivity extends Activity &#123;private ProgressDialog progressDialog; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.menu); //开始一条专门处理耗时工作的线程 new Thread(new Runnable()&#123; @Override public void run() &#123; try &#123; Thread.sleep(5*1000);//假设这项工作需要5秒才能完成 progressDialog.dismiss();//关闭进程对话框 //runOnUiThread(finishDialog);//要求运行在UI线程 &#125; catch (InterruptedException e) &#123;&#125; &#125; &#125;).start(); progressDialog = ProgressDialog.show(ProgressDialogActivity.this, &quot;请稍等&quot;, &quot;数据正在加载中...&quot;, true); &#125; private Runnable finishDialog = new Runnable() &#123; @Override public void run() &#123; progressDialog.dismiss(); &#125; &#125;;&#125; 横向进度条风格的对话框 123456789ProgressDialog dialog = new ProgressDialog(this);dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); // 设置进度条样式dialog.setTitle(&quot;下载中&quot;);dialog.setMessage(&quot;请稍候...&quot;);dialog.setCancelable(false);dialog.setMax(100);dialog.show();dialog.setProgress(10); // 设置进度dialog.dismiss(); // 对话框结束 本文链接：http://www.sguotao.top/Android基础-2012-07-15-android-basic-10.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Toast</tag>
        <tag>Notification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础9 多媒体]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-07-09-android-basic-9.html</url>
    <content type="text"><![CDATA[1. 录音机使用手机进行现场录音，实现步骤如下：a) 在功能清单文件AndroidManifest.xml中添加音频刻录权限： 1&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt; b) 编写音频刻录代码: 1234567891011MediaRecorder recorder = new MediaRecorder(); recorder.setAudioSource(MediaRecorder.AudioSource.MIC);//从麦克风采集声音 recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);//内容输出格式 recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);//音频编码方式 recorder.setOutputFile(&quot;/mnt/sdcard/ncist.amr&quot;); recorder.prepare();//预期准备 recorder.start(); //开始刻录 ... recorder.stop();//停止刻录 recorder.reset(); //重设 recorder.release(); //刻录完成一定要释放资源 2. 音频播放器 123456789101112131415161718192021222324MediaPlayer mediaPlayer = new MediaPlayer();if (mediaPlayer.isPlaying()) &#123; mediaPlayer.reset();//重置为初始状态&#125;mediaPlayer.setDataSource(&quot;/mnt/sdcard/god.mp3&quot;);mediaPlayer.prepare(); mediaPlayer.start();//开始或恢复播放mediaPlayer.pause();//暂停播放mediaPlayer.start();//恢复播放mediaPlayer.stop();//停止播放mediaPlayer.release();//释放资源mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123;//播出完毕事件 @Override public void onCompletion(MediaPlayer arg0) &#123; mediaPlayer.release(); &#125;&#125;);mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() &#123;// 错误处理事件 @Override public boolean onError(MediaPlayer player, int arg1, int arg2) &#123; mediaPlayer.release(); return false; &#125;&#125;); 3. 使用soundpool播放音效在Android开发中我们经常使用MediaPlayer来播放音频文件，但是MediaPlayer存在一些不足，例如：资源占用量较高、延迟时间较长、不支持多个音频同时播放等。这些缺点决定了MediaPlayer在某些场合的使用情况不会很理想，例如在对时间精准度要求相对较高的游戏开发中。在游戏开发中我们经常需要播放一些游戏音效（比如：子弹爆炸，物体撞击等），这些音效的共同特点是短促、密集、延迟程度小。在这样的场景下，我们可以使用SoundPool代替MediaPlayer来播放这些音效。 SoundPool（android.media.SoundPool），顾名思义是声音池的意思，主要用于播放一些较短的声音片段，支持从程序的资源或文件系统加载。与MediaPlayer相比，SoundPool的优势在于CPU资源占用量低和反应延迟小。另外，SoundPool还支持自行设置声音的品质、音量、播放比率等参数，支持通过ID对多个音频流进行管理。就现在已知的资料来说，SoundPool有一些设计上的BUG，从固件版本1.0开始有些还没有修复，我们在使用中应该小心再小心。相信将来Google会修复这些问题，但我们最好还是列出来： SoundPool最大只能申请1M的内存空间，这就意味着我们只能用一些很短的声音片段，而不是用它来播放歌曲或者做游戏背景音乐。 SoundPool提供了pause和stop方法，但这些方法建议最好不要轻易使用，因为有些时候它们可能会使你的程序莫名其妙的终止.建议使用这两个方法的时候尽可能多做测试工作，还有些朋友反映它们不会立即中止播放声音,而是把缓冲区里的数据播放完才会停下来,也许会多播放一秒钟。 SoundPool的效率问题。其实SoundPool的效率在这些播放类中算是很好的了，但是有的朋友在G1中测试它还是有100ms左右的延迟，这可能会影响用户体验。也许这不能管SoundPool本身，因为到了性能比较好的Droid中这个延迟就可以让人接受了。 在现阶段SoundPool有这些缺陷，但也有着它不可替代的优点，基于这些建议大家在如下情况中多使用SoundPoola) 应用程序中的声效(按键提示音，消息等)b) 游戏中密集而短暂的声音(如多个飞船同时爆炸) 开发步骤a) 往项目的res/raw目录中放入音效文件。b) 新建SoundPool对象，然后调用SoundPool.load()加载音效，调用SoundPool.play()播放指定音效文件。 123456789101112131415161718192021public class AudioActivity extends Activity &#123;private SoundPool pool;@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); //指定声音池的最大音频流数目为10，声音品质为5 pool = new SoundPool(10, AudioManager.STREAM_SYSTEM, 5); final int sourceid = pool.load(this, R.raw.pj, 0);//载入音频流，返回在池中的id Button button = (Button)this.findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; //播放音频，第二个参数为左声道音量; 第三个参数为右声道音量; 第四个参数为优先级；第五个参数为循环次数，0不循环，-1循环;第六个参数为速率，速率最低0.5最高为2，1代表正常速度 pool.play(sourceid, 1, 1, 0, -1, 1); &#125; &#125;);&#125;&#125; 4. 视频播放器 a) 在main.xml布局文件添加用于视频画面绘制的SurfaceView 控件 1&lt;SurfaceView android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;240dip&quot; android:id=&quot;@+id/surfaceView&quot; /&gt; b) 在Activity中 12345678910111213141516SurfaceView surfaceView = (SurfaceView)this.findViewById(R.id.surfaceView);surfaceView.getHolder().setFixedSize(176, 144); //设置分辨率/*下面设置Surface不维护自己的缓冲区，而是等待屏幕的渲染引擎将内容推送到用户面前*/surfaceView.getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);MediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.reset();//重置为初始状态mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);/* 设置Video影片以SurfaceHolder播放 */mediaPlayer.setDisplay(surfaceView.getHolder());mediaPlayer.setDataSource(&quot;/mnt/sdcard/oppo.mp4&quot;);mediaPlayer.prepare(); mediaPlayer.start();//播放mediaPlayer.pause();//暂停播放mediaPlayer.start();//恢复播放mediaPlayer.stop();//停止播放mediaPlayer.release();//释放资源 5. 拍照a) 在main.xml布局文件添加用于显示取景画面的SurfaceView 控件： 1&lt;SurfaceView android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;240dip&quot; android:id=&quot;@+id/surfaceView&quot; /&gt; b) 在Activity中 123456789101112131415161718192021SurfaceView surfaceView = (SurfaceView)this.findViewById(R.id.surfaceView);surfaceView.getHolder().setFixedSize(176, 144); //设置分辨率/*下面设置Surface不维护自己的缓冲区，而是等待屏幕的渲染引擎将内容推送到用户面前*/surfaceView.getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);//打开摄像头SDK2.3之后支持前置摄像头，open方法可以接收一个int参数，用来指定哪个摄像头Camera camera = Camera.open();WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);Display display = wm.getDefaultDisplay();Camera.Parameters parameters = camera.getParameters();parameters.setPreviewSize(display.getWidth(), display.getHeight());//设置预览照片的大小parameters.setPreviewFrameRate(3);//每秒3帧parameters.setPictureFormat(PixelFormat.JPEG);//设置照片的输出格式parameters.set(&quot;jpeg-quality&quot;, 85);//照片质量parameters.setPictureSize(display.getWidth(), display.getHeight());//设置照片的大小camera.setParameters(parameters);camera.setPreviewDisplay(surfaceView.getHolder());//通过SurfaceView显示取景画面camera.startPreview();//开始预览camera.autoFocus(null);//自动对焦camera.takePicture(null, null, null, jpegCallback);//拍照片camera.stopPreview();//停止预览camera.release();//释放摄像头 c) 需要权限 1&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; 小结a) 设置预览显示位置 1setPreviewDisplay(SurfaceHolder holder) 注意：SurfaceView不在前端显示的时候会被销毁，恢复之后会重绘b) 将摄像头拍摄画面显示在SurfaceView中，在此之前可对摄像头进行参数配置，getParameters() 方法可以获取摄像头的相关参数Parameters，调用其内部方法即可进行配置 c) 自动对焦 1autoFocus(AutoFocusCallback cb) 自动对焦是一个异步操作，如果我们向等待自动对焦结束之后才开始拍照，需要传入一个回调对象，在其回调函数中调用拍照方法 d) 拍照 1takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback jpeg) 拍照也是异步操作，需要通过回调函数来得到拍照之后的数据，注意拍照之后摄像头不回自动回到预览状态，需要重写调用startPreview()方法 1&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt; 6. 录像a) 在功能清单文件AndroidManifest.xml中添加音频刻录和照相机权限： 1234&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; b) 编写音频刻录代码: 123456789101112131415recorder.reset();recorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); //设置视频输入源，从照相机采集视频recorder.setAudioSource(MediaRecorder.AudioSource.MIC); //设置音频输入源recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);//设置输出格式recorder.setVideoSize(320, 240);recorder.setVideoFrameRate(3); //每秒3帧recorder.setVideoEncoder(MediaRecorder.VideoEncoder.H263); //设置视频编码方式recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);//设置音频编码器recorder.setOutputFile(&quot;/mnt/sdcard/ncist.3gp&quot;);//设置输出文件recorder.setPreviewDisplay(surfaceView.getHolder().getSurface());//设置预览显示位置recorder.prepare();//预期准备recorder.start();//开始刻录...recorder.stop();//停止刻录recorder.release(); //刻录完成一定要释放资源 本文链接：http://www.sguotao.top/Android基础-2012-07-09-android-basic-9.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础8 服务(Service)]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-07-03-Android%E5%9F%BA%E7%A1%80-8-Service.html</url>
    <content type="text"><![CDATA[服务(Service) Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的程序。Service与Broadcast都是运行于主线程中的组件，所以不能直接执行耗时操作（20s ANR），否则会出现ANR。 Service与Thread的区别Thread，线程，是程序运行的最小单元，运行相对独立，通常在线程中执行一些耗时操作。Service，服务，Android的后台服务就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。Service运行依托主线程，不能做耗时操作！因此服务和子线程是完全不同的概念。 开启Service的两种方式以及区别服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。 使用startService()方法启用服务,访问者与服务之间没有关连，即使访问者退出了，服务仍然运行。 使用bindService()方法启用服务，访问者与服务绑定在了一起，访问者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。 在使用两种方式开启Service之前，都需要完成: 定义一个类继承Service; 在AndroidManifest.xml文件中的节点里对服务进行配置； StartService 使用Context的startService(Intent)方法启动该Service； 当不在使用该Service时，调用stopService(Intent)方法停止该服务。 onStartCommand()返回值，startsticky意味着因系统内存不足被杀死时，当系统内存有空闲时，系统尝试再次创建Service，再次执行onStartCommand方法，但是Intent为空。 采用Context.startService()方法启动服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。 BindService 创建BindService服务端，继承自Service并在类中创建一个实现IBinder接口的实例对象并提供公共方法给客户端调用； 从onBind()回调方法返回此Binder实例； 在客户端中，从onServiceConnected()回调方法接收Binder，并使用提供的方法调用绑定服务 通过BindService方式，实现Activity中获取Service成员变量状态，参考实例代码，Service的实现代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestService extends Service &#123; private boolean quit; private int count; //1.创建BindService服务端，继承自Service并在类中创建一个实现IBinder接口的实例对象并提供公共方法给客户端调用； private ServiceBinder serviceBinder = new ServiceBinder(); public class ServiceBinder extends Binder implements ICountService &#123; @Override public int getCount() &#123; return count; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; //2.从onBind()回调方法返回此Binder实例； return serviceBinder; &#125; @Override public void onCreate() &#123; super.onCreate(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (!quit) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; count++; &#125; &#125; &#125;).start(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); this.quit = true; &#125; public interface ICountService &#123; int getCount(); &#125;&#125; Activity的实现代码: 1234567891011121314151617181920212223242526272829303132333435public class TestServiceActivity extends Activity &#123; private TestService.ICountService countService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test_service); this.bindService(new Intent(this, TestService.class), this.serviceConnection, BIND_AUTO_CREATE); &#125; public void getCount(View view) &#123; int i = countService.getCount(); Log.v("sguotao", "Count is " + i); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); this.unbindService(serviceConnection);//解除服务 &#125; private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //3.在客户端中，从onServiceConnected()回调方法接收Binder， // 并使用提供的方法调用绑定服务(对于本地服务，获取的实例和服务onBind()返回的实例是同一个) countService = (TestService.ICountService) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; countService = null; &#125; &#125;;&#125; 服务的生命周期服务的生命周期跟启动服务的方法有关： 当采用Context.startService()方法启动服务，与之有关的生命周期方法:onCreate() –&gt;onStart() –&gt; onDestroy() onCreate()该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。 onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。 onDestroy()该方法在服务被终止时调用。 当采用Context.bindService()方法启动服务，与之有关的生命周期方法:onCreate() –&gt;onBind() –&gt;onUnbind() –&gt;onDestroy() onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。 onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用。 如果先采用startService()启动服务,然后调用bindService()方法绑定到服务，再调用unbindService()解除绑定，最后调用bindService()再次绑定到服务。触发的生命周期方法如下：onCreate() –&gt; onStart() –&gt; onBind() –&gt; onUnbind()[重载后的方法需返回true] –&gt; onRebind() Service的两种通信根据Activity与Service是否处在同一个进程，可将Service分为本地服务和远程服务，本地服务即Activity与Service处在同一个进程中，远程服务即Activity与Service处在不同的进程中。 本地服务实现通信通过startService()和stopService()启动关闭服务。适用于服务和访问者之间没有交互的情况。如果服务和访问者之间需要方法调用或传递参数,则需要使用bindService()和unbindService()启动关闭服务。 采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()，接着调用onBind()，这个时候访问者和服务绑定在一起。 如果访问者要与服务进行通信，那么，onBind()必须返回Ibinder对象。如果访问者退出了，系统就会先调用服务的onUnbind()，接着调用onDestroy()。如果调用bindService()方法前服务已经被绑定，多次调用bindService()并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果访问者希望与正在绑定的服务解除绑定，可以调用unbindService()，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy() Activity与本地服务进行通信，就是通过context.bindService()方法，实现过程就是BindService方式启动Service的过程。 远程服务实现通信(IPC)在Android中, 每个应用程序都有自己的进程，当需要在不同的进程之间传递对象时，该如何实现呢? 显然, Java中是不支持跨进程内存共享的。因此要传递对象, 需要把对象解析成操作系统能够理解的数据格式, 以达到跨进程访问对象的目的。在JavaEE中，采用RMI通过序列化传递对象。在Android中, 则采用AIDL(Android Interface Definition Language：接口定义语言)方式实现。 AIDL是一种接口定义语言，用于约束两个进程间的通讯规则，供编译器生成代码，实现Android设备上的两个进程间通信(IPC)。AIDL的IPC机制和EJB所采用的CORBA很类似，进程之间的通信信息，首先会被转换成AIDL协议消息，然后发送给对方，对方收到AIDL协议消息后再转换成相应的对象。由于进程之间的通信信息需要双向转换，所以android采用代理类在背后实现了信息的双向转换，代理类由android编译器生成，对开发人员来说是透明的。 实现进程通信，一般需要下面步骤：假设A应用需要与B应用进行通信，调用B应用中的download(String path)方法，B应用以Service方式向A应用提供服务。需要下面步骤: 在B应用中创建*.aidl文件，aidl文件的定义和接口的定义很相类，如：在cn.ncist.aidl包下创建IDownloadService.aidl文件，内容如下： 1234package cn.ncist.aidl;interface IDownloadService &#123; void download(String path);&#125; 当完成aidl文件创建后，编译器会自动在项目的gen目录中同步生成IDownloadService.java接口文件。接口文件中生成一个Stub的抽象类，里面包括aidl定义的方法，还包括一些其它辅助方法。值得关注的是asInterface(IBinder iBinder),它返回接口类型的实例，对于远程服务调用，远程服务返回给客户端的对象为代理对象，客户端在onServiceConnected(ComponentName name, IBinder service)引用该对象时不能直接强转成接口类型的实例，而应该使用asInterface(IBinder iBinder)进行类型转换。 编写aidl文件时，需要注意下面几点 接口名和aidl文件名相同; 接口和方法前不用加访问权限修饰符public,private,protected等,也不能用final,static aidl默认支持的类型包话java基本类型（int,long,boolean等）和（String,List,Map,CharSequence），使用这些类型时不需要import声明。对于List和Map中的元素类型必须是aidl支持的类型。如果使用自定义类型作为参数或返回值，自定义类型必须实现Serializable接口(推荐Parcelable接口)。 自定义类型和AIDL生成的其它接口类型在aidl描述文件中，应该显式import，即便在该类和定义的包在同一个包中。 在aidl文件中所有非Java基本类型参数必须加上in、out、inout标记，以指明参数是输入参数、输出参数还是输入输出参数。Java原始类型默认的标记为in,不能为其它标记。 在B应用中实现aidl文件生成的接口（本例是IDownloadService），但并非直接实现接口，而是通过继承接口的Stub来实现（Stub抽象类内部实现了aidl接口），并且实现接口方法的代码。内容如下： 123456public class ServiceBinder extends IDownloadService.Stub &#123; @Override public void download(String path) throws RemoteException &#123; Log.i("DownloadService", path); &#125; &#125; 在B应用中创建一个Service（服务），在服务的onBind(Intent intent)方法中返回实现了aidl接口的对象（本例是ServiceBinder）。内容如下： 12345678910111213public class DownloadService extends Service &#123; private ServiceBinder serviceBinder = new ServiceBinder(); @Override public IBinder onBind(Intent intent) &#123; return serviceBinder; &#125; public class ServiceBinder extends IDownloadService.Stub &#123; @Override public void download(String path) throws RemoteException &#123; Log.i("DownloadService", path); &#125; &#125;&#125; 其他应用可以通过隐式意图访问服务,意图的动作可以自定义，AndroidManifest.xml配置代码如下： 12345&lt;service android:name=".DownloadService" &gt; &lt;intent-filter&gt; &lt;action android:name="cn.ncist.process.aidl.DownloadService" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 把B应用中aidl文件所在package连同aidl文件一起拷贝到客户端A应用，eclipse会自动在A应用的gen目录中为aidl文件同步生成IDownloadService.java接口文件,接下来就可以在A应用中实现与B应用通信，代码如下： 12345678910111213141516171819202122232425262728293031323334public class ClientActivity extends Activity &#123; private IDownloadService downloadService; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); this.bindService(newIntent("cn.ncist.process.aidl.DownloadService"), this.serviceConnection, BIND_AUTO_CREATE);//绑定到服务 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); this.unbindService(serviceConnection);//解除服务 &#125; private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadService = IDownloadService.Stub.asInterface(service); try &#123; downloadService.download("http://www.ncist.cn"); &#125; catch (RemoteException e) &#123; Log.e("ClientActivity", e.toString()); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; downloadService = null; &#125; &#125;;&#125; 进程间传递自定义类型参数Aidl默认支持的类型包话java基本类型（int、long、boolean等）和（String、List、Map、CharSequence），如果要传递自定义的类型该如何实现呢？要传递自定义类型，首先要让自定义类型支持parcelable协议，实现步骤如下： 自定义类型必须实现Parcelable接口，并且实现Parcelable接口的public void writeToParcel(Parcel dest, int flags)方法 。 自定义类型中必须含有一个名称为CREATOR的静态成员，该成员对象要求实现Parcelable.Creator接口及其方法。 创建一个aidl文件声明你的自定义类型。 Parcelable接口的作用实现了Parcelable接口的实例可以将自身的状态信息（状态信息通常指的是各成员变量的值）写入Parcel，也可以从Parcel中恢复其状态。 Parcel用来完成数据的序列化传递。 进程间传递自定义类型的实现过程如下:1. 创建自定义类型，并实现Parcelable接口,使其支持parcelable协议。如：在cn.ncist.domain包下创建Person.java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.ncist.domain;import android.os.Parcel;import android.os.Parcelable;public class Person implements Parcelable private Integer id; private String name; public Person()&#123;&#125; public Person(Integer id, String name) &#123; this.id = id; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; //把javanbean中的数据写到Parcel dest.writeInt(this.id); dest.writeString(this.name); &#125; //添加一个静态成员,名为CREATOR,该对象实现了Parcelable.Creator接口 public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;()&#123; @Override public Person createFromParcel(Parcel source) &#123; //从Parcel中读取数据，返回person对象 return new Person(source.readInt(), source.readString()); &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;;&#125; 2.在自定义类型所在包下创建一个aidl文件对自定义类型进行声明，文件的名称与自定义类型同名。 12package cn.ncist.domain;parcelable Person; 3.在接口aidl文件中使用自定义类型,需要使用import显式导入，本例在cn.ncist.aidl包下创建IPersonService.aidl文件，内容如下： 12345package cn.ncist.aidl;import cn.ncist.domain.Person;interface IPersonService &#123; void save(in Person person);&#125; 4.在实现aidl文件生成的接口（本例是IPersonService），但并非直接实现接口，而是通过继承接口的Stub来实现（Stub抽象类内部实现了aidl接口），并且实现接口方法的代码。内容如下： 123456public class ServiceBinder extends IPersonService.Stub &#123; @Override public void save(Person person) throws RemoteException &#123; Log.i("PersonService", person.getId()+"="+ person.getName()); &#125; &#125; 5.创建一个Service（服务），在服务的onBind(Intent intent)方法中返回实现了aidl接口的对象（本例是ServiceBinder）。内容如下： 12345678910111213public class PersonService extends Service &#123; private ServiceBinder serviceBinder = new ServiceBinder(); @Override public IBinder onBind(Intent intent) &#123; return serviceBinder; &#125; public class ServiceBinder extends IPersonService.Stub &#123; @Override public void save(Person person) throws RemoteException &#123; Log.i("PersonService", person.getId()+"="+ person.getName()); &#125; &#125;&#125; 其他应用可以通过隐式意图访问服务,意图的动作可以自定义，AndroidManifest.xml配置代码如下： 12345&lt;service android:name=".PersonService" &gt; &lt;intent-filter&gt; &lt;action android:name="cn.ncist.process.aidl.PersonService " /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 5.把应用中的aidl文件和所在package一起拷贝到客户端应用的src目录下，编译器会自动在客户端应用的gen目录中为aidl文件同步生成IPersonService.java接口文件,接下来再把自定义类型文件和类型声明aidl文件及所在package一起拷贝到客户端应用的src目录下。最后就可以在客户端应用中实现与远程服务的通信，代码如下： 123456789101112131415161718192021222324252627282930public class ClientActivity extends Activity &#123; private IPersonService personService; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); this.bindService(new Intent("cn.ncist.process.aidl.PersonService"), this.serviceConnection, BIND_AUTO_CREATE);//绑定到服务 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); this.unbindService(serviceConnection);//解除服务 &#125; private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; personService = IPersonService.Stub.asInterface(service); try &#123; personService.save(new Person(56,"liming")); &#125; catch (RemoteException e) &#123; Log.e("ClientActivity", e.toString()); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; personService = null; &#125; &#125;;&#125; 案例监听电话状态如果要实现电话窃听，需要监听电话的状态，主要是实现PhoneStateListener，方法如下： 123456789101112131415161718/* 取得电话服务 */ TelephonyManager telManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE); PhoneStateListener listener = new PhoneStateListener()&#123; @Override public void onCallStateChanged(int state, String incomingNumber) &#123; switch (state)&#123; case TelephonyManager.CALL_STATE_IDLE: /* 无任何状态时 */ break; case TelephonyManager.CALL_STATE_OFFHOOK: /* 接起电话时 */ break; case TelephonyManager.CALL_STATE_RINGING: /* 电话进来时 */ break; &#125; super.onCallStateChanged(state, incomingNumber); &#125; &#125;;//监听电话的状态telManager.listen(listener, PhoneStateListener.LISTEN_CALL_STATE); 在清单文件AndroidManifest.xml中添加权限： 1&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; 结束通话实现黑名单拦截Android没有对外公开结束通话的API，如果需要结束通话，可以使用AIDL与电话管理服务进行通信，并调用服务中的API实现结束通话，方法如下：1.从Android的源代码中拷贝以下文件到项目中，开发工具会在gen目录下自动生成ITelephony.javacom.android.internal.telephony包下的ITelephony.aidlandroid.telephony包下的NeighboringCellInfo.aidl注意：需要在项目中建立对应的包名存放上述两个aidl文件 2.调用ITelephony.endCall()结束通话: 1234Method method = Class.forName("android.os.ServiceManager").getMethod("getService", String.class);IBinder binder = (IBinder)method.invoke(null, new Object[]&#123;TELEPHONY_SERVICE&#125;);ITelephony telephony = ITelephony.Stub.asInterface(binder);telephony.endCall(); 在清单文件AndroidManifest.xml中添加权限： 1&lt;uses-permission android:name="android.permission.CALL_PHONE" /&gt; 电话录音实现思路，通过PhoneStateListener监听电话的状态，在TelephonyManager.CALL_STATE_OFFHOOK时，进行录制。参考示例代码: 12345678910111213141516171819202122232425262728293031323334TelephonyManager manager = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);manager.listen(new MyListener(), PhoneStateListener.LISTEN_CALL_STATE);private final class MyListener extends PhoneStateListener &#123; private String num; private MediaRecorder recorder; public void onCallStateChanged(int state, String incomingNumber) &#123; switch (state) &#123; case TelephonyManager.CALL_STATE_RINGING: num = incomingNumber; break; case TelephonyManager.CALL_STATE_OFFHOOK: try &#123; File file = new File(Environment.getExternalStorageDirectory(), num + "_" + System.currentTimeMillis() + ".3gp"); recorder = new MediaRecorder(); recorder.setAudioSource(AudioSource.MIC); recorder.setOutputFormat(OutputFormat.THREE_GPP); recorder.setAudioEncoder(AudioEncoder.AMR_NB); recorder.setOutputFile(file.getAbsolutePath()); recorder.prepare(); recorder.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; break; case TelephonyManager.CALL_STATE_IDLE: if (recorder != null) &#123; recorder.stop(); recorder.release(); &#125; break; &#125; &#125;&#125; 参考文献[1]GoogleAPI指南-服务 本文链接：http://www.sguotao.top/Android基础-2012-07-03-Android基础-8-Service.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础7 广播接收者(BroadcastReceiver)]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-06-28-Android%E5%9F%BA%E7%A1%80-7-Broadcast.html</url>
    <content type="text"><![CDATA[广播 在Android中，Broadcast是一种广泛运用在应用程序之间传输信息的机制，Android中我们要发送的广播内容是一个Intent，这个Intent中可以携带我们要传送的数据。 广播的生命周期 广播接收者的生命周期是非常短暂的，在接收到广播的时候创建，onReceive()方法结束之后销毁。 广播接收者中不要做一些耗时的工作，耗时的较长的工作最好放在后台服务的线程中完成，否则会弹出Application No Response错误对话框。 最好也不要在广播接收者中创建子线程做耗时的工作，因为广播接收者被销毁后进程就成为了空进程，很容易被系统杀掉。 广播的场景 同一app具有多个进程的不同组件之间的消息通信； 不同app之间的组件之间消息通信。 广播的类型广播根据特征的不同，可以划分为以下三种类型: 普通广播（NormalBroadcast） 有序广播（OrderedBroadcast） 本地广播（LocalBroadcast） 普通广播普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高，但缺点是，接收者不能将处理结果传递给下一个接收者，并且无法终止广播Intent的传播，普通广播的发送方式: 12//发送的是普通广播，所有订阅者都有机会获得并进行处理。Context.sendBroadcast() 还有一个与sendBroadcast()长的差不多的方法，sendStickyBroadcast()，那什么是StickyBroadcast? StickyBoradcast，粘性广播，通过Context.sendStickyBoradcast()发出的广播会一直滞留（等待），以便有人注册这则广播消息后能尽快的收到这条广播。其他功能与sendBroadcast相同。但是使用sendStickyBroadcast 发送广播需要获得BROADCAST_STICKY permission，如果没有这个permission则会抛出异常。 比如在监听网络变化状态是，通常都会按照这样的方式注册: 123456789101112131415161718 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); registerReceiver(netReceiver, filter); &#125; ``` 当网络变化的时候，系统就会给对应的netReceiver发起一个网络变化的广播。查看源码会发现ConnectivityManager.CONNECTIVITY_ACTION是一个粘性广播，因此，在registerReceiver时，就会收到网络变化的广播，会回调onReceive()方法。### 有序广播有序广播是按照接收者声明的优先级别，被接收者依次接收广播。如A的级别高于B，B的级别高于C,那么，广播先传给A，再传给B，最后传给C。优先级别声明在intent-filter元素的android:priority属性中，数越大优先级别越高,取值范围:-1000到1000，优先级别也可以调用IntentFilter对象的setPriority()进行设置 。有序广播的接收者可以终止广播Intent的传播，广播Intent的传播一旦终止，后面的接收者就无法接收到广播。另外，有序广播的接收者可以将数据传递给下一个接收者，如A得到广播后，可以往它的结果对象中存入数据，当广播传给B时,B可以从A的结果对象中得到A存入的数据。有序广播的发送方式:```Java//发送有序广播Context.sendOrderedBroadcast() 发送的是有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者，前面的接收者有权终止广播(BroadcastReceiver.abortBroadcast())，如果广播被前面的接收者终止，后面的接收者就再也无法获取到广播。对于有序广播，前面的接收者可以将数据通过setResultExtras(Bundle)方法存放进结果对象，然后传给下一个接收者，下一个接收者通过代码：Bundle bundle = getResultExtras(true))可以获取上一个接收者存入在结果对象中的数据。 系统收到短信，发出的广播属于有序广播。如果想阻止用户收到短信，可以通过设置优先级，让你们自定义的接收者先获取到广播，然后终止广播，这样用户就接收不到短信了。 本地广播本地广播，只在App内进行传播，与普通广播和有序广播相比，本地广播具有以下特点: 使用它发送的广播将只在自身App内传播，因此不必担心泄露隐私数据； 其它App无法对你的app发送该广播，因为你的App根本就不可能接收到非自身应用发送的该广播，因此你不必担心有安全漏洞可以利用； 比系统的全局广播更加高效。 本地广播的调用方式: 123//获取LocalBroadcastManager实例LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this);lbm.sendBroadcast(new Intent(LOCAL_ACTION)); 查看LocalBroadcastManager源码，会发现以下几点:1.LocalBroadcastManager内部协作主要是靠这两个Map集合:mReceivers和mActions,当然还有一个List集合mPendingBroadcast，这个主要就是存储待接收的广播对象。 1234567private final HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt; mReceivers = new HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt;();private final HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions = new HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt;();private final ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts = new ArrayList&lt;BroadcastRecord&gt;(); 2.LocalBroadcastManager高效的原因主要是因为它内部是通过Handler实现的，它的sendBroadcast()方法含义并非和我们平时所用的一样，它的sendBroadcast()方法其实是通过handler发送一个Message实现的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public boolean sendBroadcast(Intent intent) &#123; synchronized (mReceivers) &#123; final String action = intent.getAction(); final String type = intent.resolveTypeIfNeeded( mAppContext.getContentResolver()); final Uri data = intent.getData(); final String scheme = intent.getScheme(); final Set&lt;String&gt; categories = intent.getCategories(); final boolean debug = DEBUG || ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0); if (debug) Log.v( TAG, "Resolving type " + type + " scheme " + scheme + " of intent " + intent); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction()); if (entries != null) &#123; if (debug) Log.v(TAG, "Action list: " + entries); ArrayList&lt;ReceiverRecord&gt; receivers = null; for (int i=0; i&lt;entries.size(); i++) &#123; ReceiverRecord receiver = entries.get(i); if (debug) Log.v(TAG, "Matching against filter " + receiver.filter); if (receiver.broadcasting) &#123; if (debug) &#123; Log.v(TAG, " Filter's target already added"); &#125; continue; &#125; int match = receiver.filter.match(action, type, scheme, data, categories, "LocalBroadcastManager"); if (match &gt;= 0) &#123; if (debug) Log.v(TAG, " Filter matched! match=0x" + Integer.toHexString(match)); if (receivers == null) &#123; receivers = new ArrayList&lt;ReceiverRecord&gt;(); &#125; receivers.add(receiver); receiver.broadcasting = true; &#125; else &#123; if (debug) &#123; String reason; switch (match) &#123; case IntentFilter.NO_MATCH_ACTION: reason = "action"; break; case IntentFilter.NO_MATCH_CATEGORY: reason = "category"; break; case IntentFilter.NO_MATCH_DATA: reason = "data"; break; case IntentFilter.NO_MATCH_TYPE: reason = "type"; break; default: reason = "unknown reason"; break; &#125; Log.v(TAG, " Filter did not match: " + reason); &#125; &#125; &#125; if (receivers != null) &#123; for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123; mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; &#125; &#125; return false; &#125; 3.既然它内部是通过Handler来实现广播发送的，那么相比与系统广播通过Binder实现可定是更高效了，同时使用Handler来实现，别的应用无法向我们发送该广播，而我们应用内发送的广播也不会离开我们的应用。 广播实现机制BroadcastRecever内部实现机制可以总结为一下几个步骤: 自定义广播接收者BroadcastRecever,并复写 onReceive()方法； 通过Binder机制向ActivityManagerService进行注册； 广播发送者通过Binder机制向ActivityManagerService发送广播； ActivityManagerService查找符合相应条件的BroadcastReceiver,将广播发送到BroadcastReceiver相应的消息队列中; 消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法； ActivityManagerService是贯穿android系统的核心服务，负责四大组件的启动，切换，调度以及应用程序的启动和调度工作。Binder机制是android IPC（进程间通信）的核心，是客户端和服务端C/S结构，客户端进程可以获取服务端进程的代理接口，并通过这个代理接口里的方法来读取进程间的数据通信。 定义广播接收者广播接收者（BroadcastReceiver）用于接收广播Intent，广播Intent的发送是通过调用Context.sendBroadcast()、Context.sendOrderedBroadcast()来实现的。要实现一个广播接收者方法如下：第一步：继承BroadcastReceiver，并重写onReceive()方法。 12345public class IncomingSMSReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; …… &#125;&#125; 第二步：注册广播Intent，注册的方法有动态注册和静态注册两种方式。动态注册方式，在退出是，需要调用unRegister(receiver)来取消注册，参考示例代码: 1234//动态注册IntentFilter filter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED");IncomingSMSReceiver receiver = new IncomingSMSReceiver();registerReceiver(receiver, filter); 静态注册，参考示例代码: 123456&lt;!--静态注册--&gt;&lt;receiver android:name=".IncomingSMSReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 静态注册与动态注册的区别: 注册方式不同，静态注册在manifest文件中进行声明；动态注册在Activity中通过register方式进行注册。 动态注册的方式会跟随Activity的生命周期，静态注册的广播，Activity销毁，甚至app进程被杀掉后，仍然能收到广播；案例监听短信接收Android系统在收到短信的时候会发送一条有序广播，我们如果定义一个接收者接收这个广播，就可以得到短信内容，也可以拦截短信。当系统收到短信时，会发出一个广播Intent，Intent的action名称为android.provider.Telephony.SMS_RECEIVED，该Intent存放了系统接收到的短信内容，我们使用名称“pdus”即可从Intent中获取到短信内容。 监听短信接收需要实现以下几个步骤: 定义广播接收者接收广播； 在onReceive方法内部调用Intent的getExtras()获取其中pdus字段，得到一个Object[]，其中每一个元素都是一个byte[]； 通过SmsMessage类的createFromPdu方法创建SmsMessage对象； 从SmsMessage对象中即可获取发送者号码、短信内容、发送时间等信息； 需要接收短信权限android.permission.RECEIVE_SMS。 12345678910111213141516171819202122232425262728/** *1.定义广播接收者接收广播 */public class IncomingSMSReceiver extends BroadcastReceiver &#123; private static final String SMS_RECEIVED = "android.provider.Telephony.SMS_RECEIVED"; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(SMS_RECEIVED)) &#123; SmsManager sms = SmsManager.getDefault(); //2.调用Intent的getExtras()获取其中pdus字段 Bundle bundle = intent.getExtras(); if (bundle != null) &#123; Object[] pdus = (Object[]) bundle.get("pdus"); SmsMessage[] messages = new SmsMessage[pdus.length]; for (int i = 0; i &lt; pdus.length; i++) ////3.通过SmsMessage类的createFromPdu方法创建SmsMessage对象 messages[i] = SmsMessage.createFromPdu((byte[]) pdus[i]); //4.从SmsMessage对象中即可获取发送者号码、短信内容、发送时间等信息 for (SmsMessage message : messages) &#123; String msg = message.getMessageBody(); String to = message.getOriginatingAddress(); sms.sendTextMessage(to, null, msg, null, null); &#125; &#125; &#125; &#125; &#125; 在AndroidManifest.xml文件中添加以下权限： 123&lt;!--5.需要接收短信权限android.permission.RECEIVE_SMS--&gt;&lt;uses-permission android:name="android.permission.RECEIVE_SMS"/&gt;&lt;!-- 接收短信权限 --&gt;&lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;&lt;!-- 发送短信权限 --&gt; 在AndroidManifest.xml文件中的节点里对接收到短信的广播Intent进行订阅。 12345&lt;receiver android:name=".IncomingSMSReceiver"&gt; &lt;intent-filter&gt; &lt;actionandroid:name="android.provider.Telephony.SMS_RECEIVED"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; Android系统中收到短信的通知是一个有序通知，我们如需拦截垃圾短信，可以配置较高的priority，收到信息进行判断是否abortBroadcast()。除了短信到来广播Intent，Android还有很多广播Intent，如：开机启动、电池电量变化、时间已经改变等广播Intent。 接收电池电量变化广播Intent ，在AndroidManifest.xml文件中的节点里订阅此Intent 12345&lt;receiver android:name=".IncomingSMSReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BATTERY_CHANGED"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 接收开机启动广播Intent，在AndroidManifest.xml文件中的节点里订阅此Intent: 12345&lt;receiver android:name=".IncomingSMSReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 并且要进行权限声明： 1&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt; 监听呼出电话向外拨打电话时系统会发出一个有序广播，虽然该广播最终会被拔号器里的广播接收者所接收并实现电话拔打，但我们可以在广播传递给拔号广播接收者之前先得到该广播，然后清除传递给拔号广播接收者的电话号码，在拔号广播接收者接收到该广播时，由于电话号码为null，因此取消电话拔打。也可以在onReceive方法中使用getResultData()和 setResultData()方法获取和设置电话号码。 123456789public class OutgoingCallReceiver extends BroadcastReceiver &#123; public void onReceive(Context context, Intent intent) &#123; //清除电话，广播被传给系统的接收者后，因为电话为null，取消电话拔打 setResultData(null); // 同样如果你想修改外拔的电话号码，可以这样做 // String phone = getResultData();//得到外拔电话 // setResultData(“12593”+ phone);//在电话前面加上12593 &#125;&#125; 接收外拔电话广播Intent，在AndroidManifest.xml文件中的节点里订阅此Intent。 12345&lt;receiver android:name=".OutgoingCallReceiver"&gt; &lt;intent-filter android:priority="1"&gt; &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 进行权限声明： 1&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt; 参考文献[1]Google-API指南-应用组件-Broadcasts 本文链接：http://www.sguotao.top/Android基础-2012-06-28-Android基础-7-Broadcast.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Broadcast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础6 活动(Activity)]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-06-27-android-basic-6.html</url>
    <content type="text"><![CDATA[1. 创建Activity1.1 定义Activity定义类继承Activity123456public class NewActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //这里可以使用setContentView(R.layout.xxx)显示某个视图.... &#125;&#125; 在AndroidManifest.xml的节点中声明12345678&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;cn.ncist.action&quot; android:versionCode=&quot;1&quot; android:versionName=&quot;1.0&quot;&gt; &lt;application android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot;&gt; ..... &lt;activity android:name=&quot;.NewActivity&quot; android:label=&quot;新activity的页面标题&quot;/&gt; &lt;/application&gt; ...&lt;/manifest&gt; android:name属性值的前面加了一个点表示NewActivity是当前包cn.ncist.action下的类，如果类在应用的当前包下，可以省略点符号，如果类在应用的子包下必须加点，如：NewActivity类在cn.ncist.action.user包下可以这样写： 1.2 显式意图创建方式 构造函数，代码少new Intent(this, NewActivity.class); 类名形式，灵活，可扩展性强intent.setClassName(this, “cn.ncist.activity.NewActivity”); 包名类名形式，可启动其他程序中的Activityintent.setClassName(“cn.ncist.downloader”, “cn.ncist.downloader.MainActivity”); 1.3 创建Activity并传递数据 在意图对象中封装了一个Bundle对象，可以用来携带数据 在新Activity中可以获得意图对象以获取其中Bundle保存的数据123456789101112131415161718192021public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ....... button.setOnClickListener(new View.OnClickListener()&#123;//点击该按钮会打开一个新的Activity public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, NewActivity.class)Bundle bundle = new Bundle();//该类用作携带数据bundle.putString(&quot;name&quot;, &quot;华北科技&quot;);bundle.putInt(&quot;age&quot;, 4);intent.putExtras(bundle);//附带上额外的数据startActivity(intent); &#125;&#125;); &#125;&#125;public class NewActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ........ Bundle bundle = this.getIntent().getExtras(); String name = bundle.getString(&quot;name&quot;); int age = bundle.getInt(&quot;age&quot;); &#125;&#125; 1.4 创建Activity获取返回数据 使用startActivityForResult(Intent intent, int requestCode) 方法打开Activity 重写onActivityResult(int requestCode, int resultCode, Intent data) 方法 新Activity中调用setResult(int resultCode, Intent data) 设置返回数据之后，关闭Activity就会调用onActivityResult方法 1.5 隐式意图创建Activity 显式意图是指在创建意图时指定了组件，而隐式意图则不指定组件，通过动作、类型、数据匹配对应的组件 在清单文件中定义时需要定义才能被隐式意图启动 中至少配置一个和一个，否则无法被启动 Intent对象中设置的action、category、data在必须全部包含才能启动 中的、、都可以配置多个，Intent对象中不用全部匹配，每样匹配一个即可启动如果一个意图可以匹配多个Activity，Android系统会提示选择 2. Bundle类的作用Bundle类用作携带数据，它类似于Map，用于存放key-value名值对形式的值。相对于Map，它提供了各种常用类型的putXxx()/getXxx()方法，如:putString()/getString()和putInt()/getInt()，putXxx()用于往Bundle对象放入数据，getXxx()方法用于从Bundle对象里获取数据。Bundle的内部实际上是使用了HashMap类型的变量来存放putXxx()方法放入的值：12345678910111213141516public final class Bundle implements Parcelable, Cloneable &#123; ...... Map&lt;String, Object&gt; mMap; public Bundle() &#123; mMap = new HashMap&lt;String, Object&gt;(); ...... &#125; public void putString(String key, String value) &#123; mMap.put(key, value); &#125;public String getString(String key) &#123; Object o = mMap.get(key); return (String) o; ........//类型转换失败后会返回null，这里省略了类型转换失败后的处理代码&#125;&#125; 在调用Bundle对象的getXxx()方法时，方法内部会从该变量中获取数据，然后对数据进行类型转换，转换成什么类型由方法的Xxx决定，getXxx()方法会把转换后的值返回。 3. Intent意图Android基本的设计理念是鼓励减少组件间的耦合，因此Android提供了Intent (意图) ，Intent提供了一种通用的消息系统，它允许在你的应用程序与其它的应用程序间传递Intent来执行动作和产生事件。使用Intent可以激活Android应用的三个核心组件：活动、服务和广播接收器。 Intent可以划分成显式意图和隐式意图显式意图：调用Intent.setComponent()或Intent.setClass()方法明确指定了组件名的Intent为显式意图，显式意图明确指定了Intent应该传递给哪个组件。隐式意图:没有明确指定组件名的Intent为隐式意图。 Android系统会根据隐式意图中设置的动作(action)、类别(category)、数据（URI和数据类型）找到最合适的组件来处理这个意图。12345678910&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.CALL&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;tel&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.CALL&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;vnd.android.cursor.item/phone&quot; /&gt; &lt;/intent-filter&gt; 对于隐式意图，Android是怎样寻找到这个最合适的组件呢？记的前面我们在定义活动时，指定了一个intent-filter，Intent Filter（意图过滤器）其实就是用来匹配隐式Intent的，当一个意图对象被一个意图过滤器进行匹配测试时，只有三个方面会被参考到：动作、数据（URI以及数据类型）和类别。 动作测试（Action test）一个意图对象只能指定一个动作名称，而一个过滤器可能列举多个动作名称。如果意图对象或过滤器没有指定任何动作，结果将如下： 如果过滤器没有指定任何动作，那么将阻塞所有的意图，因此所有的意图都会测试失败。没有意图能够通过这个过滤器。 另一方面，只要过滤器包含至少一个动作，一个没有指定动作的意图对象自动通过这个测试 类别测试（Category test）对于一个能够通过类别匹配测试的意图，意图对象中的类别必须匹配过滤器中的类别。这个过滤器可以列举另外的类别，但它不能遗漏在这个意图中的任何类别。原则上一个没有类别的意图对象应该总能够通过匹配测试，而不管过滤器里有什么。大部分情况下这个是对的。但有一个例外，Android把所有传给startActivity()的隐式意图当作他们包含至少一个类别：”android.intent.category.DEFAULT” （CATEGORY_DEFAULT常量）。 因此，想要接收隐式意图的活动必须在它们的意图过滤器中包含”android.intent.category.DEFAULT”。（带”android.intent.action.MAIN”和”android.intent.category.LAUNCHER”设置的过滤器是例外） 数据测试（Data test）当一个意图对象中的URI被用来和一个过滤器中的URI比较时，比较的是URI的各个组成部分。例如，如果过滤器仅指定了一个scheme，所有该scheme的URIs都能够和这个过滤器相匹配；如果过滤器指定了一个scheme、主机名但没有路经部分，所有具有相同scheme和主机名的URIs都可以和这个过滤器相匹配，而不管它们的路经；如果过滤器指定了一个scheme、主机名和路经，只有具有相同scheme、主机名和路经的URIs才可以和这个过滤器相匹配。当然，一个过滤器中的路径规格可以包含通配符，这样只需要部分匹配即可。 数据测试同时比较意图对象和过滤器中指定的URI和数据类型。规则如下： 一个既不包含URI也不包含数据类型的意图对象仅在过滤器也同样没有指定任何URIs和数据类型的情况下才能通过测试。 一个包含URI但没有数据类型的意图对象仅在它的URI和一个同样没有指定数据类型的过滤器里的URI匹配时才能通过测试。这通常发生在类似于mailto:和tel：这样的URIs上：它们并不引用实际数据。 一个包含数据类型但不包含URI的意图对象仅在这个过滤器列举了同样的数据类型而且也没有指定一个URI的情况下才能通过测试。 一个同时包含URI和数据类型（或者可从URI推断出数据类型）的意图对象可以通过测试，如果它的类型和过滤器中列举的类型相匹配的话。如果它的URI和这个过滤器中的一个URI相匹配或者它有一个内容content:或者文件file: URI而且这个过滤器没有指定一个URI，那么它也能通过测试。换句话说，一个组件被假定为支持content:和file: 数据如果它的过滤器仅列举了一个数据类型。 为Intent附加数据的两种形式：第一种写法，用于批量添加数据到Intent：1234Intent intent = new Intent();Bundle bundle = new Bundle();//该类用作携带数据bundle.putString(&quot;name&quot;, &quot;华北科技&quot;);intent.putExtras(bundle);//为意图追加额外的数据，意图原来已经具有的数据不会丢失，但key同名的数据会被替换 第二种写法：这种写法的作用等价于上面的写法，只不过这种写法是把数据一个个地添加进Intent，这种写法使用起来比较方便，而且只需要编写少量的代码。12Intent intent = new Intent();intent.putExtra(&quot;name&quot;, &quot;华北科技&quot;); Intent提供了各种常用类型重载后的putExtra()方法，如： putExtra(String name, String value)、 putExtra(String name, long value)，在putExtra()方法内部会判断当前Intent对象内部是否已经存在一个Bundle对象，如果不存在就会新建Bundle对象，以后调用putExtra()方法传入的值都会存放于该Bundle对象，下面是Intent的putExtra(String name, String value)方法代码片断：123456789public class Intent implements Parcelable &#123;private Bundle mExtras;public Intent putExtra(String name, String value) &#123; if (mExtras == null) &#123; mExtras = new Bundle(); &#125; mExtras.putString(name, value); return this; &#125; 4. 生命周期Acitivity三种状态 运行：activity在屏幕最前端运行（位于当前任务栈的顶部） 暂停：当它上面有另外一个Activity，使它失去了焦点但任然对用户可见时，它处于暂停状态，在它之上的Activity没有完全覆盖屏幕或者是透明的，被暂停的Activity仍然对用户可见，并且是存活状态（它保留着所有的状态和成员信息并保持和窗口管理器的连接）。如果系统处于内存不足时，会杀死这个Activity。 停止：activity不可见，完全被覆盖，它仍然保留着所有的状态和成员信息，然而对用户是不可见的，所以它的窗口被隐藏，如果其它地方需要内存，则系统经常会杀死这个Activity。 生命周期相关方法当Activity从一种状态转变到另外一种状态时，会调用以下保护方法来通知这种变化。 onCreate：创建时调用，或者程序在暂停、停止状态下被杀死之后重新打开时也会调用 onStart：onCreate之后或者从停止状态恢复时调用 onResume：onStart之后或者从暂停状态恢复时调用，从停止状态恢复时由于调用onStart，也会调用onResume onPause：进入暂停、停止状态，或者销毁时会调用 onStop：进入停止状态，或者销毁时会调用 onDestroy：销毁时调用 onRestart：从停止状态恢复时调用这七个方法定义了Activity的完整的声明周期。 Activity的完整声明周期自第一次调用onCreate()开始，直至调用onDestroy()为止。Activity在onCreate()中设置所有“全局”状态以完成初始化，而在onDestroy()中释放所有系统资源。 Activity的可视声明周期自onStart()调用开始直到相应的onStop()调用结束，在此期间，用户可以在屏幕上看到Activity，尽管它也许并不是位于前台或者也不予用户进行交互，在这两个方法之间，可以保留用来向用户显示这个Activity所需的资源。 Activity的前台声明周期自onResume()调用起，至相应的onPause()调用为止，在此期间，Activity位于前台最上面并于用户进行交互。Activity会经常在暂停和恢复之间进行状态转换。 Activity的前台生命周期循环例子: 创建一个Activity，添加七个生命周期方法，方法内输出各个方法名称。再添加一个按钮用于打开下面新添加的Activity。 startActivity(new Intent(LifeActivity.this, CustomDialogActivity.class)); 添加一个新Activity，代码如下：123456789public class CustomDialogActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //必须在调用setContentView()之前调用requestWindowFeature() requestWindowFeature(Window.FEATURE_LEFT_ICON);//要标题栏显示图标 setContentView(R.layout.dialog_activity); getWindow().setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, android.R.drawable.ic_dialog_alert);//设置图标 &#125;&#125; 在AndroidManifest.xml文件配置Activity，并且通过主题指定该Activity以对话框样式显示。12345&lt;application android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot;&gt; ..... &lt;activity android:name=&quot;.CustomDialogActivity&quot; android:label=&quot;对话框activity&quot; android:theme=&quot;@android:style/Theme.Dialog&quot;/&gt; &lt;/application&gt; 5. 保存信息相关方法Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity时，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。因为在这种情况下，用户的行为决定了不需要保存Activity的状态。通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。 另外，当屏幕的方向发生了改变， Activity会被摧毁并且被重新创建，如果你想在Activity被摧毁前缓存一些数据，并且在Activity被重新创建后恢复缓存的数据。可以重写Activity的 onSaveInstanceState() 和 onRestoreInstanceState()方法，如下：1234567891011public class PreferencesActivity extends Activity &#123; private String name; protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; name = savedInstanceState.getString(&quot;name&quot;); //被重新创建后恢复缓存的数据 super.onRestoreInstanceState(savedInstanceState); &#125; protected void onSaveInstanceState(Bundle outState) &#123; outState.putString(&quot;name&quot;, &quot;liming&quot;);//被摧毁前缓存一些数据 super.onSaveInstanceState(outState); &#125;&#125; onSaveInstanceState()：在Activity被动的摧毁或停止的时候调用，用于保存运行数据，可以将数据存在在Bundle中。onRestoreInstanceState()：该方法在Activity被重新绘制的时候调用，例如改变屏幕方向，savedInstanceState为onSaveInstanceState保存的数据。 横竖屏幕的切换默认情况下，当“屏幕方向”或“键盘显示隐藏” 变化时都会销毁当前Activity，创建新的Activity。如果不希望重新创建Activity实例，可以按如下配置Activity：1&lt;activity android:name=&quot;.MainActivity&quot; android:configChanges=&quot;keyboardHidden|orientation&quot;&gt; 上面的android:configChanges属性指定了要捕获“屏幕方向”和“键盘显示隐藏”变化，当捕获到这些变化后会调用Activity的onConfigurationChanged()方法。默认情况下(没有配置android:configChanges属性)： 竖屏切横屏，销毁当前Activity之后，创建一个新Activity实例。 横屏切竖屏，销毁当前Activity之后，创建一个新Activity实例，新的Activity实例很快就被销毁，接着又会创建一个新Activity实例。如果只希望创建一个实例，可以配置android:configChanges=”orientation” 6. 得到新打开的Activity关闭后返回的数据如果你想在Activity中得到新打开Activity 关闭后返回的数据，你需要使用系统提供的startActivityForResult(Intent intent, int requestCode)方法打开新的Activity，新的Activity 关闭后会向前面的Activity 传回数据，为了得到传回的数据，你必须在前面的Activity中重写onActivityResult(int requestCode, int resultCode, Intent data)方法：123456789101112131415161718public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ....... Button button =(Button) this.findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener()&#123;//点击该按钮会打开一个新的Activity public void onClick(View v) &#123; //第二个参数为请求码，可以根据业务需求自己编号 startActivityForResult (new Intent(MainActivity.this, NewActivity.class), 1); &#125;&#125;); &#125; //第一个参数为请求码，即调用startActivityForResult()传递过去的值 //第二个参数为结果码，结果码用于标识返回数据来自哪个新Activity @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; String result = data.getExtras().getString(“result”));//得到新Activity 关闭后返回的数据 &#125;&#125; 当新Activity关闭后，新Activity返回的数据通过Intent进行传递，android平台会调用前面Activity 的onActivityResult()方法，把存放了返回数据的Intent作为第三个输入参数传入，在onActivityResult()方法中使用第三个输入参数可以取出新Activity返回的数据。 使用startActivityForResult(Intent intent, int requestCode)方法打开新的Activity，新Activity关闭前需要向前面的Activity返回数据需要使用系统提供的setResult(int resultCode, Intent data)方法实现：12345678910111213public class NewActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ...... button.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v) &#123; Intent intent = new Intent();//数据是使用Intent返回 intent.putExtra(“result”, “华北科技的学生很可爱”);//把返回数据存入Intent NewActivity.this.setResult(RESULT_OK, intent);//设置返回数据 NewActivity.this.finish();//关闭Activity &#125;&#125;); &#125;&#125; setResult()方法的第一个参数值可以根据业务需要自己定义，上面代码中使用到的RESULT_OK是系统Activity类定义的一个常量，值为-1，代码片断如下：12345public class android.app.Activity extends ......&#123; public static final int RESULT_CANCELED = 0; public static final int RESULT_OK = -1; public static final int RESULT_FIRST_USER = 1;&#125; 请求码的作用使用startActivityForResult(Intent intent, int requestCode)方法打开新的Activity，我们需要为startActivityForResult()方法传入一个请求码(第二个参数)。请求码的值是根据业务需要由自已设定，用于标识请求来源。 例如：一个Activity有两个按钮，点击这两个按钮都会打开同一个Activity，不管是那个按钮打开新Activity，当这个新Activity关闭后，系统都会调用前面Activity的onActivityResult(int requestCode, int resultCode, Intent data)方法。在onActivityResult()方法如果需要知道新Activity是由那个按钮打开的，并且要做出相应的业务处理，这时可以这样做：123456789101112131415161718192021 @Override public void onCreate(Bundle savedInstanceState) &#123; .... button1.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v) &#123; startActivityForResult (new Intent(MainActivity.this, NewActivity.class), 1); &#125;&#125;); button2.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v) &#123; startActivityForResult (new Intent(MainActivity.this, NewActivity.class), 2); &#125;&#125;); @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch(requestCode)&#123; case 1: //来自按钮1的请求，作相应业务处理 case 2: //来自按钮2的请求，作相应业务处理 &#125; &#125;&#125; 结果码的作用在一个Activity中，可能会使用startActivityForResult()方法打开多个不同的Activity处理不同的业务，当这些新Activity关闭后，系统都会调用前面Activity的onActivityResult(int requestCode, int resultCode, Intent data)方法。为了知道返回的数据来自于哪个新Activity，在onActivityResult()方法中可以这样做(ResultActivity和NewActivity为要打开的新Activity)：1234567891011121314151617181920public class ResultActivity extends Activity &#123; ..... ResultActivity.this.setResult(1, intent); ResultActivity.this.finish();&#125;public class NewActivity extends Activity &#123; ...... NewActivity.this.setResult(2, intent); NewActivity.this.finish();&#125;public class MainActivity extends Activity &#123; // 在该Activity会打开ResultActivity和NewActivity @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch(resultCode)&#123; case 1: // ResultActivity的返回数据 case 2: // NewActivity的返回数据 &#125; &#125;&#125; 7. 内存管理Android系统在运行多个进程时，如果系统资源不足，会强制结束一些进程。优先选择哪个进程来结束是有优先级的。以下顺序靠上的优先结束 空：进程中所有Activity都已销毁 后台：进程中有一个停止状态的Activity 服务：进程中一个运行中的Service 可见：进程中有一个暂停状态的Activity 前台：进程中正在运行一个Activity 8. 应用的响应性ANR在Android中，应用的响应性被活动管理器（Activity Manager）和窗口管理器（Window Manager）这两个系统服务所监视。当用户触发了输入事件（如键盘输入，点击按钮等），如果应用5秒内没有响应用户的输入事件，那么，Android会认为该应用无响应，便弹出ANR（Application No Response）对话框。 在正常情况下，Android程序会在一条单线程里运行。如果Activity要处理一件比较耗时的工作，应该交给子线程完成，否侧会因为主线程被阻塞，后面的用户输入事件因没能在5秒内响应，导致应用出现ANR对话框。 9. 姻缘属性affinities应用场景：有两个android应用程序：旅游应用.apk，天气查询.apk，在Activity中配置 android:allowTaskReparenting=”true” android:taskAffinity=”tianqi”会将两个Activity放在同一个task任务栈，可以减少上下文切换到开销，节省资源。 10.启动模式在AndroidManifest.xml中的标签中可以配置android:launchMode属性，用来控制Actvity的启动模式在Android系统中我们创建的Acitivity是以栈的形式呈现的(task 任务栈) 一个应用程序可能包涵多个activity ,这些activity都是被放置在任务栈中的。可以把一个应用程序理解成一组任务的集合,即用户看到的界面(activity) 是被放置在任务栈当中的。 standard：默认的启动模式，每次调用startActivity()启动时都会创建一个新的Activity放在栈顶 singleTop：如果启动的Activity时，指定Activity不在栈顶就创建，如在栈顶，则不再创建，去调用onNewIntent()的方法。应用场景如浏览器的书签 ( bookmark ) 采用了该启动模式，不让用 户多次退出同一书签，增强用户的操作体验, singleTask：如果启动的Activity不存在就创建，如果存在直接跳转到指定的Activity所在位置，保证了当前的task栈中只有一个任务的实例 singleInstance：如果启动的Activity不存在就创建，如果存在就将指定的Activity移动到栈顶，开启一个新的task任务栈，用来维护新打开的Activity，原来的Activity中维护对其引用； task任务栈，应用程序和进程之间关系 task任务栈：用来维护一组Activity的集合，通过设置task,可以更加合理的管理Activity; 应用程序：应用程序可以分为可见和不可见两种，可见的应用程序可以理解成一组任务的集合（Activity），不可见部分包括其它三大组件； 进程：操作系统的概念，开启的应用程序都会开启一个进程 本文链接：http://www.sguotao.top/Android基础-2012-06-27-android-basic-6.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础5 网络通信]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-06-15-android-basic-5.html</url>
    <content type="text"><![CDATA[1. 获取网络图片 通过URL对象封装地址，打开一个HttpURLConnection 设置超时时间以及请求方式 获取相应码，如果成功返回200即可从HttpURLConnection中获取输入流读取数据 通过BitmapFactory的decodeByteArray(byte[] data, int offset, int length)方法将数据转换为图片对象 需要访问网络的权限 1234567891011121314151617URL url = new URL(&quot;http://photocdn.sohu.com/20100125/Img269812337.jpg&quot;);HttpURLConnection conn = (HttpURLConnection) url.openConnection();conn.setConnectTimeout(5* 1000);conn.setRequestMethod(&quot;GET&quot;);if (conn.getResponseCode() != 200) throw new RuntimeException(&quot;请求url失败&quot;);InputStream is = conn.getInputStream();readAsFile(is, &quot;Img269812337.jpg&quot;); public static void readAsFile(InputStream inSream, File file) throws Exception&#123; FileOutputStream outStream = new FileOutputStream(file); byte[] buffer = new byte[1024]; int len = -1; while( (len = inSream.read(buffer)) != -1 )&#123; outStream.write(buffer, 0, len); &#125; outStream.close(); inSream.close();&#125; 2. 获取HTML代码 和获取图片相同，使用URL封装路径，打开一个HttpURLConnection 设置头信息之后获取相应码，从输入流中获取数据 需要获取服务器端代码的编码 代码过长屏幕显示不全可以使用进行显示1234567891011121314151617181920URL url = new URL(&quot;http://www.sohu.com&quot;);HttpURLConnection conn = (HttpURLConnection) url.openConnection();conn.setConnectTimeout(5* 1000);//设置连接超时conn.setRequestMethod(“GET”);//以get方式发起请求if (conn.getResponseCode() != 200) throw new RuntimeException(&quot;请求url失败&quot;);InputStream is = conn.getInputStream();//得到网络返回的输入流String result = readData(is, &quot;GBK&quot;);conn.disconnect();//第一个参数为输入流,第二个参数为字符集编码public static String readData(InputStream inSream, String charsetName) throws Exception&#123; ByteArrayOutputStream outStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = -1; while( (len = inSream.read(buffer)) != -1 )&#123; outStream.write(buffer, 0, len); &#125; byte[] data = outStream.toByteArray(); outStream.close(); inSream.close(); return new String(data, charsetName); 3. 获取XML 使用URL封装路径，打开一个HttpURLConnection 设置头信息之后获取相应码，从输入流中获取数据 使用XmlPullPaser解析 4. 获取Json 使用URL封装路径，打开一个HttpURLConnection 设置头信息之后获取相应码，从输入流中获取数据 将数据转为String，封装成JSONArray对象 遍历JSONArray对象，获取其中的JSONObject 再从JSONObject中获取每个字段的信息 5. 发送Get请求 拼接路径和参数，通过URL进行封装，打开一个HttpURLConnection，发送请求 如果参数是中文会出现乱码 URL中包含的中文参数需要使用URLEncoder进行编码 服务器端如果是TOMCAT，其默认使用ISO8859-1编码，接收时需要处理编码问题 6. 发送Post请求 通过URL打开一个HttpURLConnection 头信息中除了超时时间和请求方式之外还必须设置Content-Type和Content-Length 从HttpURLConnection获得输出流输出参数数据 服务端可以使用request对象的setCharacterEncoding方法设置编码1234567891011121314151617181920212223StringBuilder xml = new StringBuilder();xml.append(&quot;&amp;lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot; ?&amp;gt;&quot;);xml.append(&quot;&amp;lt;M1 V=10000&amp;gt;&quot;);xml.append(&quot;&amp;lt;U I=1 D=\&quot;N73\&quot;&amp;gt;中国&amp;lt;/U&amp;gt;&quot;);xml.append(&quot;&amp;lt;/M1&amp;gt;&quot;);byte[] xmlbyte = xml.toString().getBytes(&quot;UTF-8&quot;);URL url = new URL(&quot;http://localhost:8080/ncist/contanctmanage.do?method=readxml&quot;);HttpURLConnection conn = (HttpURLConnection) url.openConnection();conn.setConnectTimeout(5* 1000);conn.setDoOutput(true);//允许输出conn.setUseCaches(false);//不使用Cacheconn.setRequestMethod(&quot;POST&quot;); conn.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;);//维持长连接conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);conn.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(xmlbyte.length));conn.setRequestProperty(&quot;Content-Type&quot;, &quot;text/xml; charset=UTF-8&quot;);DataOutputStream outStream = new DataOutputStream(conn.getOutputStream());outStream.write(xmlbyte);//发送xml数据outStream.flush();if (conn.getResponseCode() != 200) throw new RuntimeException(&quot;请求url失败&quot;);InputStream is = conn.getInputStream();//获取返回数据String result = readAsString(is, &quot;UTF-8&quot;);outStream.close(); 7.Http协议上传文件 搭建服务器，完成上传功能 使用浏览器上传，查看请求信息 HttpURLConnection 通过URL封装路径打开一个HttpURLConnection 设置请求方式以及头字段：Content-Type、Content-Length、Host 拼接数据发送 Socket 使用HttpURLConnection发送时内部有缓存机制，如果上传较大文件会导致内存溢出 我们可以使用Socket发送TCP请求，将上传数据分段发送 8.发送Xml，访问WebService发送XML 通过URL封装路径打开一个HttpURLConnection 设置请求方式，Content-Type和Content-Length，XML文件的Content-Type为：text/xml; charset=UTF-8 使用HttpURLConnection获取输出流输出数据1234567891011121314151617181920212223StringBuilder xml = new StringBuilder();xml.append(&quot;&amp;lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot; ?&amp;gt;&quot;);xml.append(&quot;&amp;lt;M1 V=10000&amp;gt;&quot;);xml.append(&quot;&amp;lt;U I=1 D=\&quot;N73\&quot;&amp;gt;中国&amp;lt;/U&amp;gt;&quot;);xml.append(&quot;&amp;lt;/M1&amp;gt;&quot;);byte[] xmlbyte = xml.toString().getBytes(&quot;UTF-8&quot;);URL url = new URL(&quot;http://localhost:8080/ncist/contanctmanage.do?method=readxml&quot;);HttpURLConnection conn = (HttpURLConnection) url.openConnection();conn.setConnectTimeout(5* 1000);conn.setDoOutput(true);//允许输出conn.setUseCaches(false);//不使用Cacheconn.setRequestMethod(&quot;POST&quot;); conn.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;);//维持长连接conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;);conn.setRequestProperty(&quot;Content-Length&quot;, String.valueOf(xmlbyte.length));conn.setRequestProperty(&quot;Content-Type&quot;, &quot;text/xml; charset=UTF-8&quot;);DataOutputStream outStream = new DataOutputStream(conn.getOutputStream());outStream.write(xmlbyte);//发送xml数据outStream.flush();if (conn.getResponseCode() != 200) throw new RuntimeException(&quot;请求url失败&quot;);InputStream is = conn.getInputStream();//获取返回数据String result = readAsString(is, &quot;UTF-8&quot;);outStream.close(); WebService WebService是发布在网络上的API，可以通过发送XML调用，WebService返回结果也是XML数据 WebService没有语言限制，只要可以发送XML数据和接收XML数据即可 http://www.webxml.com.cn 网站上提供了一些WebService服务，我们可以对其进行调用 http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx?op=getMobileCodeInfo 中提供了电话归属地查询的使用说明 9.多线程断点续传 在下载的时候多个线程并发可以占用服务器端更多资源，从而加快下载速度使用多线程下载文件可以更快完成文件的下载，多线程下载文件之所以快，是因为其抢占的服务器资源多。如：假设服务器同时最多服务100个用户，在服务器中一条线程对应一个用户，100条线程在计算机中并非并发执行，而是由CPU划分时间片轮流执行，如果A应用使用了99条线程下载文件，那么相当于占用了99个用户的资源，假设一秒内CPU分配给每条线程的平均执行时间是10ms，A应用在服务器中一秒内就得到了990ms的执行时间，而其他应用在一秒内只有10ms的执行时间。就如同一个水龙头，每秒出水量相等的情况下，放990毫秒的水肯定比放10毫秒的水要多。 手机端下载数据时难免会出现无信号断线、电量不足等情况，所以需要断点续传功能 根据下载数据长度计算每个线程下载的数据位置，程序中开启多个线程并发下载 在请求头中设置Range字段就可以获取指定位置的数据，例如：Range: bytes=100-200 在下载过程中记录每个线程已拷贝数据的数量，如果下载中断，下次启动时从记录位置继续下载 多线程下载的实现过程 首先得到下载文件的长度，然后设置本地文件的长度。 123HttpURLConnection.getContentLength();RandomAccessFile file = new RandomAccessFile(&quot;QQWubiSetup.exe&quot;,&quot;rwd&quot;);file.setLength(filesize);//设置本地文件的长度 根据文件长度和线程数计算每条线程下载的数据长度和下载位置。如：文件的长度为6M，线程数为3，那么，每条线程下载的数据长度为2M，每条线程开始下载的位置如下图所示。 使用Http的Range头字段指定每条线程从文件的什么位置开始下载，下载到什么位置为止，如：指定从文件的2M位置开始下载，下载到位置(4M-1byte)为止，代码如下： 1HttpURLConnection.setRequestProperty(&quot;Range&quot;, &quot;bytes=2097152-4194303&quot;); 保存文件，使用RandomAccessFile类指定每条线程从本地文件的什么位置开始写入数据。 12RandomAccessFile threadfile = new RandomAccessFile(&quot;QQWubiSetup.exe &quot;,&quot;rwd&quot;);threadfile.seek(2097152);//从文件的什么位置开始写入数据 多线程下载 进度条使用&lt;Progress&gt;进行配置默认为圆形进度条，水平进度条需要配置style属性，?android:attr/progressBarStyleHorizontal使用android.R.attr.progressBarStyleHorizontal作为样式 当点击下载按钮时开启多线程下载，下载过程中修改进度条进度设置最大刻度：setMax()设置当前进度：setProgress()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class FileDownLoader &#123; @Test public void download() throws Exception &#123; String path = &quot;http://browse.babasport.com/QQWubiSetup.exe&quot;; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5*1000); conn.setRequestMethod(&quot;GET&quot;); conn.setRequestProperty(&quot;Accept&quot;, &quot;image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/xaml+xml, application/vnd.ms-xpsdocument, application/x-ms-xbap, application/x-ms-application, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*&quot;); conn.setRequestProperty(&quot;Accept-Language&quot;, &quot;zh-CN&quot;); conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;); conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.2; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)&quot;); conn.setRequestProperty(&quot;Connection&quot;, &quot;Keep-Alive&quot;); System.out.println(conn.getResponseCode()); int filesize = conn.getContentLength();//得到文件大小 conn.disconnect(); int threasize = 3;//线程数 int perthreadsize = filesize / 3 + 1; RandomAccessFile file = new RandomAccessFile(&quot;102.wma&quot;,&quot;rw&quot;); file.setLength(filesize);//设置本地文件的大小 file.close(); for(int i=0; i&lt;threasize ; i++)&#123; int startpos = i * perthreadsize;//计算每条线程的下载位置 RandomAccessFile perthreadfile = new RandomAccessFile(&quot;102.wma&quot;,&quot;rw&quot;); perthreadfile.seek(startpos);//从文件的什么位置开始写入数据 new DownladerThread(i, path, startpos, perthreadsize, perthreadfile).start(); &#125; //以下代码要求用户输入q才会退出测试方法，如果没有下面代码，会因为进程结束而导致进程内的下载线程被销毁 int quit = System.in.read(); while(&apos;q&apos;!=quit)&#123; Thread.sleep(2 * 1000); &#125; &#125; private class DownladerThread extends Thread&#123; private int startpos;//从文件的什么位置开始下载 private int perthreadsize;//每条线程需要下载的文件大小 private String path; private RandomAccessFile file; private int threadid; public DownladerThread(int threadid, String path, int startpos, int perthreadsize, RandomAccessFile perthreadfile) &#123; this.path = path; this.startpos = startpos; this.perthreadsize = perthreadsize; this.file = perthreadfile; this.threadid = threadid; &#125; @Override public void run() &#123; try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setConnectTimeout(5 * 1000); conn.setRequestMethod(&quot;GET&quot;); conn.setRequestProperty(&quot;Accept&quot;, &quot;image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/xaml+xml, application/vnd.ms-xpsdocument, application/x-ms-xbap, application/x-ms-application, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*&quot;); conn.setRequestProperty(&quot;Accept-Language&quot;, &quot;zh-CN&quot;); conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;); conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + this.startpos + &quot;-&quot;); InputStream inStream = conn.getInputStream(); byte[] buffer = new byte[1024]; int len = 0; int length = 0; while(length&lt;perthreadsize &amp;&amp; (len = inStream.read(buffer))!=-1)&#123; file.write(buffer, 0, len); length += len;//累计该线程下载的总大小 &#125; file.close(); inStream.close(); System.out.println(threadid+ &quot;线程完成下载&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 断点续传 断点续传需要在下载过程中记录每条线程的下载进度 每次下载开始之前先读取数据库,查询是否有未完成的记录，有就继续下载，没有则创建新记录插入数据库 在每次向文件中写入数据之后，在数据库中更新下载进度 下载完成之后删除数据库中下载记录 Handler传输数据 主线程中创建的View只能在主线程中修改，其他线程只能通过和主线程通信，在主线程中改变View数据 我们使用Handler可以处理这种需求主线程中创建Handler，重写handleMessage()方法新线程中使用Handler发送消息，主线程即可收到消息，并且执行handleMessage()方法 动态生成新View 创建XML文件，将要生成的View配置好 获取系统服务LayoutInflater，用来生成新的ViewLayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE); 使用inflate(int resource, ViewGroup root)方法生成新的View 调用当前页面中某个容器的addView，将新创建的View添加进来 本文链接：http://www.sguotao.top/Android基础-2012-06-15-android-basic-5.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>网络通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础4 内容提供者（ContentProvider）]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-06-14-android-basic-4.html</url>
    <content type="text"><![CDATA[1.什么是内容提供者 内容提供者是Android中的四大组件之一，可以将应用中的数据对外进行共享 内容提供者将数据的访问方式统一，不必针对不同数据类型采取不同的访问策略 内容提供者将数据封装，只暴露出我们希望提供给其他程序的数据 内容提供者中数据更改可被监听 2. 创建内容提供者定义类继承ContentProvider，根据需要重写内部方法1234567public class PersonContentProvider extends ContentProvider&#123; public boolean onCreate() public Uri insert(Uri uri, ContentValues values) public int delete(Uri uri, String selection, String[] selectionArgs) public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) public String getType(Uri uri)&#125; 在清单文件的节点下进行配置，标签中需要指定name和authorities属性，name为类名，包名从程序Package开始，以“.”开始，authorities：是访问Provider时路径，要唯一。12345&lt;manifest .... &gt; &lt;application android:icon="@drawable/icon"android:label="@string/app_name"&gt; &lt;provider android:name=".PersonContentProvider" android:authorities="cn.ncist.providers.personprovider"/&gt; &lt;/application&gt;&lt;/manifest&gt; 3.Uri介绍Uri代表了要操作的数据，Uri主要包含了两部分信息： 需要操作的ContentProvider 对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：URI代表要操作的数据，由scheme、authorites、path三部分组成scheme：固定为content，代表访问内容提供者，authorites：节点中的authorites属性，path：程序定义的路径，可根据业务逻辑定义 4.UriMatcher类的使用UriMatcher类用于匹配Uri，它的用法如下：首先第一步把你需要匹配Uri路径全部给注册上，如下：123456789101112//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码UriMatcher sMatcher = new UriMatcher(UriMatcher.NO_MATCH);//如果match()方法匹配content://cn.ncist.provider.personprovider/person路径，返回匹配码为1sMatcher.addURI(“cn.ncist.provider.personprovider”, “person”, 1);//添加需要匹配uri，如果匹配就会返回匹配码//如果match()方法匹配content://cn.ncist.provider.personprovider/person/230路径，返回匹配码为2sMatcher.addURI(“cn.ncist.provider.personprovider”, “person/#”, 2);//#号为通配符switch (sMatcher.match(Uri.parse("content://cn.ncist.provider.personprovider/person/10"))) &#123; case 1 break; default://不匹配 break;&#125; 注册完需要匹配的Uri后，就可以使用sMatcher.match(uri)方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用addURI()方法传入的第三个参数，假设匹配content://cn.ncist.provider.personprovider/person路径，返回的匹配码为1 5.ContentUris类使用介绍ContentUris类用于获取Uri路径后面的ID部分，它有两个比较实用的方法： withAppendedId(uri, id)用于为路径加上ID部分： 123Uri uri = Uri.parse("content://cn.ncist.provider.personprovider/person")Uri resultUri = ContentUris.withAppendedId(uri, 10); //生成后的Uri为：content://cn.ncist.provider.personprovider/person/10 parseId(uri)方法用于从路径中获取ID部分： 12Uri uri = Uri.parse("content://cn.ncist.provider.personprovider/person/10")long personid = ContentUris.parseId(uri);//获取的结果为:10 6.使用ContentProvider共享数据ContentProvider类主要方法的作用：123456789101112public boolean onCreate()该方法在ContentProvider创建后就会被调用， Android开机后， ContentProvider在其它应用第一次访问它时才会被创建。public Uri insert(Uri uri, ContentValues values)该方法用于供外部应用往ContentProvider添加数据。public int delete(Uri uri, String selection, String[] selectionArgs)该方法用于供外部应用从ContentProvider删除数据。public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)该方法用于供外部应用更新ContentProvider中的数据。public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)该方法用于供外部应用从ContentProvider中获取数据。public String getType(Uri uri)该方法用于返回当前Url所代表数据的MIME类型。 如果操作的数据属于集合类型，那么MIME类型字符串应该以vnd.android.cursor.dir/开头，例如：要得到所有person记录的Uri为content://cn.ncist.provider.personprovider/person，那么返回的MIME类型字符串应该为：“vnd.android.cursor.dir/person”。如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor.item/开头，例如：得到id为10的person记录，Uri为content://cn.ncist.provider.personprovider/person/10，那么返回的MIME类型字符串应该为：“vnd.android.cursor.item/person”。 7.使用ContentResolver操作ContentProvider中的数据当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver 类提供了与ContentProvider类相同签名的四个方法：12345678public Uri insert(Uri uri, ContentValues values)该方法用于往ContentProvider添加数据。public int delete(Uri uri, String selection, String[] selectionArgs)该方法用于从ContentProvider删除数据。public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)该方法用于更新ContentProvider中的数据。public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)该方法用于从ContentProvider中获取数据。 这些方法的第一个参数为Uri，代表要操作的ContentProvider和对其中的什么数据进行操作，假设给定的是： Uri.parse(“content://cn.ncist.providers.personprovider/person/10”)，那么将会对主机名为cn.ncist.providers.personprovider的ContentProvider进行操作，操作的数据为person表中id为10的记录。使用ContentResolver对ContentProvider中的数据进行添加、删除、修改和查询操作：1234567891011121314151617181920ContentResolver resolver = getContentResolver();Uri uri = Uri.parse("content://cn.ncist.provider.personprovider/person");//添加一条记录ContentValues values = new ContentValues();values.put("name", "ncist");values.put("age", 25);resolver.insert(uri, values); //获取person表中所有记录Cursor cursor = resolver.query(uri, null, null, null, "personid desc");while(cursor.moveToNext())&#123; Log.i("ContentTest", "personid="+ cursor.getInt(0)+ ",name="+ cursor.getString(1));&#125;//把id为1的记录的name字段值更新为limingContentValues updateValues = new ContentValues();updateValues.put("name", "liming");Uri updateIdUri = ContentUris.withAppendedId(uri, 2);resolver.update(updateIdUri, updateValues, null, null);//删除id为2的记录Uri deleteIdUri = ContentUris.withAppendedId(uri, 2);resolver.delete(deleteIdUri, null, null); 8.ContentObserver监听ContentProvider中数据的变化如果ContentProvider的访问者需要知道ContentProvider中的数据发生了变化，可以在ContentProvider 发生数据变化时调用getContentResolver().notifyChange(uri, null)来通知注册在此URI上的访问者，例子如下：1234public class PersonContentProvider extends ContentProvider &#123; public Uri insert(Uri uri, ContentValues values) &#123; db.insert("person", "personid", values); getContext().getContentResolver().notifyChange(uri, null);&#125;&#125; 如果ContentProvider的访问者需要得到数据变化通知，必须使用ContentObserver对数据（数据采用uri描述）进行监听，当监听到数据变化通知时，系统就会调用ContentObserver的onChange()方法：\123456789 getContentResolver().registerContentObserver(Uri.parse("content://cn.ncist.providers.personprovider/person"),true, new PersonObserver(new Handler()));public class PersonObserver extends ContentObserver&#123; public PersonObserver(Handler handler) &#123; super(handler); &#125; public void onChange(boolean selfChange) &#123; //此处可以进行相应的业务处理 &#125;&#125; 9.监听发送短信注意事项： Android系统提供了Provider对短信进行查询，当发出短信时也会发送更改通知 定义一个Observer监听”content://sms” 在onChange()方法中查询”content://sms/outbox” 短信发送数据库在 com.android.providers.telephony 需要权限android.permission.READ_SMS用户使用系统自带的短信程序发送短信，程序会通过ContentProvider把短信保存进数据库，并且发出一个数据变化通知，使用ContentObserver对数据变化进行监听，在用户发送短信时，就会被ContentObserver窃听到短信，注册监听：1getContentResolver().registerContentObserver(Uri.parse("content://sms"), true, new SmsObserver(new Handler())); 监听类：123456789101112131415private final class SmsObserver extends ContentObserver&#123; public SmsObserver(Handler handler) &#123; super(handler); &#125; public void onChange(boolean selfChange) &#123; //查询发送箱中的短信(处于正在发送状态的短信放在发送箱) Cursor cursor = getContentResolver().query(Uri.parse("content://sms/outbox"),null, null, null, null); while(cursor.moveToNext())&#123; StringBuilder sb = new StringBuilder(); sb.append("_id=").append(cursor.getInt(cursor.getColumnIndex("_id"))); sb.append(",address=").append(cursor.getString(cursor.getColumnIndex("address"))); sb.append(";body=").append(cursor.getString(cursor.getColumnIndex("body"))); sb.append(";time=").append(cursor.getLong(cursor.getColumnIndex("date"))); Log.i("ReceiveSendSMS", sb.toString()); &#125; &#125; 10.操作联系人获取所有联系人Android系统中的联系人也是通过ContentProvider来对外提供数据的，数据库路径为：1/data/data/com.android.providers.contacts/database/contacts2.db 操作联系人涉及3张表Provider的authorites为com.android.contacts, 先查询raw_contacts得到每个联系人的id，在使用id从data表中查询对应数据，根据mimetype分类数据。 通过电话号码获取联系人系统内部提供了根据电话号码获取data表数据的功能，路径为：data/phones/filter/用电话号码替换“”部分就可以查到所需数据，获取“display_name”可以获取到联系人显示名 添加联系人先向raw_contacts表插入id，路径为：raw_contacts得到id之后再向data表插入数据，路径为：data 使用事务添加联系人在添加联系人得时候是分多次访问Provider，如果在过程中出现异常，会出现数据不完整的情况，这些操作应该放在一次事务中使用ContentResolver的applyBatch(String authority,ArrayList operations) 方法可以将多个操作在一个事务中执行。文档位置:/android-sdk-windows/docs/reference/android/provider/ContactsContract.RawContacts.html 关键代码： 读取联系人信息的权限 1234&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt;content://com.android.contacts/contacts 操作的数据是联系人信息Uricontent://com.android.contacts/data/phones 联系人电话Uricontent://com.android.contacts/data/emails 联系人Email Uri 取联系人信息 1234567891011121314151617181920212223Cursor cursor = getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null); while (cursor.moveToNext()) &#123; String contactId = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID)); String name = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)); Cursor phones = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID +" = "+ contactId, null, null); while (phones.moveToNext()) &#123; String phoneNumber = phones.getString(phones.getColumnIndex( ContactsContract.CommonDataKinds.Phone.NUMBER)); Log.i("RongActivity", "phoneNumber="+phoneNumber); &#125; phones.close(); Cursor emails = getContentResolver().query(ContactsContract.CommonDataKinds.Email.CONTENT_URI, null, ContactsContract.CommonDataKinds.Email.CONTACT_ID + " = " + contactId, null, null); while (emails.moveToNext()) &#123; // This would allow you get several email addresses String emailAddress=emails.getString(emails.getColumnIndex(ContactsContract.CommonDataKinds.Email.DATA)); Log.i("RongActivity", "emailAddress="+ emailAddress); &#125; emails.close(); &#125; cursor.close(); 添加联系人方法一：首先向RawContacts.CONTENT_URI执行一个空值插入，目的是获取系统返回的rawContactId 这时后面插入data表的依据，只有执行空值插入，才能使插入的联系人在通讯录里面可见 1234567891011121314151617181920212223242526public void testInsert() &#123; ContentValues values = new ContentValues(); //首先向RawContacts.CONTENT_URI执行一个空值插入，目的是获取系统返回的rawContactId Uri rawContactUri = this.getContext().getContentResolver().insert(RawContacts.CONTENT_URI, values); long rawContactId = ContentUris.parseId(rawContactUri); //往data表入姓名数据 values.clear(); values.put(Data.RAW_CONTACT_ID, rawContactId); values.put(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);//内容类型 values.put(StructuredName.GIVEN_NAME, "李天山"); this.getContext().getContentResolver().insert(android.provider.ContactsContract.Data.CONTENT_URI, values); //往data表入电话数据 values.clear(); values.put(Data.RAW_CONTACT_ID, rawContactId); values.put(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE); values.put(Phone.NUMBER, "13921009789"); values.put(Phone.TYPE, Phone.TYPE_MOBILE); this.getContext().getContentResolver().insert(android.provider.ContactsContract.Data.CONTENT_URI, values); //往data表入Email数据 values.clear(); values.put(Data.RAW_CONTACT_ID, rawContactId); values.put(Data.MIMETYPE, Email.CONTENT_ITEM_TYPE); values.put(Email.DATA, "liming@ncist.cn"); values.put(Email.TYPE, Email.TYPE_WORK); this.getContext().getContentResolver().insert(android.provider.ContactsContract.Data.CONTENT_URI, values); &#125; 方法二：批量添加,处于同一个事务中123456789101112131415161718192021222324252627282930313233public void testSave() throws Throwable&#123; //文档位置：reference\android\provider\ContactsContract.RawContacts.html ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;(); int rawContactInsertIndex = 0; ops.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI) .withValue(RawContacts.ACCOUNT_TYPE, null) .withValue(RawContacts.ACCOUNT_NAME, null) .build()); //文档位置：reference\android\provider\ContactsContract.Data.html ops.add(ContentProviderOperation.newInsert(android.provider.ContactsContract.Data.CONTENT_URI) .withValueBackReference(Data.RAW_CONTACT_ID, rawContactInsertIndex) .withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE) .withValue(StructuredName.GIVEN_NAME, "赵薇") .build()); ops.add(ContentProviderOperation.newInsert(android.provider.ContactsContract.Data.CONTENT_URI) .withValueBackReference(Data.RAW_CONTACT_ID, rawContactInsertIndex) .withValue(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE) .withValue(Phone.NUMBER, "13671323809") .withValue(Phone.TYPE, Phone.TYPE_MOBILE) .withValue(Phone.LABEL, "手机号") .build()); ops.add(ContentProviderOperation.newInsert(android.provider.ContactsContract.Data.CONTENT_URI) .withValueBackReference(Data.RAW_CONTACT_ID, rawContactInsertIndex) .withValue(Data.MIMETYPE, Email.CONTENT_ITEM_TYPE) .withValue(Email.DATA, "liming@ncist.cn") .withValue(Email.TYPE, Email.TYPE_WORK) .build()); ContentProviderResult[] results = this.getContext().getContentResolver() .applyBatch(ContactsContract.AUTHORITY, ops); for(ContentProviderResult result : results)&#123; Log.i(TAG, result.uri.toString()); &#125; &#125; 本文链接：http://www.sguotao.top/Android基础-2012-06-14-android-basic-4.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ContentProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础3 Android文件操作]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-06-09-android-basic-3.html</url>
    <content type="text"><![CDATA[1. 读写文件1.1 写文件通过Context.openFileOutput(String name, int mode)可以获取一个文件输出流。name为文件名，mode为文件模式，有4种模式。输出流指向路径为：/data/data/包名/files/ 文件模式在Context中有定义常量 模式可以组合使用，例如：MODE_WORLD_READABLE + MODE_WORLD_WRITEABLE，文件被其它应用读和写。 文件访问的原理android有一套自己的安全模型，当应用程序(.apk)在安装时系统就会分配给他一个userid，当该应用要去访问其他资源比如文件的时候，就需要userid匹配。默认情况下，任何应用创建的文件，sharedpreferences，数据库都应该是私有的（位于/data/data//files），其他程序无法访问。除非在创建时指定了Context.MODE_WORLD_READABLE或者Context.MODE_WORLD_WRITEABLE ，只有这样其他程序才能正确访问。 查看文件通过点击Eclipse菜单“Window”-“Show View”-“Other”，在对话窗口中展开android文件夹，选择下面的File Explorer视图，然后在File Explorer视图中展开/data/data//files目录就可以看到该文件。 1.2 读文件通过Context.openFileInput(String name)可以获取一个文件输入流，该输入流可以读取 /data/data/包名/files/ 路径下的文件12FileInputStream inStream = this.getContext().openFileInput("ncist.txt");Log.i("FileTest", readInStream(inStream)); 或者直接使用文件的绝对路径：123File file = new File("/data/data/cn.ncist.action/files/ncist.txt");FileInputStream inStream = new FileInputStream(file);Log.i("FileTest", readInStream(inStream)); 注意：上面文件路径中的“cn.ncist.action”为应用所在包，当你在编写代码时应替换为你自己应用使用的包。Activity还提供了getCacheDir()和getFilesDir()方法： getCacheDir()方法用于获取/data/data//cache目录getFilesDir()方法用于获取/data/data//files目录 获取当前程序Files文件路径1ContextWrapper.getFilesDir() 1.3 写入文件到SD卡需要在清单文件中注册权限12&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 2.1版本以下的SDCard位置和2.2之后版本不同可以通过Environment.getExternalStorageDirectory()获取当前SDCard位置，兼容所有版本 获取SDCard状态要往SDCard存放文件，程序必须先判断手机是否装有SDCard，并且可以进行读写。通过Environment.getExternalStorageState()方法获取SDCard当前状态，常量 Environment.MEDIA_MOUNTED 为已安装。注意：访问SDCard必须在AndroidManifest.xml中加入访问SDCard的权限 1234567if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123; File sdCardDir = Environment.getExternalStorageDirectory();//获取SDCard目录 File saveFile = new File(sdCardDir, “ncist.txt”);FileOutputStream outStream = new FileOutputStream(saveFile);outStream.write("Android".getBytes());outStream.close();&#125; 2. XML解析2.1 Pull简介常见的XML解析方式有三种，DOM、SAX、Pull，Android系统中推荐使用PullPull解析器是一个开源的Java项目，Android系统内部解析XML文件均为此种方式，也可用于JavaEE项目。 Android SDK中已经集成了Pull解析器，无需添加任何jar文件Pull解析器运行方式与SAX类似，提供各种事件的判断跟SAX不同的是， Pull解析器产生的事件是一个数字，而非方法，因此可以使用一个switch对感兴趣的事件进行处理。当元素开始解析时，调用parser.nextText()方法可以获取下一个Text类型节点的值。 官方网站：http://xmlpull.org/ 2.2 使用Pull解析器解析XML文件12345Xml.newPullParser() 获得解析器parser.setInput(in, "UTF-8") 设置输入流以及编码parser.next() 获取下一个解析事件，得到一个事件代码XmlPullParser中定义了常量来标识各种解析事件START_DOCUMENT、END_DOCUMENT 、START_TAG 、END_TAG 、TEXT 使用XmlSerializer写出XML,使用以下方法生成XML，和XML文档顺序类似1234567891011121314151617181920212223242526public static String writeXML(List&amp;lt;Person&amp;gt; persons, Writer writer)&#123; XmlSerializer serializer = Xml.newSerializer(); try &#123; serializer.setOutput(writer); serializer.startDocument("UTF-8", true); //第一个参数为命名空间,如果不使用命名空间,可以设置为null serializer.startTag("", "persons"); for (Person person : persons)&#123; serializer.startTag("", "person"); serializer.attribute("", "id", person.getId().toString()); serializer.startTag("", "name"); serializer.text(person.getName()); serializer.endTag("", "name"); serializer.startTag("", "age"); serializer.text(person.getAge().toString()); serializer.endTag("", "age"); serializer.endTag("", "person"); &#125; serializer.endTag("", "persons"); serializer.endDocument(); return writer.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 3. 偏好设定（SharedPreferences）在程序中保存一些配置参数的时候我们经常使用SharedPreferences1Context.getSharedPreferences(String name,int mode) 该方法可以在/data/data//shared_pref/目录下创建一个以name命名的xml文件，mode文件为模式 3.1 存储偏好调用edit()方法可以获取一个Editor对象，对数据进行存储，存储之后需要调用commit()保存到文件。因为SharedPreferences背后是使用xml文件保存数据，getSharedPreferences(name,mode)方法的第一个参数用于指定该文件的名称，名称不用带后缀，后缀会由Android自动加上。方法的第二个参数指定文件的操作模式，共有四种操作模式，如果希望SharedPreferences背后使用的xml文件能被其他应用读和写，可以指定Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE权限。 在Activity中获取SharedPreferences在Activity中可以调用getPreferences(int mode)方法获得一个SharedPreferences，文件名和Activity名一致 12345SharedPreferences sharedPreferences = getSharedPreferences("ncist", Context.MODE_PRIVATE);Editor editor = sharedPreferences.edit();//获取编辑器editor.putString("name", "Android");editor.putInt("age", 4);editor.commit();//提交修改 3.2 读取偏好获得SharedPreferences之后调用getString()、getInt()等方法获取其中设置的值 1234SharedPreferences sharedPreferences = getSharedPreferences("ncist", Context.MODE_PRIVATE);//getString()第二个参数为缺省值，如果preference中不存在该key，将返回缺省值String name = sharedPreferences.getString("name", "");int age = sharedPreferences.getInt("age", 1); 如果访问其他应用中的Preference，前提条件是：该preference创建时指定了Context.MODE_WORLD_READABLE或者Context.MODE_WORLD_WRITEABLE权限。如：有个为cn.ncist.action的应用使用下面语句创建了preference。 1getSharedPreferences(&quot;ncist&quot;, Context.MODE_WORLD_READABLE); 其他应用要访问上面应用的preference，首先需要创建上面应用的Context，然后通过Context 访问preference ，访问preference时会在应用所在包下的shared_prefs目录找到preference ： 1234Context otherAppsContext = createPackageContext("cn.ncist.action", Context.CONTEXT_IGNORE_SECURITY);SharedPreferences sharedPreferences = otherAppsContext.getSharedPreferences("ncist", Context.MODE_WORLD_READABLE);String name = sharedPreferences.getString("name", "");int age = sharedPreferences.getInt("age", 0); 如果不通过创建Context访问其他应用的preference，也可以以读取xml文件方式直接访问其他应用preference对应的xml文件，如： 1File xmlFile = new File(“/data/data/&lt;package name&gt;/shared_prefs/ncist.xml”);//&lt;package name&gt;应替换成应用的包名 4. 数据库（SQLite）4.1 SQLite特点Android平台中嵌入了一个关系型数据库SQLite，和其他数据库不同的是SQLite存储数据时不区分类型，例如一个字段声明为Integer类型，我们也可以将一个字符串存入，一个字段声明为布尔型，我们也可以存入浮点数。除非是主键被定义为Integer，这时只能存储64位整数创建数据库的表时可以不指定数据类型，例如： 1CREATE TABLE person(id INTEGER PRIMARY KEY, name) SQLite支持大部分标准SQL语句，增删改查语句都是通用的，分页查询语句和MySQL相同12SELECT * FROM person LIMIT 20 OFFSET 10SELECT * FROM person LIMIT 20,10 4.2 创建数据库 定义类继承SQLiteOpenHelper 声明构造函数，4个参数 重写onCreate()方法 重写upGrade()方法 为了实现对数据库版本进行管理，SQLiteOpenHelper类提供了两个重要的方法，分别是onCreate(SQLiteDatabase db)和onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)，前者用于初次使用软件时生成数据库表，后者用于升级软件时更新数据库表结构。 当调用SQLiteOpenHelper的getWritableDatabase()或者getReadableDatabase()方法获取用于操作数据库的SQLiteDatabase实例的时候，如果数据库不存在，Android系统会自动生成一个数据库，接着调用onCreate()方法，onCreate()方法在初次生成数据库时才会被调用，在onCreate()方法里可以生成数据库表结构及添加一些应用使用到的初始化数据。onUpgrade()方法在数据库的版本发生变化时会被调用，一般在软件升级时才需改变版本号，并且在onUpgrade()方法里面实现表结构的更新。当软件的版本升级次数比较多，这时在onUpgrade()方法里面可以根据原版号和目标版本号进行判断，然后作出相应的表结构及数据更新。 getWritableDatabase()和getReadableDatabase()方法都可以获取一个用于操作数据库的SQLiteDatabase实例。但getWritableDatabase() 方法以读写方式打开数据库，一旦数据库的磁盘空间满了，数据库就只能读而不能写，倘若使用getWritableDatabase()打开数据库就会出错。getReadableDatabase()方法先以读写方式打开数据库，如果数据库的磁盘空间满了，就会打开失败，当打开失败后会继续尝试以只读方式打开数据库。 123456789101112131415public class DatabaseHelper extends SQLiteOpenHelper &#123; //类没有实例化,是不能用作父类构造器的参数,必须声明为静态 private static final String name = "ncist"; //数据库名称 private static final int version = 1; //数据库版本 public DatabaseHelper(Context context) &#123;//第三个参数CursorFactory指定在执行查询时获得一个游标实例的工厂类,设置为null,代表使用系统默认的工厂类 super(context, name, null, version);&#125;public void onCreate(SQLiteDatabase db) &#123;db.execSQL("CREATE TABLE IF NOT EXISTS person (personid integer primary key autoincrement, name varchar(20), age INTEGER)"); &#125;public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;db.execSQL(" ALTER TABLE person ADD phone VARCHAR(12) NULL "); //往表中增加一列 // DROP TABLE IF EXISTS person 删除表 &#125;&#125; 4.3 CRUD操作4.3.1 execSQL()和rawQuery()方法和JDBC访问数据库不同，操作SQLite数据库无需加载驱动，不用获取连接，直接可以使用，获取SQLiteDatabase对象之后通过该对象直接可以执行SQL语句。对SQLiteDatabase的学习，我们应该重点掌握execSQL()和rawQuery()方法。 execSQL()方法可以执行insert、delete、update和CREATE TABLE之类有更改行为的SQL语句； rawQuery()方法用于执行select语句。 123SQLiteDatabase db = ....;db.execSQL("insert into person(name, age) values(?,?)", new Object[]&#123;"Android", 4&#125;); db.close(); execSQL(String sql, Object[] bindArgs)方法的第一个参数为SQL语句，第二个参数为SQL语句中占位符参数的值，参数值在数组中的顺序要和占位符的位置对应。SQLiteDatabase的rawQuery() 用于执行select语句，使用例子如下： 123456789SQLiteDatabase db = ....;Cursor cursor = db.rawQuery(“select * from person”, null);while (cursor.moveToNext()) &#123; int personid = cursor.getInt(0); //获取第一列的值,第一列的索引从0开始 String name = cursor.getString(1);//获取第二列的值 int age = cursor.getInt(2);//获取第三列的值&#125;cursor.close();db.close(); rawQuery()方法的第一个参数为select语句；第二个参数为select语句中占位符参数的值，如果select语句没有使用占位符，该参数可以设置为null。带占位符参数的select语句使用例子如下： 1Cursor cursor = db.rawQuery("select * from person where name like ? and age=?", new String[]&#123;"%华科%", "4"&#125;); Cursor是结果集游标，用于对结果集进行随机访问，如果大家熟悉jdbc， 其实Cursor与JDBC中的ResultSet作用很相似。 4.3.2 getReadableDatabase()和getWritableDatabase()的区别查看源代码后我们发现getReadableDatabase()在通常情况下返回的就是getWritableDatabase()拿到的数据库只有在抛出异常的时候才会以只读方式打开。 数据库对象缓存 getWritableDatabase()方法最后会使用一个成员变量记住这个数据库对象，下次打开时判断是否重用SQLiteDatabase封装了insert()、delete()、update()、query()四个方法也可以对数据库进行操作。这些方法封装了部分SQL语句，通过参数进行拼接. 4.4 事务处理在使用SQLite数据库时可以使用SQLiteDatabase类中定义的相关方法控制事务123beginTransaction() 开启事务setTransactionSuccessful() 设置事务成功标记endTransaction() 结束事务 如果程序执行到endTransaction()之前调用了setTransactionSuccessful() 方法设置事务的标志为成功则提交事务，如果没有调用setTransactionSuccessful() 方法则回滚事务。使用例子如下： 1234567891011SQLiteDatabase db = ....;db.beginTransaction();//开始事务try &#123; db.execSQL("insert into person(name, age) values(?,?)", new Object[]&#123;"Android", 4&#125;); db.execSQL("update person set name=? where personid=?", new Object[]&#123;"Android", 1&#125;);db.setTransactionSuccessful();//调用此方法会在执行到endTransaction() 时提交当前事务，如果不调用此方法会回滚事务&#125; finally &#123; db.endTransaction();//由事务的标志决定是提交事务，还是回滚事务&#125; db.close(); endTransaction()需要放在finally中执行，否则事务只有到超时的时候才自动结束会降低数据库并发效率。 本文链接：http://www.sguotao.top/Android基础-2012-06-09-android-basic-3.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>XML</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础2 布局]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-06-07-android-basic-2.html</url>
    <content type="text"><![CDATA[1. 布局Android 有4种布局方式，分别是Linearlayout(线性布局)、RelativeLayout（相对布局）、TableLayout（表格布局）、FrameLayout（帧布局）。 1.1 Linearlayout(线性布局)1234&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;vertical&gt; 属性“xmlns:android”指定命名空间，顶级元素必须指定命名空间，而在该命名空间中的控件的属性，要在属性前加上“android”做前缀。 属性“layout_width”指定该元素的宽度，可选值有三种，“fill_parent”、“wrap_content”、具体数字。其中，“fill_parent”代表填满其父元素，对于顶级元素来说，其父元素就是整个手机屏幕。“wrap_content”代表该元素的大小仅包裹其自身的内容，而数字则代表其占相应的px。 属性“layout_height”指定该元素的高度，可选参数值与“layout_width”的参数意义相同。 属性“orientation”指定子元素的排列方式，其中指定为“vertical”则是子元素垂直排列，每个子元素会占独立的一行。而另一个可选值为“horizontal”代表子元素水平排列，即每个子元素会占独立的一列。 1.2 RelativeLayout（相对布局）文档位置： android-sdk-windows/docs/guide/topics/ui/layout-objects.html#relativelayout 相对布局中的视图组件是按照相互之间的相对位置来确定的。 1.3 TableLayout（表格布局）文档位置：android-sdk-windows/docs/guide/topics/ui/layout-objects.html#tablelayout 1.4 FrameLayout（帧布局）文档位置：android-sdk-windows/docs/guide/topics/ui/layout-objects.html#framelayout 2. Junit 项目中添加测试类在AndroidManifest.xml清单文件中添加配置 1234&lt;uses-library android:name="android.test.runner" /&gt;&lt;instrumentation android:targetPackage="cn.ncist.junit" android:name="android.test.InstrumentationTestRunner" /&gt; 定义一个类继承AndroidTestCase，定义测试方法 在Outline视图下右键点击测试方法 – Run as – Android Junit Test 创建测试项目创建Android Test Project输入项目名，选择一个已存在的工程，Eclipse可以自动配置Junit环境 3. 日志信息调试android程序的两种手段： debug模式打断点，debug as –&gt;android application 如果程序长时间停留在waiting dubug页面 –&gt;androidmainfest.xml在application节点中增加属性debuggable = true； 输出log，看logcat的信息，android 将日志信息打印到logcat中。日志信息的级别; 在LogCat视图中我们可以看到程序的日志信息，也可以在程序中输出信息到LogCat中。程序中我们可以使用Log类来输出信息。 System.out和System.err输出的信息也会显示在LogCat中，注意System.out输出信息是Info级别，System.err是Warn级别。 本文链接：http://www.sguotao.top/Android基础-2012-06-07-android-basic-2.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础1 Android项目的结构]]></title>
    <url>%2FAndroid%E5%9F%BA%E7%A1%80-2012-06-01-android-basic-1.html</url>
    <content type="text"><![CDATA[1. Android系统架构图学习Android内容，总是无法绕过Android系统架构图，这张图，在以后Android开发的过程中，总是离不开它。 2. Davlik VM和JVM的区别Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一。 2.1 Dalvik 和标准 Java 虚拟机(JVM)的首要差别Dalvik 基于寄存器，而 JVM 基于栈。基于寄存器的虚拟机对于更大的程序来说，在它们编译的时候，花费的时间更短。 JVM字节码中，局部变量会被放入局部变量表中，继而被压入堆栈供操作码进行运算，当然JVM也可以只使用堆栈而不显式地将局部变量存入变量表中。Dalvik字节码中，局部变量会被赋给65536个可用的寄存器中的任何一个，Dalvik指令直接操作这些寄存器，而不是访问堆栈中的元素。 2.2 Dalvik 和 Java 字节码的区别VM字节码由.class文件组成，每个文件一个class。JVM在运行的时候为每一个类装载字节码。相反的，Dalvik程序只包含一个.dex文件，这个文件包含了程序中所有的类。Java编译器创建了JVM字节码之后，Dalvik的dx编译器删除.class文件，重新把它们编译成Dalvik字节码，然后把它们写进一个.dex文件中。这个过程包括翻译、重构、解释程序的基本元素（常量池、类定义、数据段）。常量池描述了所有的常量，包括引用、方法名、数值常量等。类定义包括了访问标志、类名等基本信息。数据段中包含各种被VM执行的函数代码以及类和函数的相关信息（例如DVM所需要的寄存器数量、局部变量表、操作数堆栈大小），还有实例变量。 2.3 Dalvik 和 Java SDK的SDK不同及运行环境的区别 Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。 Dalvik虚拟机在android2.2之后使用JIT （Just-In-Time）技术，与传统JVM的JIT并不完全相同，Dalvik虚拟机有自己的 bytecode，并非使用 Java bytecode。 还有以下几点： Dalvik主要是完成对象生命周期管理，堆栈管理，线程管理，安全和异常管理，以及垃圾回收等等重要功能。 Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。 不同于Java虚拟机运行java字节码，Dalvik虚拟机运行的是其专有的文件格式Dex。 dex文件格式可以减少整体文件尺寸，提高I/O操作的类查找速度。 odex是为了在运行过程中进一步提高性能，对dex文件的进一步优化。 所有的Android应用的线程都对应一个Linux线程，虚拟机因而可以更多的依赖操作系统的线程调度和管理机制。 有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化、库的加载、预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的速度提供给系统。对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域。 3. 常用Android设备的屏幕分辨率 4. 安装和卸载应用adb安装打开cmd命令行 – 进入SDK根目录下tools文件夹，abd install apk文件绝对路径例如：adb install D:\Ncist\Program\android\01_HelloWorld\bin\01_HelloWorld.apk adb卸载adb uninstall 包名例如：adb uninstall cn.ncist.helloworld 5. Android项目的目录结构 本文链接：http://www.sguotao.top/Android基础-2012-06-01-android-basic-1.html]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JVM</tag>
        <tag>Davlik</tag>
      </tags>
  </entry>
</search>